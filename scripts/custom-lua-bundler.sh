#!/bin/bash
# Custom Lua Bundler for AO Environment
# Manually resolves require() statements and creates a single bundled file

set -e

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Configuration
ENTRY_POINT=""
OUTPUT_FILE=""
WORKING_DIR=""
PROCESSED_FILES=()
SHARED_MODULES=()
SIZE_LIMIT_KB=500
ENABLE_SPLITTING=false

show_help() {
    echo "Custom Lua Bundler for AO Environment"
    echo ""
    echo "Usage: $0 --entrypoint <file> --output <file> [--workdir <dir>] [--split]"
    echo ""
    echo "Options:"
    echo "  --entrypoint <file>   Entry point Lua file to bundle"
    echo "  --output <file>       Output bundled file path"
    echo "  --workdir <dir>       Working directory for module resolution (default: dirname of entrypoint)"
    echo "  --split              Enable emergency splitting for oversized bundles"
    echo "  --limit <kb>         Size limit in KB (default: 500)"
    echo "  --help               Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 --entrypoint coordinator/main.lua --output build/coordinator.lua"
    echo "  $0 --entrypoint coordinator/main.lua --output build/coordinator.lua --workdir ao-processes"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --entrypoint)
            ENTRY_POINT="$2"
            shift 2
            ;;
        --output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --workdir)
            WORKING_DIR="$2"
            shift 2
            ;;
        --split)
            ENABLE_SPLITTING=true
            shift
            ;;
        --limit)
            SIZE_LIMIT_KB="$2"
            shift 2
            ;;
        --help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Validate required arguments
if [[ -z "$ENTRY_POINT" ]]; then
    echo -e "${RED}Error: --entrypoint is required${NC}"
    show_help
    exit 1
fi

if [[ -z "$OUTPUT_FILE" ]]; then
    echo -e "${RED}Error: --output is required${NC}"
    show_help
    exit 1
fi

# Set working directory
if [[ -z "$WORKING_DIR" ]]; then
    WORKING_DIR=$(dirname "$ENTRY_POINT")
fi

echo -e "${GREEN}🔨 Custom Lua Bundler${NC}"
echo "Entry point: $ENTRY_POINT"
echo "Output file: $OUTPUT_FILE"  
echo "Working dir: $WORKING_DIR"

# Create output directory if needed
mkdir -p "$(dirname "$OUTPUT_FILE")"

# Function to resolve module path from require string
resolve_module_path() {
    local module_name="$1"
    local base_dir="$2"
    
    # Convert dot notation to file path
    local file_path=$(echo "$module_name" | sed 's/\./\//g')
    local full_path="$base_dir/$file_path.lua"
    
    if [[ -f "$full_path" ]]; then
        echo "$full_path"
        return 0
    fi
    
    return 1
}

# Function to check if file was already processed
is_already_processed() {
    local file="$1"
    for processed in "${PROCESSED_FILES[@]}"; do
        if [[ "$processed" == "$file" ]]; then
            return 0
        fi
    done
    return 1
}

# Function to identify shared modules (used by multiple processes)
identify_shared_modules() {
    local module="$1"
    # Common shared modules that should be extracted
    case "$module" in
        *"process-coordination"* | *"crypto-rng"* | *"enums"* | *"message-router"* | *"constants"*)
            return 0
            ;;
    esac
    return 1
}

# Function to split bundle if oversized
split_bundle_if_needed() {
    local bundle_file="$1"
    local size_bytes=$(wc -c < "$bundle_file")
    local size_kb=$((size_bytes / 1024))
    
    if [[ $size_kb -gt $SIZE_LIMIT_KB && "$ENABLE_SPLITTING" == true ]]; then
        echo -e "${YELLOW}⚠️  Bundle exceeds ${SIZE_LIMIT_KB}KB limit (${size_kb}KB), splitting...${NC}"
        
        local base_name=$(basename "$bundle_file" .lua)
        local dir_name=$(dirname "$bundle_file")
        local core_file="${dir_name}/${base_name}-core.lua"
        local data_file="${dir_name}/${base_name}-data.lua"
        
        # Create core bundle (essential logic only)
        echo "-- Core bundle for $base_name (essential logic only)" > "$core_file"
        echo "-- Generated by emergency splitting" >> "$core_file"
        echo "" >> "$core_file"
        
        # Create data bundle (data structures and constants)
        echo "-- Data bundle for $base_name (data structures only)" > "$data_file"
        echo "-- Generated by emergency splitting" >> "$data_file"
        echo "" >> "$data_file"
        
        # Split the bundle based on content
        in_data_section=false
        while IFS= read -r line; do
            if [[ "$line" =~ "data\." || "$line" =~ "constants\." || "$line" =~ "Species\|SPECIES\|Moves\|MOVES" ]]; then
                in_data_section=true
            elif [[ "$line" =~ "handlers\." || "$line" =~ "game-logic\." ]]; then
                in_data_section=false
            fi
            
            if [[ "$in_data_section" == true ]]; then
                echo "$line" >> "$data_file"
            else
                echo "$line" >> "$core_file"
            fi
        done < "$bundle_file"
        
        core_size=$(wc -c < "$core_file")
        data_size=$(wc -c < "$data_file")
        
        echo -e "${GREEN}✅ Bundle split completed:${NC}"
        echo -e "  Core: $(basename "$core_file") - $((core_size / 1024))KB"
        echo -e "  Data: $(basename "$data_file") - $((data_size / 1024))KB"
        
        return 0
    fi
    
    return 1
}

# Function to process a single Lua file and inline its dependencies
process_lua_file() {
    local file_path="$1"
    local indent="$2"
    
    if is_already_processed "$file_path"; then
        echo -e "${YELLOW}${indent}⚠️  Skipping already processed: $file_path${NC}"
        return 0
    fi
    
    echo -e "${GREEN}${indent}📄 Processing: $file_path${NC}"
    PROCESSED_FILES+=("$file_path")
    
    if [[ ! -f "$file_path" ]]; then
        echo -e "${RED}${indent}❌ File not found: $file_path${NC}"
        return 1
    fi
    
    # Read the file and process require statements
    while IFS= read -r line; do
        # Check if line contains a require statement
        if [[ "$line" =~ require\([\"\'](.*)[\"\']\) ]]; then
            local module_name="${BASH_REMATCH[1]}"
            
            # Skip json require (allowed in AO)
            if [[ "$module_name" == "json" ]]; then
                echo "$line" >> "$OUTPUT_FILE"
                continue
            fi
            
            echo -e "${YELLOW}${indent}  🔍 Found require: $module_name${NC}"
            
            # Resolve module path
            if module_path=$(resolve_module_path "$module_name" "$WORKING_DIR"); then
                echo -e "${GREEN}${indent}  ✅ Resolved: $module_path${NC}"
                
                # Check if this is a shared module we should deduplicate
                if identify_shared_modules "$module_name"; then
                    if is_already_processed "$module_path"; then
                        echo -e "${YELLOW}${indent}  🔄 Shared module already included: $module_name${NC}"
                        echo "-- SHARED MODULE REFERENCE: $module_name (already included)" >> "$OUTPUT_FILE"
                        continue
                    else
                        SHARED_MODULES+=("$module_name")
                        echo -e "${GREEN}${indent}  📚 Adding shared module: $module_name${NC}"
                    fi
                fi
                
                # Add module wrapper comment
                echo "" >> "$OUTPUT_FILE"
                echo "-- ===== MODULE: $module_name =====" >> "$OUTPUT_FILE"
                echo "-- File: $module_path" >> "$OUTPUT_FILE"
                echo "-- Original require: $line" >> "$OUTPUT_FILE"
                echo "" >> "$OUTPUT_FILE"
                
                # Recursively process the required module
                process_lua_file "$module_path" "$indent  "
                
                echo "" >> "$OUTPUT_FILE"
                echo "-- ===== END MODULE: $module_name =====" >> "$OUTPUT_FILE"
                echo "" >> "$OUTPUT_FILE"
            else
                echo -e "${RED}${indent}  ❌ Could not resolve module: $module_name${NC}"
                echo "-- ERROR: Could not resolve require('$module_name')" >> "$OUTPUT_FILE"
                echo "$line" >> "$OUTPUT_FILE"
            fi
        else
            # Regular line, just copy it
            echo "$line" >> "$OUTPUT_FILE"
        fi
    done < "$file_path"
}

# Main bundling process
echo -e "${GREEN}🚀 Starting bundling process...${NC}"

# Initialize output file
echo "-- Bundled Lua file for AO Environment" > "$OUTPUT_FILE"
echo "-- Generated by custom-lua-bundler.sh" >> "$OUTPUT_FILE"
echo "-- Entry point: $ENTRY_POINT" >> "$OUTPUT_FILE"
echo "-- Bundle timestamp: $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"
echo "-- JSON require (allowed in AO environment)" >> "$OUTPUT_FILE"
echo "local json = require('json')" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Process the entry point file
if process_lua_file "$ENTRY_POINT" ""; then
    size_bytes=$(wc -c < "$OUTPUT_FILE")
    size_kb=$((size_bytes / 1024))
    lines=$(wc -l < "$OUTPUT_FILE")
    
    echo -e "${GREEN}✅ Bundling completed successfully!${NC}"
    echo -e "${GREEN}📄 Output: $OUTPUT_FILE${NC}"
    echo -e "${GREEN}📊 Size: ${size_bytes} bytes (${size_kb}KB)${NC}"
    echo -e "${GREEN}📏 Lines: $lines lines${NC}"
    echo -e "${GREEN}📚 Shared modules: ${#SHARED_MODULES[@]}${NC}"
    
    # Size validation
    if [[ $size_kb -gt $SIZE_LIMIT_KB ]]; then
        echo -e "${RED}⚠️  WARNING: Bundle exceeds ${SIZE_LIMIT_KB}KB limit by $((size_kb - SIZE_LIMIT_KB))KB${NC}"
        
        # Attempt emergency splitting if enabled
        if split_bundle_if_needed "$OUTPUT_FILE"; then
            echo -e "${GREEN}✅ Emergency splitting completed${NC}"
        else
            if [[ "$ENABLE_SPLITTING" == false ]]; then
                echo -e "${YELLOW}💡 Use --split to enable emergency bundle splitting${NC}"
            fi
            echo -e "${RED}❌ Bundle size exceeds AO deployment limits!${NC}"
            exit 1
        fi
    else
        echo -e "${GREEN}✅ Bundle size within ${SIZE_LIMIT_KB}KB limit${NC}"
    fi
    
    echo -e "${GREEN}🎯 Bundle optimization summary:${NC}"
    echo -e "  Shared modules identified: ${#SHARED_MODULES[@]}"
    echo -e "  Final size: ${size_kb}KB / ${SIZE_LIMIT_KB}KB limit"
    echo -e "  Status: $([ $size_kb -le $SIZE_LIMIT_KB ] && echo "✅ Ready for AO deployment" || echo "❌ Requires optimization")"
else
    echo -e "${RED}❌ Bundling failed${NC}"
    exit 1
fi