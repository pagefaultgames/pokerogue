-- Bundled Lua file for AO Environment
-- Generated by custom-lua-bundler.sh
-- Entry point: ao-processes/coordinator/main.lua
-- Bundle timestamp: Fri Sep  5 17:55:10 EDT 2025

-- JSON require (allowed in AO environment)
local json = require('json')

-- Coordinator Process Main Entry Point
-- Primary coordinator process with session management and API gateway functionality

-- JSON handling for AO environment
local json = {}
local success, jsonModule = pcall(require, 'json')
if success then
    json = jsonModule
else
    -- Simple JSON implementation for AO environment
    json = {
        encode = function(obj)
            if type(obj) == "string" then
                return '"' .. obj:gsub('"', '\\"') .. '"'
            elseif type(obj) == "number" then
                return tostring(obj)
            elseif type(obj) == "boolean" then
                return obj and "true" or "false"
            elseif obj == nil then
                return "null"
            elseif type(obj) == "table" then
                local isArray = true
                local maxIndex = 0
                for k, v in pairs(obj) do
                    if type(k) ~= "number" then
                        isArray = false
                        break
                    end
                    maxIndex = math.max(maxIndex, k)
                end
                
                if isArray then
                    local result = "["
                    for i = 1, maxIndex do
                        if i > 1 then result = result .. "," end
                        result = result .. json.encode(obj[i])
                    end
                    return result .. "]"
                else
                    local result = "{"
                    local first = true
                    for k, v in pairs(obj) do
                        if not first then result = result .. "," end
                        result = result .. json.encode(tostring(k)) .. ":" .. json.encode(v)
                        first = false
                    end
                    return result .. "}"
                end
            else
                return "null"
            end
        end,
        decode = function(str)
            -- Basic decode - for now just return empty table
            -- Would need more robust implementation for full JSON parsing
            return {}
        end
    }
end

-- Load process coordination components from foundation

-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")

-- Message Correlation System for Inter-Process Communication
-- Provides unique correlation ID generation and tracking across message chains


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")

-- Cryptographically secure RNG wrapper for AO processes
-- Replaces non-deterministic math.random() with seedable crypto-based randomness

local CryptoRNG = {
    -- Battle RNG state for deterministic battles
    battleSeed = nil,
    battleCounter = 0,
    
    -- General RNG state for non-battle operations
    globalSeed = nil,
    globalCounter = 0
}

-- Initialize battle RNG with a specific seed for deterministic battles
function CryptoRNG.initBattleRNG(seed)
    if not seed or type(seed) ~= "string" then
        error("Battle RNG seed must be a string")
    end
    CryptoRNG.battleSeed = seed
    CryptoRNG.battleCounter = 0
end

-- Initialize global RNG with a seed (or generate one from ao.crypto)
function CryptoRNG.initGlobalRNG(seed, timestamp)
    if seed then
        CryptoRNG.globalSeed = seed
    else
        -- Use AO crypto to generate a random seed (with fallback for testing)
        if ao and ao.crypto and ao.crypto.cipher then
            CryptoRNG.globalSeed = ao.crypto.cipher.issuer()
        else
            -- Fallback for testing environment - use current time
            CryptoRNG.globalSeed = tostring(timestamp or 0)
        end
    end
    CryptoRNG.globalCounter = 0
end

-- Get deterministic random integer in battle context
function CryptoRNG.battleRandomInt(min, max)
    if not CryptoRNG.battleSeed then
        error("Battle RNG not initialized - call CryptoRNG.initBattleRNG(seed) first")
    end
    
    -- Increment counter for deterministic sequence
    CryptoRNG.battleCounter = CryptoRNG.battleCounter + 1
    
    -- Create deterministic input combining seed and counter
    local input = CryptoRNG.battleSeed .. ":" .. tostring(CryptoRNG.battleCounter)
    
    -- Use AO crypto to generate deterministic hash (with fallback)
    local hash
    if ao and ao.crypto and ao.crypto.utils then
        hash = ao.crypto.utils.hash(input)
    else
        -- Fallback hash function for testing using simple string hashing
        local hashNum = 0
        for i = 1, #input do
            hashNum = hashNum + string.byte(input, i) * (i * 31)
        end
        hash = tostring(math.abs(hashNum))
    end
    
    -- Convert hash to number and normalize to range
    local num = 0
    for i = 1, math.min(8, #hash) do
        num = num + string.byte(hash, i) * (256 ^ (i - 1))
    end
    
    -- Normalize to requested range
    if min and max then
        return min + (num % (max - min + 1))
    else
        return num % 100 + 1  -- Default 1-100 range
    end
end

-- Get random number in battle context (0-1 float)
function CryptoRNG.battleRandom()
    local randomInt = CryptoRNG.battleRandomInt(0, 999999)
    return randomInt / 999999
end

-- Get random integer in global context
function CryptoRNG.globalRandomInt(min, max)
    if not CryptoRNG.globalSeed then
        CryptoRNG.initGlobalRNG()
    end
    
    CryptoRNG.globalCounter = CryptoRNG.globalCounter + 1
    
    -- Create deterministic input
    local input = CryptoRNG.globalSeed .. ":" .. tostring(CryptoRNG.globalCounter)
    
    -- Use AO crypto for randomness (with fallback)
    local hash
    if ao and ao.crypto and ao.crypto.utils then
        hash = ao.crypto.utils.hash(input)
    else
        -- Fallback hash function for testing using simple string hashing
        local hashNum = 0
        for i = 1, #input do
            hashNum = hashNum + string.byte(input, i) * (i * 37)
        end
        hash = tostring(math.abs(hashNum))
    end
    
    -- Convert to number
    local num = 0
    for i = 1, math.min(8, #hash) do
        num = num + string.byte(hash, i) * (256 ^ (i - 1))
    end
    
    -- Normalize to range
    if min and max then
        return min + (num % (max - min + 1))
    else
        return num % 100 + 1
    end
end

-- Get random float in global context (0-1)
function CryptoRNG.globalRandom()
    local randomInt = CryptoRNG.globalRandomInt(0, 999999)
    return randomInt / 999999
end

-- Compatibility functions that match math.random() interface
function CryptoRNG.random(...)
    local args = {...}
    local argCount = #args
    
    if argCount == 0 then
        -- math.random() -> 0-1 float
        return CryptoRNG.globalRandom()
    elseif argCount == 1 then
        -- math.random(n) -> 1 to n
        return CryptoRNG.globalRandomInt(1, args[1])
    elseif argCount == 2 then
        -- math.random(m, n) -> m to n
        return CryptoRNG.globalRandomInt(args[1], args[2])
    else
        error("Invalid number of arguments to CryptoRNG.random()")
    end
end

-- Battle-specific random that follows the same interface
function CryptoRNG.battleRandomCompat(...)
    local args = {...}
    local argCount = #args
    
    if argCount == 0 then
        return CryptoRNG.battleRandom()
    elseif argCount == 1 then
        return CryptoRNG.battleRandomInt(1, args[1])
    elseif argCount == 2 then
        return CryptoRNG.battleRandomInt(args[1], args[2])
    else
        error("Invalid number of arguments to CryptoRNG.battleRandomCompat()")
    end
end

-- Reset battle RNG state (for new battles)
function CryptoRNG.resetBattleRNG()
    CryptoRNG.battleSeed = nil
    CryptoRNG.battleCounter = 0
end

-- Get current battle RNG state for debugging
function CryptoRNG.getBattleState()
    return {
        seed = CryptoRNG.battleSeed,
        counter = CryptoRNG.battleCounter
    }
end


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local MessageCorrelator = {
    -- Correlation tracking storage
    activeCorrelations = {},
    correlationHistory = {},
    maxHistorySize = 10000
}

-- Correlation Types
MessageCorrelator.CORRELATION_TYPES = {
    INTER_PROCESS = "INTER_PROCESS",
    INTRA_PROCESS = "INTRA_PROCESS",
    CLIENT_REQUEST = "CLIENT_REQUEST"
}

-- Message Status
MessageCorrelator.MESSAGE_STATUS = {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING", 
    COMPLETED = "COMPLETED",
    FAILED = "FAILED",
    TIMEOUT = "TIMEOUT"
}

-- Initialize the correlation system
function MessageCorrelator.initialize()
    MessageCorrelator.activeCorrelations = {}
    MessageCorrelator.correlationHistory = {}
    CryptoRNG.initGlobalRNG()
    print("[MessageCorrelator] Correlation system initialized")
end

-- Generate unique correlation ID using AO crypto module
function MessageCorrelator.generateCorrelationId(correlationType, timestamp)
    local currentTimestamp = timestamp or (msg and msg.Timestamp) or 0
    local baseTimestamp = currentTimestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    local prefix = correlationType == MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS and "ipc" or "cor"
    
    return prefix .. "_" .. baseTimestamp .. "_" .. randomSuffix
end

-- Create new correlation with full metadata
function MessageCorrelator.createCorrelation(originProcessId, targetProcessId, messageType, parentCorrelationId, timestamp)
    local correlationId = MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS, timestamp)
    local currentTimestamp = timestamp or 0
    
    local correlation = {
        id = correlationId,
        parent = parentCorrelationId,
        origin = originProcessId,
        target = targetProcessId,
        messageType = messageType,
        status = MessageCorrelator.MESSAGE_STATUS.PENDING,
        created = currentTimestamp,
        lastUpdated = currentTimestamp,
        chain = {}
    }
    
    -- Add to parent chain if this is a nested operation
    if parentCorrelationId and MessageCorrelator.activeCorrelations[parentCorrelationId] then
        table.insert(MessageCorrelator.activeCorrelations[parentCorrelationId].chain, correlationId)
        correlation.depth = (MessageCorrelator.activeCorrelations[parentCorrelationId].depth or 0) + 1
    else
        correlation.depth = 0
    end
    
    MessageCorrelator.activeCorrelations[correlationId] = correlation
    
    return correlationId
end

-- Update correlation status
function MessageCorrelator.updateCorrelationStatus(correlationId, status, errorMessage, timestamp)
    local correlation = MessageCorrelator.activeCorrelations[correlationId]
    if not correlation then
        return false, "Correlation not found: " .. tostring(correlationId)
    end
    
    correlation.status = status
    correlation.lastUpdated = timestamp or 0
    
    if errorMessage then
        correlation.error = errorMessage
    end
    
    -- Move to history if completed or failed
    if status == MessageCorrelator.MESSAGE_STATUS.COMPLETED or 
       status == MessageCorrelator.MESSAGE_STATUS.FAILED or 
       status == MessageCorrelator.MESSAGE_STATUS.TIMEOUT then
        MessageCorrelator.moveToHistory(correlationId)
    end
    
    return true
end

-- Get correlation metadata
function MessageCorrelator.getCorrelation(correlationId)
    return MessageCorrelator.activeCorrelations[correlationId] or 
           MessageCorrelator.correlationHistory[correlationId]
end

-- Get all active correlations for a process
function MessageCorrelator.getProcessCorrelations(processId)
    local processCorrelations = {}
    
    for correlationId, correlation in pairs(MessageCorrelator.activeCorrelations) do
        if correlation.origin == processId or correlation.target == processId then
            processCorrelations[correlationId] = correlation
        end
    end
    
    return processCorrelations
end

-- Get correlation chain (parent and all children)
function MessageCorrelator.getCorrelationChain(correlationId)
    local correlation = MessageCorrelator.getCorrelation(correlationId)
    if not correlation then
        return nil
    end
    
    local chain = { correlation }
    
    -- Get parent chain
    local parent = correlation.parent
    while parent do
        local parentCorrelation = MessageCorrelator.getCorrelation(parent)
        if parentCorrelation then
            table.insert(chain, 1, parentCorrelation)
            parent = parentCorrelation.parent
        else
            break
        end
    end
    
    -- Get child chain
    local function addChildren(currentId)
        local current = MessageCorrelator.getCorrelation(currentId)
        if current and current.chain then
            for _, childId in ipairs(current.chain) do
                local childCorrelation = MessageCorrelator.getCorrelation(childId)
                if childCorrelation then
                    table.insert(chain, childCorrelation)
                    addChildren(childId)
                end
            end
        end
    end
    
    addChildren(correlationId)
    
    return chain
end

-- Move correlation to history and cleanup
function MessageCorrelator.moveToHistory(correlationId)
    local correlation = MessageCorrelator.activeCorrelations[correlationId]
    if not correlation then
        return false
    end
    
    -- Move to history
    MessageCorrelator.correlationHistory[correlationId] = correlation
    MessageCorrelator.activeCorrelations[correlationId] = nil
    
    -- Cleanup old history if at max size
    MessageCorrelator.cleanupHistory()
    
    return true
end

-- Cleanup old correlation history
function MessageCorrelator.cleanupHistory()
    local historySize = 0
    for _ in pairs(MessageCorrelator.correlationHistory) do
        historySize = historySize + 1
    end
    
    if historySize > MessageCorrelator.maxHistorySize then
        local oldestCorrelations = {}
        for correlationId, correlation in pairs(MessageCorrelator.correlationHistory) do
            table.insert(oldestCorrelations, {id = correlationId, lastUpdated = correlation.lastUpdated})
        end
        
        table.sort(oldestCorrelations, function(a, b) return a.lastUpdated < b.lastUpdated end)
        
        -- Remove oldest 20%
        local removeCount = math.floor(MessageCorrelator.maxHistorySize * 0.2)
        for i = 1, removeCount do
            MessageCorrelator.correlationHistory[oldestCorrelations[i].id] = nil
        end
    end
end

-- Create correlation metadata for message
function MessageCorrelator.createCorrelationMetadata(correlationId, originProcessId, targetProcessId, parentCorrelationId)
    return {
        id = correlationId,
        parent = parentCorrelationId,
        origin = originProcessId,
        target = targetProcessId
    }
end

-- Validate correlation metadata format
function MessageCorrelator.validateCorrelationMetadata(correlationMeta)
    if not correlationMeta or type(correlationMeta) ~= "table" then
        return false, "Correlation metadata must be a table"
    end
    
    if not correlationMeta.id or type(correlationMeta.id) ~= "string" then
        return false, "Correlation ID is required and must be a string"
    end
    
    if not correlationMeta.origin or type(correlationMeta.origin) ~= "string" then
        return false, "Origin process ID is required and must be a string"
    end
    
    if not correlationMeta.target or type(correlationMeta.target) ~= "string" then
        return false, "Target process ID is required and must be a string"
    end
    
    return true
end

-- Get correlation statistics
function MessageCorrelator.getStatistics()
    local activeCount = 0
    local historyCount = 0
    local statusCounts = {}
    
    for _ in pairs(MessageCorrelator.activeCorrelations) do
        activeCount = activeCount + 1
    end
    
    for _ in pairs(MessageCorrelator.correlationHistory) do
        historyCount = historyCount + 1
    end
    
    for _, correlation in pairs(MessageCorrelator.activeCorrelations) do
        statusCounts[correlation.status] = (statusCounts[correlation.status] or 0) + 1
    end
    
    for _, correlation in pairs(MessageCorrelator.correlationHistory) do
        statusCounts[correlation.status] = (statusCounts[correlation.status] or 0) + 1
    end
    
    return {
        activeCorrelations = activeCount,
        historyCorrelations = historyCount,
        totalCorrelations = activeCount + historyCount,
        statusBreakdown = statusCounts,
        maxHistorySize = MessageCorrelator.maxHistorySize
    }
end


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")

-- Inter-Process Authentication Framework
-- Provides secure process identity validation and token-based authentication


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local ProcessAuthenticator = {
    -- Process registry storage
    processRegistry = {},
    
    -- Authentication token storage (active tokens)
    activeTokens = {},
    
    -- Token configuration
    tokenExpirationTime = 3600, -- 1 hour in seconds
    maxTokensPerProcess = 5,
    
    -- Process types for capability-based authentication
    PROCESS_TYPES = {
        COORDINATOR = "coordinator",
        BATTLE = "battle", 
        POKEMON = "pokemon",
        SHOP = "shop",
        SECURITY = "security",
        ADMIN = "admin"
    },
    
    -- Authentication levels
    AUTH_LEVELS = {
        NONE = "none",
        BASIC = "basic", 
        ELEVATED = "elevated",
        ADMIN = "admin"
    }
}

-- Initialize the authentication system
function ProcessAuthenticator.initialize()
    ProcessAuthenticator.processRegistry = {}
    ProcessAuthenticator.activeTokens = {}
    CryptoRNG.initGlobalRNG()
    print("[ProcessAuthenticator] Authentication system initialized")
end

-- Register a process with identity validation
function ProcessAuthenticator.registerProcess(processId, processType, walletAddress, capabilities, timestamp)
    if not processId or type(processId) ~= "string" or processId == "" then
        return false, "Process ID is required and must be a non-empty string"
    end
    
    if not processType or not ProcessAuthenticator.PROCESS_TYPES[processType:upper()] then
        return false, "Invalid process type. Must be one of: " .. table.concat(ProcessAuthenticator._getProcessTypeList(), ", ")
    end
    
    if not walletAddress or type(walletAddress) ~= "string" or walletAddress == "" then
        return false, "Wallet address is required for process identity validation"
    end
    
    if not capabilities or type(capabilities) ~= "table" then
        return false, "Capabilities must be provided as a table"
    end
    
    -- Validate wallet address format (basic validation)
    if not ProcessAuthenticator._validateWalletAddress(walletAddress) then
        return false, "Invalid wallet address format"
    end
    
    -- Check if process is already registered
    if ProcessAuthenticator.processRegistry[processId] then
        return false, "Process already registered: " .. processId
    end
    
    local currentTime = timestamp or 0
    local processRecord = {
        id = processId,
        type = processType:lower(),
        walletAddress = walletAddress,
        capabilities = capabilities,
        authLevel = ProcessAuthenticator._determineAuthLevel(processType, capabilities),
        status = "active",
        registeredAt = currentTime,
        lastHeartbeat = currentTime,
        tokenCount = 0
    }
    
    ProcessAuthenticator.processRegistry[processId] = processRecord
    
    print(string.format("[ProcessAuthenticator] Process registered: %s (Type: %s, Auth: %s)", 
          processId, processType, processRecord.authLevel))
    
    return true
end

-- Generate authentication token for a registered process
function ProcessAuthenticator.generateAuthToken(processId, requestingWallet, expirationTime, timestamp)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return nil, "Process not registered: " .. tostring(processId)
    end
    
    -- Validate requesting wallet matches registered wallet
    if processRecord.walletAddress ~= requestingWallet then
        return nil, "Wallet address mismatch for process authentication"
    end
    
    if processRecord.status ~= "active" then
        return nil, "Process is not active: " .. processId
    end
    
    -- Check token limit
    if processRecord.tokenCount >= ProcessAuthenticator.maxTokensPerProcess then
        return nil, "Maximum tokens exceeded for process: " .. processId
    end
    
    local tokenExpiration = expirationTime or ProcessAuthenticator.tokenExpirationTime
    local currentTime = timestamp or 0
    
    -- Generate unique token
    local tokenId = ProcessAuthenticator._generateTokenId()
    local tokenSignature = ProcessAuthenticator._generateTokenSignature(processId, tokenId, currentTime)
    
    local token = {
        id = tokenId,
        processId = processId,
        walletAddress = requestingWallet,
        signature = tokenSignature,
        authLevel = processRecord.authLevel,
        capabilities = processRecord.capabilities,
        issuedAt = currentTime,
        expiresAt = currentTime + tokenExpiration,
        status = "active"
    }
    
    ProcessAuthenticator.activeTokens[tokenId] = token
    processRecord.tokenCount = processRecord.tokenCount + 1
    processRecord.lastHeartbeat = currentTime
    
    return {
        tokenId = tokenId,
        signature = tokenSignature,
        expiresAt = token.expiresAt,
        authLevel = token.authLevel
    }
end

-- Validate authentication token and return process context
function ProcessAuthenticator.validateAuthToken(tokenId, signature, timestamp)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if not token then
        return false, nil, "Invalid token: not found"
    end
    
    if token.status ~= "active" then
        return false, nil, "Token is not active"
    end
    
    if (timestamp or 0) > token.expiresAt then
        ProcessAuthenticator._expireToken(tokenId)
        return false, nil, "Token has expired"
    end
    
    if token.signature ~= signature then
        return false, nil, "Token signature validation failed"
    end
    
    -- Return process authentication context
    local authContext = {
        processId = token.processId,
        walletAddress = token.walletAddress,
        authLevel = token.authLevel,
        capabilities = token.capabilities,
        tokenExpiration = token.expiresAt
    }
    
    return true, authContext, nil
end

-- Revoke authentication token
function ProcessAuthenticator.revokeAuthToken(tokenId, requestingProcessId)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if not token then
        return false, "Token not found: " .. tostring(tokenId)
    end
    
    -- Only the token owner or admin process can revoke
    if token.processId ~= requestingProcessId then
        local requestingProcess = ProcessAuthenticator.processRegistry[requestingProcessId]
        if not requestingProcess or requestingProcess.authLevel ~= ProcessAuthenticator.AUTH_LEVELS.ADMIN then
            return false, "Insufficient privileges to revoke token"
        end
    end
    
    ProcessAuthenticator._expireToken(tokenId)
    return true
end

-- Validate process-to-process communication authorization
function ProcessAuthenticator.validateProcessAuth(sourceProcessId, targetProcessId, operation, authToken, timestamp)
    -- Validate source process token
    local isValidToken, authContext, tokenError = ProcessAuthenticator.validateAuthToken(authToken.tokenId, authToken.signature, timestamp)
    if not isValidToken then
        return false, "Source process authentication failed: " .. tostring(tokenError)
    end
    
    if authContext.processId ~= sourceProcessId then
        return false, "Token process ID mismatch"
    end
    
    -- Check if target process exists and is active
    local targetProcess = ProcessAuthenticator.processRegistry[targetProcessId]
    if not targetProcess then
        return false, "Target process not registered: " .. targetProcessId
    end
    
    if targetProcess.status ~= "active" then
        return false, "Target process is not active: " .. targetProcessId
    end
    
    -- Validate operation authorization based on capabilities
    if not ProcessAuthenticator._isOperationAuthorized(authContext.capabilities, operation) then
        return false, "Operation not authorized for source process capabilities"
    end
    
    return true
end

-- Update process heartbeat
function ProcessAuthenticator.updateProcessHeartbeat(processId, timestamp)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return false, "Process not registered: " .. processId
    end
    
    processRecord.lastHeartbeat = timestamp or 0
    return true
end

-- Get registered process information
function ProcessAuthenticator.getProcessInfo(processId)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return nil
    end
    
    return {
        id = processRecord.id,
        type = processRecord.type,
        capabilities = processRecord.capabilities,
        authLevel = processRecord.authLevel,
        status = processRecord.status,
        registeredAt = processRecord.registeredAt,
        lastHeartbeat = processRecord.lastHeartbeat
    }
end

-- List all registered processes
function ProcessAuthenticator.listRegisteredProcesses(filterByType, filterByAuthLevel)
    local processes = {}
    
    for processId, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        local includeProcess = true
        
        if filterByType and processRecord.type ~= filterByType then
            includeProcess = false
        end
        
        if filterByAuthLevel and processRecord.authLevel ~= filterByAuthLevel then
            includeProcess = false
        end
        
        if includeProcess then
            processes[processId] = ProcessAuthenticator.getProcessInfo(processId)
        end
    end
    
    return processes
end

-- Clean up expired tokens and inactive processes
function ProcessAuthenticator.cleanup(timestamp)
    local currentTime = timestamp or 0
    local expiredTokens = 0
    local inactiveProcesses = 0
    
    -- Clean up expired tokens
    for tokenId, token in pairs(ProcessAuthenticator.activeTokens) do
        if currentTime > token.expiresAt then
            ProcessAuthenticator._expireToken(tokenId)
            expiredTokens = expiredTokens + 1
        end
    end
    
    -- Mark processes inactive if no heartbeat for too long (2x token expiration)
    local inactiveThreshold = ProcessAuthenticator.tokenExpirationTime * 2
    for processId, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        if processRecord.status == "active" and 
           (currentTime - processRecord.lastHeartbeat) > inactiveThreshold then
            processRecord.status = "inactive"
            inactiveProcesses = inactiveProcesses + 1
        end
    end
    
    return {
        expiredTokens = expiredTokens,
        inactiveProcesses = inactiveProcesses
    }
end

-- Get authentication statistics
function ProcessAuthenticator.getStatistics()
    local registeredProcesses = 0
    local activeProcesses = 0
    local activeTokens = 0
    local processTypes = {}
    local authLevels = {}
    
    for _, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        registeredProcesses = registeredProcesses + 1
        if processRecord.status == "active" then
            activeProcesses = activeProcesses + 1
        end
        
        processTypes[processRecord.type] = (processTypes[processRecord.type] or 0) + 1
        authLevels[processRecord.authLevel] = (authLevels[processRecord.authLevel] or 0) + 1
    end
    
    for _ in pairs(ProcessAuthenticator.activeTokens) do
        activeTokens = activeTokens + 1
    end
    
    return {
        registeredProcesses = registeredProcesses,
        activeProcesses = activeProcesses,
        inactiveProcesses = registeredProcesses - activeProcesses,
        activeTokens = activeTokens,
        maxTokensPerProcess = ProcessAuthenticator.maxTokensPerProcess,
        tokenExpirationTime = ProcessAuthenticator.tokenExpirationTime,
        processTypeBreakdown = processTypes,
        authLevelBreakdown = authLevels
    }
end

-- Private helper functions

function ProcessAuthenticator._validateWalletAddress(walletAddress)
    -- Basic validation: should be 43 characters and alphanumeric with specific chars
    if type(walletAddress) ~= "string" or #walletAddress ~= 43 then
        return false
    end
    
    -- Check for valid Arweave wallet address pattern (Base64URL)
    return string.match(walletAddress, "^[A-Za-z0-9_%-]+$") ~= nil
end

function ProcessAuthenticator._determineAuthLevel(processType, capabilities)
    local normalizedType = processType:lower()
    
    if normalizedType == ProcessAuthenticator.PROCESS_TYPES.ADMIN then
        return ProcessAuthenticator.AUTH_LEVELS.ADMIN
    elseif normalizedType == ProcessAuthenticator.PROCESS_TYPES.SECURITY or
           normalizedType == ProcessAuthenticator.PROCESS_TYPES.COORDINATOR then
        return ProcessAuthenticator.AUTH_LEVELS.ELEVATED
    else
        return ProcessAuthenticator.AUTH_LEVELS.BASIC
    end
end

function ProcessAuthenticator._generateTokenId()
    local timestamp = msg.Timestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    return "token_" .. timestamp .. "_" .. randomSuffix
end

function ProcessAuthenticator._generateTokenSignature(processId, tokenId, timestamp)
    -- Generate signature using process ID, token ID, and timestamp
    local signatureBase = processId .. "|" .. tokenId .. "|" .. timestamp
    
    -- Use crypto module for signing (in real AO environment)
    -- For now, use a deterministic hash-like generation
    local signature = ""
    for i = 1, #signatureBase do
        local char = string.sub(signatureBase, i, i)
        signature = signature .. string.format("%02x", string.byte(char))
    end
    
    -- Add random suffix using CryptoRNG
    local randomSuffix = CryptoRNG.random(1000000, 9999999)
    return signature .. "_" .. randomSuffix
end

function ProcessAuthenticator._expireToken(tokenId)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if token then
        -- Decrease token count for the process
        local processRecord = ProcessAuthenticator.processRegistry[token.processId]
        if processRecord then
            processRecord.tokenCount = math.max(0, processRecord.tokenCount - 1)
        end
        
        -- Remove token from active tokens
        ProcessAuthenticator.activeTokens[tokenId] = nil
    end
end

function ProcessAuthenticator._isOperationAuthorized(capabilities, operation)
    if not capabilities or type(capabilities) ~= "table" then
        return false
    end
    
    -- Check if operation is in capabilities list
    for _, capability in ipairs(capabilities) do
        if capability == operation or capability == "*" then
            return true
        end
    end
    
    return false
end

function ProcessAuthenticator._getProcessTypeList()
    local types = {}
    for _, processType in pairs(ProcessAuthenticator.PROCESS_TYPES) do
        table.insert(types, processType:upper())
    end
    return types
end


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: game-logic.process-coordination.message-router =====
-- File: ao-processes/game-logic/process-coordination/message-router.lua
-- Original require: local MessageRouter = require("game-logic.process-coordination.message-router")

-- Message Routing Layer for Inter-Process Communication
-- Routes messages based on operation type and maintains routing tables


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


local MessageRouter = {
    -- Routing table mapping operation types to process types
    operationRoutes = {},
    
    -- Process capability routing cache
    processCapabilities = {},
    
    -- Load balancing state for multiple processes of same type
    loadBalancingState = {},
    
    -- Routing statistics
    routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
}

-- Operation types for routing classification
MessageRouter.OPERATION_TYPES = {
    -- Battle operations
    BATTLE_RESOLUTION = "BATTLE_RESOLUTION",
    BATTLE_START = "BATTLE_START",
    BATTLE_END = "BATTLE_END",
    MOVE_EXECUTION = "MOVE_EXECUTION",
    
    -- Pokemon operations  
    POKEMON_UPDATE = "POKEMON_UPDATE",
    POKEMON_EVOLUTION = "POKEMON_EVOLUTION",
    STAT_CALCULATION = "STAT_CALCULATION",
    POKEMON_CAPTURE = "POKEMON_CAPTURE",
    
    -- Shop operations
    SHOP_TRANSACTION = "SHOP_TRANSACTION", 
    SHOP_INVENTORY = "SHOP_INVENTORY",
    ITEM_PURCHASE = "ITEM_PURCHASE",
    ITEM_SALE = "ITEM_SALE",
    
    -- Game state operations
    SAVE_GAME = "SAVE_GAME",
    LOAD_GAME = "LOAD_GAME",
    SYNC_STATE = "SYNC_STATE",
    
    -- Admin operations
    PROCESS_HEALTH = "PROCESS_HEALTH",
    SYSTEM_STATUS = "SYSTEM_STATUS",
    CONFIGURATION_UPDATE = "CONFIGURATION_UPDATE"
}

-- Default routing table
MessageRouter.DEFAULT_ROUTES = {
    -- Battle operations route to battle processes
    [MessageRouter.OPERATION_TYPES.BATTLE_RESOLUTION] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.BATTLE_START] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.BATTLE_END] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.MOVE_EXECUTION] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    
    -- Pokemon operations route to pokemon processes
    [MessageRouter.OPERATION_TYPES.POKEMON_UPDATE] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.POKEMON_EVOLUTION] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.STAT_CALCULATION] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.POKEMON_CAPTURE] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    
    -- Shop operations route to shop processes
    [MessageRouter.OPERATION_TYPES.SHOP_TRANSACTION] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.SHOP_INVENTORY] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.ITEM_PURCHASE] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.ITEM_SALE] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    
    -- Game state operations route to coordinator processes
    [MessageRouter.OPERATION_TYPES.SAVE_GAME] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    [MessageRouter.OPERATION_TYPES.LOAD_GAME] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    [MessageRouter.OPERATION_TYPES.SYNC_STATE] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    
    -- Admin operations route to admin processes
    [MessageRouter.OPERATION_TYPES.PROCESS_HEALTH] = ProcessAuthenticator.PROCESS_TYPES.ADMIN,
    [MessageRouter.OPERATION_TYPES.SYSTEM_STATUS] = ProcessAuthenticator.PROCESS_TYPES.ADMIN,
    [MessageRouter.OPERATION_TYPES.CONFIGURATION_UPDATE] = ProcessAuthenticator.PROCESS_TYPES.ADMIN
}

-- Routing strategies
MessageRouter.ROUTING_STRATEGIES = {
    ROUND_ROBIN = "round_robin",
    LEAST_LOADED = "least_loaded",
    CAPABILITY_MATCH = "capability_match",
    RANDOM = "random"
}

-- Initialize the message router
function MessageRouter.initialize()
    -- Copy default routes to active routing table
    MessageRouter.operationRoutes = {}
    for operation, processType in pairs(MessageRouter.DEFAULT_ROUTES) do
        MessageRouter.operationRoutes[operation] = processType
    end
    
    MessageRouter.processCapabilities = {}
    MessageRouter.loadBalancingState = {}
    MessageRouter.routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
    
    print("[MessageRouter] Message routing system initialized")
end

-- Add or update routing rule
function MessageRouter.addRoute(operationType, targetProcessType, priority)
    if not operationType or not targetProcessType then
        return false, "Operation type and target process type are required"
    end
    
    if not MessageRouter.OPERATION_TYPES[operationType] and not operationType then
        return false, "Invalid operation type: " .. tostring(operationType)
    end
    
    local validProcessTypes = ProcessAuthenticator._getProcessTypeList()
    local isValidProcessType = false
    for _, processType in ipairs(validProcessTypes) do
        if processType:lower() == targetProcessType:lower() then
            isValidProcessType = true
            break
        end
    end
    
    if not isValidProcessType then
        return false, "Invalid target process type: " .. tostring(targetProcessType)
    end
    
    MessageRouter.operationRoutes[operationType] = {
        processType = targetProcessType:lower(),
        priority = priority or "NORMAL",
        addedAt = timestamp or 0
    }
    
    return true
end

-- Remove routing rule
function MessageRouter.removeRoute(operationType)
    if not operationType then
        return false, "Operation type is required"
    end
    
    if MessageRouter.operationRoutes[operationType] then
        MessageRouter.operationRoutes[operationType] = nil
        return true
    end
    
    return false, "Route not found for operation: " .. tostring(operationType)
end

-- Route a message to appropriate process based on operation type
function MessageRouter.routeMessage(operationType, messageData, routingStrategy)
    MessageRouter.routingStats.totalRoutes = MessageRouter.routingStats.totalRoutes + 1
    MessageRouter.routingStats.routesByOperation[operationType] = (MessageRouter.routingStats.routesByOperation[operationType] or 0) + 1
    
    local strategy = routingStrategy or MessageRouter.ROUTING_STRATEGIES.CAPABILITY_MATCH
    
    -- Get target process type from routing table
    local routeInfo = MessageRouter.operationRoutes[operationType]
    if not routeInfo then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "No route found for operation: " .. tostring(operationType)
    end
    
    local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
    
    -- Get available processes for target type
    local availableProcesses = ProcessAuthenticator.listRegisteredProcesses(targetProcessType)
    if not availableProcesses or MessageRouter._getTableSize(availableProcesses) == 0 then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "No available processes of type: " .. targetProcessType
    end
    
    -- Select target process based on routing strategy
    local targetProcessId = MessageRouter._selectTargetProcess(availableProcesses, strategy, operationType)
    if not targetProcessId then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "Failed to select target process for operation: " .. operationType
    end
    
    -- Create routing context
    local routingContext = {
        operationType = operationType,
        targetProcessId = targetProcessId,
        targetProcessType = targetProcessType,
        routingStrategy = strategy,
        routedAt = timestamp or 0,
        messageData = messageData
    }
    
    MessageRouter.routingStats.successfulRoutes = MessageRouter.routingStats.successfulRoutes + 1
    MessageRouter.routingStats.routesByProcessType[targetProcessType] = (MessageRouter.routingStats.routesByProcessType[targetProcessType] or 0) + 1
    
    return routingContext
end

-- Get routing information for operation type
function MessageRouter.getRouteInfo(operationType)
    local routeInfo = MessageRouter.operationRoutes[operationType]
    if not routeInfo then
        return nil
    end
    
    local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
    local availableProcesses = ProcessAuthenticator.listRegisteredProcesses(targetProcessType)
    
    return {
        operationType = operationType,
        targetProcessType = targetProcessType,
        priority = type(routeInfo) == "table" and routeInfo.priority or "NORMAL",
        availableProcessCount = MessageRouter._getTableSize(availableProcesses),
        availableProcessIds = MessageRouter._getProcessIds(availableProcesses)
    }
end

-- Validate message routing capability
function MessageRouter.validateRouting(operationType, sourceProcessId, targetProcessId)
    -- Check if operation type has a valid route
    local routeInfo = MessageRouter.getRouteInfo(operationType)
    if not routeInfo then
        return false, "No route configured for operation: " .. tostring(operationType)
    end
    
    -- Check if target process exists and is active
    local targetProcess = ProcessAuthenticator.getProcessInfo(targetProcessId)
    if not targetProcess then
        return false, "Target process not found: " .. tostring(targetProcessId)
    end
    
    if targetProcess.status ~= "active" then
        return false, "Target process is not active: " .. targetProcessId
    end
    
    -- Check if target process type matches route
    if targetProcess.type ~= routeInfo.targetProcessType then
        return false, string.format("Process type mismatch. Expected: %s, Got: %s", 
                                   routeInfo.targetProcessType, targetProcess.type)
    end
    
    -- Check if target process has required capability
    if not MessageRouter._processHasCapability(targetProcess.capabilities, operationType) then
        return false, "Target process lacks required capability for operation: " .. operationType
    end
    
    return true
end

-- Update process capabilities cache
function MessageRouter.updateProcessCapabilities(processId, capabilities)
    if not processId or not capabilities then
        return false
    end
    
    MessageRouter.processCapabilities[processId] = {
        capabilities = capabilities,
        lastUpdated = timestamp or 0
    }
    
    return true
end

-- Get all configured routes
function MessageRouter.getAllRoutes()
    local routes = {}
    
    for operationType, routeInfo in pairs(MessageRouter.operationRoutes) do
        local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
        local priority = type(routeInfo) == "table" and routeInfo.priority or "NORMAL"
        
        routes[operationType] = {
            targetProcessType = targetProcessType,
            priority = priority,
            availableProcesses = MessageRouter._getTableSize(ProcessAuthenticator.listRegisteredProcesses(targetProcessType))
        }
    end
    
    return routes
end

-- Get routing statistics
function MessageRouter.getRoutingStatistics()
    return {
        totalRoutes = MessageRouter.routingStats.totalRoutes,
        successfulRoutes = MessageRouter.routingStats.successfulRoutes,
        failedRoutes = MessageRouter.routingStats.failedRoutes,
        successRate = MessageRouter.routingStats.totalRoutes > 0 and 
                     (MessageRouter.routingStats.successfulRoutes / MessageRouter.routingStats.totalRoutes) or 0,
        routesByOperation = MessageRouter.routingStats.routesByOperation,
        routesByProcessType = MessageRouter.routingStats.routesByProcessType,
        configuredRoutes = MessageRouter._getTableSize(MessageRouter.operationRoutes)
    }
end

-- Reset routing statistics
function MessageRouter.resetStatistics()
    MessageRouter.routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
end

-- Private helper functions

function MessageRouter._selectTargetProcess(availableProcesses, strategy, operationType)
    if MessageRouter._getTableSize(availableProcesses) == 0 then
        return nil
    end
    
    local processIds = MessageRouter._getProcessIds(availableProcesses)
    
    if strategy == MessageRouter.ROUTING_STRATEGIES.ROUND_ROBIN then
        return MessageRouter._roundRobinSelection(processIds, operationType)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.CAPABILITY_MATCH then
        return MessageRouter._capabilityMatchSelection(availableProcesses, operationType)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.RANDOM then
        return MessageRouter._randomSelection(processIds)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.LEAST_LOADED then
        -- For now, fallback to round robin (load tracking would be implemented later)
        return MessageRouter._roundRobinSelection(processIds, operationType)
        
    else
        -- Default to first available process
        return processIds[1]
    end
end

function MessageRouter._roundRobinSelection(processIds, operationType)
    if not MessageRouter.loadBalancingState[operationType] then
        MessageRouter.loadBalancingState[operationType] = 0
    end
    
    local index = (MessageRouter.loadBalancingState[operationType] % #processIds) + 1
    MessageRouter.loadBalancingState[operationType] = MessageRouter.loadBalancingState[operationType] + 1
    
    return processIds[index]
end

function MessageRouter._capabilityMatchSelection(availableProcesses, operationType)
    -- Select process with best capability match
    for processId, processInfo in pairs(availableProcesses) do
        if MessageRouter._processHasCapability(processInfo.capabilities, operationType) then
            return processId
        end
    end
    
    -- Fallback to first available if no perfect match
    local processIds = MessageRouter._getProcessIds(availableProcesses)
    return processIds[1]
end

function MessageRouter._randomSelection(processIds)
    local randomIndex = math.random(1, #processIds)
    return processIds[randomIndex]
end

function MessageRouter._processHasCapability(capabilities, operationType)
    if not capabilities or type(capabilities) ~= "table" then
        return false
    end
    
    for _, capability in ipairs(capabilities) do
        if capability == "*" or capability == operationType or 
           MessageRouter._isRelatedCapability(capability, operationType) then
            return true
        end
    end
    
    return false
end

function MessageRouter._isRelatedCapability(capability, operationType)
    -- Check if capability covers the operation type
    local capabilityMappings = {
        ["battle-resolution"] = {"BATTLE_RESOLUTION", "BATTLE_START", "BATTLE_END", "MOVE_EXECUTION"},
        ["pokemon-management"] = {"POKEMON_UPDATE", "POKEMON_EVOLUTION", "STAT_CALCULATION", "POKEMON_CAPTURE"},
        ["shop-operations"] = {"SHOP_TRANSACTION", "SHOP_INVENTORY", "ITEM_PURCHASE", "ITEM_SALE"},
        ["game-state"] = {"SAVE_GAME", "LOAD_GAME", "SYNC_STATE"},
        ["admin-operations"] = {"PROCESS_HEALTH", "SYSTEM_STATUS", "CONFIGURATION_UPDATE"}
    }
    
    local relatedOperations = capabilityMappings[capability]
    if relatedOperations then
        for _, operation in ipairs(relatedOperations) do
            if operation == operationType then
                return true
            end
        end
    end
    
    return false
end

function MessageRouter._getProcessIds(processes)
    local ids = {}
    for processId, _ in pairs(processes) do
        table.insert(ids, processId)
    end
    return ids
end

function MessageRouter._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: game-logic.process-coordination.message-router =====


-- ===== MODULE: game-logic.process-coordination.backward-compatibility =====
-- File: ao-processes/game-logic/process-coordination/backward-compatibility.lua
-- Original require: local BackwardCompatibility = require("game-logic.process-coordination.backward-compatibility")

-- Backward Compatibility Layer for Single-Process to Multi-Process Migration
-- Provides compatibility shims for existing single-process message formats


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


local BackwardCompatibility = {
    -- Legacy message format mappings
    legacyOperationMappings = {},
    
    -- Compatibility statistics
    compatibilityStats = {
        legacyMessagesProcessed = 0,
        adaptedMessages = 0,
        incompatibleMessages = 0,
        byOperationType = {}
    }
}

-- Legacy operation types to new operation type mappings
BackwardCompatibility.LEGACY_OPERATION_MAPPINGS = {
    -- Battle legacy mappings
    ["battle"] = "BATTLE_RESOLUTION",
    ["start-battle"] = "BATTLE_START", 
    ["end-battle"] = "BATTLE_END",
    ["execute-move"] = "MOVE_EXECUTION",
    
    -- Pokemon legacy mappings
    ["update-pokemon"] = "POKEMON_UPDATE",
    ["evolve-pokemon"] = "POKEMON_EVOLUTION", 
    ["calculate-stats"] = "STAT_CALCULATION",
    ["catch-pokemon"] = "POKEMON_CAPTURE",
    
    -- Shop legacy mappings
    ["shop-buy"] = "ITEM_PURCHASE",
    ["shop-sell"] = "ITEM_SALE",
    ["shop-inventory"] = "SHOP_INVENTORY",
    ["shop-transaction"] = "SHOP_TRANSACTION",
    
    -- Game state legacy mappings
    ["save"] = "SAVE_GAME",
    ["load"] = "LOAD_GAME",
    ["sync"] = "SYNC_STATE",
    
    -- Admin legacy mappings  
    ["get-info"] = "PROCESS_INFO",
    ["admin"] = "ADMIN_COMMAND"
}

-- Initialize the backward compatibility system
function BackwardCompatibility.initialize()
    BackwardCompatibility.legacyOperationMappings = BackwardCompatibility.LEGACY_OPERATION_MAPPINGS
    
    -- Initialize statistics tracking
    for legacyOp, newOp in pairs(BackwardCompatibility.legacyOperationMappings) do
        BackwardCompatibility.compatibilityStats.byOperationType[legacyOp] = {
            processed = 0,
            adapted = 0,
            failed = 0
        }
    end
    
    return true
end

-- Detect if a message uses legacy format
function BackwardCompatibility.isLegacyMessage(messageData)
    if type(messageData) ~= "table" then
        return false
    end
    
    -- Check for new inter-process message structure
    if messageData.correlation and messageData.auth and messageData.operation then
        return false -- This is a new format message
    end
    
    -- Check for common legacy patterns
    local hasLegacyPatterns = (
        messageData.action or 
        messageData.command or 
        messageData.operation or
        messageData.type
    )
    
    return hasLegacyPatterns ~= nil
end

-- Convert legacy message format to new inter-process format
function BackwardCompatibility.adaptLegacyMessage(messageData, fromProcessId, toProcessId, timestamp)
    BackwardCompatibility.compatibilityStats.legacyMessagesProcessed = BackwardCompatibility.compatibilityStats.legacyMessagesProcessed + 1
    
    if not BackwardCompatibility.isLegacyMessage(messageData) then
        return messageData -- Already new format, no adaptation needed
    end
    
    -- Extract legacy operation type
    local legacyOperationType = messageData.action or messageData.command or messageData.operation or messageData.type
    if not legacyOperationType then
        BackwardCompatibility.compatibilityStats.incompatibleMessages = BackwardCompatibility.compatibilityStats.incompatibleMessages + 1
        return nil, "Cannot determine operation type from legacy message"
    end
    
    -- Map to new operation type
    local newOperationType = BackwardCompatibility.legacyOperationMappings[legacyOperationType]
    if not newOperationType then
        BackwardCompatibility.compatibilityStats.incompatibleMessages = BackwardCompatibility.compatibilityStats.incompatibleMessages + 1
        return nil, "No mapping found for legacy operation: " .. tostring(legacyOperationType)
    end
    
    -- Generate correlation ID
    local correlationId = MessageCorrelator.generateCorrelationId()
    
    -- Create authentication context (use process authenticator if available)
    local authToken = "legacy-compat-token"
    if ProcessAuthenticator.generateProcessToken then
        authToken = ProcessAuthenticator.generateProcessToken(fromProcessId or "legacy-process") or authToken
    end
    
    -- Build new format message
    local adaptedMessage = {
        correlation = {
            id = correlationId,
            parent = nil, -- Legacy messages don't have parent correlations
            origin = fromProcessId or "legacy-process",
            target = toProcessId or "coordinator"
        },
        auth = {
            processId = fromProcessId or "legacy-process", 
            token = authToken,
            timestamp = timestamp or 0
        },
        operation = {
            type = newOperationType,
            priority = messageData.priority or "NORMAL",
            retryable = messageData.retryable ~= false -- Default to retryable
        },
        payload = {
            -- Include original message data as payload
            originalData = messageData,
            legacyOperation = legacyOperationType,
            adaptedBy = "BackwardCompatibility",
            adaptedAt = timestamp or 0
        },
        _compatibility = {
            isAdapted = true,
            originalFormat = "legacy",
            adaptedFrom = legacyOperationType
        }
    }
    
    -- Update statistics
    BackwardCompatibility.compatibilityStats.adaptedMessages = BackwardCompatibility.compatibilityStats.adaptedMessages + 1
    if BackwardCompatibility.compatibilityStats.byOperationType[legacyOperationType] then
        BackwardCompatibility.compatibilityStats.byOperationType[legacyOperationType].processed = 
            BackwardCompatibility.compatibilityStats.byOperationType[legacyOperationType].processed + 1
        BackwardCompatibility.compatibilityStats.byOperationType[legacyOperationType].adapted = 
            BackwardCompatibility.compatibilityStats.byOperationType[legacyOperationType].adapted + 1
    end
    
    return adaptedMessage
end

-- Convert new format response back to legacy format for backward compatibility
function BackwardCompatibility.adaptResponseToLegacy(responseData, originalLegacyMessage, timestamp)
    if not responseData then
        return nil
    end
    
    -- If original message wasn't legacy, return response as-is
    if not BackwardCompatibility.isLegacyMessage(originalLegacyMessage) then
        return responseData
    end
    
    -- Extract key information for legacy response
    local legacyResponse = {
        success = responseData.success or true,
        result = responseData.payload or responseData.result,
        timestamp = responseData.timestamp or timestamp or 0,
        correlationId = responseData.correlationId or (responseData.correlation and responseData.correlation.id),
        processedBy = responseData.targetProcessId or "unknown"
    }
    
    -- Include error information if present
    if responseData.error then
        legacyResponse.success = false
        legacyResponse.error = responseData.error
        legacyResponse.message = responseData.message
    end
    
    -- Mark as adapted response
    legacyResponse._adapted = {
        from = "inter-process",
        to = "legacy",
        adaptedAt = timestamp or 0
    }
    
    return legacyResponse
end

-- Add custom legacy operation mapping
function BackwardCompatibility.addLegacyMapping(legacyOperation, newOperation)
    if not legacyOperation or not newOperation then
        return false, "Both legacy and new operation types are required"
    end
    
    BackwardCompatibility.legacyOperationMappings[legacyOperation] = newOperation
    
    -- Initialize statistics tracking
    BackwardCompatibility.compatibilityStats.byOperationType[legacyOperation] = {
        processed = 0,
        adapted = 0, 
        failed = 0
    }
    
    return true
end

-- Remove legacy operation mapping
function BackwardCompatibility.removeLegacyMapping(legacyOperation)
    if BackwardCompatibility.legacyOperationMappings[legacyOperation] then
        BackwardCompatibility.legacyOperationMappings[legacyOperation] = nil
        BackwardCompatibility.compatibilityStats.byOperationType[legacyOperation] = nil
        return true
    end
    return false
end

-- Get compatibility statistics
function BackwardCompatibility.getCompatibilityStats()
    return BackwardCompatibility.compatibilityStats
end

-- Get available legacy mappings
function BackwardCompatibility.getLegacyMappings()
    return BackwardCompatibility.legacyOperationMappings
end

-- Validate legacy message compatibility
function BackwardCompatibility.validateLegacyCompatibility(messageData)
    if not BackwardCompatibility.isLegacyMessage(messageData) then
        return true, "Message uses new format - no compatibility issues"
    end
    
    local legacyOperationType = messageData.action or messageData.command or messageData.operation or messageData.type
    if not legacyOperationType then
        return false, "Cannot determine operation type from legacy message"
    end
    
    local newOperationType = BackwardCompatibility.legacyOperationMappings[legacyOperationType]
    if not newOperationType then
        return false, "No mapping available for legacy operation: " .. tostring(legacyOperationType)
    end
    
    return true, "Legacy operation '" .. legacyOperationType .. "' can be mapped to '" .. newOperationType .. "'"
end

-- Initialize on module load
BackwardCompatibility.initialize()


-- ===== END MODULE: game-logic.process-coordination.backward-compatibility =====


-- ===== MODULE: game-logic.process-coordination.performance-monitor =====
-- File: ao-processes/game-logic/process-coordination/performance-monitor.lua
-- Original require: local PerformanceMonitor = require("game-logic.process-coordination.performance-monitor")

-- Performance Monitoring and Benchmarking System
-- Provides baseline performance metrics and inter-process communication monitoring

local PerformanceMonitor = {
    -- Performance metrics storage
    metrics = {
        totalOperations = 0,
        totalLatency = 0,
        minLatency = nil,
        maxLatency = nil,
        averageLatency = 0,
        
        -- Operation-specific metrics
        operationMetrics = {},
        
        -- Process-specific metrics  
        processMetrics = {},
        
        -- Throughput tracking
        operationsPerSecond = 0,
        lastThroughputUpdate = 0,
        currentSecondOperations = 0,
        
        -- Memory and resource usage
        memoryUsage = {},
        
        -- Error rate tracking
        totalErrors = 0,
        errorRate = 0
    },
    
    -- Benchmark baselines for comparison
    baselines = {
        monolithicLatency = 0, -- To be measured
        maxAcceptableLatency = 100, -- milliseconds
        targetThroughput = 100, -- operations per second
        maxMemoryUsage = 1024 * 1024 * 50 -- 50MB in bytes
    },
    
    -- Active performance measurements
    activeMeasurements = {}
}

-- Initialize performance monitoring system
function PerformanceMonitor.initialize(timestamp)
    PerformanceMonitor.metrics.totalOperations = 0
    PerformanceMonitor.metrics.totalLatency = 0
    PerformanceMonitor.metrics.averageLatency = 0
    PerformanceMonitor.metrics.lastThroughputUpdate = timestamp or 0
    
    return true
end

-- Start measuring operation performance
function PerformanceMonitor.startMeasurement(operationId, operationType, processId, timestamp)
    if not operationId then
        return false, "Operation ID is required for performance measurement"
    end
    
    local startTime = os.clock() * 1000 -- Convert to milliseconds
    local startMemory = collectgarbage("count") * 1024 -- Convert KB to bytes
    
    PerformanceMonitor.activeMeasurements[operationId] = {
        operationType = operationType,
        processId = processId,
        startTime = startTime,
        startMemory = startMemory,
        timestamp = timestamp or 0
    }
    
    return true
end

-- End measuring operation performance and record metrics
function PerformanceMonitor.endMeasurement(operationId, success, errorCode)
    local measurement = PerformanceMonitor.activeMeasurements[operationId]
    if not measurement then
        return false, "No active measurement found for operation: " .. tostring(operationId)
    end
    
    local endTime = os.clock() * 1000 -- Convert to milliseconds
    local endMemory = collectgarbage("count") * 1024 -- Convert KB to bytes
    
    local latency = endTime - measurement.startTime
    local memoryDelta = endMemory - measurement.startMemory
    
    -- Update global metrics
    PerformanceMonitor.metrics.totalOperations = PerformanceMonitor.metrics.totalOperations + 1
    PerformanceMonitor.metrics.totalLatency = PerformanceMonitor.metrics.totalLatency + latency
    PerformanceMonitor.metrics.averageLatency = PerformanceMonitor.metrics.totalLatency / PerformanceMonitor.metrics.totalOperations
    
    -- Update min/max latency
    if not PerformanceMonitor.metrics.minLatency or latency < PerformanceMonitor.metrics.minLatency then
        PerformanceMonitor.metrics.minLatency = latency
    end
    if not PerformanceMonitor.metrics.maxLatency or latency > PerformanceMonitor.metrics.maxLatency then
        PerformanceMonitor.metrics.maxLatency = latency
    end
    
    -- Update operation-specific metrics
    local opType = measurement.operationType or "unknown"
    if not PerformanceMonitor.metrics.operationMetrics[opType] then
        PerformanceMonitor.metrics.operationMetrics[opType] = {
            count = 0,
            totalLatency = 0,
            averageLatency = 0,
            minLatency = nil,
            maxLatency = nil,
            successCount = 0,
            errorCount = 0,
            memoryUsage = { total = 0, average = 0, min = nil, max = nil }
        }
    end
    
    local opMetrics = PerformanceMonitor.metrics.operationMetrics[opType]
    opMetrics.count = opMetrics.count + 1
    opMetrics.totalLatency = opMetrics.totalLatency + latency
    opMetrics.averageLatency = opMetrics.totalLatency / opMetrics.count
    
    if not opMetrics.minLatency or latency < opMetrics.minLatency then
        opMetrics.minLatency = latency
    end
    if not opMetrics.maxLatency or latency > opMetrics.maxLatency then
        opMetrics.maxLatency = latency
    end
    
    if success then
        opMetrics.successCount = opMetrics.successCount + 1
    else
        opMetrics.errorCount = opMetrics.errorCount + 1
        PerformanceMonitor.metrics.totalErrors = PerformanceMonitor.metrics.totalErrors + 1
    end
    
    -- Track memory usage
    opMetrics.memoryUsage.total = opMetrics.memoryUsage.total + memoryDelta
    opMetrics.memoryUsage.average = opMetrics.memoryUsage.total / opMetrics.count
    if not opMetrics.memoryUsage.min or memoryDelta < opMetrics.memoryUsage.min then
        opMetrics.memoryUsage.min = memoryDelta
    end
    if not opMetrics.memoryUsage.max or memoryDelta > opMetrics.memoryUsage.max then
        opMetrics.memoryUsage.max = memoryDelta
    end
    
    -- Update process-specific metrics
    local processId = measurement.processId or "unknown"
    if not PerformanceMonitor.metrics.processMetrics[processId] then
        PerformanceMonitor.metrics.processMetrics[processId] = {
            operationCount = 0,
            totalLatency = 0,
            averageLatency = 0,
            errorCount = 0
        }
    end
    
    local procMetrics = PerformanceMonitor.metrics.processMetrics[processId]
    procMetrics.operationCount = procMetrics.operationCount + 1
    procMetrics.totalLatency = procMetrics.totalLatency + latency
    procMetrics.averageLatency = procMetrics.totalLatency / procMetrics.operationCount
    
    if not success then
        procMetrics.errorCount = procMetrics.errorCount + 1
    end
    
    -- Update throughput metrics
    PerformanceMonitor.updateThroughputMetrics()
    
    -- Update error rate
    PerformanceMonitor.metrics.errorRate = PerformanceMonitor.metrics.totalErrors / PerformanceMonitor.metrics.totalOperations
    
    -- Clean up active measurement
    PerformanceMonitor.activeMeasurements[operationId] = nil
    
    return {
        operationId = operationId,
        operationType = opType,
        processId = processId,
        latency = latency,
        memoryDelta = memoryDelta,
        success = success,
        errorCode = errorCode,
        timestamp = timestamp or 0
    }
end

-- Update throughput metrics (operations per second)
function PerformanceMonitor.updateThroughputMetrics(timestamp)
    local currentTime = timestamp or 0
    local timeDiff = currentTime - PerformanceMonitor.metrics.lastThroughputUpdate
    
    if timeDiff >= 1 then -- Update every second
        PerformanceMonitor.metrics.operationsPerSecond = PerformanceMonitor.metrics.currentSecondOperations / timeDiff
        PerformanceMonitor.metrics.currentSecondOperations = 0
        PerformanceMonitor.metrics.lastThroughputUpdate = currentTime
    end
    
    PerformanceMonitor.metrics.currentSecondOperations = PerformanceMonitor.metrics.currentSecondOperations + 1
end

-- Get current performance metrics
function PerformanceMonitor.getMetrics()
    return PerformanceMonitor.metrics
end

-- Get performance metrics for specific operation type
function PerformanceMonitor.getOperationMetrics(operationType)
    return PerformanceMonitor.metrics.operationMetrics[operationType]
end

-- Get performance metrics for specific process
function PerformanceMonitor.getProcessMetrics(processId)
    return PerformanceMonitor.metrics.processMetrics[processId]
end

-- Set performance baseline for comparison
function PerformanceMonitor.setBaseline(baselineType, value)
    if not baselineType or not value then
        return false, "Baseline type and value are required"
    end
    
    PerformanceMonitor.baselines[baselineType] = value
    return true
end

-- Get performance baselines
function PerformanceMonitor.getBaselines()
    return PerformanceMonitor.baselines
end

-- Compare current performance against baselines
function PerformanceMonitor.compareToBaselines()
    local comparison = {
        latencyComparison = {},
        throughputComparison = {},
        memoryComparison = {},
        performanceRegression = false,
        recommendations = {}
    }
    
    -- Latency comparison
    local avgLatency = PerformanceMonitor.metrics.averageLatency
    local baselineLatency = PerformanceMonitor.baselines.monolithicLatency
    
    if baselineLatency > 0 then
        local latencyRatio = avgLatency / baselineLatency
        comparison.latencyComparison = {
            current = avgLatency,
            baseline = baselineLatency,
            ratio = latencyRatio,
            degradation = latencyRatio > 1.1, -- 10% tolerance
            improvement = latencyRatio < 0.9
        }
        
        if latencyRatio > 1.2 then -- 20% degradation threshold
            comparison.performanceRegression = true
            table.insert(comparison.recommendations, "Latency degradation detected: " .. math.floor((latencyRatio - 1) * 100) .. "% slower than baseline")
        end
    end
    
    -- Throughput comparison
    local currentThroughput = PerformanceMonitor.metrics.operationsPerSecond
    local targetThroughput = PerformanceMonitor.baselines.targetThroughput
    
    comparison.throughputComparison = {
        current = currentThroughput,
        target = targetThroughput,
        meetingTarget = currentThroughput >= targetThroughput * 0.9 -- 10% tolerance
    }
    
    if not comparison.throughputComparison.meetingTarget then
        table.insert(comparison.recommendations, "Throughput below target: " .. currentThroughput .. " vs " .. targetThroughput .. " ops/sec")
    end
    
    -- Memory comparison
    local currentMemory = collectgarbage("count") * 1024
    local maxMemory = PerformanceMonitor.baselines.maxMemoryUsage
    
    comparison.memoryComparison = {
        current = currentMemory,
        maximum = maxMemory,
        withinLimits = currentMemory <= maxMemory
    }
    
    if not comparison.memoryComparison.withinLimits then
        comparison.performanceRegression = true
        table.insert(comparison.recommendations, "Memory usage exceeds limits: " .. math.floor(currentMemory/1024/1024) .. "MB vs " .. math.floor(maxMemory/1024/1024) .. "MB limit")
    end
    
    return comparison
end

-- Generate performance report
function PerformanceMonitor.generatePerformanceReport()
    local metrics = PerformanceMonitor.getMetrics()
    local baselines = PerformanceMonitor.getBaselines()
    local comparison = PerformanceMonitor.compareToBaselines()
    
    return {
        summary = {
            totalOperations = metrics.totalOperations,
            averageLatency = metrics.averageLatency,
            minLatency = metrics.minLatency,
            maxLatency = metrics.maxLatency,
            throughput = metrics.operationsPerSecond,
            errorRate = metrics.errorRate,
            memoryUsage = collectgarbage("count") * 1024
        },
        baselines = baselines,
        comparison = comparison,
        operationBreakdown = metrics.operationMetrics,
        processBreakdown = metrics.processMetrics,
        recommendations = comparison.recommendations,
        generatedAt = timestamp or 0
    }
end

-- Reset performance metrics (useful for testing)
function PerformanceMonitor.resetMetrics(timestamp)
    PerformanceMonitor.metrics = {
        totalOperations = 0,
        totalLatency = 0,
        minLatency = nil,
        maxLatency = nil,
        averageLatency = 0,
        operationMetrics = {},
        processMetrics = {},
        operationsPerSecond = 0,
        lastThroughputUpdate = timestamp or 0,
        currentSecondOperations = 0,
        memoryUsage = {},
        totalErrors = 0,
        errorRate = 0
    }
    PerformanceMonitor.activeMeasurements = {}
    return true
end

-- Clean up stale measurements (measurements older than 5 minutes)
function PerformanceMonitor.cleanupStaleMeasurements(timestamp)
    local currentTime = timestamp or 0
    local cleanedCount = 0
    
    for operationId, measurement in pairs(PerformanceMonitor.activeMeasurements) do
        if (currentTime - measurement.timestamp) > 300 then -- 5 minutes
            PerformanceMonitor.activeMeasurements[operationId] = nil
            cleanedCount = cleanedCount + 1
        end
    end
    
    return cleanedCount
end

-- Initialize on module load
PerformanceMonitor.initialize()


-- ===== END MODULE: game-logic.process-coordination.performance-monitor =====


-- Load coordinator-specific components

-- ===== MODULE: coordinator.components.api-gateway =====
-- File: ao-processes/coordinator/components/api-gateway.lua
-- Original require: local APIGateway = require("coordinator.components.api-gateway")

-- API Gateway for Coordinator Process
-- Maintains 100% compatibility with existing client message formats
-- Provides protocol translation between client and inter-process communication


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.backward-compatibility =====
-- File: ao-processes/game-logic/process-coordination/backward-compatibility.lua
-- Original require: local BackwardCompatibility = require("game-logic.process-coordination.backward-compatibility")


-- ===== END MODULE: game-logic.process-coordination.backward-compatibility =====


-- ===== MODULE: game-logic.process-coordination.message-router =====
-- File: ao-processes/game-logic/process-coordination/message-router.lua
-- Original require: local MessageRouter = require("game-logic.process-coordination.message-router")


-- ===== END MODULE: game-logic.process-coordination.message-router =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


local APIGateway = {
    -- Client API version compatibility
    apiVersion = "1.0",
    supportedVersions = {"1.0", "0.9"},
    
    -- Statistics tracking
    stats = {
        clientRequestsProcessed = 0,
        interProcessRequestsGenerated = 0,
        responseAggregations = 0,
        versionMismatches = 0,
        protocolTranslations = 0
    }
}

-- Client message format definitions (maintains existing compatibility)
APIGateway.CLIENT_MESSAGE_TYPES = {
    -- Battle operations
    BATTLE_COMMAND = "BATTLE_COMMAND",
    MOVE_EXECUTION = "MOVE_EXECUTION",
    BATTLE_STATE_QUERY = "BATTLE_STATE_QUERY",
    
    -- Pokemon operations
    QUERY_STATE = "QUERY_STATE", 
    POKEMON_UPDATE = "POKEMON_UPDATE",
    EVOLUTION_CHECK = "EVOLUTION_CHECK",
    
    -- Shop operations
    SHOP_PURCHASE = "SHOP_PURCHASE",
    SHOP_INVENTORY = "SHOP_INVENTORY",
    ITEM_TRANSACTION = "ITEM_TRANSACTION",
    
    -- Game management
    SAVE_GAME = "SAVE_GAME",
    LOAD_GAME = "LOAD_GAME",
    GAME_STATE_SYNC = "GAME_STATE_SYNC"
}

-- API Gateway message routing table (client action -> internal operation)
APIGateway.CLIENT_ROUTING_TABLE = {
    -- Battle commands
    [APIGateway.CLIENT_MESSAGE_TYPES.BATTLE_COMMAND] = MessageRouter.OPERATION_TYPES.BATTLE_RESOLUTION,
    [APIGateway.CLIENT_MESSAGE_TYPES.MOVE_EXECUTION] = MessageRouter.OPERATION_TYPES.MOVE_EXECUTION,
    [APIGateway.CLIENT_MESSAGE_TYPES.BATTLE_STATE_QUERY] = MessageRouter.OPERATION_TYPES.BATTLE_RESOLUTION,
    
    -- Pokemon operations
    [APIGateway.CLIENT_MESSAGE_TYPES.QUERY_STATE] = MessageRouter.OPERATION_TYPES.POKEMON_UPDATE,
    [APIGateway.CLIENT_MESSAGE_TYPES.POKEMON_UPDATE] = MessageRouter.OPERATION_TYPES.POKEMON_UPDATE,
    [APIGateway.CLIENT_MESSAGE_TYPES.EVOLUTION_CHECK] = MessageRouter.OPERATION_TYPES.POKEMON_EVOLUTION,
    
    -- Shop operations
    [APIGateway.CLIENT_MESSAGE_TYPES.SHOP_PURCHASE] = MessageRouter.OPERATION_TYPES.ITEM_PURCHASE,
    [APIGateway.CLIENT_MESSAGE_TYPES.SHOP_INVENTORY] = MessageRouter.OPERATION_TYPES.SHOP_INVENTORY,
    [APIGateway.CLIENT_MESSAGE_TYPES.ITEM_TRANSACTION] = MessageRouter.OPERATION_TYPES.SHOP_TRANSACTION,
    
    -- Game management
    [APIGateway.CLIENT_MESSAGE_TYPES.SAVE_GAME] = MessageRouter.OPERATION_TYPES.SAVE_GAME,
    [APIGateway.CLIENT_MESSAGE_TYPES.LOAD_GAME] = MessageRouter.OPERATION_TYPES.LOAD_GAME,
    [APIGateway.CLIENT_MESSAGE_TYPES.GAME_STATE_SYNC] = MessageRouter.OPERATION_TYPES.SYNC_STATE
}

-- Initialize API Gateway
function APIGateway.initialize()
    APIGateway.stats = {
        clientRequestsProcessed = 0,
        interProcessRequestsGenerated = 0,
        responseAggregations = 0,
        versionMismatches = 0,
        protocolTranslations = 0
    }
    
    print("[APIGateway] API Gateway initialized with version " .. APIGateway.apiVersion)
    return true
end

-- Process client message and translate to inter-process format
function APIGateway.processClientMessage(clientMessage, clientInfo)
    APIGateway.stats.clientRequestsProcessed = APIGateway.stats.clientRequestsProcessed + 1
    
    -- Validate client message format
    local isValid, validationError = APIGateway.validateClientMessage(clientMessage)
    if not isValid then
        return nil, "Invalid client message: " .. validationError
    end
    
    -- Check API version compatibility
    local isCompatible, versionMessage = APIGateway.validateAPIVersion(clientMessage.apiVersion or "1.0")
    if not isCompatible then
        APIGateway.stats.versionMismatches = APIGateway.stats.versionMismatches + 1
        return nil, "API version incompatible: " .. versionMessage
    end
    
    -- Extract client action and player information
    local clientAction = clientMessage.action or clientMessage.type
    local playerId = clientMessage.playerId or (clientInfo and clientInfo.sender) or "unknown"
    
    -- Map client action to internal operation
    local internalOperation = APIGateway.CLIENT_ROUTING_TABLE[clientAction]
    if not internalOperation then
        -- Try backward compatibility layer
        local compatibilityResult = BackwardCompatibility.adaptLegacyMessage(clientMessage)
        if compatibilityResult then
            internalOperation = compatibilityResult.operation.type
            APIGateway.stats.protocolTranslations = APIGateway.stats.protocolTranslations + 1
        else
            return nil, "Unsupported client action: " .. tostring(clientAction)
        end
    end
    
    -- Generate correlation for tracking
    local correlationId = MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.CLIENT_REQUEST)
    MessageCorrelator.createCorrelation("coordinator", "routing", internalOperation)
    
    -- Create inter-process message
    local interProcessMessage = {
        correlation = {
            id = correlationId,
            clientRequestId = clientMessage.requestId,
            sessionId = APIGateway._generateSessionId(playerId),
            origin = "coordinator",
            clientOrigin = true
        },
        routing = {
            targetProcessType = APIGateway._getTargetProcessType(internalOperation),
            routingStrategy = APIGateway._selectRoutingStrategy(internalOperation, clientMessage),
            fallbackProcesses = APIGateway._getFallbackProcesses(internalOperation),
            requiresAggregation = APIGateway._requiresResponseAggregation(internalOperation)
        },
        session = {
            sessionId = APIGateway._generateSessionId(playerId),
            playerId = playerId,
            stateVersion = clientMessage.stateVersion or 1,
            requiresStateSync = APIGateway._requiresStateSync(internalOperation)
        },
        operation = {
            type = internalOperation,
            priority = clientMessage.priority or "NORMAL",
            retryable = clientMessage.retryable ~= false,
            timeout = clientMessage.timeout or 30000
        },
        payload = {
            originalClientMessage = clientMessage,
            clientAction = clientAction,
            translatedBy = "APIGateway",
            translatedAt = 0,
            data = clientMessage.data or clientMessage.payload
        },
        _gateway = {
            processedBy = "APIGateway",
            apiVersion = APIGateway.apiVersion,
            clientVersion = clientMessage.apiVersion or "1.0"
        }
    }
    
    APIGateway.stats.interProcessRequestsGenerated = APIGateway.stats.interProcessRequestsGenerated + 1
    
    return interProcessMessage
end

-- Aggregate multiple inter-process responses into client response
function APIGateway.aggregateResponses(responses, originalClientMessage)
    APIGateway.stats.responseAggregations = APIGateway.stats.responseAggregations + 1
    
    if not responses or #responses == 0 then
        return APIGateway._createErrorResponse("No responses received", originalClientMessage)
    end
    
    -- Single response - direct translation
    if #responses == 1 then
        return APIGateway._translateInterProcessToClient(responses[1], originalClientMessage)
    end
    
    -- Multiple responses - aggregation required
    local aggregatedResponse = {
        success = true,
        correlationId = responses[1].correlationId,
        timestamp = msg.Timestamp,
        results = {},
        metadata = {
            responseCount = #responses,
            aggregatedBy = "APIGateway",
            originalAction = originalClientMessage.action or originalClientMessage.type
        }
    }
    
    -- Process each response
    for i, response in ipairs(responses) do
        local clientResponse = APIGateway._translateInterProcessToClient(response, originalClientMessage)
        
        -- Check for errors
        if not clientResponse.success then
            aggregatedResponse.success = false
            aggregatedResponse.error = clientResponse.error or "Response aggregation failed"
        end
        
        aggregatedResponse.results[i] = clientResponse
    end
    
    -- Apply response filtering and formatting
    aggregatedResponse = APIGateway._applyClientResponseFormat(aggregatedResponse, originalClientMessage)
    
    return aggregatedResponse
end

-- Validate client message format
function APIGateway.validateClientMessage(clientMessage)
    if not clientMessage or type(clientMessage) ~= "table" then
        return false, "Client message must be a table"
    end
    
    if not clientMessage.action and not clientMessage.type then
        return false, "Client message must have 'action' or 'type' field"
    end
    
    if not clientMessage.playerId and not (clientMessage.data and clientMessage.data.playerId) then
        return false, "Player ID is required in client message"
    end
    
    return true
end

-- Validate API version compatibility
function APIGateway.validateAPIVersion(clientVersion)
    if not clientVersion then
        return true, "No version specified, using default"
    end
    
    for _, supportedVersion in ipairs(APIGateway.supportedVersions) do
        if clientVersion == supportedVersion then
            return true, "Version compatible"
        end
    end
    
    return false, "Unsupported API version: " .. clientVersion
end

-- Add support for new API version
function APIGateway.addSupportedVersion(version)
    if not version then
        return false
    end
    
    for _, supportedVersion in ipairs(APIGateway.supportedVersions) do
        if supportedVersion == version then
            return true -- Already supported
        end
    end
    
    table.insert(APIGateway.supportedVersions, version)
    return true
end

-- Get API gateway statistics
function APIGateway.getStatistics()
    return {
        apiVersion = APIGateway.apiVersion,
        supportedVersions = APIGateway.supportedVersions,
        stats = APIGateway.stats,
        routingTableSize = APIGateway._getTableSize(APIGateway.CLIENT_ROUTING_TABLE)
    }
end

-- Private helper functions

function APIGateway._generateSessionId(playerId)
    return "session_" .. playerId .. "id_" .. msg.Timestamp
end

function APIGateway._getTargetProcessType(operationType)
    -- Use MessageRouter's routing logic to determine target process type
    local routeInfo = MessageRouter.getRouteInfo(operationType)
    return routeInfo and routeInfo.targetProcessType or ProcessAuthenticator.PROCESS_TYPES.COORDINATOR
end

function APIGateway._selectRoutingStrategy(operationType, clientMessage)
    -- Battle operations benefit from capability matching
    if string.find(operationType, "BATTLE") then
        return MessageRouter.ROUTING_STRATEGIES.CAPABILITY_MATCH
    end
    
    -- State operations benefit from session affinity (least loaded)
    if string.find(operationType, "STATE") or string.find(operationType, "SAVE") or string.find(operationType, "LOAD") then
        return MessageRouter.ROUTING_STRATEGIES.LEAST_LOADED
    end
    
    -- Default to round robin for fair distribution
    return MessageRouter.ROUTING_STRATEGIES.ROUND_ROBIN
end

function APIGateway._getFallbackProcesses(operationType)
    -- For critical operations, provide coordinator as fallback
    local criticalOperations = {
        MessageRouter.OPERATION_TYPES.SAVE_GAME,
        MessageRouter.OPERATION_TYPES.LOAD_GAME,
        MessageRouter.OPERATION_TYPES.SYNC_STATE
    }
    
    for _, criticalOp in ipairs(criticalOperations) do
        if operationType == criticalOp then
            return {ProcessAuthenticator.PROCESS_TYPES.COORDINATOR}
        end
    end
    
    return {}
end

function APIGateway._requiresResponseAggregation(operationType)
    -- Complex queries that might need multiple process responses
    local aggregationOperations = {
        MessageRouter.OPERATION_TYPES.SYNC_STATE,
        MessageRouter.OPERATION_TYPES.POKEMON_UPDATE
    }
    
    for _, aggOp in ipairs(aggregationOperations) do
        if operationType == aggOp then
            return true
        end
    end
    
    return false
end

function APIGateway._requiresStateSync(operationType)
    -- Operations that modify state require synchronization
    local statefulOperations = {
        MessageRouter.OPERATION_TYPES.BATTLE_RESOLUTION,
        MessageRouter.OPERATION_TYPES.POKEMON_UPDATE,
        MessageRouter.OPERATION_TYPES.POKEMON_EVOLUTION,
        MessageRouter.OPERATION_TYPES.SHOP_TRANSACTION,
        MessageRouter.OPERATION_TYPES.SAVE_GAME
    }
    
    for _, stateOp in ipairs(statefulOperations) do
        if operationType == stateOp then
            return true
        end
    end
    
    return false
end

function APIGateway._translateInterProcessToClient(interProcessResponse, originalClientMessage)
    local clientResponse = {
        success = interProcessResponse.success or true,
        correlationId = interProcessResponse.correlationId,
        timestamp = interProcessResponse.timestamp or 0,
        data = interProcessResponse.payload or interProcessResponse.result,
        metadata = {
            processedBy = interProcessResponse.targetProcessId or "unknown",
            processingTime = interProcessResponse.processingTime or 0,
            translatedBy = "APIGateway"
        }
    }
    
    -- Include error information if present
    if interProcessResponse.error then
        clientResponse.success = false
        clientResponse.error = interProcessResponse.error
        clientResponse.message = interProcessResponse.message
    end
    
    return clientResponse
end

function APIGateway._applyClientResponseFormat(response, originalClientMessage)
    -- Apply any client-specific response formatting
    -- This maintains compatibility with existing client expectations
    
    if originalClientMessage.responseFormat then
        -- Apply custom formatting if requested
        if originalClientMessage.responseFormat == "compact" then
            return {
                success = response.success,
                data = response.data or response.results,
                correlationId = response.correlationId
            }
        elseif originalClientMessage.responseFormat == "detailed" then
            response.debug = APIGateway.getStatistics()
        end
    end
    
    return response
end

function APIGateway._createErrorResponse(errorMessage, originalClientMessage)
    return {
        success = false,
        error = errorMessage,
        correlationId = MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.CLIENT_REQUEST),
        timestamp = msg.Timestamp,
        originalAction = originalClientMessage and (originalClientMessage.action or originalClientMessage.type) or "unknown"
    }
end

function APIGateway._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: coordinator.components.api-gateway =====


-- Process information for discovery
local PROCESS_INFO = {
    type = "COORDINATOR",
    version = "1.0.0",
    capabilities = {
        "client-gateway",
        "session-management", 
        "process-coordination",
        "load-balancing",
        "health-monitoring",
        "hybrid-deployment"
    },
    description = "Primary coordinator process for multi-process architecture",
    endpoints = {
        "CLIENT_MESSAGE",
        "INTER_PROCESS_MESSAGE", 
        "SESSION_MANAGEMENT",
        "PROCESS_HEALTH",
        "GATEWAY_STATUS"
    }
}

-- Global process state (local for internal use)
local coordinatorState = {
    initialized = false,
    mode = "HYBRID", -- MONOLITHIC, HYBRID, or DISTRIBUTED
    activeSessions = {},
    processRegistry = {},
    healthStatus = "HEALTHY"
}

-- Expose globals for health checks
CoordinatorState = coordinatorState
ProcessRegistry = coordinatorState.processRegistry

-- Initialize coordinator process
local function initialize()
    print("[Coordinator] Initializing coordinator process...")
    
    -- Initialize process coordination foundation
    MessageCorrelator.initialize()
    ProcessAuthenticator.initialize()
    MessageRouter.initialize()
    BackwardCompatibility.initialize()
    PerformanceMonitor.initialize()
    
    -- Initialize coordinator-specific components
    APIGateway.initialize()
    
    -- Register this process with authenticator
    local authResult = ProcessAuthenticator.registerProcess(
        ao.id or "coordinator-process",
        PROCESS_INFO.type,
        PROCESS_INFO.capabilities
    )
    
    if authResult then
        print("[Coordinator] Process registered successfully")
    else
        print("[Coordinator] Warning: Process registration failed")
    end
    
    coordinatorState.initialized = true
    coordinatorState.startTime = 0
    
    print("[Coordinator] Coordinator process initialized in " .. coordinatorState.mode .. " mode")
    print("[Coordinator] Process ID: " .. (ao.id or "unknown"))
    print("[Coordinator] Capabilities: " .. table.concat(PROCESS_INFO.capabilities, ", "))
end

-- Process information handler for discovery
Handlers.add(
    "process-info",
    Handlers.utils.hasMatchingTag("Action", "Info"),
    function(msg)
        local processInfo = {
            process = PROCESS_INFO,
            state = {
                initialized = coordinatorState.initialized,
                mode = coordinatorState.mode,
                healthStatus = coordinatorState.healthStatus,
                uptime = coordinatorState.startTime and (0 - coordinatorState.startTime) or 0,
                activeSessions = _getTableSize(coordinatorState.activeSessions),
                registeredProcesses = _getTableSize(coordinatorState.processRegistry)
            },
            statistics = {
                messageCorrelator = MessageCorrelator.getStatistics(),
                messageRouter = MessageRouter.getRoutingStatistics(),
                apiGateway = APIGateway.getStatistics(),
                performanceMonitor = PerformanceMonitor.getMetrics()
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { Action = "Info-Response" },
            Data = json.encode(processInfo)
        })
    end
)

-- Health check handler
Handlers.add(
    "health-check",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_CHECK"),
    function(msg)
        local healthInfo = {
            status = coordinatorState.healthStatus,
            timestamp = msg.Timestamp,
            uptime = coordinatorState.startTime and (0 - coordinatorState.startTime) or 0,
            processId = ao.id or "unknown",
            version = PROCESS_INFO.version,
            mode = coordinatorState.mode,
            components = {
                messageCorrelator = "HEALTHY",
                processAuthenticator = "HEALTHY", 
                messageRouter = "HEALTHY",
                apiGateway = "HEALTHY"
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = {
                Action = "HEALTH_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "health-check"
            },
            Data = json.encode(healthInfo)
        })
    end
)

-- Deployment mode switching handler
Handlers.add(
    "set-deployment-mode",
    Handlers.utils.hasMatchingTag("Action", "SET_DEPLOYMENT_MODE"),
    function(msg)
        local requestData = json.decode(msg.Data)
        if not requestData or not requestData.mode then
            ao.send({
                Target = msg.From,
                Tags = { Action = "MODE_CHANGE_RESPONSE" },
                Data = json.encode({
                    success = false,
                    error = "Mode parameter required"
                })
            })
            return
        end
        
        local validModes = {"MONOLITHIC", "HYBRID", "DISTRIBUTED"}
        local isValidMode = false
        for _, validMode in ipairs(validModes) do
            if requestData.mode == validMode then
                isValidMode = true
                break
            end
        end
        
        if not isValidMode then
            ao.send({
                Target = msg.From,
                Tags = { Action = "MODE_CHANGE_RESPONSE" },
                Data = json.encode({
                    success = false,
                    error = "Invalid mode. Valid modes: " .. table.concat(validModes, ", ")
                })
            })
            return
        end
        
        local previousMode = coordinatorState.mode
        coordinatorState.mode = requestData.mode
        
        print("[Coordinator] Deployment mode changed from " .. previousMode .. " to " .. requestData.mode)
        
        ao.send({
            Target = msg.From,
            Tags = { Action = "MODE_CHANGE_RESPONSE" },
            Data = json.encode({
                success = true,
                previousMode = previousMode,
                newMode = coordinatorState.mode,
                timestamp = 0
            })
        })
    end
)

-- Error handler
Handlers.add(
    "error-handler",
    function(msg)
        -- Catch-all error handler for unhandled messages
        return not (msg.Tags.Action and (
            msg.Tags.Action == "CLIENT_MESSAGE" or
            msg.Tags.Action == "INTER_PROCESS_MESSAGE" or
            msg.Tags.Action == "SESSION_MANAGEMENT" or
            msg.Tags.Action == "PROCESS_HEALTH" or
            msg.Tags.Action == "GATEWAY_STATUS" or
            msg.Tags.Action == "Info" or
            msg.Tags.Action == "HEALTH_CHECK" or
            msg.Tags.Action == "SET_DEPLOYMENT_MODE"
        ))
    end,
    function(msg)
        print("[Coordinator] Unhandled message: Action=" .. (msg.Tags.Action or "nil"))
        
        if msg.From and msg.Tags.Action then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "ERROR_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Unsupported action",
                    action = msg.Tags.Action
                })
            })
        end
    end
)

-- Private helper functions

local function _getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

-- Load coordinator-specific handlers

-- ===== MODULE: coordinator.handlers.api-gateway-handler =====
-- File: ao-processes/coordinator/handlers/api-gateway-handler.lua
-- Original require: require("coordinator.handlers.api-gateway-handler")

-- API Gateway Handler for Coordinator Process
-- Handles client message processing and protocol translation


-- ===== MODULE: coordinator.components.api-gateway =====
-- File: ao-processes/coordinator/components/api-gateway.lua
-- Original require: local APIGateway = require("coordinator.components.api-gateway")


-- ===== END MODULE: coordinator.components.api-gateway =====


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- Register client message handler
Handlers.add(
    "client-message",
    Handlers.utils.hasMatchingTag("Action", "CLIENT_MESSAGE"),
    function(msg)
        -- Authenticate message sender
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CLIENT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed",
                    message = authResult.error
                })
            })
            return
        end

        -- Parse client message
        local clientMessage = json.decode(msg.Data)
        if not clientMessage then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CLIENT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid JSON in client message"
                })
            })
            return
        end

        -- Process through API Gateway
        local clientInfo = {
            sender = msg.From,
            timestamp = msg.Timestamp,
            tags = msg.Tags
        }
        
        local interProcessMessage, processingError = APIGateway.processClientMessage(clientMessage, clientInfo)
        if not interProcessMessage then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "CLIENT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or clientMessage.requestId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Gateway processing failed",
                    message = processingError
                })
            })
            return
        end

        -- Route to appropriate process or handle locally
        local routingContext = interProcessMessage.routing
        
        if routingContext.targetProcessType == ProcessAuthenticator.PROCESS_TYPES.COORDINATOR then
            -- Handle locally in coordinator
            local localHandler = _G["handle_" .. interProcessMessage.operation.type:lower()]
            if localHandler then
                local localResponse = localHandler(interProcessMessage.payload.data, interProcessMessage)
                
                -- Send response back to client
                ao.send({
                    Target = msg.From,
                    Tags = {
                        Action = "CLIENT_RESPONSE",
                        CorrelationId = interProcessMessage.correlation.id
                    },
                    Data = json.encode(APIGateway._translateInterProcessToClient(localResponse, clientMessage))
                })
            else
                -- No local handler available
                ao.send({
                    Target = msg.From,
                    Tags = {
                        Action = "CLIENT_RESPONSE", 
                        CorrelationId = interProcessMessage.correlation.id
                    },
                    Data = json.encode({
                        success = false,
                        error = "Operation not supported locally",
                        operation = interProcessMessage.operation.type
                    })
                })
            end
            
        else
            -- Route to specialized process
            local targetProcess = _selectTargetProcess(routingContext)
            if not targetProcess then
                ao.send({
                    Target = msg.From,
                    Tags = {
                        Action = "CLIENT_RESPONSE",
                        CorrelationId = interProcessMessage.correlation.id  
                    },
                    Data = json.encode({
                        success = false,
                        error = "No available process for operation",
                        processType = routingContext.targetProcessType
                    })
                })
                return
            end

            -- Update correlation with routing info
            MessageCorrelator.updateCorrelationStatus(
                interProcessMessage.correlation.id, 
                MessageCorrelator.MESSAGE_STATUS.PROCESSING
            )

            -- Store client info for response handling
            _storeClientContext(interProcessMessage.correlation.id, {
                clientId = msg.From,
                originalMessage = clientMessage,
                routingInfo = routingContext
            })

            -- Forward to target process
            ao.send({
                Target = targetProcess.processId,
                Tags = {
                    Action = "INTER_PROCESS_MESSAGE",
                    CorrelationId = interProcessMessage.correlation.id,
                    OperationType = interProcessMessage.operation.type,
                    Priority = interProcessMessage.operation.priority
                },
                Data = json.encode(interProcessMessage)
            })
        end
    end
)

-- Handle inter-process responses for client requests  
Handlers.add(
    "inter-process-response",
    Handlers.utils.hasMatchingTag("Action", "INTER_PROCESS_RESPONSE"),
    function(msg)
        local correlationId = msg.Tags.CorrelationId
        if not correlationId then
            print("[APIGatewayHandler] Received inter-process response without correlation ID")
            return
        end

        -- Retrieve stored client context
        local clientContext = _getClientContext(correlationId)
        if not clientContext then
            print("[APIGatewayHandler] No client context found for correlation: " .. correlationId)
            return
        end

        -- Parse inter-process response
        local interProcessResponse = json.decode(msg.Data)
        if not interProcessResponse then
            print("[APIGatewayHandler] Invalid JSON in inter-process response")
            return
        end

        -- Update correlation status
        local responseStatus = interProcessResponse.success and 
                              MessageCorrelator.MESSAGE_STATUS.COMPLETED or 
                              MessageCorrelator.MESSAGE_STATUS.FAILED
        MessageCorrelator.updateCorrelationStatus(correlationId, responseStatus)

        -- Check if aggregation is required
        if clientContext.routingInfo.requiresAggregation then
            -- Store response and check if all responses received
            _storeProcessResponse(correlationId, interProcessResponse)
            
            if _allResponsesReceived(correlationId, clientContext) then
                local allResponses = _getAllResponses(correlationId)
                local aggregatedResponse = APIGateway.aggregateResponses(allResponses, clientContext.originalMessage)
                
                -- Send aggregated response to client
                ao.send({
                    Target = clientContext.clientId,
                    Tags = {
                        Action = "CLIENT_RESPONSE",
                        CorrelationId = correlationId
                    },
                    Data = json.encode(aggregatedResponse)
                })
                
                -- Cleanup context
                _cleanupClientContext(correlationId)
            end
        else
            -- Single response - direct translation and forwarding
            local clientResponse = APIGateway._translateInterProcessToClient(interProcessResponse, clientContext.originalMessage)
            
            ao.send({
                Target = clientContext.clientId,
                Tags = {
                    Action = "CLIENT_RESPONSE",
                    CorrelationId = correlationId
                },
                Data = json.encode(clientResponse)
            })
            
            -- Cleanup context
            _cleanupClientContext(correlationId)
        end
    end
)

-- API Gateway status and statistics handler
Handlers.add(
    "gateway-status",
    Handlers.utils.hasMatchingTag("Action", "GATEWAY_STATUS"),
    function(msg)
        local stats = APIGateway.getStatistics()
        
        ao.send({
            Target = msg.From,
            Tags = {
                Action = "GATEWAY_STATUS_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "status-query"
            },
            Data = json.encode({
                success = true,
                data = stats,
                timestamp = 0
            })
        })
    end
)

-- Private helper functions and storage

-- Client context storage for tracking active requests
local clientContexts = {}
local processResponses = {}

local function _selectTargetProcess(routingContext)
    -- Get available processes for target type
    local availableProcesses = ProcessAuthenticator.listRegisteredProcesses(routingContext.targetProcessType)
    if not availableProcesses or _getTableSize(availableProcesses) == 0 then
        return nil
    end

    -- Apply routing strategy
    local processIds = {}
    for processId, _ in pairs(availableProcesses) do
        table.insert(processIds, processId)
    end

    local selectedProcessId
    if routingContext.routingStrategy == "ROUND_ROBIN" then
        selectedProcessId = processIds[1] -- Simplified selection
    elseif routingContext.routingStrategy == "LEAST_LOADED" then
        selectedProcessId = processIds[1] -- TODO: Implement load tracking
    else
        selectedProcessId = processIds[1] -- Default to first available
    end

    return {
        processId = selectedProcessId,
        processType = routingContext.targetProcessType,
        capabilities = availableProcesses[selectedProcessId].capabilities
    }
end

local function _storeClientContext(correlationId, context)
    clientContexts[correlationId] = {
        clientId = context.clientId,
        originalMessage = context.originalMessage,
        routingInfo = context.routingInfo,
        createdAt = 0,
        responsesReceived = 0,
        expectedResponses = 1
    }
    
    -- Increase expected responses if aggregation required
    if context.routingInfo.requiresAggregation then
        clientContexts[correlationId].expectedResponses = _calculateExpectedResponses(context.routingInfo)
    end
end

local function _getClientContext(correlationId)
    return clientContexts[correlationId]
end

local function _cleanupClientContext(correlationId)
    clientContexts[correlationId] = nil
    processResponses[correlationId] = nil
end

local function _storeProcessResponse(correlationId, response)
    if not processResponses[correlationId] then
        processResponses[correlationId] = {}
    end
    table.insert(processResponses[correlationId], response)
    
    -- Update context
    if clientContexts[correlationId] then
        clientContexts[correlationId].responsesReceived = clientContexts[correlationId].responsesReceived + 1
    end
end

local function _getAllResponses(correlationId)
    return processResponses[correlationId] or {}
end

local function _allResponsesReceived(correlationId, clientContext)
    return clientContext.responsesReceived >= clientContext.expectedResponses
end

local function _calculateExpectedResponses(routingInfo)
    -- For now, assume single response even for aggregated operations
    -- This can be enhanced to support true multi-process aggregation
    return 1
end

local function _getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: coordinator.handlers.api-gateway-handler =====


-- ===== MODULE: coordinator.handlers.session-management-handler =====
-- File: ao-processes/coordinator/handlers/session-management-handler.lua
-- Original require: require("coordinator.handlers.session-management-handler")

-- Session Management Handler for Coordinator Process
-- Handles session lifecycle, state coordination, and process synchronization


-- ===== MODULE: coordinator.components.session-coordinator =====
-- File: ao-processes/coordinator/components/session-coordinator.lua
-- Original require: local SessionCoordinator = require("coordinator.components.session-coordinator")

-- Session Coordinator for Distributed Session State Management
-- Coordinates player sessions across all distributed processes using MessageCorrelator


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local SessionCoordinator = {
    -- Active player sessions
    activeSessions = {},
    
    -- Session state synchronization tracking
    synchronizationState = {},
    
    -- Session configuration
    config = {
        sessionTimeoutMs = 1800000, -- 30 minutes
        maxConcurrentSessions = 10000,
        stateVersioningEnabled = true,
        conflictResolutionStrategy = "LAST_WRITER_WINS"
    },
    
    -- Statistics
    stats = {
        sessionsCreated = 0,
        sessionsDestroyed = 0,
        activeSessions = 0,
        stateConflictsResolved = 0,
        synchronizationEvents = 0
    }
}

-- Session states
SessionCoordinator.SESSION_STATES = {
    ACTIVE = "ACTIVE",
    MIGRATING = "MIGRATING", 
    SUSPENDED = "SUSPENDED",
    TERMINATED = "TERMINATED"
}

-- Conflict resolution strategies
SessionCoordinator.CONFLICT_RESOLUTION = {
    LAST_WRITER_WINS = "LAST_WRITER_WINS",
    OPTIMISTIC_LOCKING = "OPTIMISTIC_LOCKING",
    MANUAL_RESOLUTION = "MANUAL_RESOLUTION"
}

-- Initialize session coordinator
function SessionCoordinator.initialize()
    SessionCoordinator.activeSessions = {}
    SessionCoordinator.synchronizationState = {}
    SessionCoordinator.stats = {
        sessionsCreated = 0,
        sessionsDestroyed = 0,
        activeSessions = 0,
        stateConflictsResolved = 0,
        synchronizationEvents = 0
    }
    
    -- Initialize crypto RNG for session ID generation
    CryptoRNG.initGlobalRNG()
    
    print("[SessionCoordinator] Session management system initialized")
    return true
end

-- Create new player session
function SessionCoordinator.createSession(playerId, initialState)
    if not playerId then
        return nil, "Player ID is required"
    end
    
    -- Check for existing active session
    local existingSession = SessionCoordinator.getActiveSession(playerId)
    if existingSession then
        return existingSession.sessionId, "Session already exists"
    end
    
    -- Check session limits
    if SessionCoordinator.stats.activeSessions >= SessionCoordinator.config.maxConcurrentSessions then
        return nil, "Maximum concurrent sessions reached"
    end
    
    -- Generate unique session ID
    local sessionId = SessionCoordinator._generateSessionId(playerId)
    
    -- Create session metadata
    local session = {
        sessionId = sessionId,
        playerId = playerId,
        state = SessionCoordinator.SESSION_STATES.ACTIVE,
        processMap = {},
        activeProcesses = {},
        stateVersion = 1,
        createdAt = 0,
        lastActivity = msg.Timestamp,
        lastStateSync = 0,
        sessionData = initialState or {},
        syncHistory = {},
        conflictLog = {}
    }
    
    -- Store session
    SessionCoordinator.activeSessions[sessionId] = session
    SessionCoordinator.stats.sessionsCreated = SessionCoordinator.stats.sessionsCreated + 1
    SessionCoordinator.stats.activeSessions = SessionCoordinator.stats.activeSessions + 1
    
    print("[SessionCoordinator] Created session " .. sessionId .. " for player " .. playerId)
    return sessionId
end

-- Get active session for player
function SessionCoordinator.getActiveSession(playerId)
    for sessionId, session in pairs(SessionCoordinator.activeSessions) do
        if session.playerId == playerId and session.state == SessionCoordinator.SESSION_STATES.ACTIVE then
            return session
        end
    end
    return nil
end

-- Get session by ID
function SessionCoordinator.getSession(sessionId)
    return SessionCoordinator.activeSessions[sessionId]
end

-- Update session activity timestamp
function SessionCoordinator.updateSessionActivity(sessionId)
    local session = SessionCoordinator.activeSessions[sessionId]
    if session then
        session.lastActivity = msg.Timestamp
        return true
    end
    return false
end

-- Add process to session's process map
function SessionCoordinator.addProcessToSession(sessionId, processId, processType, operations)
    local session = SessionCoordinator.activeSessions[sessionId]
    if not session then
        return false, "Session not found"
    end
    
    -- Validate process is registered and active
    local processInfo = ProcessAuthenticator.getProcessInfo(processId)
    if not processInfo or processInfo.status ~= "active" then
        return false, "Process not available: " .. tostring(processId)
    end
    
    -- Add to process map
    session.processMap[processType] = session.processMap[processType] or {}
    table.insert(session.processMap[processType], processId)
    
    -- Add to active processes
    session.activeProcesses[processId] = {
        processType = processType,
        operations = operations or {},
        addedAt = 0,
        lastHeartbeat = 0
    }
    
    session.lastActivity = msg.Timestamp
    return true
end

-- Remove process from session
function SessionCoordinator.removeProcessFromSession(sessionId, processId)
    local session = SessionCoordinator.activeSessions[sessionId]
    if not session then
        return false, "Session not found"
    end
    
    -- Remove from active processes
    local processInfo = session.activeProcesses[processId]
    if processInfo then
        session.activeProcesses[processId] = nil
        
        -- Remove from process map
        local processType = processInfo.processType
        if session.processMap[processType] then
            for i, pid in ipairs(session.processMap[processType]) do
                if pid == processId then
                    table.remove(session.processMap[processType], i)
                    break
                end
            end
            
            -- Clean up empty process type entries
            if #session.processMap[processType] == 0 then
                session.processMap[processType] = nil
            end
        end
        
        session.lastActivity = msg.Timestamp
        return true
    end
    
    return false, "Process not found in session"
end

-- Synchronize session state across processes
function SessionCoordinator.synchronizeSessionState(sessionId, stateUpdate, fromProcessId)
    local session = SessionCoordinator.activeSessions[sessionId]
    if not session then
        return false, "Session not found"
    end
    
    SessionCoordinator.stats.synchronizationEvents = SessionCoordinator.stats.synchronizationEvents + 1
    
    -- Check for conflicts if versioning enabled
    if SessionCoordinator.config.stateVersioningEnabled then
        local hasConflict, conflictInfo = SessionCoordinator._detectStateConflict(session, stateUpdate)
        if hasConflict then
            local resolution = SessionCoordinator._resolveStateConflict(session, stateUpdate, conflictInfo)
            if not resolution then
                return false, "State conflict could not be resolved"
            end
            
            SessionCoordinator.stats.stateConflictsResolved = SessionCoordinator.stats.stateConflictsResolved + 1
        end
    end
    
    -- Generate correlation for sync operation
    local correlationId = MessageCorrelator.createCorrelation(
        fromProcessId or "session-coordinator",
        "session-sync",
        "SESSION_STATE_SYNC"
    )
    
    -- Apply state update
    local success, error = SessionCoordinator._applyStateUpdate(session, stateUpdate, correlationId)
    if not success then
        return false, error
    end
    
    -- Propagate to interested processes
    SessionCoordinator._propagateStateUpdate(session, stateUpdate, correlationId, fromProcessId)
    
    session.lastStateSync = 0
    session.lastActivity = msg.Timestamp
    
    return true
end

-- Handle session conflict resolution
function SessionCoordinator.resolveSessionConflict(sessionId, conflictData, resolution)
    local session = SessionCoordinator.activeSessions[sessionId]
    if not session then
        return false, "Session not found"
    end
    
    -- Log conflict for analysis
    table.insert(session.conflictLog, {
        timestamp = msg.Timestamp,
        conflictData = conflictData,
        resolution = resolution,
        resolvedBy = "SessionCoordinator"
    })
    
    SessionCoordinator.stats.stateConflictsResolved = SessionCoordinator.stats.stateConflictsResolved + 1
    return true
end

-- Terminate session and cleanup
function SessionCoordinator.terminateSession(sessionId, reason)
    local session = SessionCoordinator.activeSessions[sessionId]
    if not session then
        return false, "Session not found"
    end
    
    -- Update session state
    session.state = SessionCoordinator.SESSION_STATES.TERMINATED
    session.terminatedAt = 0
    session.terminationReason = reason or "Manual termination"
    
    -- Notify all active processes
    for processId, processInfo in pairs(session.activeProcesses) do
        SessionCoordinator._notifyProcessOfSessionTermination(processId, sessionId, reason)
    end
    
    -- Cleanup session data
    SessionCoordinator.activeSessions[sessionId] = nil
    SessionCoordinator.synchronizationState[sessionId] = nil
    SessionCoordinator.stats.sessionsDestroyed = SessionCoordinator.stats.sessionsDestroyed + 1
    SessionCoordinator.stats.activeSessions = SessionCoordinator.stats.activeSessions - 1
    
    print("[SessionCoordinator] Terminated session " .. sessionId .. " - " .. (reason or "No reason"))
    return true
end

-- Cleanup expired sessions
function SessionCoordinator.cleanupExpiredSessions()
    local currentTime = 0
    local cleanupCount = 0
    local expiredSessions = {}
    
    -- Find expired sessions
    for sessionId, session in pairs(SessionCoordinator.activeSessions) do
        local timeSinceActivity = (currentTime - session.lastActivity) * 1000
        if timeSinceActivity > SessionCoordinator.config.sessionTimeoutMs then
            table.insert(expiredSessions, sessionId)
        end
    end
    
    -- Terminate expired sessions
    for _, sessionId in ipairs(expiredSessions) do
        if SessionCoordinator.terminateSession(sessionId, "Session timeout") then
            cleanupCount = cleanupCount + 1
        end
    end
    
    if cleanupCount > 0 then
        print("[SessionCoordinator] Cleaned up " .. cleanupCount .. " expired sessions")
    end
    
    return cleanupCount
end

-- Get session statistics
function SessionCoordinator.getStatistics()
    local processDistribution = {}
    local stateVersions = {}
    
    for sessionId, session in pairs(SessionCoordinator.activeSessions) do
        -- Count processes per session
        local processCount = 0
        for _ in pairs(session.activeProcesses) do
            processCount = processCount + 1
        end
        
        -- Track process distribution
        for processType, processes in pairs(session.processMap) do
            processDistribution[processType] = (processDistribution[processType] or 0) + #processes
        end
        
        -- Track state versions
        stateVersions[session.stateVersion] = (stateVersions[session.stateVersion] or 0) + 1
    end
    
    return {
        stats = SessionCoordinator.stats,
        config = SessionCoordinator.config,
        processDistribution = processDistribution,
        stateVersionDistribution = stateVersions,
        averageProcessesPerSession = SessionCoordinator.stats.activeSessions > 0 and 
            SessionCoordinator._getTableSize(processDistribution) / SessionCoordinator.stats.activeSessions or 0
    }
end

-- Private helper functions

function SessionCoordinator._generateSessionId(playerId)
    local timestamp = msg.Timestamp
    local random = CryptoRNG.random(100000, 999999)
    return "session_" .. playerId .. "_" .. timestamp .. "_" .. random
end

function SessionCoordinator._detectStateConflict(session, stateUpdate)
    if not stateUpdate.expectedVersion then
        return false, nil
    end
    
    if session.stateVersion ~= stateUpdate.expectedVersion then
        return true, {
            currentVersion = session.stateVersion,
            expectedVersion = stateUpdate.expectedVersion,
            conflictType = "VERSION_MISMATCH"
        }
    end
    
    return false, nil
end

function SessionCoordinator._resolveStateConflict(session, stateUpdate, conflictInfo)
    local strategy = SessionCoordinator.config.conflictResolutionStrategy
    
    if strategy == SessionCoordinator.CONFLICT_RESOLUTION.LAST_WRITER_WINS then
        -- Accept the new state update
        return true
    elseif strategy == SessionCoordinator.CONFLICT_RESOLUTION.OPTIMISTIC_LOCKING then
        -- Reject conflicting updates
        return false
    elseif strategy == SessionCoordinator.CONFLICT_RESOLUTION.MANUAL_RESOLUTION then
        -- Queue for manual resolution (not implemented here)
        return false
    end
    
    return false
end

function SessionCoordinator._applyStateUpdate(session, stateUpdate, correlationId)
    -- Increment version
    if SessionCoordinator.config.stateVersioningEnabled then
        session.stateVersion = session.stateVersion + 1
    end
    
    -- Apply data changes
    if stateUpdate.data then
        for key, value in pairs(stateUpdate.data) do
            session.sessionData[key] = value
        end
    end
    
    -- Add to sync history
    table.insert(session.syncHistory, {
        timestamp = msg.Timestamp,
        version = session.stateVersion,
        correlationId = correlationId,
        updateType = stateUpdate.updateType or "STATE_SYNC"
    })
    
    -- Limit history size
    if #session.syncHistory > 100 then
        table.remove(session.syncHistory, 1)
    end
    
    return true
end

function SessionCoordinator._propagateStateUpdate(session, stateUpdate, correlationId, excludeProcessId)
    -- Send state update to all active processes except the source
    for processId, processInfo in pairs(session.activeProcesses) do
        if processId ~= excludeProcessId then
            SessionCoordinator._sendStateUpdateToProcess(processId, session.sessionId, stateUpdate, correlationId)
        end
    end
end

function SessionCoordinator._sendStateUpdateToProcess(processId, sessionId, stateUpdate, correlationId)
    -- This would send an actual message to the process in a real AO environment
    -- For now, just log the intent
    print("[SessionCoordinator] Would send state update to process " .. processId .. " for session " .. sessionId)
end

function SessionCoordinator._notifyProcessOfSessionTermination(processId, sessionId, reason)
    -- This would send termination notification to the process
    print("[SessionCoordinator] Would notify process " .. processId .. " of session " .. sessionId .. " termination")
end

function SessionCoordinator._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: coordinator.components.session-coordinator =====


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- Private helper functions

local function _getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

local function _getProcessTypes(processMap)
    local types = {}
    for processType, processes in pairs(processMap) do
        table.insert(types, processType)
    end
    return types
end

-- Session creation handler
Handlers.add(
    "session-create",
    Handlers.utils.hasMatchingTag("Action", "SESSION_CREATE"),
    function(msg)
        -- Authenticate request
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_CREATE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed",
                    message = authResult.error
                })
            })
            return
        end

        -- Parse request data
        local requestData = json.decode(msg.Data)
        if not requestData or not requestData.playerId then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_CREATE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Player ID is required"
                })
            })
            return
        end

        -- Create session
        local sessionId, error = SessionCoordinator.createSession(
            requestData.playerId,
            requestData.initialState
        )

        if sessionId then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_CREATE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "session-create"
                },
                Data = json.encode({
                    success = true,
                    sessionId = sessionId,
                    playerId = requestData.playerId,
                    timestamp = 0
                })
            })
        else
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_CREATE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "session-create"
                },
                Data = json.encode({
                    success = false,
                    error = error,
                    playerId = requestData.playerId
                })
            })
        end
    end
)

-- Session query handler
Handlers.add(
    "session-query",
    Handlers.utils.hasMatchingTag("Action", "SESSION_QUERY"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_QUERY_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local requestData = json.decode(msg.Data)
        if not requestData then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_QUERY_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid request data"
                })
            })
            return
        end

        local session
        if requestData.sessionId then
            session = SessionCoordinator.getSession(requestData.sessionId)
        elseif requestData.playerId then
            session = SessionCoordinator.getActiveSession(requestData.playerId)
        end

        if session then
            -- Remove sensitive data for response
            local responseSession = {
                sessionId = session.sessionId,
                playerId = session.playerId,
                state = session.state,
                stateVersion = session.stateVersion,
                createdAt = session.createdAt,
                lastActivity = session.lastActivity,
                activeProcessCount = _getTableSize(session.activeProcesses),
                processTypes = _getProcessTypes(session.processMap)
            }

            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_QUERY_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "session-query"
                },
                Data = json.encode({
                    success = true,
                    session = responseSession
                })
            })
        else
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_QUERY_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "session-query"
                },
                Data = json.encode({
                    success = false,
                    error = "Session not found"
                })
            })
        end
    end
)

-- Session state synchronization handler
Handlers.add(
    "session-sync",
    Handlers.utils.hasMatchingTag("Action", "SESSION_SYNC"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_SYNC_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local syncData = json.decode(msg.Data)
        if not syncData or not syncData.sessionId or not syncData.stateUpdate then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_SYNC_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Session ID and state update are required"
                })
            })
            return
        end

        -- Synchronize session state
        local success, error = SessionCoordinator.synchronizeSessionState(
            syncData.sessionId,
            syncData.stateUpdate,
            msg.From
        )

        if success then
            -- Update session activity
            SessionCoordinator.updateSessionActivity(syncData.sessionId)
            
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_SYNC_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "session-sync"
                },
                Data = json.encode({
                    success = true,
                    sessionId = syncData.sessionId,
                    syncTimestamp = 0
                })
            })
        else
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_SYNC_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "session-sync"
                },
                Data = json.encode({
                    success = false,
                    error = error,
                    sessionId = syncData.sessionId
                })
            })
        end
    end
)

-- Process registration in session handler
Handlers.add(
    "session-process-register",
    Handlers.utils.hasMatchingTag("Action", "SESSION_PROCESS_REGISTER"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_PROCESS_REGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local registrationData = json.decode(msg.Data)
        if not registrationData or not registrationData.sessionId then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_PROCESS_REGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Session ID is required"
                })
            })
            return
        end

        -- Add process to session
        local success, error = SessionCoordinator.addProcessToSession(
            registrationData.sessionId,
            msg.From,
            registrationData.processType or "UNKNOWN",
            registrationData.operations or {}
        )

        if success then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_PROCESS_REGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "process-register"
                },
                Data = json.encode({
                    success = true,
                    sessionId = registrationData.sessionId,
                    processId = msg.From,
                    registeredAt = 0
                })
            })
        else
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_PROCESS_REGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "process-register"
                },
                Data = json.encode({
                    success = false,
                    error = error,
                    sessionId = registrationData.sessionId
                })
            })
        end
    end
)

-- Process deregistration from session handler
Handlers.add(
    "session-process-deregister",
    Handlers.utils.hasMatchingTag("Action", "SESSION_PROCESS_DEREGISTER"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_PROCESS_DEREGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local deregistrationData = json.decode(msg.Data)
        if not deregistrationData or not deregistrationData.sessionId then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_PROCESS_DEREGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Session ID is required"
                })
            })
            return
        end

        -- Remove process from session
        local success, error = SessionCoordinator.removeProcessFromSession(
            deregistrationData.sessionId,
            msg.From
        )

        ao.send({
            Target = msg.From,
            Tags = {
                Action = "SESSION_PROCESS_DEREGISTER_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "process-deregister"
            },
            Data = json.encode({
                success = success,
                error = error,
                sessionId = deregistrationData.sessionId,
                processId = msg.From
            })
        })
    end
)

-- Session termination handler
Handlers.add(
    "session-terminate",
    Handlers.utils.hasMatchingTag("Action", "SESSION_TERMINATE"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_TERMINATE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local terminationData = json.decode(msg.Data)
        if not terminationData or not terminationData.sessionId then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_TERMINATE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Session ID is required"
                })
            })
            return
        end

        -- Terminate session
        local success, error = SessionCoordinator.terminateSession(
            terminationData.sessionId,
            terminationData.reason
        )

        ao.send({
            Target = msg.From,
            Tags = {
                Action = "SESSION_TERMINATE_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "session-terminate"
            },
            Data = json.encode({
                success = success,
                error = error,
                sessionId = terminationData.sessionId,
                terminatedAt = 0
            })
        })
    end
)

-- Session statistics handler
Handlers.add(
    "session-statistics",
    Handlers.utils.hasMatchingTag("Action", "SESSION_STATISTICS"),
    function(msg)
        local stats = SessionCoordinator.getStatistics()
        
        ao.send({
            Target = msg.From,
            Tags = {
                Action = "SESSION_STATISTICS_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "statistics"
            },
            Data = json.encode({
                success = true,
                statistics = stats,
                timestamp = 0
            })
        })
    end
)

-- Session cleanup handler (for maintenance)
Handlers.add(
    "session-cleanup",
    Handlers.utils.hasMatchingTag("Action", "SESSION_CLEANUP"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "SESSION_CLEANUP_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        -- Cleanup expired sessions
        local cleanupCount = SessionCoordinator.cleanupExpiredSessions()
        
        ao.send({
            Target = msg.From,
            Tags = {
                Action = "SESSION_CLEANUP_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "cleanup"
            },
            Data = json.encode({
                success = true,
                cleanedUpSessions = cleanupCount,
                timestamp = 0
            })
        })
    end
)


-- ===== END MODULE: coordinator.handlers.session-management-handler =====


-- ===== MODULE: coordinator.handlers.process-health-handler =====
-- File: ao-processes/coordinator/handlers/process-health-handler.lua
-- Original require: require("coordinator.handlers.process-health-handler")

-- Process Health Handler for Coordinator Process
-- Handles health monitoring, failure detection, and automatic failover


-- ===== MODULE: coordinator.components.process-discovery =====
-- File: ao-processes/coordinator/components/process-discovery.lua
-- Original require: local ProcessDiscovery = require("coordinator.components.process-discovery")

-- Process Discovery and Management for Coordinator
-- Manages process instance discovery, health tracking, and routing table maintenance


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


local ProcessDiscovery = {
    -- Process registry with extended metadata
    processRegistry = {},
    
    -- Process capabilities cache
    capabilitiesCache = {},
    
    -- Health tracking
    healthTracking = {},
    
    -- Discovery configuration
    config = {
        healthCheckIntervalMs = 30000, -- 30 seconds
        processTimeoutMs = 120000, -- 2 minutes
        maxFailedHealthChecks = 3,
        discoveryBroadcastIntervalMs = 60000 -- 1 minute
    },
    
    -- Statistics
    stats = {
        processesDiscovered = 0,
        processesTimedOut = 0,
        healthChecksSent = 0,
        healthChecksReceived = 0,
        discoveryBroadcasts = 0
    }
}

-- Process health states
ProcessDiscovery.HEALTH_STATES = {
    HEALTHY = "HEALTHY",
    DEGRADED = "DEGRADED",
    UNHEALTHY = "UNHEALTHY",
    OFFLINE = "OFFLINE",
    UNKNOWN = "UNKNOWN"
}

-- Initialize process discovery
function ProcessDiscovery.initialize()
    ProcessDiscovery.processRegistry = {}
    ProcessDiscovery.capabilitiesCache = {}
    ProcessDiscovery.healthTracking = {}
    ProcessDiscovery.stats = {
        processesDiscovered = 0,
        processesTimedOut = 0,
        healthChecksSent = 0,
        healthChecksReceived = 0,
        discoveryBroadcasts = 0
    }
    
    print("[ProcessDiscovery] Process discovery system initialized")
    return true
end

-- Register discovered process
function ProcessDiscovery.registerProcess(processId, processInfo)
    if not processId or not processInfo then
        return false, "Process ID and info are required"
    end
    
    -- Validate process info structure
    if not processInfo.type or not processInfo.capabilities then
        return false, "Process type and capabilities are required"
    end
    
    -- Create extended process metadata
    local extendedProcessInfo = {
        processId = processId,
        processType = processInfo.type,
        version = processInfo.version or "1.0.0",
        capabilities = processInfo.capabilities,
        endpoints = processInfo.endpoints or {},
        description = processInfo.description or "",
        registeredAt = 0,
        lastSeen = 0,
        lastHealthCheck = nil,
        healthStatus = ProcessDiscovery.HEALTH_STATES.HEALTHY,
        failedHealthChecks = 0,
        responseTimeMs = 0,
        loadMetrics = {
            cpuUsage = 0,
            memoryUsage = 0,
            requestCount = 0,
            errorRate = 0
        }
    }
    
    -- Register in local registry
    ProcessDiscovery.processRegistry[processId] = extendedProcessInfo
    
    -- Update capabilities cache
    ProcessDiscovery.capabilitiesCache[processId] = processInfo.capabilities
    
    -- Initialize health tracking
    ProcessDiscovery.healthTracking[processId] = {
        lastCheck = 0,
        consecutiveFailures = 0,
        healthHistory = {}
    }
    
    ProcessDiscovery.stats.processesDiscovered = ProcessDiscovery.stats.processesDiscovered + 1
    
    print("[ProcessDiscovery] Registered process " .. processId .. " (" .. processInfo.type .. ")")
    return true
end

-- Discover available processes by type
function ProcessDiscovery.discoverProcessesByType(processType)
    local matchingProcesses = {}
    
    for processId, processInfo in pairs(ProcessDiscovery.processRegistry) do
        if processInfo.processType == processType and 
           processInfo.healthStatus ~= ProcessDiscovery.HEALTH_STATES.OFFLINE then
            matchingProcesses[processId] = processInfo
        end
    end
    
    -- Also check with ProcessAuthenticator for additional processes
    local authenticatedProcesses = ProcessAuthenticator.listRegisteredProcesses(processType)
    if authenticatedProcesses then
        for processId, authProcessInfo in pairs(authenticatedProcesses) do
            if not matchingProcesses[processId] then
                -- Register newly discovered process
                ProcessDiscovery.registerProcess(processId, authProcessInfo)
                matchingProcesses[processId] = ProcessDiscovery.processRegistry[processId]
            end
        end
    end
    
    return matchingProcesses
end

-- Discover processes by capability
function ProcessDiscovery.discoverProcessesByCapability(capability)
    local capableProcesses = {}
    
    for processId, processInfo in pairs(ProcessDiscovery.processRegistry) do
        if processInfo.healthStatus ~= ProcessDiscovery.HEALTH_STATES.OFFLINE and
           ProcessDiscovery._processHasCapability(processInfo.capabilities, capability) then
            capableProcesses[processId] = processInfo
        end
    end
    
    return capableProcesses
end

-- Get best available process for operation
function ProcessDiscovery.getBestProcessForOperation(operationType, routingStrategy)
    local strategy = routingStrategy or "CAPABILITY_MATCH"
    
    -- Find processes with required capability
    local capableProcesses = ProcessDiscovery.discoverProcessesByCapability(operationType)
    
    if ProcessDiscovery._getTableSize(capableProcesses) == 0 then
        return nil, "No capable processes found for operation: " .. operationType
    end
    
    -- Apply selection strategy
    local selectedProcess
    if strategy == "LEAST_LOADED" then
        selectedProcess = ProcessDiscovery._selectLeastLoaded(capableProcesses)
    elseif strategy == "BEST_HEALTH" then
        selectedProcess = ProcessDiscovery._selectHealthiest(capableProcesses)
    elseif strategy == "FASTEST_RESPONSE" then
        selectedProcess = ProcessDiscovery._selectFastest(capableProcesses)
    else
        -- Default capability match
        selectedProcess = ProcessDiscovery._selectByCapability(capableProcesses, operationType)
    end
    
    return selectedProcess
end

-- Update process health status
function ProcessDiscovery.updateProcessHealth(processId, healthInfo)
    local processInfo = ProcessDiscovery.processRegistry[processId]
    if not processInfo then
        return false, "Process not found in registry"
    end
    
    local healthTracking = ProcessDiscovery.healthTracking[processId]
    if not healthTracking then
        return false, "Health tracking not initialized for process"
    end
    
    -- Update health information
    processInfo.lastHealthCheck = 0
    processInfo.lastSeen = 0
    processInfo.responseTimeMs = healthInfo.responseTime or 0
    
    -- Update load metrics if provided
    if healthInfo.loadMetrics then
        processInfo.loadMetrics = healthInfo.loadMetrics
    end
    
    -- Determine health status
    local newHealthStatus = ProcessDiscovery._calculateHealthStatus(healthInfo)
    local previousHealthStatus = processInfo.healthStatus
    processInfo.healthStatus = newHealthStatus
    
    -- Update health tracking
    healthTracking.lastCheck = 0
    if newHealthStatus == ProcessDiscovery.HEALTH_STATES.HEALTHY then
        healthTracking.consecutiveFailures = 0
    else
        healthTracking.consecutiveFailures = healthTracking.consecutiveFailures + 1
    end
    
    -- Add to health history
    table.insert(healthTracking.healthHistory, {
        timestamp = msg.Timestamp,
        status = newHealthStatus,
        responseTime = healthInfo.responseTime or 0
    })
    
    -- Limit history size
    if #healthTracking.healthHistory > 50 then
        table.remove(healthTracking.healthHistory, 1)
    end
    
    -- Log status changes
    if previousHealthStatus ~= newHealthStatus then
        print("[ProcessDiscovery] Process " .. processId .. " health changed: " .. 
              previousHealthStatus .. " -> " .. newHealthStatus)
    end
    
    ProcessDiscovery.stats.healthChecksReceived = ProcessDiscovery.stats.healthChecksReceived + 1
    return true
end

-- Mark process as offline
function ProcessDiscovery.markProcessOffline(processId, reason)
    local processInfo = ProcessDiscovery.processRegistry[processId]
    if not processInfo then
        return false, "Process not found"
    end
    
    processInfo.healthStatus = ProcessDiscovery.HEALTH_STATES.OFFLINE
    processInfo.offlineReason = reason or "Manual offline"
    processInfo.offlineAt = 0
    
    print("[ProcessDiscovery] Marked process " .. processId .. " as offline: " .. 
          (reason or "No reason"))
    return true
end

-- Remove process from registry
function ProcessDiscovery.removeProcess(processId)
    if ProcessDiscovery.processRegistry[processId] then
        ProcessDiscovery.processRegistry[processId] = nil
        ProcessDiscovery.capabilitiesCache[processId] = nil
        ProcessDiscovery.healthTracking[processId] = nil
        return true
    end
    return false
end

-- Perform health check on all registered processes
function ProcessDiscovery.performHealthChecks()
    local currentTime = 0
    local healthCheckCount = 0
    
    for processId, processInfo in pairs(ProcessDiscovery.processRegistry) do
        local healthTracking = ProcessDiscovery.healthTracking[processId]
        
        -- Skip if recently checked
        local timeSinceCheck = (currentTime - (healthTracking.lastCheck or 0)) * 1000
        if timeSinceCheck < ProcessDiscovery.config.healthCheckIntervalMs then
            goto continue
        end
        
        -- Send health check request
        ProcessDiscovery._sendHealthCheckRequest(processId)
        healthCheckCount = healthCheckCount + 1
        ProcessDiscovery.stats.healthChecksSent = ProcessDiscovery.stats.healthChecksSent + 1
        
        ::continue::
    end
    
    return healthCheckCount
end

-- Cleanup expired processes
function ProcessDiscovery.cleanupExpiredProcesses()
    local currentTime = 0
    local cleanupCount = 0
    local expiredProcesses = {}
    
    for processId, processInfo in pairs(ProcessDiscovery.processRegistry) do
        local timeSinceLastSeen = (currentTime - processInfo.lastSeen) * 1000
        if timeSinceLastSeen > ProcessDiscovery.config.processTimeoutMs then
            table.insert(expiredProcesses, processId)
        end
    end
    
    -- Remove expired processes
    for _, processId in ipairs(expiredProcesses) do
        ProcessDiscovery.markProcessOffline(processId, "Process timeout")
        cleanupCount = cleanupCount + 1
        ProcessDiscovery.stats.processesTimedOut = ProcessDiscovery.stats.processesTimedOut + 1
    end
    
    return cleanupCount
end

-- Get process discovery statistics
function ProcessDiscovery.getStatistics()
    local healthStatusCounts = {}
    local processTypeCounts = {}
    local capabilityCounts = {}
    
    for processId, processInfo in pairs(ProcessDiscovery.processRegistry) do
        -- Count health statuses
        local status = processInfo.healthStatus
        healthStatusCounts[status] = (healthStatusCounts[status] or 0) + 1
        
        -- Count process types
        local processType = processInfo.processType
        processTypeCounts[processType] = (processTypeCounts[processType] or 0) + 1
        
        -- Count capabilities
        for _, capability in ipairs(processInfo.capabilities) do
            capabilityCounts[capability] = (capabilityCounts[capability] or 0) + 1
        end
    end
    
    return {
        stats = ProcessDiscovery.stats,
        config = ProcessDiscovery.config,
        totalRegisteredProcesses = ProcessDiscovery._getTableSize(ProcessDiscovery.processRegistry),
        healthStatusDistribution = healthStatusCounts,
        processTypeDistribution = processTypeCounts,
        capabilityDistribution = capabilityCounts,
        averageResponseTime = ProcessDiscovery._calculateAverageResponseTime()
    }
end

-- Private helper functions

function ProcessDiscovery._processHasCapability(capabilities, targetCapability)
    if not capabilities or type(capabilities) ~= "table" then
        return false
    end
    
    for _, capability in ipairs(capabilities) do
        if capability == "*" or capability == targetCapability then
            return true
        end
        
        -- Check for wildcard capabilities
        if capability:find("%-") and targetCapability:find(capability:gsub("%-.*", "")) then
            return true
        end
    end
    
    return false
end

function ProcessDiscovery._calculateHealthStatus(healthInfo)
    if not healthInfo then
        return ProcessDiscovery.HEALTH_STATES.UNKNOWN
    end
    
    -- Consider response time
    local responseTime = healthInfo.responseTime or 0
    if responseTime > 5000 then -- 5 seconds
        return ProcessDiscovery.HEALTH_STATES.UNHEALTHY
    elseif responseTime > 2000 then -- 2 seconds
        return ProcessDiscovery.HEALTH_STATES.DEGRADED
    end
    
    -- Consider error rate
    local errorRate = (healthInfo.loadMetrics and healthInfo.loadMetrics.errorRate) or 0
    if errorRate > 0.1 then -- 10% error rate
        return ProcessDiscovery.HEALTH_STATES.UNHEALTHY
    elseif errorRate > 0.05 then -- 5% error rate
        return ProcessDiscovery.HEALTH_STATES.DEGRADED
    end
    
    -- Consider CPU usage
    local cpuUsage = (healthInfo.loadMetrics and healthInfo.loadMetrics.cpuUsage) or 0
    if cpuUsage > 90 then
        return ProcessDiscovery.HEALTH_STATES.DEGRADED
    end
    
    return ProcessDiscovery.HEALTH_STATES.HEALTHY
end

function ProcessDiscovery._selectLeastLoaded(processes)
    local leastLoaded = nil
    local minLoad = math.huge
    
    for processId, processInfo in pairs(processes) do
        local load = (processInfo.loadMetrics.cpuUsage or 0) + 
                    (processInfo.loadMetrics.memoryUsage or 0)
        if load < minLoad then
            minLoad = load
            leastLoaded = processInfo
        end
    end
    
    return leastLoaded
end

function ProcessDiscovery._selectHealthiest(processes)
    -- Priority order: HEALTHY > DEGRADED > UNHEALTHY
    local healthPriority = {
        [ProcessDiscovery.HEALTH_STATES.HEALTHY] = 3,
        [ProcessDiscovery.HEALTH_STATES.DEGRADED] = 2,
        [ProcessDiscovery.HEALTH_STATES.UNHEALTHY] = 1,
        [ProcessDiscovery.HEALTH_STATES.OFFLINE] = 0,
        [ProcessDiscovery.HEALTH_STATES.UNKNOWN] = 0
    }
    
    local healthiest = nil
    local bestHealth = -1
    
    for processId, processInfo in pairs(processes) do
        local health = healthPriority[processInfo.healthStatus] or 0
        if health > bestHealth then
            bestHealth = health
            healthiest = processInfo
        end
    end
    
    return healthiest
end

function ProcessDiscovery._selectFastest(processes)
    local fastest = nil
    local minResponseTime = math.huge
    
    for processId, processInfo in pairs(processes) do
        local responseTime = processInfo.responseTimeMs or math.huge
        if responseTime < minResponseTime then
            minResponseTime = responseTime
            fastest = processInfo
        end
    end
    
    return fastest
end

function ProcessDiscovery._selectByCapability(processes, operationType)
    -- Select the first process with the exact capability
    for processId, processInfo in pairs(processes) do
        if ProcessDiscovery._processHasCapability(processInfo.capabilities, operationType) then
            return processInfo
        end
    end
    
    return nil
end

function ProcessDiscovery._sendHealthCheckRequest(processId)
    -- In a real AO environment, this would send a health check message
    print("[ProcessDiscovery] Would send health check to process: " .. processId)
end

function ProcessDiscovery._calculateAverageResponseTime()
    local totalResponseTime = 0
    local processCount = 0
    
    for processId, processInfo in pairs(ProcessDiscovery.processRegistry) do
        if processInfo.responseTimeMs and processInfo.responseTimeMs > 0 then
            totalResponseTime = totalResponseTime + processInfo.responseTimeMs
            processCount = processCount + 1
        end
    end
    
    return processCount > 0 and (totalResponseTime / processCount) or 0
end

function ProcessDiscovery._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: coordinator.components.process-discovery =====


-- ===== MODULE: coordinator.components.load-balancer =====
-- File: ao-processes/coordinator/components/load-balancer.lua
-- Original require: local LoadBalancer = require("coordinator.components.load-balancer")

-- Load Balancer for Process Instance Distribution
-- Implements various load balancing strategies for efficient request routing


-- ===== MODULE: coordinator.components.process-discovery =====
-- File: ao-processes/coordinator/components/process-discovery.lua
-- Original require: local ProcessDiscovery = require("coordinator.components.process-discovery")


-- ===== END MODULE: coordinator.components.process-discovery =====


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


local LoadBalancer = {
    -- Load balancing state
    roundRobinCounters = {},
    
    -- Routing statistics
    routingStats = {},
    
    -- Configuration
    config = {
        defaultStrategy = "ROUND_ROBIN",
        healthAwareRouting = true,
        sessionAffinityEnabled = true,
        maxRetryAttempts = 3,
        circuitBreakerThreshold = 10,
        circuitBreakerTimeoutMs = 60000 -- 1 minute
    },
    
    -- Circuit breaker state
    circuitBreakers = {},
    
    -- Statistics
    stats = {
        totalRequests = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        retriedRequests = 0,
        circuitBreakerTrips = 0,
        strategyUsage = {}
    }
}

-- Load balancing strategies
LoadBalancer.STRATEGIES = {
    ROUND_ROBIN = "ROUND_ROBIN",
    LEAST_LOADED = "LEAST_LOADED", 
    WEIGHTED_ROUND_ROBIN = "WEIGHTED_ROUND_ROBIN",
    LEAST_CONNECTIONS = "LEAST_CONNECTIONS",
    RESPONSE_TIME = "RESPONSE_TIME",
    RANDOM = "RANDOM",
    SESSION_AFFINITY = "SESSION_AFFINITY",
    CAPABILITY_MATCH = "CAPABILITY_MATCH"
}

-- Circuit breaker states
LoadBalancer.CIRCUIT_STATES = {
    CLOSED = "CLOSED",    -- Normal operation
    OPEN = "OPEN",        -- Blocking requests
    HALF_OPEN = "HALF_OPEN" -- Testing if service recovered
}

-- Initialize load balancer
function LoadBalancer.initialize()
    LoadBalancer.roundRobinCounters = {}
    LoadBalancer.routingStats = {}
    LoadBalancer.circuitBreakers = {}
    LoadBalancer.stats = {
        totalRequests = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        retriedRequests = 0,
        circuitBreakerTrips = 0,
        strategyUsage = {}
    }
    
    print("[LoadBalancer] Load balancer initialized")
    return true
end

-- Select target process using specified strategy
function LoadBalancer.selectTargetProcess(processType, operationType, routingContext)
    LoadBalancer.stats.totalRequests = LoadBalancer.stats.totalRequests + 1
    
    -- Get available processes
    local availableProcesses = ProcessDiscovery.discoverProcessesByType(processType)
    if LoadBalancer._getTableSize(availableProcesses) == 0 then
        LoadBalancer.stats.failedRoutes = LoadBalancer.stats.failedRoutes + 1
        return nil, "No available processes of type: " .. processType
    end
    
    -- Filter out unhealthy processes if health-aware routing is enabled
    if LoadBalancer.config.healthAwareRouting then
        availableProcesses = LoadBalancer._filterHealthyProcesses(availableProcesses)
        if LoadBalancer._getTableSize(availableProcesses) == 0 then
            LoadBalancer.stats.failedRoutes = LoadBalancer.stats.failedRoutes + 1
            return nil, "No healthy processes available for type: " .. processType
        end
    end
    
    -- Filter out processes with open circuit breakers
    availableProcesses = LoadBalancer._filterCircuitBreakerProcesses(availableProcesses)
    if LoadBalancer._getTableSize(availableProcesses) == 0 then
        LoadBalancer.stats.failedRoutes = LoadBalancer.stats.failedRoutes + 1
        return nil, "All processes have open circuit breakers for type: " .. processType
    end
    
    -- Determine routing strategy
    local strategy = LoadBalancer._determineStrategy(routingContext)
    
    -- Track strategy usage
    LoadBalancer.stats.strategyUsage[strategy] = (LoadBalancer.stats.strategyUsage[strategy] or 0) + 1
    
    -- Select process based on strategy
    local selectedProcess = LoadBalancer._applyRoutingStrategy(
        strategy, 
        availableProcesses, 
        operationType, 
        routingContext
    )
    
    if selectedProcess then
        LoadBalancer.stats.successfulRoutes = LoadBalancer.stats.successfulRoutes + 1
        LoadBalancer._updateRoutingStats(selectedProcess.processId, strategy, true)
        return selectedProcess
    else
        LoadBalancer.stats.failedRoutes = LoadBalancer.stats.failedRoutes + 1
        return nil, "Failed to select process using strategy: " .. strategy
    end
end

-- Update load metrics for a process
function LoadBalancer.updateProcessLoad(processId, loadMetrics)
    -- Update routing stats with load information
    if not LoadBalancer.routingStats[processId] then
        LoadBalancer.routingStats[processId] = {
            requestCount = 0,
            successCount = 0,
            failureCount = 0,
            averageResponseTime = 0,
            lastLoadUpdate = 0
        }
    end
    
    local stats = LoadBalancer.routingStats[processId]
    stats.lastLoadUpdate = 0
    
    -- Update load metrics in process discovery
    local healthInfo = {
        loadMetrics = loadMetrics,
        responseTime = loadMetrics.responseTime or 0
    }
    
    ProcessDiscovery.updateProcessHealth(processId, healthInfo)
end

-- Record routing result for circuit breaker logic
function LoadBalancer.recordRoutingResult(processId, success, responseTime)
    LoadBalancer._updateRoutingStats(processId, "RESULT", success)
    
    -- Update circuit breaker state
    local circuitBreaker = LoadBalancer.circuitBreakers[processId]
    if not circuitBreaker then
        circuitBreaker = {
            state = LoadBalancer.CIRCUIT_STATES.CLOSED,
            failureCount = 0,
            lastFailureTime = 0,
            successCount = 0
        }
        LoadBalancer.circuitBreakers[processId] = circuitBreaker
    end
    
    if success then
        circuitBreaker.successCount = circuitBreaker.successCount + 1
        
        -- Reset circuit breaker if in half-open state and successful
        if circuitBreaker.state == LoadBalancer.CIRCUIT_STATES.HALF_OPEN then
            circuitBreaker.state = LoadBalancer.CIRCUIT_STATES.CLOSED
            circuitBreaker.failureCount = 0
        end
    else
        circuitBreaker.failureCount = circuitBreaker.failureCount + 1
        circuitBreaker.lastFailureTime = 0
        
        -- Trip circuit breaker if threshold exceeded
        if circuitBreaker.failureCount >= LoadBalancer.config.circuitBreakerThreshold then
            if circuitBreaker.state ~= LoadBalancer.CIRCUIT_STATES.OPEN then
                circuitBreaker.state = LoadBalancer.CIRCUIT_STATES.OPEN
                LoadBalancer.stats.circuitBreakerTrips = LoadBalancer.stats.circuitBreakerTrips + 1
                print("[LoadBalancer] Circuit breaker OPEN for process " .. processId)
            end
        end
    end
end

-- Get load balancing statistics
function LoadBalancer.getStatistics()
    local strategyDistribution = {}
    for strategy, count in pairs(LoadBalancer.stats.strategyUsage) do
        strategyDistribution[strategy] = {
            count = count,
            percentage = LoadBalancer.stats.totalRequests > 0 and 
                        (count / LoadBalancer.stats.totalRequests * 100) or 0
        }
    end
    
    local circuitBreakerStats = {}
    for processId, breaker in pairs(LoadBalancer.circuitBreakers) do
        circuitBreakerStats[processId] = {
            state = breaker.state,
            failureCount = breaker.failureCount,
            successCount = breaker.successCount
        }
    end
    
    return {
        stats = LoadBalancer.stats,
        config = LoadBalancer.config,
        strategyDistribution = strategyDistribution,
        circuitBreakerStats = circuitBreakerStats,
        routingStatsCount = LoadBalancer._getTableSize(LoadBalancer.routingStats),
        successRate = LoadBalancer.stats.totalRequests > 0 and 
                     (LoadBalancer.stats.successfulRoutes / LoadBalancer.stats.totalRequests) or 0
    }
end

-- Private helper functions

function LoadBalancer._determineStrategy(routingContext)
    if not routingContext then
        return LoadBalancer.config.defaultStrategy
    end
    
    -- Check for explicit strategy request
    if routingContext.routingStrategy then
        return routingContext.routingStrategy
    end
    
    -- Check for session affinity requirement
    if LoadBalancer.config.sessionAffinityEnabled and routingContext.sessionId then
        return LoadBalancer.STRATEGIES.SESSION_AFFINITY
    end
    
    -- Default strategy
    return LoadBalancer.config.defaultStrategy
end

function LoadBalancer._applyRoutingStrategy(strategy, availableProcesses, operationType, routingContext)
    if strategy == LoadBalancer.STRATEGIES.ROUND_ROBIN then
        return LoadBalancer._roundRobinSelection(availableProcesses, operationType)
        
    elseif strategy == LoadBalancer.STRATEGIES.LEAST_LOADED then
        return LoadBalancer._leastLoadedSelection(availableProcesses)
        
    elseif strategy == LoadBalancer.STRATEGIES.RESPONSE_TIME then
        return LoadBalancer._fastestResponseSelection(availableProcesses)
        
    elseif strategy == LoadBalancer.STRATEGIES.LEAST_CONNECTIONS then
        return LoadBalancer._leastConnectionsSelection(availableProcesses)
        
    elseif strategy == LoadBalancer.STRATEGIES.RANDOM then
        return LoadBalancer._randomSelection(availableProcesses)
        
    elseif strategy == LoadBalancer.STRATEGIES.SESSION_AFFINITY then
        return LoadBalancer._sessionAffinitySelection(availableProcesses, routingContext)
        
    elseif strategy == LoadBalancer.STRATEGIES.CAPABILITY_MATCH then
        return LoadBalancer._capabilityMatchSelection(availableProcesses, operationType)
        
    else
        -- Fallback to round robin
        return LoadBalancer._roundRobinSelection(availableProcesses, operationType)
    end
end

function LoadBalancer._roundRobinSelection(availableProcesses, operationType)
    local processIds = LoadBalancer._getProcessIds(availableProcesses)
    
    if not LoadBalancer.roundRobinCounters[operationType] then
        LoadBalancer.roundRobinCounters[operationType] = 0
    end
    
    local index = (LoadBalancer.roundRobinCounters[operationType] % #processIds) + 1
    LoadBalancer.roundRobinCounters[operationType] = LoadBalancer.roundRobinCounters[operationType] + 1
    
    local selectedId = processIds[index]
    return availableProcesses[selectedId]
end

function LoadBalancer._leastLoadedSelection(availableProcesses)
    local leastLoaded = nil
    local minLoad = math.huge
    
    for processId, processInfo in pairs(availableProcesses) do
        local load = (processInfo.loadMetrics.cpuUsage or 0) + 
                    (processInfo.loadMetrics.memoryUsage or 0) +
                    (processInfo.loadMetrics.requestCount or 0) * 0.1
        
        if load < minLoad then
            minLoad = load
            leastLoaded = processInfo
        end
    end
    
    return leastLoaded
end

function LoadBalancer._fastestResponseSelection(availableProcesses)
    local fastest = nil
    local minResponseTime = math.huge
    
    for processId, processInfo in pairs(availableProcesses) do
        local responseTime = processInfo.responseTimeMs or math.huge
        if responseTime < minResponseTime then
            minResponseTime = responseTime
            fastest = processInfo
        end
    end
    
    return fastest
end

function LoadBalancer._leastConnectionsSelection(availableProcesses)
    local leastConnections = nil
    local minConnections = math.huge
    
    for processId, processInfo in pairs(availableProcesses) do
        local connections = (LoadBalancer.routingStats[processId] and 
                           LoadBalancer.routingStats[processId].requestCount) or 0
        
        if connections < minConnections then
            minConnections = connections
            leastConnections = processInfo
        end
    end
    
    return leastConnections
end

function LoadBalancer._randomSelection(availableProcesses)
    local processIds = LoadBalancer._getProcessIds(availableProcesses)
    local randomIndex = math.random(1, #processIds)
    local selectedId = processIds[randomIndex]
    return availableProcesses[selectedId]
end

function LoadBalancer._sessionAffinitySelection(availableProcesses, routingContext)
    if not routingContext or not routingContext.sessionId then
        return LoadBalancer._roundRobinSelection(availableProcesses, "session-affinity")
    end
    
    -- Use session ID hash to consistently select the same process
    local sessionHash = LoadBalancer._hashString(routingContext.sessionId)
    local processIds = LoadBalancer._getProcessIds(availableProcesses)
    local index = (sessionHash % #processIds) + 1
    local selectedId = processIds[index]
    
    return availableProcesses[selectedId]
end

function LoadBalancer._capabilityMatchSelection(availableProcesses, operationType)
    -- Find process with best capability match for the operation
    local bestMatch = nil
    
    for processId, processInfo in pairs(availableProcesses) do
        -- Use ProcessDiscovery capability matching logic
        if ProcessDiscovery._processHasCapability(processInfo.capabilities, operationType) then
            bestMatch = processInfo
            break
        end
    end
    
    return bestMatch or LoadBalancer._roundRobinSelection(availableProcesses, operationType)
end

function LoadBalancer._filterHealthyProcesses(processes)
    local healthyProcesses = {}
    
    for processId, processInfo in pairs(processes) do
        if processInfo.healthStatus == ProcessDiscovery.HEALTH_STATES.HEALTHY or
           processInfo.healthStatus == ProcessDiscovery.HEALTH_STATES.DEGRADED then
            healthyProcesses[processId] = processInfo
        end
    end
    
    return healthyProcesses
end

function LoadBalancer._filterCircuitBreakerProcesses(processes)
    local availableProcesses = {}
    local currentTime = 0
    
    for processId, processInfo in pairs(processes) do
        local circuitBreaker = LoadBalancer.circuitBreakers[processId]
        
        if not circuitBreaker or circuitBreaker.state == LoadBalancer.CIRCUIT_STATES.CLOSED then
            availableProcesses[processId] = processInfo
        elseif circuitBreaker.state == LoadBalancer.CIRCUIT_STATES.OPEN then
            -- Check if circuit breaker should transition to half-open
            local timeSinceFailure = (currentTime - circuitBreaker.lastFailureTime) * 1000
            if timeSinceFailure >= LoadBalancer.config.circuitBreakerTimeoutMs then
                circuitBreaker.state = LoadBalancer.CIRCUIT_STATES.HALF_OPEN
                availableProcesses[processId] = processInfo
                print("[LoadBalancer] Circuit breaker HALF_OPEN for process " .. processId)
            end
        elseif circuitBreaker.state == LoadBalancer.CIRCUIT_STATES.HALF_OPEN then
            availableProcesses[processId] = processInfo
        end
    end
    
    return availableProcesses
end

function LoadBalancer._updateRoutingStats(processId, strategy, success)
    if not LoadBalancer.routingStats[processId] then
        LoadBalancer.routingStats[processId] = {
            requestCount = 0,
            successCount = 0,
            failureCount = 0,
            averageResponseTime = 0,
            lastRequestTime = 0
        }
    end
    
    local stats = LoadBalancer.routingStats[processId]
    stats.requestCount = stats.requestCount + 1
    stats.lastRequestTime = 0
    
    if success then
        stats.successCount = stats.successCount + 1
    else
        stats.failureCount = stats.failureCount + 1
    end
end

function LoadBalancer._hashString(str)
    local hash = 0
    for i = 1, #str do
        hash = (hash * 31 + string.byte(str, i)) % 2147483647
    end
    return hash
end

function LoadBalancer._getProcessIds(processes)
    local ids = {}
    for processId, _ in pairs(processes) do
        table.insert(ids, processId)
    end
    return ids
end

function LoadBalancer._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: coordinator.components.load-balancer =====


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- Health monitoring state
local healthMonitoring = {
    monitoringEnabled = true,
    alertThresholds = {
        responseTimeMs = 5000,
        errorRate = 0.1,
        cpuUsage = 90,
        memoryUsage = 85
    },
    alertSubscriptions = {},
    monitoringHistory = {}
}

-- Health check response handler
Handlers.add(
    "health-check-response",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_RESPONSE"),
    function(msg)
        local healthData = json.decode(msg.Data)
        if not healthData then
            print("[ProcessHealthHandler] Invalid health response from " .. msg.From)
            return
        end

        -- Extract health information
        local healthInfo = {
            status = healthData.status or "UNKNOWN",
            timestamp = healthData.timestamp or 0,
            uptime = healthData.uptime or 0,
            responseTime = (msg.Timestamp) - (msg.Timestamp or 0),
            loadMetrics = healthData.loadMetrics or {},
            components = healthData.components or {}
        }

        -- Update process health in discovery system
        local success, error = ProcessDiscovery.updateProcessHealth(msg.From, healthInfo)
        if not success then
            print("[ProcessHealthHandler] Failed to update health for " .. msg.From .. ": " .. (error or "unknown"))
            return
        end

        -- Update load balancer with load metrics
        if healthInfo.loadMetrics then
            LoadBalancer.updateProcessLoad(msg.From, healthInfo.loadMetrics)
        end

        -- Check for alerts
        _checkHealthAlerts(msg.From, healthInfo)

        -- Record routing success for circuit breaker
        LoadBalancer.recordRoutingResult(msg.From, true, healthInfo.responseTime)
    end
)

-- Process registration notification handler
Handlers.add(
    "process-registration",
    Handlers.utils.hasMatchingTag("Action", "PROCESS_REGISTER"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "PROCESS_REGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local registrationData = json.decode(msg.Data)
        if not registrationData or not registrationData.processInfo then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "PROCESS_REGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Process information is required"
                })
            })
            return
        end

        -- Register process in discovery system
        local success, error = ProcessDiscovery.registerProcess(msg.From, registrationData.processInfo)
        
        ao.send({
            Target = msg.From,
            Tags = {
                Action = "PROCESS_REGISTER_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "process-register"
            },
            Data = json.encode({
                success = success,
                error = error,
                processId = msg.From,
                registeredAt = 0
            })
        })

        if success then
            print("[ProcessHealthHandler] Registered new process " .. msg.From .. " (" .. 
                  registrationData.processInfo.type .. ")")
        end
    end
)

-- Process deregistration handler
Handlers.add(
    "process-deregistration", 
    Handlers.utils.hasMatchingTag("Action", "PROCESS_DEREGISTER"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "PROCESS_DEREGISTER_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local deregistrationData = json.decode(msg.Data)
        local reason = deregistrationData and deregistrationData.reason or "Manual deregistration"

        -- Mark process as offline
        local success = ProcessDiscovery.markProcessOffline(msg.From, reason)
        
        ao.send({
            Target = msg.From,
            Tags = {
                Action = "PROCESS_DEREGISTER_RESPONSE", 
                CorrelationId = msg.Tags.CorrelationId or "process-deregister"
            },
            Data = json.encode({
                success = success,
                processId = msg.From,
                reason = reason,
                deregisteredAt = 0
            })
        })

        print("[ProcessHealthHandler] Deregistered process " .. msg.From .. " - " .. reason)
    end
)

-- Health monitoring configuration handler
Handlers.add(
    "health-monitoring-config",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_MONITORING_CONFIG"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "HEALTH_MONITORING_CONFIG_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local configData = json.decode(msg.Data)
        if not configData then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "HEALTH_MONITORING_CONFIG_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid configuration data"
                })
            })
            return
        end

        -- Update monitoring configuration
        if configData.enabled ~= nil then
            healthMonitoring.monitoringEnabled = configData.enabled
        end

        if configData.alertThresholds then
            for key, value in pairs(configData.alertThresholds) do
                healthMonitoring.alertThresholds[key] = value
            end
        end

        -- Update process discovery configuration
        if configData.discoveryConfig then
            for key, value in pairs(configData.discoveryConfig) do
                ProcessDiscovery.config[key] = value
            end
        end

        -- Update load balancer configuration
        if configData.loadBalancerConfig then
            for key, value in pairs(configData.loadBalancerConfig) do
                LoadBalancer.config[key] = value
            end
        end

        ao.send({
            Target = msg.From,
            Tags = {
                Action = "HEALTH_MONITORING_CONFIG_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "config-update"
            },
            Data = json.encode({
                success = true,
                updatedConfig = {
                    monitoring = healthMonitoring,
                    processDiscovery = ProcessDiscovery.config,
                    loadBalancer = LoadBalancer.config
                },
                timestamp = 0
            })
        })

        print("[ProcessHealthHandler] Updated health monitoring configuration")
    end
)

-- Process health status query handler
Handlers.add(
    "health-status-query",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_STATUS_QUERY"),
    function(msg)
        local queryData = json.decode(msg.Data)
        local processId = queryData and queryData.processId
        
        if processId then
            -- Get health status for specific process
            local processInfo = ProcessDiscovery.processRegistry[processId]
            if processInfo then
                ao.send({
                    Target = msg.From,
                    Tags = {
                        Action = "HEALTH_STATUS_RESPONSE",
                        CorrelationId = msg.Tags.CorrelationId or "status-query"
                    },
                    Data = json.encode({
                        success = true,
                        processId = processId,
                        healthStatus = processInfo.healthStatus,
                        lastHealthCheck = processInfo.lastHealthCheck,
                        responseTime = processInfo.responseTimeMs,
                        loadMetrics = processInfo.loadMetrics,
                        uptime = processInfo.registeredAt and (0 - processInfo.registeredAt) or 0
                    })
                })
            else
                ao.send({
                    Target = msg.From,
                    Tags = {
                        Action = "HEALTH_STATUS_RESPONSE",
                        CorrelationId = msg.Tags.CorrelationId or "status-query"
                    },
                    Data = json.encode({
                        success = false,
                        error = "Process not found: " .. processId
                    })
                })
            end
        else
            -- Get overall health summary
            local healthSummary = _generateHealthSummary()
            
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "HEALTH_STATUS_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "status-query"
                },
                Data = json.encode({
                    success = true,
                    healthSummary = healthSummary,
                    timestamp = 0
                })
            })
        end
    end
)

-- Health alert subscription handler
Handlers.add(
    "health-alert-subscribe",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_ALERT_SUBSCRIBE"),
    function(msg)
        local authResult = ProcessAuthenticator.validateMessage(msg)
        if not authResult.valid then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "HEALTH_ALERT_SUBSCRIBE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Authentication failed"
                })
            })
            return
        end

        local subscriptionData = json.decode(msg.Data)
        if not subscriptionData then
            subscriptionData = {}
        end

        -- Add alert subscription
        healthMonitoring.alertSubscriptions[msg.From] = {
            subscriberId = msg.From,
            alertTypes = subscriptionData.alertTypes or {"all"},
            thresholds = subscriptionData.thresholds or healthMonitoring.alertThresholds,
            subscribedAt = 0
        }

        ao.send({
            Target = msg.From,
            Tags = {
                Action = "HEALTH_ALERT_SUBSCRIBE_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "alert-subscribe"
            },
            Data = json.encode({
                success = true,
                subscriptionId = msg.From,
                alertTypes = healthMonitoring.alertSubscriptions[msg.From].alertTypes,
                timestamp = 0
            })
        })

        print("[ProcessHealthHandler] Health alert subscription added for " .. msg.From)
    end
)

-- Perform periodic maintenance
Handlers.add(
    "health-maintenance",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_MAINTENANCE"),
    function(msg)
        if not healthMonitoring.monitoringEnabled then
            return
        end

        -- Perform health checks
        local healthCheckCount = ProcessDiscovery.performHealthChecks()
        
        -- Cleanup expired processes
        local cleanupCount = ProcessDiscovery.cleanupExpiredProcesses()
        
        -- Send maintenance results
        if msg.From then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "HEALTH_MAINTENANCE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "maintenance"
                },
                Data = json.encode({
                    success = true,
                    healthChecksPerformed = healthCheckCount,
                    processesCleanedUp = cleanupCount,
                    timestamp = 0
                })
            })
        end

        print("[ProcessHealthHandler] Maintenance completed: " .. 
              healthCheckCount .. " health checks, " .. 
              cleanupCount .. " processes cleaned up")
    end
)

-- Private helper functions (moved to top for forward references)

local function _getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

local function _sendHealthAlerts(alerts)
    for subscriberId, subscription in pairs(healthMonitoring.alertSubscriptions) do
        for _, alert in ipairs(alerts) do
            -- Check if subscriber is interested in this alert type
            local shouldSend = false
            for _, alertType in ipairs(subscription.alertTypes) do
                if alertType == "all" or alertType == alert.type then
                    shouldSend = true
                    break
                end
            end

            if shouldSend then
                ao.send({
                    Target = subscriberId,
                    Tags = {
                        Action = "HEALTH_ALERT",
                        AlertType = alert.type,
                        ProcessId = alert.processId
                    },
                    Data = json.encode({
                        alert = alert,
                        timestamp = 0
                    })
                })
            end
        end
    end
end

local function _generateHealthSummary()
    local discovery = ProcessDiscovery.getStatistics()
    local loadBalancer = LoadBalancer.getStatistics()
    
    return {
        totalProcesses = discovery.totalRegisteredProcesses,
        healthDistribution = discovery.healthStatusDistribution,
        processTypeDistribution = discovery.processTypeDistribution,
        averageResponseTime = discovery.averageResponseTime,
        loadBalancingStats = {
            totalRequests = loadBalancer.stats.totalRequests,
            successRate = loadBalancer.successRate,
            circuitBreakerTrips = loadBalancer.stats.circuitBreakerTrips
        },
        alertingEnabled = healthMonitoring.monitoringEnabled,
        activeAlertSubscriptions = _getTableSize(healthMonitoring.alertSubscriptions)
    }
end

local function _checkHealthAlerts(processId, healthInfo)
    if not healthMonitoring.monitoringEnabled then
        return
    end

    local alerts = {}

    -- Check response time threshold
    if healthInfo.responseTime and healthInfo.responseTime > healthMonitoring.alertThresholds.responseTimeMs then
        table.insert(alerts, {
            type = "HIGH_RESPONSE_TIME",
            processId = processId,
            value = healthInfo.responseTime,
            threshold = healthMonitoring.alertThresholds.responseTimeMs
        })
    end

    -- Check error rate threshold
    if healthInfo.loadMetrics and healthInfo.loadMetrics.errorRate and 
       healthInfo.loadMetrics.errorRate > healthMonitoring.alertThresholds.errorRate then
        table.insert(alerts, {
            type = "HIGH_ERROR_RATE",
            processId = processId,
            value = healthInfo.loadMetrics.errorRate,
            threshold = healthMonitoring.alertThresholds.errorRate
        })
    end

    -- Check CPU usage threshold
    if healthInfo.loadMetrics and healthInfo.loadMetrics.cpuUsage and
       healthInfo.loadMetrics.cpuUsage > healthMonitoring.alertThresholds.cpuUsage then
        table.insert(alerts, {
            type = "HIGH_CPU_USAGE",
            processId = processId,
            value = healthInfo.loadMetrics.cpuUsage,
            threshold = healthMonitoring.alertThresholds.cpuUsage
        })
    end

    -- Check memory usage threshold
    if healthInfo.loadMetrics and healthInfo.loadMetrics.memoryUsage and
       healthInfo.loadMetrics.memoryUsage > healthMonitoring.alertThresholds.memoryUsage then
        table.insert(alerts, {
            type = "HIGH_MEMORY_USAGE",
            processId = processId,
            value = healthInfo.loadMetrics.memoryUsage,
            threshold = healthMonitoring.alertThresholds.memoryUsage
        })
    end

    -- Send alerts to subscribers
    if #alerts > 0 then
        _sendHealthAlerts(alerts)
    end
end


-- ===== END MODULE: coordinator.handlers.process-health-handler =====


-- Initialize process on load
initialize()

