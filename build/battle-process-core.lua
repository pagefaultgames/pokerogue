-- Core bundle for battle-process (essential logic only)
-- Generated by emergency splitting

-- Bundled Lua file for AO Environment
-- Generated by custom-lua-bundler.sh
-- Entry point: ao-processes/battle/main.lua
-- Bundle timestamp: Mon Sep  8 12:46:35 EDT 2025

-- JSON require (allowed in AO environment)
local json = require('json')

-- Battle Process - Dedicated High-Performance Battle Engine
-- Extracted battle processing for Epic 32.3: Battle Engine Process Extraction
-- Handles battle calculations, turn resolution, and concurrent battle management

-- Core AO process identification
Name = "BattleProcess"
Owner = Owner or "process-owner"

-- JSON handling for AO environment
local json = {}
local success, jsonModule = pcall(require, 'json')
if success then
    json = jsonModule
else
    -- Pure Lua JSON implementation for AO environment compatibility
    json = {
        encode = function(obj)
            if type(obj) == "string" then
                return '"' .. obj:gsub('"', '\\"'):gsub('\n', '\\n'):gsub('\r', '\\r'):gsub('\t', '\\t') .. '"'
            elseif type(obj) == "number" then
                return tostring(obj)
            elseif type(obj) == "boolean" then
                return obj and "true" or "false"
            elseif obj == nil then
                return "null"
            elseif type(obj) == "table" then
                local isArray = true
                local maxIndex = 0
                for k, v in pairs(obj) do
                    if type(k) ~= "number" then
                        isArray = false
                        break
                    end
                    maxIndex = math.max(maxIndex, k)
                end
                
                if isArray then
                    local result = "["
                    for i = 1, maxIndex do
                        if i > 1 then result = result .. "," end
                        result = result .. json.encode(obj[i])
                    end
                    return result .. "]"
                else
                    local result = "{"
                    local first = true
                    for k, v in pairs(obj) do
                        if not first then result = result .. "," end
                        result = result .. json.encode(tostring(k)) .. ":" .. json.encode(v)
                        first = false
                    end
                    return result .. "}"
                end
            else
                return "null"
            end
        end,
        decode = function(str)
            -- Basic decode fallback - returns empty table for safety
            -- More robust implementation would be needed for full JSON parsing
            return {}
        end
    }
end

-- Process metadata for discovery
local PROCESS_INFO = {
    name = "BattleProcess",
    version = "1.0.0",
    description = "Dedicated battle engine process for high-performance battle calculations",
    capabilities = {
        "BATTLE_COMMAND_PROCESSING",
        "DAMAGE_CALCULATION", 
        "MOVE_EFFECT_PROCESSING",
        "BATTLE_STATE_MANAGEMENT",
        "CONCURRENT_BATTLES",
        "BATTLE_REPLAY"
    },
    dependencies = {
        "CoordinatorProcess",
        "PokemonProcess",
        "RNGProcess"
    }
}

-- Load inter-process communication components

-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")

-- Message Correlation System for Inter-Process Communication
-- Provides unique correlation ID generation and tracking across message chains


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")

-- Cryptographically secure RNG wrapper for AO processes
-- Replaces non-deterministic math.random() with seedable crypto-based randomness

local CryptoRNG = {
    -- Battle RNG state for deterministic battles
    battleSeed = nil,
    battleCounter = 0,
    
    -- General RNG state for non-battle operations
    globalSeed = nil,
    globalCounter = 0
}

-- Initialize battle RNG with a specific seed for deterministic battles
function CryptoRNG.initBattleRNG(seed)
    if not seed or type(seed) ~= "string" then
        error("Battle RNG seed must be a string")
    end
    CryptoRNG.battleSeed = seed
    CryptoRNG.battleCounter = 0
end

-- Initialize global RNG with a seed (or generate one from ao.crypto)
function CryptoRNG.initGlobalRNG(seed)
    if seed then
        CryptoRNG.globalSeed = seed
    else
        -- Use AO crypto to generate a random seed (with fallback for testing)
        if ao and ao.crypto and ao.crypto.cipher then
            CryptoRNG.globalSeed = ao.crypto.cipher.issuer()
        else
            -- Fallback for testing environment - use current time
            CryptoRNG.globalSeed = tostring(os.time())
        end
    end
    CryptoRNG.globalCounter = 0
end

-- Get deterministic random integer in battle context
function CryptoRNG.battleRandomInt(min, max)
    if not CryptoRNG.battleSeed then
        error("Battle RNG not initialized - call CryptoRNG.initBattleRNG(seed) first")
    end
    
    -- Increment counter for deterministic sequence
    CryptoRNG.battleCounter = CryptoRNG.battleCounter + 1
    
    -- Create deterministic input combining seed and counter
    local input = CryptoRNG.battleSeed .. ":" .. tostring(CryptoRNG.battleCounter)
    
    -- Use AO crypto to generate deterministic hash (with fallback)
    local hash
    if ao and ao.crypto and ao.crypto.utils then
        hash = ao.crypto.utils.hash(input)
    else
        -- Fallback hash function for testing using simple string hashing
        local hashNum = 0
        for i = 1, #input do
            hashNum = hashNum + string.byte(input, i) * (i * 31)
        end
        hash = tostring(math.abs(hashNum))
    end
    
    -- Convert hash to number and normalize to range
    local num = 0
    for i = 1, math.min(8, #hash) do
        num = num + string.byte(hash, i) * (256 ^ (i - 1))
    end
    
    -- Normalize to requested range
    if min and max then
        return min + (num % (max - min + 1))
    else
        return num % 100 + 1  -- Default 1-100 range
    end
end

-- Get random number in battle context (0-1 float)
function CryptoRNG.battleRandom()
    local randomInt = CryptoRNG.battleRandomInt(0, 999999)
    return randomInt / 999999
end

-- Get random integer in global context
function CryptoRNG.globalRandomInt(min, max)
    if not CryptoRNG.globalSeed then
        CryptoRNG.initGlobalRNG()
    end
    
    CryptoRNG.globalCounter = CryptoRNG.globalCounter + 1
    
    -- Create deterministic input
    local input = CryptoRNG.globalSeed .. ":" .. tostring(CryptoRNG.globalCounter)
    
    -- Use AO crypto for randomness (with fallback)
    local hash
    if ao and ao.crypto and ao.crypto.utils then
        hash = ao.crypto.utils.hash(input)
    else
        -- Fallback hash function for testing using simple string hashing
        local hashNum = 0
        for i = 1, #input do
            hashNum = hashNum + string.byte(input, i) * (i * 37)
        end
        hash = tostring(math.abs(hashNum))
    end
    
    -- Convert to number
    local num = 0
    for i = 1, math.min(8, #hash) do
        num = num + string.byte(hash, i) * (256 ^ (i - 1))
    end
    
    -- Normalize to range
    if min and max then
        return min + (num % (max - min + 1))
    else
        return num % 100 + 1
    end
end

-- Get random float in global context (0-1)
function CryptoRNG.globalRandom()
    local randomInt = CryptoRNG.globalRandomInt(0, 999999)
    return randomInt / 999999
end

-- Compatibility functions that match math.random() interface
function CryptoRNG.random(...)
    local args = {...}
    local argCount = #args
    
    if argCount == 0 then
        -- math.random() -> 0-1 float
        return CryptoRNG.globalRandom()
    elseif argCount == 1 then
        -- math.random(n) -> 1 to n
        return CryptoRNG.globalRandomInt(1, args[1])
    elseif argCount == 2 then
        -- math.random(m, n) -> m to n
        return CryptoRNG.globalRandomInt(args[1], args[2])
    else
        error("Invalid number of arguments to CryptoRNG.random()")
    end
end

-- Battle-specific random that follows the same interface
function CryptoRNG.battleRandomCompat(...)
    local args = {...}
    local argCount = #args
    
    if argCount == 0 then
        return CryptoRNG.battleRandom()
    elseif argCount == 1 then
        return CryptoRNG.battleRandomInt(1, args[1])
    elseif argCount == 2 then
        return CryptoRNG.battleRandomInt(args[1], args[2])
    else
        error("Invalid number of arguments to CryptoRNG.battleRandomCompat()")
    end
end

-- Reset battle RNG state (for new battles)
function CryptoRNG.resetBattleRNG()
    CryptoRNG.battleSeed = nil
    CryptoRNG.battleCounter = 0
end

-- Get current battle RNG state for debugging
function CryptoRNG.getBattleState()
    return {
        seed = CryptoRNG.battleSeed,
        counter = CryptoRNG.battleCounter
    }
end


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local MessageCorrelator = {
    -- Correlation tracking storage
    activeCorrelations = {},
    correlationHistory = {},
    maxHistorySize = 10000
}

-- Correlation Types
MessageCorrelator.CORRELATION_TYPES = {
    INTER_PROCESS = "INTER_PROCESS",
    INTRA_PROCESS = "INTRA_PROCESS",
    CLIENT_REQUEST = "CLIENT_REQUEST"
}

-- Message Status
MessageCorrelator.MESSAGE_STATUS = {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING", 
    COMPLETED = "COMPLETED",
    FAILED = "FAILED",
    TIMEOUT = "TIMEOUT"
}

-- Initialize the correlation system
function MessageCorrelator.initialize()
    MessageCorrelator.activeCorrelations = {}
    MessageCorrelator.correlationHistory = {}
    CryptoRNG.initGlobalRNG()
    print("[MessageCorrelator] Correlation system initialized")
end

-- Generate unique correlation ID using AO crypto module
function MessageCorrelator.generateCorrelationId(correlationType, timestamp)
    local currentTimestamp = timestamp or (msg and msg.Timestamp) or 0
    local baseTimestamp = currentTimestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    local prefix = correlationType == MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS and "ipc" or "cor"
    
    return prefix .. "_" .. baseTimestamp .. "_" .. randomSuffix
end

-- Create new correlation with full metadata
function MessageCorrelator.createCorrelation(originProcessId, targetProcessId, messageType, parentCorrelationId, timestamp)
    local correlationId = MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS, timestamp)
    local currentTimestamp = timestamp or 0
    
    local correlation = {
        id = correlationId,
        parent = parentCorrelationId,
        origin = originProcessId,
        target = targetProcessId,
        messageType = messageType,
        status = MessageCorrelator.MESSAGE_STATUS.PENDING,
        created = currentTimestamp,
        lastUpdated = currentTimestamp,
        chain = {}
    }
    
    -- Add to parent chain if this is a nested operation
    if parentCorrelationId and MessageCorrelator.activeCorrelations[parentCorrelationId] then
        table.insert(MessageCorrelator.activeCorrelations[parentCorrelationId].chain, correlationId)
        correlation.depth = (MessageCorrelator.activeCorrelations[parentCorrelationId].depth or 0) + 1
    else
        correlation.depth = 0
    end
    
    MessageCorrelator.activeCorrelations[correlationId] = correlation
    
    return correlationId
end

-- Update correlation status
function MessageCorrelator.updateCorrelationStatus(correlationId, status, errorMessage, timestamp)
    local correlation = MessageCorrelator.activeCorrelations[correlationId]
    if not correlation then
        return false, "Correlation not found: " .. tostring(correlationId)
    end
    
    correlation.status = status
    correlation.lastUpdated = timestamp or 0
    
    if errorMessage then
        correlation.error = errorMessage
    end
    
    -- Move to history if completed or failed
    if status == MessageCorrelator.MESSAGE_STATUS.COMPLETED or 
       status == MessageCorrelator.MESSAGE_STATUS.FAILED or 
       status == MessageCorrelator.MESSAGE_STATUS.TIMEOUT then
        MessageCorrelator.moveToHistory(correlationId)
    end
    
    return true
end

-- Get correlation metadata
function MessageCorrelator.getCorrelation(correlationId)
    return MessageCorrelator.activeCorrelations[correlationId] or 
           MessageCorrelator.correlationHistory[correlationId]
end

-- Get all active correlations for a process
function MessageCorrelator.getProcessCorrelations(processId)
    local processCorrelations = {}
    
    for correlationId, correlation in pairs(MessageCorrelator.activeCorrelations) do
        if correlation.origin == processId or correlation.target == processId then
            processCorrelations[correlationId] = correlation
        end
    end
    
    return processCorrelations
end

-- Get correlation chain (parent and all children)
function MessageCorrelator.getCorrelationChain(correlationId)
    local correlation = MessageCorrelator.getCorrelation(correlationId)
    if not correlation then
        return nil
    end
    
    local chain = { correlation }
    
    -- Get parent chain
    local parent = correlation.parent
    while parent do
        local parentCorrelation = MessageCorrelator.getCorrelation(parent)
        if parentCorrelation then
            table.insert(chain, 1, parentCorrelation)
            parent = parentCorrelation.parent
        else
            break
        end
    end
    
    -- Get child chain
    local function addChildren(currentId)
        local current = MessageCorrelator.getCorrelation(currentId)
        if current and current.chain then
            for _, childId in ipairs(current.chain) do
                local childCorrelation = MessageCorrelator.getCorrelation(childId)
                if childCorrelation then
                    table.insert(chain, childCorrelation)
                    addChildren(childId)
                end
            end
        end
    end
    
    addChildren(correlationId)
    
    return chain
end

-- Move correlation to history and cleanup
function MessageCorrelator.moveToHistory(correlationId)
    local correlation = MessageCorrelator.activeCorrelations[correlationId]
    if not correlation then
        return false
    end
    
    -- Move to history
    MessageCorrelator.correlationHistory[correlationId] = correlation
    MessageCorrelator.activeCorrelations[correlationId] = nil
    
    -- Cleanup old history if at max size
    MessageCorrelator.cleanupHistory()
    
    return true
end

-- Cleanup old correlation history
function MessageCorrelator.cleanupHistory()
    local historySize = 0
    for _ in pairs(MessageCorrelator.correlationHistory) do
        historySize = historySize + 1
    end
    
    if historySize > MessageCorrelator.maxHistorySize then
        local oldestCorrelations = {}
        for correlationId, correlation in pairs(MessageCorrelator.correlationHistory) do
            table.insert(oldestCorrelations, {id = correlationId, lastUpdated = correlation.lastUpdated})
        end
        
        table.sort(oldestCorrelations, function(a, b) return a.lastUpdated < b.lastUpdated end)
        
        -- Remove oldest 20%
        local removeCount = math.floor(MessageCorrelator.maxHistorySize * 0.2)
        for i = 1, removeCount do
            MessageCorrelator.correlationHistory[oldestCorrelations[i].id] = nil
        end
    end
end

-- Create correlation metadata for message
function MessageCorrelator.createCorrelationMetadata(correlationId, originProcessId, targetProcessId, parentCorrelationId)
    return {
        id = correlationId,
        parent = parentCorrelationId,
        origin = originProcessId,
        target = targetProcessId
    }
end

-- Validate correlation metadata format
function MessageCorrelator.validateCorrelationMetadata(correlationMeta)
    if not correlationMeta or type(correlationMeta) ~= "table" then
        return false, "Correlation metadata must be a table"
    end
    
    if not correlationMeta.id or type(correlationMeta.id) ~= "string" then
        return false, "Correlation ID is required and must be a string"
    end
    
    if not correlationMeta.origin or type(correlationMeta.origin) ~= "string" then
        return false, "Origin process ID is required and must be a string"
    end
    
    if not correlationMeta.target or type(correlationMeta.target) ~= "string" then
        return false, "Target process ID is required and must be a string"
    end
    
    return true
end

-- Get correlation statistics
function MessageCorrelator.getStatistics()
    local activeCount = 0
    local historyCount = 0
    local statusCounts = {}
    
    for _ in pairs(MessageCorrelator.activeCorrelations) do
        activeCount = activeCount + 1
    end
    
    for _ in pairs(MessageCorrelator.correlationHistory) do
        historyCount = historyCount + 1
    end
    
    for _, correlation in pairs(MessageCorrelator.activeCorrelations) do
        statusCounts[correlation.status] = (statusCounts[correlation.status] or 0) + 1
    end
    
    for _, correlation in pairs(MessageCorrelator.correlationHistory) do
        statusCounts[correlation.status] = (statusCounts[correlation.status] or 0) + 1
    end
    
    return {
        activeCorrelations = activeCount,
        historyCorrelations = historyCount,
        totalCorrelations = activeCount + historyCount,
        statusBreakdown = statusCounts,
        maxHistorySize = MessageCorrelator.maxHistorySize
    }
end


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator") 

-- Inter-Process Authentication Framework
-- Provides secure process identity validation and token-based authentication

-- SHARED MODULE REFERENCE: game-logic.rng.crypto-rng (already included)

local ProcessAuthenticator = {
    -- Process registry storage
    processRegistry = {},
    
    -- Authentication token storage (active tokens)
    activeTokens = {},
    
    -- Token configuration
    tokenExpirationTime = 3600, -- 1 hour in seconds
    maxTokensPerProcess = 5,
    
    -- Process types for capability-based authentication
    PROCESS_TYPES = {
        COORDINATOR = "coordinator",
        BATTLE = "battle", 
        POKEMON = "pokemon",
        SHOP = "shop",
        SECURITY = "security",
        ADMIN = "admin"
    },
    
    -- Authentication levels
    AUTH_LEVELS = {
        NONE = "none",
        BASIC = "basic", 
        ELEVATED = "elevated",
        ADMIN = "admin"
    }
}

-- Initialize the authentication system
function ProcessAuthenticator.initialize()
    ProcessAuthenticator.processRegistry = {}
    ProcessAuthenticator.activeTokens = {}
    CryptoRNG.initGlobalRNG()
    print("[ProcessAuthenticator] Authentication system initialized")
end

-- Register a process with identity validation
function ProcessAuthenticator.registerProcess(processId, processType, walletAddress, capabilities, timestamp)
    if not processId or type(processId) ~= "string" or processId == "" then
        return false, "Process ID is required and must be a non-empty string"
    end
    
    if not processType or not ProcessAuthenticator.PROCESS_TYPES[processType:upper()] then
        return false, "Invalid process type. Must be one of: " .. table.concat(ProcessAuthenticator._getProcessTypeList(), ", ")
    end
    
    if not walletAddress or type(walletAddress) ~= "string" or walletAddress == "" then
        return false, "Wallet address is required for process identity validation"
    end
    
    if not capabilities or type(capabilities) ~= "table" then
        return false, "Capabilities must be provided as a table"
    end
    
    -- Validate wallet address format (basic validation)
    if not ProcessAuthenticator._validateWalletAddress(walletAddress) then
        return false, "Invalid wallet address format"
    end
    
    -- Check if process is already registered
    if ProcessAuthenticator.processRegistry[processId] then
        return false, "Process already registered: " .. processId
    end
    
    local currentTime = timestamp or 0
    local processRecord = {
        id = processId,
        type = processType:lower(),
        walletAddress = walletAddress,
        capabilities = capabilities,
        authLevel = ProcessAuthenticator._determineAuthLevel(processType, capabilities),
        status = "active",
        registeredAt = currentTime,
        lastHeartbeat = currentTime,
        tokenCount = 0
    }
    
    ProcessAuthenticator.processRegistry[processId] = processRecord
    
    print(string.format("[ProcessAuthenticator] Process registered: %s (Type: %s, Auth: %s)", 
          processId, processType, processRecord.authLevel))
    
    return true
end

-- Generate authentication token for a registered process
function ProcessAuthenticator.generateAuthToken(processId, requestingWallet, expirationTime, timestamp)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return nil, "Process not registered: " .. tostring(processId)
    end
    
    -- Validate requesting wallet matches registered wallet
    if processRecord.walletAddress ~= requestingWallet then
        return nil, "Wallet address mismatch for process authentication"
    end
    
    if processRecord.status ~= "active" then
        return nil, "Process is not active: " .. processId
    end
    
    -- Check token limit
    if processRecord.tokenCount >= ProcessAuthenticator.maxTokensPerProcess then
        return nil, "Maximum tokens exceeded for process: " .. processId
    end
    
    local tokenExpiration = expirationTime or ProcessAuthenticator.tokenExpirationTime
    local currentTime = timestamp or 0
    
    -- Generate unique token
    local tokenId = ProcessAuthenticator._generateTokenId()
    local tokenSignature = ProcessAuthenticator._generateTokenSignature(processId, tokenId, currentTime)
    
    local token = {
        id = tokenId,
        processId = processId,
        walletAddress = requestingWallet,
        signature = tokenSignature,
        authLevel = processRecord.authLevel,
        capabilities = processRecord.capabilities,
        issuedAt = currentTime,
        expiresAt = currentTime + tokenExpiration,
        status = "active"
    }
    
    ProcessAuthenticator.activeTokens[tokenId] = token
    processRecord.tokenCount = processRecord.tokenCount + 1
    processRecord.lastHeartbeat = currentTime
    
    return {
        tokenId = tokenId,
        signature = tokenSignature,
        expiresAt = token.expiresAt,
        authLevel = token.authLevel
    }
end

-- Validate authentication token and return process context
function ProcessAuthenticator.validateAuthToken(tokenId, signature, timestamp)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if not token then
        return false, nil, "Invalid token: not found"
    end
    
    if token.status ~= "active" then
        return false, nil, "Token is not active"
    end
    
    if (timestamp or 0) > token.expiresAt then
        ProcessAuthenticator._expireToken(tokenId)
        return false, nil, "Token has expired"
    end
    
    if token.signature ~= signature then
        return false, nil, "Token signature validation failed"
    end
    
    -- Return process authentication context
    local authContext = {
        processId = token.processId,
        walletAddress = token.walletAddress,
        authLevel = token.authLevel,
        capabilities = token.capabilities,
        tokenExpiration = token.expiresAt
    }
    
    return true, authContext, nil
end

-- Revoke authentication token
function ProcessAuthenticator.revokeAuthToken(tokenId, requestingProcessId)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if not token then
        return false, "Token not found: " .. tostring(tokenId)
    end
    
    -- Only the token owner or admin process can revoke
    if token.processId ~= requestingProcessId then
        local requestingProcess = ProcessAuthenticator.processRegistry[requestingProcessId]
        if not requestingProcess or requestingProcess.authLevel ~= ProcessAuthenticator.AUTH_LEVELS.ADMIN then
            return false, "Insufficient privileges to revoke token"
        end
    end
    
    ProcessAuthenticator._expireToken(tokenId)
    return true
end

-- Validate process-to-process communication authorization
function ProcessAuthenticator.validateProcessAuth(sourceProcessId, targetProcessId, operation, authToken, timestamp)
    -- Validate source process token
    local isValidToken, authContext, tokenError = ProcessAuthenticator.validateAuthToken(authToken.tokenId, authToken.signature, timestamp)
    if not isValidToken then
        return false, "Source process authentication failed: " .. tostring(tokenError)
    end
    
    if authContext.processId ~= sourceProcessId then
        return false, "Token process ID mismatch"
    end
    
    -- Check if target process exists and is active
    local targetProcess = ProcessAuthenticator.processRegistry[targetProcessId]
    if not targetProcess then
        return false, "Target process not registered: " .. targetProcessId
    end
    
    if targetProcess.status ~= "active" then
        return false, "Target process is not active: " .. targetProcessId
    end
    
    -- Validate operation authorization based on capabilities
    if not ProcessAuthenticator._isOperationAuthorized(authContext.capabilities, operation) then
        return false, "Operation not authorized for source process capabilities"
    end
    
    return true
end

-- Update process heartbeat
function ProcessAuthenticator.updateProcessHeartbeat(processId, timestamp)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return false, "Process not registered: " .. processId
    end
    
    processRecord.lastHeartbeat = timestamp or 0
    return true
end

-- Get registered process information
function ProcessAuthenticator.getProcessInfo(processId)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return nil
    end
    
    return {
        id = processRecord.id,
        type = processRecord.type,
        capabilities = processRecord.capabilities,
        authLevel = processRecord.authLevel,
        status = processRecord.status,
        registeredAt = processRecord.registeredAt,
        lastHeartbeat = processRecord.lastHeartbeat
    }
end

-- List all registered processes
function ProcessAuthenticator.listRegisteredProcesses(filterByType, filterByAuthLevel)
    local processes = {}
    
    for processId, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        local includeProcess = true
        
        if filterByType and processRecord.type ~= filterByType then
            includeProcess = false
        end
        
        if filterByAuthLevel and processRecord.authLevel ~= filterByAuthLevel then
            includeProcess = false
        end
        
        if includeProcess then
            processes[processId] = ProcessAuthenticator.getProcessInfo(processId)
        end
    end
    
    return processes
end

-- Clean up expired tokens and inactive processes
function ProcessAuthenticator.cleanup(timestamp)
    local currentTime = timestamp or 0
    local expiredTokens = 0
    local inactiveProcesses = 0
    
    -- Clean up expired tokens
    for tokenId, token in pairs(ProcessAuthenticator.activeTokens) do
        if currentTime > token.expiresAt then
            ProcessAuthenticator._expireToken(tokenId)
            expiredTokens = expiredTokens + 1
        end
    end
    
    -- Mark processes inactive if no heartbeat for too long (2x token expiration)
    local inactiveThreshold = ProcessAuthenticator.tokenExpirationTime * 2
    for processId, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        if processRecord.status == "active" and 
           (currentTime - processRecord.lastHeartbeat) > inactiveThreshold then
            processRecord.status = "inactive"
            inactiveProcesses = inactiveProcesses + 1
        end
    end
    
    return {
        expiredTokens = expiredTokens,
        inactiveProcesses = inactiveProcesses
    }
end

-- Get authentication statistics
function ProcessAuthenticator.getStatistics()
    local registeredProcesses = 0
    local activeProcesses = 0
    local activeTokens = 0
    local processTypes = {}
    local authLevels = {}
    
    for _, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        registeredProcesses = registeredProcesses + 1
        if processRecord.status == "active" then
            activeProcesses = activeProcesses + 1
        end
        
        processTypes[processRecord.type] = (processTypes[processRecord.type] or 0) + 1
        authLevels[processRecord.authLevel] = (authLevels[processRecord.authLevel] or 0) + 1
    end
    
    for _ in pairs(ProcessAuthenticator.activeTokens) do
        activeTokens = activeTokens + 1
    end
    
    return {
        registeredProcesses = registeredProcesses,
        activeProcesses = activeProcesses,
        inactiveProcesses = registeredProcesses - activeProcesses,
        activeTokens = activeTokens,
        maxTokensPerProcess = ProcessAuthenticator.maxTokensPerProcess,
        tokenExpirationTime = ProcessAuthenticator.tokenExpirationTime,
        processTypeBreakdown = processTypes,
        authLevelBreakdown = authLevels
    }
end

-- Private helper functions

function ProcessAuthenticator._validateWalletAddress(walletAddress)
    -- Basic validation: should be 43 characters and alphanumeric with specific chars
    if type(walletAddress) ~= "string" or #walletAddress ~= 43 then
        return false
    end
    
    -- Check for valid Arweave wallet address pattern (Base64URL)
    return string.match(walletAddress, "^[A-Za-z0-9_%-]+$") ~= nil
end

function ProcessAuthenticator._determineAuthLevel(processType, capabilities)
    local normalizedType = processType:lower()
    
    if normalizedType == ProcessAuthenticator.PROCESS_TYPES.ADMIN then
        return ProcessAuthenticator.AUTH_LEVELS.ADMIN
    elseif normalizedType == ProcessAuthenticator.PROCESS_TYPES.SECURITY or
           normalizedType == ProcessAuthenticator.PROCESS_TYPES.COORDINATOR then
        return ProcessAuthenticator.AUTH_LEVELS.ELEVATED
    else
        return ProcessAuthenticator.AUTH_LEVELS.BASIC
    end
end

function ProcessAuthenticator._generateTokenId()
    local timestamp = msg.Timestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    return "token_" .. timestamp .. "_" .. randomSuffix
end

function ProcessAuthenticator._generateTokenSignature(processId, tokenId, timestamp)
    -- Generate signature using process ID, token ID, and timestamp
    local signatureBase = processId .. "|" .. tokenId .. "|" .. timestamp
    
    -- Use crypto module for signing (in real AO environment)
    -- For now, use a deterministic hash-like generation
    local signature = ""
    for i = 1, #signatureBase do
        local char = string.sub(signatureBase, i, i)
        signature = signature .. string.format("%02x", string.byte(char))
    end
    
    -- Add random suffix using CryptoRNG
    local randomSuffix = CryptoRNG.random(1000000, 9999999)
    return signature .. "_" .. randomSuffix
end

function ProcessAuthenticator._expireToken(tokenId)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if token then
        -- Decrease token count for the process
        local processRecord = ProcessAuthenticator.processRegistry[token.processId]
        if processRecord then
            processRecord.tokenCount = math.max(0, processRecord.tokenCount - 1)
        end
        
        -- Remove token from active tokens
        ProcessAuthenticator.activeTokens[tokenId] = nil
    end
end

function ProcessAuthenticator._isOperationAuthorized(capabilities, operation)
    if not capabilities or type(capabilities) ~= "table" then
        return false
    end
    
    -- Check if operation is in capabilities list
    for _, capability in ipairs(capabilities) do
        if capability == operation or capability == "*" then
            return true
        end
    end
    
    return false
end

function ProcessAuthenticator._getProcessTypeList()
    local types = {}
    for _, processType in pairs(ProcessAuthenticator.PROCESS_TYPES) do
        table.insert(types, processType:upper())
    end
    return types
end


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: game-logic.process-coordination.message-router =====
-- File: ao-processes/game-logic/process-coordination/message-router.lua
-- Original require: local MessageRouter = require("game-logic.process-coordination.message-router")

-- Message Routing Layer for Inter-Process Communication
-- Routes messages based on operation type and maintains routing tables

-- SHARED MODULE REFERENCE: game-logic.process-coordination.process-authenticator (already included)
-- SHARED MODULE REFERENCE: game-logic.process-coordination.message-correlator (already included)

local MessageRouter = {
    -- Routing table mapping operation types to process types
    operationRoutes = {},
    
    -- Process capability routing cache
    processCapabilities = {},
    
    -- Load balancing state for multiple processes of same type
    loadBalancingState = {},
    
    -- Routing statistics
    routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
}

-- Operation types for routing classification
MessageRouter.OPERATION_TYPES = {
    -- Battle operations
    BATTLE_RESOLUTION = "BATTLE_RESOLUTION",
    BATTLE_START = "BATTLE_START",
    BATTLE_END = "BATTLE_END",
    MOVE_EXECUTION = "MOVE_EXECUTION",
    
    -- Pokemon operations  
    POKEMON_UPDATE = "POKEMON_UPDATE",
    POKEMON_EVOLUTION = "POKEMON_EVOLUTION",
    STAT_CALCULATION = "STAT_CALCULATION",
    POKEMON_CAPTURE = "POKEMON_CAPTURE",
    
    -- Shop operations
    SHOP_TRANSACTION = "SHOP_TRANSACTION", 
    SHOP_INVENTORY = "SHOP_INVENTORY",
    ITEM_PURCHASE = "ITEM_PURCHASE",
    ITEM_SALE = "ITEM_SALE",
    
    -- Game state operations
    SAVE_GAME = "SAVE_GAME",
    LOAD_GAME = "LOAD_GAME",
    SYNC_STATE = "SYNC_STATE",
    
    -- Admin operations
    PROCESS_HEALTH = "PROCESS_HEALTH",
    SYSTEM_STATUS = "SYSTEM_STATUS",
    CONFIGURATION_UPDATE = "CONFIGURATION_UPDATE"
}

-- Default routing table
MessageRouter.DEFAULT_ROUTES = {
    -- Battle operations route to battle processes
    [MessageRouter.OPERATION_TYPES.BATTLE_RESOLUTION] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.BATTLE_START] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.BATTLE_END] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.MOVE_EXECUTION] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    
    -- Pokemon operations route to pokemon processes
    [MessageRouter.OPERATION_TYPES.POKEMON_UPDATE] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.POKEMON_EVOLUTION] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.STAT_CALCULATION] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.POKEMON_CAPTURE] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    
    -- Shop operations route to shop processes
    [MessageRouter.OPERATION_TYPES.SHOP_TRANSACTION] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.SHOP_INVENTORY] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.ITEM_PURCHASE] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.ITEM_SALE] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    
    -- Game state operations route to coordinator processes
    [MessageRouter.OPERATION_TYPES.SAVE_GAME] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    [MessageRouter.OPERATION_TYPES.LOAD_GAME] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    [MessageRouter.OPERATION_TYPES.SYNC_STATE] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    
    -- Admin operations route to admin processes
    [MessageRouter.OPERATION_TYPES.PROCESS_HEALTH] = ProcessAuthenticator.PROCESS_TYPES.ADMIN,
    [MessageRouter.OPERATION_TYPES.SYSTEM_STATUS] = ProcessAuthenticator.PROCESS_TYPES.ADMIN,
    [MessageRouter.OPERATION_TYPES.CONFIGURATION_UPDATE] = ProcessAuthenticator.PROCESS_TYPES.ADMIN
}

-- Routing strategies
MessageRouter.ROUTING_STRATEGIES = {
    ROUND_ROBIN = "round_robin",
    LEAST_LOADED = "least_loaded",
    CAPABILITY_MATCH = "capability_match",
    RANDOM = "random"
}

-- Initialize the message router
function MessageRouter.initialize()
    -- Copy default routes to active routing table
    MessageRouter.operationRoutes = {}
    for operation, processType in pairs(MessageRouter.DEFAULT_ROUTES) do
        MessageRouter.operationRoutes[operation] = processType
    end
    
    MessageRouter.processCapabilities = {}
    MessageRouter.loadBalancingState = {}
    MessageRouter.routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
    
    print("[MessageRouter] Message routing system initialized")
end

-- Add or update routing rule
function MessageRouter.addRoute(operationType, targetProcessType, priority)
    if not operationType or not targetProcessType then
        return false, "Operation type and target process type are required"
    end
    
    if not MessageRouter.OPERATION_TYPES[operationType] and not operationType then
        return false, "Invalid operation type: " .. tostring(operationType)
    end
    
    local validProcessTypes = ProcessAuthenticator._getProcessTypeList()
    local isValidProcessType = false
    for _, processType in ipairs(validProcessTypes) do
        if processType:lower() == targetProcessType:lower() then
            isValidProcessType = true
            break
        end
    end
    
    if not isValidProcessType then
        return false, "Invalid target process type: " .. tostring(targetProcessType)
    end
    
    MessageRouter.operationRoutes[operationType] = {
        processType = targetProcessType:lower(),
        priority = priority or "NORMAL",
        addedAt = timestamp or 0
    }
    
    return true
end

-- Remove routing rule
function MessageRouter.removeRoute(operationType)
    if not operationType then
        return false, "Operation type is required"
    end
    
    if MessageRouter.operationRoutes[operationType] then
        MessageRouter.operationRoutes[operationType] = nil
        return true
    end
    
    return false, "Route not found for operation: " .. tostring(operationType)
end

-- Route a message to appropriate process based on operation type
function MessageRouter.routeMessage(operationType, messageData, routingStrategy)
    MessageRouter.routingStats.totalRoutes = MessageRouter.routingStats.totalRoutes + 1
    MessageRouter.routingStats.routesByOperation[operationType] = (MessageRouter.routingStats.routesByOperation[operationType] or 0) + 1
    
    local strategy = routingStrategy or MessageRouter.ROUTING_STRATEGIES.CAPABILITY_MATCH
    
    -- Get target process type from routing table
    local routeInfo = MessageRouter.operationRoutes[operationType]
    if not routeInfo then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "No route found for operation: " .. tostring(operationType)
    end
    
    local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
    
    -- Get available processes for target type
    local availableProcesses = ProcessAuthenticator.listRegisteredProcesses(targetProcessType)
    if not availableProcesses or MessageRouter._getTableSize(availableProcesses) == 0 then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "No available processes of type: " .. targetProcessType
    end
    
    -- Select target process based on routing strategy
    local targetProcessId = MessageRouter._selectTargetProcess(availableProcesses, strategy, operationType)
    if not targetProcessId then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "Failed to select target process for operation: " .. operationType
    end
    
    -- Create routing context
    local routingContext = {
        operationType = operationType,
        targetProcessId = targetProcessId,
        targetProcessType = targetProcessType,
        routingStrategy = strategy,
        routedAt = timestamp or 0,
        messageData = messageData
    }
    
    MessageRouter.routingStats.successfulRoutes = MessageRouter.routingStats.successfulRoutes + 1
    MessageRouter.routingStats.routesByProcessType[targetProcessType] = (MessageRouter.routingStats.routesByProcessType[targetProcessType] or 0) + 1
    
    return routingContext
end

-- Get routing information for operation type
function MessageRouter.getRouteInfo(operationType)
    local routeInfo = MessageRouter.operationRoutes[operationType]
    if not routeInfo then
        return nil
    end
    
    local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
    local availableProcesses = ProcessAuthenticator.listRegisteredProcesses(targetProcessType)
    
    return {
        operationType = operationType,
        targetProcessType = targetProcessType,
        priority = type(routeInfo) == "table" and routeInfo.priority or "NORMAL",
        availableProcessCount = MessageRouter._getTableSize(availableProcesses),
        availableProcessIds = MessageRouter._getProcessIds(availableProcesses)
    }
end

-- Validate message routing capability
function MessageRouter.validateRouting(operationType, sourceProcessId, targetProcessId)
    -- Check if operation type has a valid route
    local routeInfo = MessageRouter.getRouteInfo(operationType)
    if not routeInfo then
        return false, "No route configured for operation: " .. tostring(operationType)
    end
    
    -- Check if target process exists and is active
    local targetProcess = ProcessAuthenticator.getProcessInfo(targetProcessId)
    if not targetProcess then
        return false, "Target process not found: " .. tostring(targetProcessId)
    end
    
    if targetProcess.status ~= "active" then
        return false, "Target process is not active: " .. targetProcessId
    end
    
    -- Check if target process type matches route
    if targetProcess.type ~= routeInfo.targetProcessType then
        return false, string.format("Process type mismatch. Expected: %s, Got: %s", 
                                   routeInfo.targetProcessType, targetProcess.type)
    end
    
    -- Check if target process has required capability
    if not MessageRouter._processHasCapability(targetProcess.capabilities, operationType) then
        return false, "Target process lacks required capability for operation: " .. operationType
    end
    
    return true
end

-- Update process capabilities cache
function MessageRouter.updateProcessCapabilities(processId, capabilities)
    if not processId or not capabilities then
        return false
    end
    
    MessageRouter.processCapabilities[processId] = {
        capabilities = capabilities,
        lastUpdated = timestamp or 0
    }
    
    return true
end

-- Get all configured routes
function MessageRouter.getAllRoutes()
    local routes = {}
    
    for operationType, routeInfo in pairs(MessageRouter.operationRoutes) do
        local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
        local priority = type(routeInfo) == "table" and routeInfo.priority or "NORMAL"
        
        routes[operationType] = {
            targetProcessType = targetProcessType,
            priority = priority,
            availableProcesses = MessageRouter._getTableSize(ProcessAuthenticator.listRegisteredProcesses(targetProcessType))
        }
    end
    
    return routes
end

-- Get routing statistics
function MessageRouter.getRoutingStatistics()
    return {
        totalRoutes = MessageRouter.routingStats.totalRoutes,
        successfulRoutes = MessageRouter.routingStats.successfulRoutes,
        failedRoutes = MessageRouter.routingStats.failedRoutes,
        successRate = MessageRouter.routingStats.totalRoutes > 0 and 
                     (MessageRouter.routingStats.successfulRoutes / MessageRouter.routingStats.totalRoutes) or 0,
        routesByOperation = MessageRouter.routingStats.routesByOperation,
        routesByProcessType = MessageRouter.routingStats.routesByProcessType,
        configuredRoutes = MessageRouter._getTableSize(MessageRouter.operationRoutes)
    }
end

-- Reset routing statistics
function MessageRouter.resetStatistics()
    MessageRouter.routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
end

-- Private helper functions

function MessageRouter._selectTargetProcess(availableProcesses, strategy, operationType)
    if MessageRouter._getTableSize(availableProcesses) == 0 then
        return nil
    end
    
    local processIds = MessageRouter._getProcessIds(availableProcesses)
    
    if strategy == MessageRouter.ROUTING_STRATEGIES.ROUND_ROBIN then
        return MessageRouter._roundRobinSelection(processIds, operationType)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.CAPABILITY_MATCH then
        return MessageRouter._capabilityMatchSelection(availableProcesses, operationType)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.RANDOM then
        return MessageRouter._randomSelection(processIds)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.LEAST_LOADED then
        -- For now, fallback to round robin (load tracking would be implemented later)
        return MessageRouter._roundRobinSelection(processIds, operationType)
        
    else
        -- Default to first available process
        return processIds[1]
    end
end

function MessageRouter._roundRobinSelection(processIds, operationType)
    if not MessageRouter.loadBalancingState[operationType] then
        MessageRouter.loadBalancingState[operationType] = 0
    end
    
    local index = (MessageRouter.loadBalancingState[operationType] % #processIds) + 1
    MessageRouter.loadBalancingState[operationType] = MessageRouter.loadBalancingState[operationType] + 1
    
    return processIds[index]
end

function MessageRouter._capabilityMatchSelection(availableProcesses, operationType)
    -- Select process with best capability match
    for processId, processInfo in pairs(availableProcesses) do
        if MessageRouter._processHasCapability(processInfo.capabilities, operationType) then
            return processId
        end
    end
    
    -- Fallback to first available if no perfect match
    local processIds = MessageRouter._getProcessIds(availableProcesses)
    return processIds[1]
end

function MessageRouter._randomSelection(processIds)
    local randomIndex = math.random(1, #processIds)
    return processIds[randomIndex]
end

function MessageRouter._processHasCapability(capabilities, operationType)
    if not capabilities or type(capabilities) ~= "table" then
        return false
    end
    
    for _, capability in ipairs(capabilities) do
        if capability == "*" or capability == operationType or 
           MessageRouter._isRelatedCapability(capability, operationType) then
            return true
        end
    end
    
    return false
end

function MessageRouter._isRelatedCapability(capability, operationType)
    -- Check if capability covers the operation type
    local capabilityMappings = {
        ["battle-resolution"] = {"BATTLE_RESOLUTION", "BATTLE_START", "BATTLE_END", "MOVE_EXECUTION"},
        ["pokemon-management"] = {"POKEMON_UPDATE", "POKEMON_EVOLUTION", "STAT_CALCULATION", "POKEMON_CAPTURE"},
        ["shop-operations"] = {"SHOP_TRANSACTION", "SHOP_INVENTORY", "ITEM_PURCHASE", "ITEM_SALE"},
        ["game-state"] = {"SAVE_GAME", "LOAD_GAME", "SYNC_STATE"},
        ["admin-operations"] = {"PROCESS_HEALTH", "SYSTEM_STATUS", "CONFIGURATION_UPDATE"}
    }
    
    local relatedOperations = capabilityMappings[capability]
    if relatedOperations then
        for _, operation in ipairs(relatedOperations) do
            if operation == operationType then
                return true
            end
        end
    end
    
    return false
end

function MessageRouter._getProcessIds(processes)
    local ids = {}
    for processId, _ in pairs(processes) do
        table.insert(ids, processId)
    end
    return ids
end

function MessageRouter._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: game-logic.process-coordination.message-router =====


-- Load battle-specific handlers

-- ===== MODULE: battle.handlers.battle-command-handler =====
-- File: ao-processes/battle/handlers/battle-command-handler.lua
-- Original require: local BattleCommandHandler = require("battle.handlers.battle-command-handler")

-- Battle Command Handler
-- Processes battle command requests from coordinator and other processes
-- Integrates with turn processor and damage calculator for battle execution
-- Epic 32.3: Battle Engine Process Extraction

local BattleCommandHandler = {}

-- Load dependencies

-- ===== MODULE: battle.components.concurrent-battle-manager =====
-- File: ao-processes/battle/components/concurrent-battle-manager.lua
-- Original require: local ConcurrentBattleManager = require("battle.components.concurrent-battle-manager")

-- Concurrent Battle Manager
-- Manages multiple battle instances with load balancing and resource management
-- Enables parallel battle processing for improved performance
-- Epic 32.3: Battle Engine Process Extraction

local ConcurrentBattleManager = {}

-- Load dependencies

-- ===== MODULE: battle.components.battle-state-manager =====
-- File: ao-processes/battle/components/battle-state-manager.lua
-- Original require: local BattleStateManager = require("battle.components.battle-state-manager")

-- Battle Process State Manager
-- Extracted and adapted for dedicated battle process with inter-process coordination
-- Manages battle state synchronization, persistence, and coordination with other processes
-- Epic 32.3: Battle Engine Process Extraction

local BattleStateManager = {}

-- Load inter-process communication components
-- SHARED MODULE REFERENCE: game-logic.process-coordination.message-correlator (already included)
-- SHARED MODULE REFERENCE: game-logic.process-coordination.process-authenticator (already included)
-- SHARED MODULE REFERENCE: game-logic.process-coordination.message-router (already included)

-- Load battle dependencies

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")

-- Battle-specific deterministic RNG system
-- Ensures reproducible battle outcomes using battle seeds

-- SHARED MODULE REFERENCE: game-logic.rng.crypto-rng (already included)

local BattleRNG = {}

-- Initialize battle with deterministic seed
function BattleRNG.initBattle(battleId, seed)
    if not battleId or not seed then
        error("Battle RNG requires both battleId and seed")
    end
    
    -- Combine battle ID and seed for unique determinism
    local battleSeed = battleId .. ":" .. seed
    CryptoRNG.initBattleRNG(battleSeed)
end

-- Get damage roll for moves (critical for parity)
function BattleRNG.damageRoll(minDamage, maxDamage)
    if not minDamage or not maxDamage then
        error("Damage roll requires min and max damage")
    end
    return CryptoRNG.battleRandomInt(minDamage, maxDamage)
end

-- Critical hit determination
function BattleRNG.criticalHit(critRate)
    critRate = critRate or 1
    local roll = CryptoRNG.battleRandomInt(1, 24)  -- Standard crit mechanics
    return roll <= critRate
end

-- Accuracy check for moves
function BattleRNG.accuracyCheck(accuracy)
    accuracy = accuracy or 100
    local roll = CryptoRNG.battleRandomInt(1, 100)
    return roll <= accuracy
end

-- Status condition chance
function BattleRNG.statusChance(chance)
    if not chance or chance <= 0 then
        return false
    end
    local roll = CryptoRNG.battleRandomInt(1, 100)
    return roll <= chance
end

-- Speed tie resolution
function BattleRNG.speedTie()
    return CryptoRNG.battleRandomInt(1, 2) == 1
end

-- Multi-hit move determination
function BattleRNG.multiHitCount(minHits, maxHits)
    minHits = minHits or 2
    maxHits = maxHits or 5
    return CryptoRNG.battleRandomInt(minHits, maxHits)
end

-- Confusion damage chance
function BattleRNG.confusionDamage()
    return CryptoRNG.battleRandomInt(1, 3) == 1  -- 33% chance
end

-- Sleep duration (1-3 turns)
function BattleRNG.sleepDuration()
    return CryptoRNG.battleRandomInt(1, 3)
end

-- Flinch chance
function BattleRNG.flinchChance(chance)
    chance = chance or 30  -- Default 30% for moves like Bite
    local roll = CryptoRNG.battleRandomInt(1, 100)
    return roll <= chance
end

-- Type effectiveness variation (for moves that have random type)
function BattleRNG.randomType(typeList)
    if not typeList or #typeList == 0 then
        error("Random type requires type list")
    end
    local index = CryptoRNG.battleRandomInt(1, #typeList)
    return typeList[index]
end

-- Weather duration
function BattleRNG.weatherDuration(baseDuration)
    baseDuration = baseDuration or 5
    -- Some weather effects can vary 1 turn
    local variance = CryptoRNG.battleRandomInt(-1, 1)
    return math.max(1, baseDuration + variance)
end

-- Healing amount variation (for moves like Rest)
function BattleRNG.healingAmount(baseHealing, pokemon)
    -- Most healing is fixed, but some moves have variation
    return baseHealing
end

-- Item drop chance (for abilities like Pickup)
function BattleRNG.itemDrop(chance)
    chance = chance or 10  -- Default 10%
    local roll = CryptoRNG.battleRandomInt(1, 100)
    return roll <= chance
end

-- Reset battle RNG (called between battles)
function BattleRNG.reset()
    CryptoRNG.resetBattleRNG()
end

-- Get current state for debugging
function BattleRNG.getState()
    return CryptoRNG.getBattleState()
end

-- Generic random integer (for complex probability distributions)
function BattleRNG.randomInt(min, max)
    return CryptoRNG.battleRandomInt(min or 1, max or 100)
end

-- Generic random float (0-1)
function BattleRNG.randomFloat()
    return CryptoRNG.battleRandom()
end

-- Seed battle for testing
function BattleRNG.seed(testSeed)
    CryptoRNG.initBattleRNG(testSeed or "test-battle-seed")
end


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- ===== MODULE: data.constants.enums =====
-- File: ao-processes/data/constants/enums.lua
-- Original require: local Enums = require("data.constants.enums")

-- Game Enums and Constants
-- Complete enum definitions matching TypeScript reference implementation
-- Provides centralized constants for species, types, abilities, and game mechanics

local Enums = {}

-- Pokemon Type Enumeration (matching TypeScript PokemonType enum)
Enums.PokemonType = {
    UNKNOWN = -1,
    NORMAL = 0,
    FIGHTING = 1,
    FLYING = 2,
    POISON = 3,
    GROUND = 4,
    ROCK = 5,
    BUG = 6,
    GHOST = 7,
    STEEL = 8,
    FIRE = 9,
    WATER = 10,
    GRASS = 11,
    ELECTRIC = 12,
    PSYCHIC = 13,
    ICE = 14,
    DRAGON = 15,
    DARK = 16,
    FAIRY = 17,
    STELLAR = 18
}

-- Reverse lookup for type numbers to names
Enums.PokemonTypeName = {}
for typeName, typeNum in pairs(Enums.PokemonType) do
    Enums.PokemonTypeName[typeNum] = typeName
end

-- Species ID Enumeration (matching TypeScript SpeciesId enum)
-- Starting with Generation 1 Pokemon, expandable to full 800+ species
Enums.SpeciesId = {
    -- Generation 1
    BULBASAUR = 1,
    IVYSAUR = 2,
    VENUSAUR = 3,
    CHARMANDER = 4,
    CHARMELEON = 5,
    CHARIZARD = 6,
    SQUIRTLE = 7,
    WARTORTLE = 8,
    BLASTOISE = 9,
    CATERPIE = 10,
    METAPOD = 11,
    BUTTERFREE = 12,
    WEEDLE = 13,
    KAKUNA = 14,
    BEEDRILL = 15,
    PIDGEY = 16,
    PIDGEOTTO = 17,
    PIDGEOT = 18,
    RATTATA = 19,
    RATICATE = 20,
    SPEAROW = 21,
    FEAROW = 22,
    EKANS = 23,
    ARBOK = 24,
    PIKACHU = 25,
    RAICHU = 26,
    SANDSHREW = 27,
    SANDSLASH = 28,
    NIDORAN_F = 29,
    NIDORINA = 30,
    NIDOQUEEN = 31,
    NIDORAN_M = 32,
    NIDORINO = 33,
    NIDOKING = 34,
    CLEFAIRY = 35,
    CLEFABLE = 36,
    VULPIX = 37,
    NINETALES = 38,
    JIGGLYPUFF = 39,
    WIGGLYTUFF = 40,
    ZUBAT = 41,
    GOLBAT = 42,
    ODDISH = 43,
    GLOOM = 44,
    VILEPLUME = 45,
    PARAS = 46,
    PARASECT = 47,
    VENONAT = 48,
    VENOMOTH = 49,
    DIGLETT = 50,
    DUGTRIO = 51,
    MEOWTH = 52,
    PERSIAN = 53,
    PSYDUCK = 54,
    GOLDUCK = 55,
    MANKEY = 56,
    PRIMEAPE = 57,
    GROWLITHE = 58,
    ARCANINE = 59,
    POLIWAG = 60,
    POLIWHIRL = 61,
    POLIWRATH = 62,
    ABRA = 63,
    KADABRA = 64,
    ALAKAZAM = 65,
    MACHOP = 66,
    MACHOKE = 67,
    MACHAMP = 68,
    BELLSPROUT = 69,
    WEEPINBELL = 70,
    VICTREEBEL = 71,
    TENTACOOL = 72,
    TENTACRUEL = 73,
    GEODUDE = 74,
    GRAVELER = 75,
    GOLEM = 76,
    PONYTA = 77,
    RAPIDASH = 78,
    SLOWPOKE = 79,
    SLOWBRO = 80,
    MAGNEMITE = 81,
    MAGNETON = 82,
    FARFETCHD = 83,
    DODUO = 84,
    DODRIO = 85,
    SEEL = 86,
    DEWGONG = 87,
    GRIMER = 88,
    MUK = 89,
    SHELLDER = 90,
    CLOYSTER = 91,
    GASTLY = 92,
    HAUNTER = 93,
    GENGAR = 94,
    ONIX = 95,
    DROWZEE = 96,
    HYPNO = 97,
    KRABBY = 98,
    KINGLER = 99,
    VOLTORB = 100,
    ELECTRODE = 101,
    EXEGGCUTE = 102,
    EXEGGUTOR = 103,
    CUBONE = 104,
    MAROWAK = 105,
    HITMONLEE = 106,
    HITMONCHAN = 107,
    LICKITUNG = 108,
    KOFFING = 109,
    WEEZING = 110,
    RHYHORN = 111,
    RHYDON = 112,
    CHANSEY = 113,
    TANGELA = 114,
    KANGASKHAN = 115,
    HORSEA = 116,
    SEADRA = 117,
    GOLDEEN = 118,
    SEAKING = 119,
    STARYU = 120,
    STARMIE = 121,
    MR_MIME = 122,
    SCYTHER = 123,
    JYNX = 124,
    ELECTABUZZ = 125,
    MAGMAR = 126,
    PINSIR = 127,
    TAUROS = 128,
    MAGIKARP = 129,
    GYARADOS = 130,
    LAPRAS = 131,
    DITTO = 132,
    EEVEE = 133,
    VAPOREON = 134,
    JOLTEON = 135,
    FLAREON = 136,
    PORYGON = 137,
    OMANYTE = 138,
    OMASTAR = 139,
    KABUTO = 140,
    KABUTOPS = 141,
    AERODACTYL = 142,
    SNORLAX = 143,
    ARTICUNO = 144,
    ZAPDOS = 145,
    MOLTRES = 146,
    DRATINI = 147,
    DRAGONAIR = 148,
    DRAGONITE = 149,
    MEWTWO = 150,
    MEW = 151,
    
    -- Note: Additional generations and regional variants would continue here
    -- Regional variants typically use ranges:
    -- Alolan variants: 2000+
    -- Galarian variants: 4000+
    -- Hisuian variants: 6000+
    -- Paldean variants: 8000+
}

-- Reverse lookup for species IDs to names
Enums.SpeciesName = {}
for speciesName, speciesId in pairs(Enums.SpeciesId) do
    Enums.SpeciesName[speciesId] = speciesName
end

-- Base Stat Enumeration (matching TypeScript Stat enum)
Enums.Stat = {
    HP = 0,
    ATK = 1,
    DEF = 2,
    SPATK = 3,
    SPDEF = 4,
    SPD = 5,
    SPEED = 5,  -- Alias for SPD for compatibility
    ACC = 6,    -- Battle-only stat (accuracy)
    EVA = 7     -- Battle-only stat (evasion)
}

-- Permanent stats used in base stat calculations (excludes ACC/EVA)
Enums.PERMANENT_STATS = {
    Enums.Stat.HP,
    Enums.Stat.ATK,
    Enums.Stat.DEF,
    Enums.Stat.SPATK,
    Enums.Stat.SPDEF,
    Enums.Stat.SPD
}

-- Growth Rate Enumeration (matching TypeScript GrowthRate enum)
Enums.GrowthRate = {
    ERRATIC = 0,
    FAST = 1,
    MEDIUM_FAST = 2,
    MEDIUM_SLOW = 3,
    SLOW = 4,
    FLUCTUATING = 5
}

-- Ability ID Enumeration (partial list for foundational structure)
-- Full implementation would include all 200+ abilities
Enums.AbilityId = {
    NONE = 0,
    STENCH = 1,
    DRIZZLE = 2,
    SPEED_BOOST = 3,
    BATTLE_ARMOR = 4,
    STURDY = 5,
    DAMP = 6,
    LIMBER = 7,
    SAND_VEIL = 8,
    STATIC = 9,
    VOLT_ABSORB = 10,
    WATER_ABSORB = 11,
    OBLIVIOUS = 12,
    CLOUD_NINE = 13,
    COMPOUND_EYES = 14,
    INSOMNIA = 15,
    COLOR_CHANGE = 16,
    IMMUNITY = 17,
    FLASH_FIRE = 18,
    SHIELD_DUST = 19,
    OWN_TEMPO = 20,
    SUCTION_CUPS = 21,
    INTIMIDATE = 22,
    SHADOW_TAG = 23,
    ROUGH_SKIN = 24,
    WONDER_GUARD = 25,
    LEVITATE = 26,
    EFFECT_SPORE = 27,
    SYNCHRONIZE = 28,
    CLEAR_BODY = 29,
    NATURAL_CURE = 30,
    LIGHTNING_ROD = 31,
    SERENE_GRACE = 32,
    SWIFT_SWIM = 33,
    CHLOROPHYLL = 34,
    ILLUMINATE = 35,
    TRACE = 36,
    HUGE_POWER = 37,
    POISON_POINT = 38,
    INNER_FOCUS = 39,
    MAGMA_ARMOR = 40,
    WATER_VEIL = 41,
    MAGNET_PULL = 42,
    SOUNDPROOF = 43,
    RAIN_DISH = 44,
    SAND_STREAM = 45,
    PRESSURE = 46,
    THICK_FAT = 47,
    EARLY_BIRD = 48,
    FLAME_BODY = 49,
    RUN_AWAY = 50,
    KEEN_EYE = 51,
    HYPER_CUTTER = 52,
    PICKUP = 53,
    TRUANT = 54,
    HUSTLE = 55,
    CUTE_CHARM = 56,
    PLUS = 57,
    MINUS = 58,
    FORECAST = 59,
    STICKY_HOLD = 60,
    SHED_SKIN = 61,
    GUTS = 62,
    MARVEL_SCALE = 63,
    LIQUID_OOZE = 64,
    OVERGROW = 65,
    BLAZE = 66,
    TORRENT = 67,
    SWARM = 68,
    ROCK_HEAD = 69,
    DROUGHT = 70,
    ARENA_TRAP = 71,
    VITAL_SPIRIT = 72,
    WHITE_SMOKE = 73,
    PURE_POWER = 74,
    SHELL_ARMOR = 75,
    AIR_LOCK = 76,
    SOLAR_POWER = 77,
    SIMPLE = 78,
    CONTRARY = 79,
    ICE_BODY = 80,
    SAND_RUSH = 81,
    SNOW_CLOAK = 82,
    OVERCOAT = 83,
    SNOW_WARNING = 84,
    DRY_SKIN = 85, -- Weather healing/damage ability
    
    -- Terrain-related abilities (adding to support terrain system)
    ELECTRIC_SURGE = 226, -- Sets Electric Terrain on switch-in
    GRASSY_SURGE = 229, -- Sets Grassy Terrain on switch-in
    MISTY_SURGE = 228, -- Sets Misty Terrain on switch-in
    PSYCHIC_SURGE = 227, -- Sets Psychic Terrain on switch-in
    SURGE_SURFER = 207, -- Speed doubles in Electric Terrain
    GRASS_PELT = 179 -- Defense is raised in Grassy Terrain

    -- Note: Full ability list would continue with all abilities through modern generations
}

-- Move Category Enumeration (for move system integration)
Enums.MoveCategory = {
    PHYSICAL = 0,
    SPECIAL = 1,
    STATUS = 2
}

-- Move Target Enumeration (matching TypeScript MoveTarget enum)
Enums.MoveTarget = {
    USER = 0,
    OTHER = 1,
    ALL_OTHERS = 2,
    NEAR_OTHER = 3,
    ALL_NEAR_OTHERS = 4,
    NEAR_ENEMY = 5,
    ALL_NEAR_ENEMIES = 6,
    RANDOM_NEAR_ENEMY = 7,
    ALL_ENEMIES = 8,
    ATTACKER = 9,
    NEAR_ALLY = 10,
    ALLY = 11,
    USER_OR_NEAR_ALLY = 12,
    USER_AND_ALLIES = 13,
    ALL = 14,
    USER_SIDE = 15,
    ENEMY_SIDE = 16,
    BOTH_SIDES = 17,
    PARTY = 18,
    CURSE = 19
}

-- Move Flags Enumeration (matching TypeScript MoveFlags enum)
-- Represented as bitmask values for flag combinations
Enums.MoveFlags = {
    NONE = 0,
    MAKES_CONTACT = 1, -- 1 << 0
    IGNORE_PROTECT = 2, -- 1 << 1
    SOUND_BASED = 4, -- 1 << 2
    HIDE_USER = 8, -- 1 << 3
    HIDE_TARGET = 16, -- 1 << 4
    BITING_MOVE = 32, -- 1 << 5
    PULSE_MOVE = 64, -- 1 << 6
    PUNCHING_MOVE = 128, -- 1 << 7
    SLICING_MOVE = 256, -- 1 << 8
    RECKLESS_MOVE = 512, -- 1 << 9
    BALLBOMB_MOVE = 1024, -- 1 << 10
    POWDER_MOVE = 2048, -- 1 << 11
    DANCE_MOVE = 4096, -- 1 << 12
    WIND_MOVE = 8192, -- 1 << 13
    TRIAGE_MOVE = 16384, -- 1 << 14
    IGNORE_ABILITIES = 32768, -- 1 << 15
    CHECK_ALL_HITS = 65536, -- 1 << 16
    IGNORE_SUBSTITUTE = 131072, -- 1 << 17
    REDIRECT_COUNTER = 262144, -- 1 << 18
    REFLECTABLE = 524288 -- 1 << 19
}

-- Move ID Enumeration (starting with foundational moves)
-- Full implementation would include all 957 moves from TypeScript MoveId enum
Enums.MoveId = {
    NONE = 0,
    POUND = 1,
    KARATE_CHOP = 2,
    DOUBLE_SLAP = 3,
    COMET_PUNCH = 4,
    MEGA_PUNCH = 5,
    PAY_DAY = 6,
    FIRE_PUNCH = 7,
    ICE_PUNCH = 8,
    THUNDER_PUNCH = 9,
    SCRATCH = 10,
    VISE_GRIP = 11,
    GUILLOTINE = 12,
    RAZOR_WIND = 13,
    SWORDS_DANCE = 14,
    CUT = 15,
    GUST = 16,
    WING_ATTACK = 17,
    WHIRLWIND = 18,
    FLY = 19,
    BIND = 20,
    SLAM = 21,
    VINE_WHIP = 22,
    STOMP = 23,
    DOUBLE_KICK = 24,
    MEGA_KICK = 25,
    JUMP_KICK = 26,
    ROLLING_KICK = 27,
    SAND_ATTACK = 28,
    HEADBUTT = 29,
    HORN_ATTACK = 30,
    FURY_ATTACK = 31,
    HORN_DRILL = 32,
    TACKLE = 33,
    BODY_SLAM = 34,
    WRAP = 35,
    TAKE_DOWN = 36,
    THRASH = 37,
    DOUBLE_EDGE = 38,
    TAIL_WHIP = 39,
    POISON_STING = 40,
    TWINEEDLE = 41,
    PIN_MISSILE = 42,
    LEER = 43,
    BITE = 44,
    GROWL = 45,
    ROAR = 46,
    SING = 47,
    SUPERSONIC = 48,
    SONIC_BOOM = 49,
    DISABLE = 50,
    ACID = 51,
    EMBER = 52,
    FLAMETHROWER = 53,
    MIST = 54,
    WATER_GUN = 55,
    HYDRO_PUMP = 56,
    SURF = 57,
    ICE_BEAM = 58,
    BLIZZARD = 59,
    PSYBEAM = 60,
    BUBBLE_BEAM = 61,
    AURORA_BEAM = 62,
    HYPER_BEAM = 63,
    PECK = 64,
    DRILL_PECK = 65,
    SUBMISSION = 66,
    LOW_KICK = 67,
    COUNTER = 68,
    SEISMIC_TOSS = 69,
    STRENGTH = 70,
    ABSORB = 71,
    MEGA_DRAIN = 72,
    LEECH_SEED = 73,
    GROWTH = 74,
    RAZOR_LEAF = 75,
    SOLAR_BEAM = 76,
    POISON_POWDER = 77,
    STUN_SPORE = 78,
    SLEEP_POWDER = 79,
    PETAL_DANCE = 80,
    STRING_SHOT = 81,
    DRAGON_RAGE = 82,
    FIRE_SPIN = 83,
    THUNDER_SHOCK = 84,
    THUNDERBOLT = 85,
    THUNDER_WAVE = 86,
    THUNDER = 87,
    ROCK_THROW = 88,
    EARTHQUAKE = 89,
    FISSURE = 90,
    DIG = 91,
    TOXIC = 92,
    CONFUSION = 93,
    PSYCHIC = 94,
    HYPNOSIS = 95,
    MEDITATE = 96,
    AGILITY = 97,
    QUICK_ATTACK = 98,
    RAGE = 99,
    TELEPORT = 100,
    NIGHT_SHADE = 101,
    MIMIC = 102,
    SCREECH = 103,
    DOUBLE_TEAM = 104,
    RECOVER = 105,
    HARDEN = 106,
    MINIMIZE = 107,
    SMOKESCREEN = 108,
    CONFUSE_RAY = 109,
    WITHDRAW = 110,
    DEFENSE_CURL = 111,
    BARRIER = 112,
    LIGHT_SCREEN = 113,
    HAZE = 114,
    REFLECT = 115,
    FOCUS_ENERGY = 116,
    BIDE = 117,
    METRONOME = 118,
    MIRROR_MOVE = 119,
    SELF_DESTRUCT = 120,
    EGG_BOMB = 121,
    LICK = 122,
    SMOG = 123,
    SLUDGE = 124,
    BONE_CLUB = 125,
    FIRE_BLAST = 126,
    WATERFALL = 127,
    CLAMP = 128,
    SWIFT = 129,
    SKULL_BASH = 130,
    SPIKE_CANNON = 131,
    CONSTRICT = 132,
    AMNESIA = 133,
    KINESIS = 134,
    SOFT_BOILED = 135,
    HIGH_JUMP_KICK = 136,
    GLARE = 137,
    DREAM_EATER = 138,
    POISON_GAS = 139,
    BARRAGE = 140,
    LEECH_LIFE = 141,
    LOVELY_KISS = 142,
    SKY_ATTACK = 143,
    TRANSFORM = 144,
    BUBBLE = 145,
    DIZZY_PUNCH = 146,
    SPORE = 147,
    FLASH = 148,
    PSYWAVE = 149,
    SPLASH = 150,
    ACID_ARMOR = 151,
    CRABHAMMER = 152,
    EXPLOSION = 153,
    FURY_SWIPES = 154,
    BONEMERANG = 155,
    REST = 156,
    ROCK_SLIDE = 157,
    HYPER_FANG = 158,
    SHARPEN = 159,
    CONVERSION = 160,
    TRI_ATTACK = 161,
    SUPER_FANG = 162,
    SLASH = 163,
    SUBSTITUTE = 164,
    STRUGGLE = 165,
    SKETCH = 166,
    TRIPLE_KICK = 167,
    THIEF = 168,
    SPIDER_WEB = 169,
    MIND_READER = 170,
    NIGHTMARE = 171,
    FLAME_WHEEL = 172,
    SNORE = 173,
    CURSE = 174,
    FLAIL = 175,
    CONVERSION_2 = 176,
    AEROBLAST = 177,
    COTTON_SPORE = 178,
    REVERSAL = 179,
    SPITE = 180,
    POWDER_SNOW = 181,
    PROTECT = 182,
    MACH_PUNCH = 183,
    SCARY_FACE = 184,
    FEINT_ATTACK = 185,
    SWEET_KISS = 186,
    BELLY_DRUM = 187,
    SLUDGE_BOMB = 188,
    MUD_SLAP = 189,
    OCTAZOOKA = 190,
    SPIKES = 191,
    ZAP_CANNON = 192,
    FORESIGHT = 193,
    DESTINY_BOND = 194,
    PERISH_SONG = 195,
    ICY_WIND = 196,
    DETECT = 197,
    BONE_RUSH = 198,
    LOCK_ON = 199,
    OUTRAGE = 200,
    -- Additional moves needed for move effects
    DIVE = 291,
    BOUNCE = 340,
    SHADOW_FORCE = 467,
    FREEZE_SHOCK = 553,
    SLEEP_TALK = 214,
    MIRROR_COAT = 243,
    ENDURE = 203,
    FOLLOW_ME = 266,
    HELPING_HAND = 270,
    CHATTER = 448,
    FOCUS_PUNCH = 264,
    UPROAR = 253,
    ASSIST = 274,
    -- Note: Full implementation would include all moves up to ~957
    -- This foundation provides structure for complete move system integration
}

-- Nature Enumeration (for stat calculations)
Enums.Nature = {
    HARDY = 0,
    LONELY = 1,
    BRAVE = 2,
    ADAMANT = 3,
    NAUGHTY = 4,
    BOLD = 5,
    DOCILE = 6,
    RELAXED = 7,
    IMPISH = 8,
    LAX = 9,
    TIMID = 10,
    HASTY = 11,
    SERIOUS = 12,
    JOLLY = 13,
    NAIVE = 14,
    MODEST = 15,
    MILD = 16,
    QUIET = 17,
    BASHFUL = 18,
    RASH = 19,
    CALM = 20,
    GENTLE = 21,
    SASSY = 22,
    CAREFUL = 23,
    QUIRKY = 24
}

-- Utility functions for enum operations

-- Get type name from type ID
-- @param typeId: Type ID number
-- @return: Type name string or "UNKNOWN"
function Enums.getTypeName(typeId)
    return Enums.PokemonTypeName[typeId] or "UNKNOWN"
end

-- Get type ID from type name
-- @param typeName: Type name string
-- @return: Type ID number or -1 for unknown
function Enums.getTypeId(typeName)
    return Enums.PokemonType[string.upper(typeName)] or Enums.PokemonType.UNKNOWN
end

-- Get species name from species ID
-- @param speciesId: Species ID number
-- @return: Species name string or "UNKNOWN"
function Enums.getSpeciesName(speciesId)
    return Enums.SpeciesName[speciesId] or "UNKNOWN"
end

-- Get species ID from species name
-- @param speciesName: Species name string
-- @return: Species ID number or nil if not found
function Enums.getSpeciesId(speciesName)
    return Enums.SpeciesId[string.upper(speciesName)]
end

-- Check if a type is valid
-- @param typeId: Type ID to validate
-- @return: Boolean indicating if type exists
function Enums.isValidType(typeId)
    return Enums.PokemonTypeName[typeId] ~= nil
end

-- Check if a species is valid
-- @param speciesId: Species ID to validate
-- @return: Boolean indicating if species exists
function Enums.isValidSpecies(speciesId)
    return Enums.SpeciesName[speciesId] ~= nil
end

-- Get weather type name from weather ID
-- @param weatherId: Weather ID number
-- @return: Weather type name string or "UNKNOWN"
function Enums.getWeatherTypeName(weatherId)
    return Enums.WeatherTypeName[weatherId] or "UNKNOWN"
end

-- Get weather type ID from weather name
-- @param weatherName: Weather type name string
-- @return: Weather type ID number or nil if not found
function Enums.getWeatherTypeId(weatherName)
    return Enums.WeatherType[string.upper(weatherName)]
end

-- Check if a weather type is valid
-- @param weatherId: Weather type ID to validate
-- @return: Boolean indicating if weather type exists
function Enums.isValidWeatherType(weatherId)
    return Enums.WeatherTypeName[weatherId] ~= nil
end

-- Get all valid type IDs
-- @return: Array of all valid type IDs
function Enums.getAllTypeIds()
    local types = {}
    for _, typeId in pairs(Enums.PokemonType) do
        if typeId >= 0 then -- Exclude UNKNOWN (-1)
            table.insert(types, typeId)
        end
    end
    table.sort(types)
    return types
end

-- Get all valid species IDs
-- @return: Array of all valid species IDs
function Enums.getAllSpeciesIds()
    local species = {}
    for _, speciesId in pairs(Enums.SpeciesId) do
        table.insert(species, speciesId)
    end
    table.sort(species)
    return species
end

-- Get all valid weather type IDs
-- @return: Array of all valid weather type IDs
function Enums.getAllWeatherTypeIds()
    local weatherTypes = {}
    for _, weatherId in pairs(Enums.WeatherType) do
        table.insert(weatherTypes, weatherId)
    end
    table.sort(weatherTypes)
    return weatherTypes
end

-- Weather Type Enumeration (for weather system)
Enums.WeatherType = {
    NONE = 0,
    SUNNY = 1,
    RAIN = 2,
    SANDSTORM = 3,
    HAIL = 4,
    FOG = 5,
    HEAVY_RAIN = 6,
    HARSH_SUN = 7,
    STRONG_WINDS = 8
}

-- Weather Type Name Lookup
Enums.WeatherTypeName = {}
for weatherName, weatherId in pairs(Enums.WeatherType) do
    Enums.WeatherTypeName[weatherId] = weatherName
end

-- Gender enumeration for Pokemon
Enums.Gender = {
    GENDERLESS = 0,
    MALE = 1,
    FEMALE = 2,
    UNKNOWN = -1
}

-- Move-related utility functions

-- Get move target name from target ID
-- @param targetId: Target ID number
-- @return: Target name string or "UNKNOWN"
function Enums.getMoveTargetName(targetId)
    for targetName, id in pairs(Enums.MoveTarget) do
        if id == targetId then
            return targetName
        end
    end
    return "UNKNOWN"
end

-- Get move category name from category ID
-- @param categoryId: Category ID number (0=Physical, 1=Special, 2=Status)
-- @return: Category name string or "UNKNOWN"
function Enums.getMoveCategoryName(categoryId)
    for categoryName, id in pairs(Enums.MoveCategory) do
        if id == categoryId then
            return categoryName
        end
    end
    return "UNKNOWN"
end

-- Check if a move flag is set in a flags bitmask
-- @param flags: Bitmask of move flags
-- @param flag: Flag to check for
-- @return: Boolean indicating if flag is set
function Enums.hasMoveFlag(flags, flag)
    return (flags & flag) == flag
end

-- Get move name from move ID
-- @param moveId: Move ID number
-- @return: Move name string or "UNKNOWN"
function Enums.getMoveName(moveId)
    for moveName, id in pairs(Enums.MoveId) do
        if id == moveId then
            return moveName
        end
    end
    return "UNKNOWN"
end

-- Get move ID from move name
-- @param moveName: Move name string
-- @return: Move ID number or nil if not found
function Enums.getMoveId(moveName)
    return Enums.MoveId[string.upper(moveName)]
end

-- Check if a move target is valid
-- @param targetId: Target ID to validate
-- @return: Boolean indicating if target exists
function Enums.isValidMoveTarget(targetId)
    for _, id in pairs(Enums.MoveTarget) do
        if id == targetId then
            return true
        end
    end
    return false
end

-- Check if a move category is valid
-- @param categoryId: Category ID to validate
-- @return: Boolean indicating if category exists
function Enums.isValidMoveCategory(categoryId)
    return categoryId >= 0 and categoryId <= 2
end

-- Get all valid move target IDs
-- @return: Array of all valid target IDs
function Enums.getAllMoveTargetIds()
    local targets = {}
    for _, targetId in pairs(Enums.MoveTarget) do
        table.insert(targets, targetId)
    end
    table.sort(targets)
    return targets
end

-- Get all valid move category IDs
-- @return: Array of all valid category IDs
function Enums.getAllMoveCategoryIds()
    local categories = {}
    for _, categoryId in pairs(Enums.MoveCategory) do
        table.insert(categories, categoryId)
    end
    table.sort(categories)
    return categories
end

-- Item ID Enumeration (basic items for terrain system)
Enums.ItemId = {
    NONE = 0,
    AIR_BALLOON = 541, -- Makes Pokemon not grounded until hit
    IRON_BALL = 278, -- Forces Pokemon to be grounded (nullifies Flying/Levitate)
    TERRAIN_EXTENDER = 879 -- Extends terrain duration from 5 to 8 turns
}

-- Legacy enum aliases for compatibility
Enums.Type = Enums.PokemonType
Enums.Ability = Enums.AbilityId
Enums.Move = Enums.MoveId


-- ===== END MODULE: data.constants.enums =====


-- Battle state storage
local BattleStates = {}
local StateHistory = {}
local SynchronizationQueue = {}

-- Configuration
local CONFIG = {
    maxStateHistory = 1000,
    syncInterval = 100, -- milliseconds
    stateBackupInterval = 10000, -- 10 seconds
    maxConcurrentBattles = 100
}

-- Battle state status enumeration
BattleStateManager.StateStatus = {
    INITIALIZING = "INITIALIZING",
    ACTIVE = "ACTIVE",
    PAUSED = "PAUSED",
    COMPLETED = "COMPLETED",
    ERROR = "ERROR",
    SYNCHRONIZING = "SYNCHRONIZING"
}

-- Initialize the battle state manager
function BattleStateManager.initialize()
    BattleStates = {}
    StateHistory = {}
    SynchronizationQueue = {}
    
    print("[BattleStateManager] State manager initialized")
    return {
        success = true,
        maxConcurrentBattles = CONFIG.maxConcurrentBattles
    }
end

-- Create new battle state with inter-process coordination
-- @param battleId: Unique battle identifier
-- @param battleParams: Battle initialization parameters
-- @param coordinatorId: Coordinator process ID for synchronization
-- @return: Created battle state or error
function BattleStateManager.createBattleState(battleId, battleParams, coordinatorId)
    if not battleId or not battleParams then
        return nil, "Invalid battle state creation parameters"
    end
    
    if BattleStates[battleId] then
        return nil, "Battle state already exists"
    end
    
    -- Check concurrent battle limit
    local activeBattles = 0
    for _, state in pairs(BattleStates) do
        if state.status ~= BattleStateManager.StateStatus.COMPLETED then
            activeBattles = activeBattles + 1
        end
    end
    
    if activeBattles >= CONFIG.maxConcurrentBattles then
        return nil, "Maximum concurrent battles reached"
    end
    
    -- Create correlation for coordinator communication
    local correlationId = MessageCorrelator.createCorrelation(
        ao.id,
        coordinatorId,
        "BATTLE_STATE_SYNC",
        nil
    )
    
    -- Initialize battle state
    local battleState = {
        battleId = battleId,
        status = BattleStateManager.StateStatus.INITIALIZING,
        coordinatorId = coordinatorId,
        correlationId = correlationId,
        createdAt = 0,
        lastUpdated = 0,
        lastSyncTime = 0,
        
        -- Battle data
        battleSeed = battleParams.battleSeed or BattleRNG.generateSeed(),
        battleType = battleParams.battleType or "WILD",
        turn = 0,
        phase = "COMMAND_SELECTION",
        
        -- Pokemon parties
        playerParty = battleParams.playerParty or {},
        enemyParty = battleParams.enemyParty or {},
        activePlayerPokemon = {},
        activeEnemyPokemon = {},
        
        -- Battle conditions
        battleConditions = {
            weather = nil,
            weatherTurns = 0,
            terrain = nil,
            terrainTurns = 0,
            fieldEffects = {},
            sideConditions = {
                player = {},
                enemy = {}
            }
        },
        
        -- Turn data
        turnCommands = {},
        turnOrder = {},
        currentAction = nil,
        pendingActions = {},
        
        -- Battle result
        battleResult = nil,
        
        -- Synchronization data
        syncVersion = 1,
        pendingUpdates = {},
        lastStateHash = nil
    }
    
    -- Set initial active Pokemon
    if battleState.playerParty and #battleState.playerParty > 0 then
        table.insert(battleState.activePlayerPokemon, battleState.playerParty[1])
    end
    
    if battleState.enemyParty and #battleState.enemyParty > 0 then
        table.insert(battleState.activeEnemyPokemon, battleState.enemyParty[1])
    end
    
    -- Generate state hash for synchronization
    battleState.lastStateHash = BattleStateManager.generateStateHash(battleState)
    
    -- Store battle state
    BattleStates[battleId] = battleState
    
    -- Initialize state history
    StateHistory[battleId] = {
        {
            turn = 0,
            timestamp = msg.Timestamp,
            stateSnapshot = BattleStateManager.createStateSnapshot(battleState),
            action = "BATTLE_INITIALIZED"
        }
    }
    
    -- Mark as active
    battleState.status = BattleStateManager.StateStatus.ACTIVE
    battleState.lastUpdated = 0
    
    print("[BattleStateManager] Battle state created: " .. battleId)
    
    return battleState, nil
end

-- Get battle state by ID
-- @param battleId: Battle identifier
-- @return: Battle state if found
function BattleStateManager.getBattleState(battleId)
    if not battleId then
        return nil
    end
    
    return BattleStates[battleId]
end

-- Update battle state and track changes
-- @param battleId: Battle identifier
-- @param updates: State updates to apply
-- @param actionDescription: Description of the action causing the update
-- @return: Success status and updated state
function BattleStateManager.updateBattleState(battleId, updates, actionDescription)
    if not battleId or not updates then
        return false, "Invalid update parameters"
    end
    
    local battleState = BattleStates[battleId]
    if not battleState then
        return false, "Battle state not found"
    end
    
    -- Apply updates
    for key, value in pairs(updates) do
        if key ~= "battleId" and key ~= "createdAt" and key ~= "correlationId" then
            battleState[key] = value
        end
    end
    
    -- Update metadata
    battleState.lastUpdated = 0
    battleState.syncVersion = battleState.syncVersion + 1
    
    -- Generate new state hash
    local newStateHash = BattleStateManager.generateStateHash(battleState)
    local stateChanged = newStateHash ~= battleState.lastStateHash
    battleState.lastStateHash = newStateHash
    
    -- Add to state history if state actually changed
    if stateChanged then
        BattleStateManager.addStateHistory(battleId, actionDescription or "STATE_UPDATE")
        
        -- Queue for synchronization with coordinator
        BattleStateManager.queueStateSync(battleId)
    end
    
    return true, battleState
end

-- Create state snapshot for history
-- @param battleState: Current battle state
-- @return: State snapshot
function BattleStateManager.createStateSnapshot(battleState)
    local snapshot = {
        turn = battleState.turn,
        phase = battleState.phase,
        status = battleState.status,
        battleConditions = battleState.battleConditions,
        activePlayerPokemon = {},
        activeEnemyPokemon = {},
        syncVersion = battleState.syncVersion
    }
    
    -- Copy active Pokemon data
    for _, pokemon in ipairs(battleState.activePlayerPokemon) do
        table.insert(snapshot.activePlayerPokemon, {
            id = pokemon.id,
            hp = pokemon.hp,
            status = pokemon.status,
            statStages = pokemon.statStages
        })
    end
    
    for _, pokemon in ipairs(battleState.activeEnemyPokemon) do
        table.insert(snapshot.activeEnemyPokemon, {
            id = pokemon.id,
            hp = pokemon.hp,
            status = pokemon.status,
            statStages = pokemon.statStages
        })
    end
    
    return snapshot
end

-- Add entry to state history
-- @param battleId: Battle identifier
-- @param actionDescription: Description of the action
function BattleStateManager.addStateHistory(battleId, actionDescription)
    local battleState = BattleStates[battleId]
    if not battleState then
        return
    end
    
    if not StateHistory[battleId] then
        StateHistory[battleId] = {}
    end
    
    local historyEntry = {
        turn = battleState.turn,
        timestamp = msg.Timestamp,
        stateSnapshot = BattleStateManager.createStateSnapshot(battleState),
        action = actionDescription,
        syncVersion = battleState.syncVersion
    }
    
    table.insert(StateHistory[battleId], historyEntry)
    
    -- Limit history size
    while #StateHistory[battleId] > CONFIG.maxStateHistory do
        table.remove(StateHistory[battleId], 1)
    end
end

-- Generate state hash for change detection
-- @param battleState: Battle state to hash
-- @return: State hash string
function BattleStateManager.generateStateHash(battleState)
    if not battleState then
        return ""
    end
    
    -- Create simplified state representation for hashing
    local hashData = {
        turn = battleState.turn,
        phase = battleState.phase,
        status = battleState.status,
        playerHp = {},
        enemyHp = {},
        conditions = battleState.battleConditions
    }
    
    -- Add Pokemon HP for change detection
    for _, pokemon in ipairs(battleState.activePlayerPokemon) do
        table.insert(hashData.playerHp, {id = pokemon.id, hp = pokemon.hp})
    end
    
    for _, pokemon in ipairs(battleState.activeEnemyPokemon) do
        table.insert(hashData.enemyHp, {id = pokemon.id, hp = pokemon.hp})
    end
    
    -- Simple hash generation (in production, use proper hashing)
    local hashString = json.encode(hashData)
    return tostring(#hashString) .. "_" .. tostring(0)
end

-- Queue battle state for synchronization with coordinator
-- @param battleId: Battle identifier
function BattleStateManager.queueStateSync(battleId)
    local battleState = BattleStates[battleId]
    if not battleState then
        return
    end
    
    SynchronizationQueue[battleId] = {
        battleId = battleId,
        queuedAt = 0,
        syncVersion = battleState.syncVersion,
        priority = 1
    }
end

-- Process state synchronization queue
-- @return: Number of states synchronized
function BattleStateManager.processStateSynchronization()
    local syncCount = 0
    local currentTime = 0
    
    for battleId, syncRequest in pairs(SynchronizationQueue) do
        local battleState = BattleStates[battleId]
        if battleState and battleState.coordinatorId then
            
            -- Check if sync is needed (version changed or time elapsed)
            local timeSinceLastSync = currentTime - battleState.lastSyncTime
            local versionChanged = battleState.syncVersion ~= syncRequest.syncVersion
            
            if timeSinceLastSync >= CONFIG.syncInterval or versionChanged then
                local success = BattleStateManager.synchronizeWithCoordinator(battleId)
                if success then
                    syncCount = syncCount + 1
                    battleState.lastSyncTime = currentTime
                    SynchronizationQueue[battleId] = nil
                end
            end
        else
            -- Remove invalid sync requests
            SynchronizationQueue[battleId] = nil
        end
    end
    
    return syncCount
end

-- Synchronize battle state with coordinator process
-- @param battleId: Battle identifier
-- @return: Synchronization success status
function BattleStateManager.synchronizeWithCoordinator(battleId)
    local battleState = BattleStates[battleId]
    if not battleState or not battleState.coordinatorId then
        return false
    end
    
    -- Create synchronization message
    local syncMessage = {
        correlation = {
            id = battleState.correlationId,
            sessionId = battleState.battleId,
            requestType = "BATTLE_STATE_SYNC"
        },
        battleData = {
            battleId = battleId,
            syncVersion = battleState.syncVersion,
            status = battleState.status,
            turn = battleState.turn,
            phase = battleState.phase,
            lastUpdated = battleState.lastUpdated,
            stateSnapshot = BattleStateManager.createStateSnapshot(battleState)
        },
        processAuth = {
            sourceProcessId = ao.id,
            timestamp = 0
        }
    }
    
    -- Send synchronization message to coordinator
    -- This would use AO's message sending mechanism
    print("[BattleStateManager] Synchronizing battle state: " .. battleId)
    
    return true
end

-- Get battle state history
-- @param battleId: Battle identifier
-- @param limit: Maximum number of history entries (optional)
-- @return: State history array
function BattleStateManager.getBattleHistory(battleId, limit)
    if not battleId then
        return {}
    end
    
    local history = StateHistory[battleId] or {}
    
    if limit and limit > 0 then
        local startIndex = math.max(1, #history - limit + 1)
        local limitedHistory = {}
        for i = startIndex, #history do
            table.insert(limitedHistory, history[i])
        end
        return limitedHistory
    end
    
    return history
end

-- Complete battle and perform cleanup
-- @param battleId: Battle identifier
-- @param battleResult: Final battle result
-- @return: Completion status
function BattleStateManager.completeBattle(battleId, battleResult)
    local battleState = BattleStates[battleId]
    if not battleState then
        return false, "Battle state not found"
    end
    
    -- Update battle state
    battleState.status = BattleStateManager.StateStatus.COMPLETED
    battleState.battleResult = battleResult
    battleState.lastUpdated = 0
    
    -- Add final history entry
    BattleStateManager.addStateHistory(battleId, "BATTLE_COMPLETED")
    
    -- Final synchronization with coordinator
    BattleStateManager.synchronizeWithCoordinator(battleId)
    
    print("[BattleStateManager] Battle completed: " .. battleId)
    
    return true
end

-- Clean up completed battles
-- @param maxAge: Maximum age in seconds for completed battles
-- @return: Number of battles cleaned up
function BattleStateManager.cleanupCompletedBattles(maxAge)
    maxAge = maxAge or 3600 -- Default 1 hour
    local currentTime = 0
    local cleanupCount = 0
    
    local battleIdsToRemove = {}
    
    for battleId, battleState in pairs(BattleStates) do
        if battleState.status == BattleStateManager.StateStatus.COMPLETED then
            local age = currentTime - battleState.lastUpdated
            if age > maxAge then
                table.insert(battleIdsToRemove, battleId)
            end
        end
    end
    
    -- Remove old completed battles
    for _, battleId in ipairs(battleIdsToRemove) do
        BattleStates[battleId] = nil
        StateHistory[battleId] = nil
        SynchronizationQueue[battleId] = nil
        cleanupCount = cleanupCount + 1
    end
    
    if cleanupCount > 0 then
        print("[BattleStateManager] Cleaned up " .. cleanupCount .. " completed battles")
    end
    
    return cleanupCount
end

-- Get battle state statistics
-- @return: Statistics about managed battle states
function BattleStateManager.getStatistics()
    local stats = {
        totalBattles = 0,
        activeBattles = 0,
        completedBattles = 0,
        errorBattles = 0,
        queuedSyncs = 0,
        totalHistoryEntries = 0
    }
    
    for _, battleState in pairs(BattleStates) do
        stats.totalBattles = stats.totalBattles + 1
        
        if battleState.status == BattleStateManager.StateStatus.ACTIVE then
            stats.activeBattles = stats.activeBattles + 1
        elseif battleState.status == BattleStateManager.StateStatus.COMPLETED then
            stats.completedBattles = stats.completedBattles + 1
        elseif battleState.status == BattleStateManager.StateStatus.ERROR then
            stats.errorBattles = stats.errorBattles + 1
        end
    end
    
    for _ in pairs(SynchronizationQueue) do
        stats.queuedSyncs = stats.queuedSyncs + 1
    end
    
    for _, history in pairs(StateHistory) do
        stats.totalHistoryEntries = stats.totalHistoryEntries + #history
    end
    
    return stats
end


-- ===== END MODULE: battle.components.battle-state-manager =====


-- ===== MODULE: battle.components.damage-calculator =====
-- File: ao-processes/battle/components/damage-calculator.lua
-- Original require: local DamageCalculator = require("battle.components.damage-calculator")

-- Battle Process Damage Calculator
-- Extracted from game-logic.battle.damage-calculator for dedicated battle process
-- Maintains exact mathematical parity with TypeScript implementation
-- Epic 32.3: Battle Engine Process Extraction


-- ===== MODULE: data.constants.type-chart =====
-- File: ao-processes/data/constants/type-chart.lua
-- Original require: local TypeChart = require("data.constants.type-chart")

-- Type Effectiveness Chart Implementation
-- Complete type effectiveness matrix for Pokemon battle calculations
-- Based on TypeScript reference implementation for exact behavioral parity

local TypeChart = {}

-- Type effectiveness multipliers (matching TypeScript TypeDamageMultiplier values)
TypeChart.MULTIPLIERS = {
    NO_EFFECT = 0,
    EIGHTH_EFFECTIVE = 0.125,
    QUARTER_EFFECTIVE = 0.25,
    HALF_EFFECTIVE = 0.5,
    NORMAL_EFFECTIVE = 1,
    SUPER_EFFECTIVE = 2,
    DOUBLE_SUPER_EFFECTIVE = 4,
    OCTAL_SUPER_EFFECTIVE = 8
}

-- Pokemon type constants (matching TypeScript PokemonType enum)
TypeChart.TYPES = {
    UNKNOWN = -1,
    NORMAL = 0,
    FIGHTING = 1,
    FLYING = 2,
    POISON = 3,
    GROUND = 4,
    ROCK = 5,
    BUG = 6,
    GHOST = 7,
    STEEL = 8,
    FIRE = 9,
    WATER = 10,
    GRASS = 11,
    ELECTRIC = 12,
    PSYCHIC = 13,
    ICE = 14,
    DRAGON = 15,
    DARK = 16,
    FAIRY = 17,
    STELLAR = 18
}

-- Reverse lookup from type names to numbers
TypeChart.TYPE_NAMES = {}
for typeName, typeNum in pairs(TypeChart.TYPES) do
    TypeChart.TYPE_NAMES[typeNum] = typeName
end

-- Get type damage multiplier for single type matchup
-- @param attackType: Attacking type (string or number)
-- @param defType: Defending type (string or number) 
-- @return: Damage multiplier (number: 0, 0.125, 0.25, 0.5, 1, 2, 4, or 8)
function TypeChart.getTypeDamageMultiplier(attackType, defType)
    -- Convert string types to numbers if needed
    if type(attackType) == "string" then
        attackType = TypeChart.TYPES[attackType]
    end
    if type(defType) == "string" then
        defType = TypeChart.TYPES[defType]
    end
    
    -- Handle unknown types
    if attackType == TypeChart.TYPES.UNKNOWN or defType == TypeChart.TYPES.UNKNOWN then
        return TypeChart.MULTIPLIERS.NORMAL_EFFECTIVE
    end
    
    -- Type effectiveness matrix implementation
    -- Based on exact TypeScript switch statement logic from src/data/type.ts
    
    -- NORMAL defending
    if defType == TypeChart.TYPES.NORMAL then
        if attackType == TypeChart.TYPES.FIGHTING then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        elseif attackType == TypeChart.TYPES.GHOST then
            return TypeChart.MULTIPLIERS.NO_EFFECT -- 0x
        end
        
    -- FIGHTING defending  
    elseif defType == TypeChart.TYPES.FIGHTING then
        if attackType == TypeChart.TYPES.ROCK or attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.DARK then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.FLYING or attackType == TypeChart.TYPES.PSYCHIC or attackType == TypeChart.TYPES.FAIRY then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- FLYING defending
    elseif defType == TypeChart.TYPES.FLYING then
        if attackType == TypeChart.TYPES.GROUND then
            return TypeChart.MULTIPLIERS.NO_EFFECT -- 0x
        elseif attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.GRASS then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.ROCK or attackType == TypeChart.TYPES.ELECTRIC or attackType == TypeChart.TYPES.ICE then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- POISON defending
    elseif defType == TypeChart.TYPES.POISON then
        if attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.POISON or 
           attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.GRASS or attackType == TypeChart.TYPES.FAIRY then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.GROUND or attackType == TypeChart.TYPES.PSYCHIC then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- GROUND defending
    elseif defType == TypeChart.TYPES.GROUND then
        if attackType == TypeChart.TYPES.POISON or attackType == TypeChart.TYPES.ROCK then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.WATER or attackType == TypeChart.TYPES.GRASS or attackType == TypeChart.TYPES.ICE then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        elseif attackType == TypeChart.TYPES.ELECTRIC then
            return TypeChart.MULTIPLIERS.NO_EFFECT -- 0x
        end
        
    -- ROCK defending
    elseif defType == TypeChart.TYPES.ROCK then
        if attackType == TypeChart.TYPES.NORMAL or attackType == TypeChart.TYPES.FLYING or 
           attackType == TypeChart.TYPES.POISON or attackType == TypeChart.TYPES.FIRE then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.GROUND or 
               attackType == TypeChart.TYPES.STEEL or attackType == TypeChart.TYPES.WATER or attackType == TypeChart.TYPES.GRASS then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- BUG defending
    elseif defType == TypeChart.TYPES.BUG then
        if attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.GROUND or attackType == TypeChart.TYPES.GRASS then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.FLYING or attackType == TypeChart.TYPES.ROCK or attackType == TypeChart.TYPES.FIRE then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- GHOST defending
    elseif defType == TypeChart.TYPES.GHOST then
        if attackType == TypeChart.TYPES.POISON or attackType == TypeChart.TYPES.BUG then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.GHOST or attackType == TypeChart.TYPES.DARK then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        elseif attackType == TypeChart.TYPES.NORMAL or attackType == TypeChart.TYPES.FIGHTING then
            return TypeChart.MULTIPLIERS.NO_EFFECT -- 0x
        end
        
    -- STEEL defending
    elseif defType == TypeChart.TYPES.STEEL then
        if attackType == TypeChart.TYPES.NORMAL or attackType == TypeChart.TYPES.FLYING or 
           attackType == TypeChart.TYPES.ROCK or attackType == TypeChart.TYPES.BUG or 
           attackType == TypeChart.TYPES.STEEL or attackType == TypeChart.TYPES.GRASS or 
           attackType == TypeChart.TYPES.PSYCHIC or attackType == TypeChart.TYPES.ICE or 
           attackType == TypeChart.TYPES.DRAGON or attackType == TypeChart.TYPES.FAIRY then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.GROUND or attackType == TypeChart.TYPES.FIRE then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        elseif attackType == TypeChart.TYPES.POISON then
            return TypeChart.MULTIPLIERS.NO_EFFECT -- 0x
        end
        
    -- FIRE defending
    elseif defType == TypeChart.TYPES.FIRE then
        if attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.FIRE or 
           attackType == TypeChart.TYPES.GRASS or attackType == TypeChart.TYPES.ICE or 
           attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.STEEL or attackType == TypeChart.TYPES.FAIRY then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.GROUND or attackType == TypeChart.TYPES.ROCK or attackType == TypeChart.TYPES.WATER then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- WATER defending
    elseif defType == TypeChart.TYPES.WATER then
        if attackType == TypeChart.TYPES.STEEL or attackType == TypeChart.TYPES.FIRE or 
           attackType == TypeChart.TYPES.WATER or attackType == TypeChart.TYPES.ICE then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.GRASS or attackType == TypeChart.TYPES.ELECTRIC then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- GRASS defending  
    elseif defType == TypeChart.TYPES.GRASS then
        if attackType == TypeChart.TYPES.WATER or 
           attackType == TypeChart.TYPES.GRASS or attackType == TypeChart.TYPES.ELECTRIC then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.FLYING or attackType == TypeChart.TYPES.POISON or 
               attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.FIRE or 
               attackType == TypeChart.TYPES.ICE or attackType == TypeChart.TYPES.GROUND then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- ELECTRIC defending
    elseif defType == TypeChart.TYPES.ELECTRIC then
        if attackType == TypeChart.TYPES.FLYING or attackType == TypeChart.TYPES.STEEL or attackType == TypeChart.TYPES.ELECTRIC then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.GROUND then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- PSYCHIC defending
    elseif defType == TypeChart.TYPES.PSYCHIC then
        if attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.PSYCHIC then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.GHOST or attackType == TypeChart.TYPES.DARK then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- ICE defending
    elseif defType == TypeChart.TYPES.ICE then
        if attackType == TypeChart.TYPES.ICE then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.ROCK or 
               attackType == TypeChart.TYPES.STEEL or attackType == TypeChart.TYPES.FIRE then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- DRAGON defending
    elseif defType == TypeChart.TYPES.DRAGON then
        if attackType == TypeChart.TYPES.FIRE or attackType == TypeChart.TYPES.WATER or 
           attackType == TypeChart.TYPES.ELECTRIC or attackType == TypeChart.TYPES.GRASS then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.ICE or attackType == TypeChart.TYPES.DRAGON or attackType == TypeChart.TYPES.FAIRY then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        end
        
    -- DARK defending
    elseif defType == TypeChart.TYPES.DARK then
        if attackType == TypeChart.TYPES.GHOST or attackType == TypeChart.TYPES.DARK then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.FAIRY then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        elseif attackType == TypeChart.TYPES.PSYCHIC then
            return TypeChart.MULTIPLIERS.NO_EFFECT -- 0x
        end
        
    -- FAIRY defending
    elseif defType == TypeChart.TYPES.FAIRY then
        if attackType == TypeChart.TYPES.FIGHTING or attackType == TypeChart.TYPES.BUG or attackType == TypeChart.TYPES.DARK then
            return TypeChart.MULTIPLIERS.HALF_EFFECTIVE -- 0.5x
        elseif attackType == TypeChart.TYPES.POISON or attackType == TypeChart.TYPES.STEEL then
            return TypeChart.MULTIPLIERS.SUPER_EFFECTIVE -- 2x
        elseif attackType == TypeChart.TYPES.DRAGON then
            return TypeChart.MULTIPLIERS.NO_EFFECT -- 0x
        end
        
    -- STELLAR defending (special case)
    elseif defType == TypeChart.TYPES.STELLAR then
        -- Stellar type has special handling in battle context
        return TypeChart.MULTIPLIERS.NORMAL_EFFECTIVE -- 1x (will be modified by Terastalization logic)
    end
    
    -- Default case - normal effectiveness
    return TypeChart.MULTIPLIERS.NORMAL_EFFECTIVE -- 1x
end

-- Calculate attack type effectiveness against Pokemon with potentially multiple types
-- @param attackType: Attacking type (string or number)
-- @param defendingTypes: Array of defending types or single type
-- @return: Final damage multiplier after applying all type interactions
function TypeChart.getAttackTypeEffectiveness(attackType, defendingTypes)
    -- Handle single type Pokemon (convert to array)
    if type(defendingTypes) ~= "table" then
        defendingTypes = {defendingTypes}
    end
    
    -- Calculate effectiveness against each defending type and multiply together
    local finalMultiplier = TypeChart.MULTIPLIERS.NORMAL_EFFECTIVE
    
    for _, defType in ipairs(defendingTypes) do
        local typeMultiplier = TypeChart.getTypeDamageMultiplier(attackType, defType)
        finalMultiplier = finalMultiplier * typeMultiplier
    end
    
    return finalMultiplier
end

-- Check if attack type is super effective against defending types
-- @param attackType: Attacking type
-- @param defendingTypes: Array of defending types or single type
-- @return: Boolean indicating if attack is super effective (> 1x)
function TypeChart.isSuperEffective(attackType, defendingTypes)
    local effectiveness = TypeChart.getAttackTypeEffectiveness(attackType, defendingTypes)
    return effectiveness > TypeChart.MULTIPLIERS.NORMAL_EFFECTIVE
end

-- Check if attack type is not very effective against defending types
-- @param attackType: Attacking type
-- @param defendingTypes: Array of defending types or single type
-- @return: Boolean indicating if attack is not very effective (< 1x but > 0x)
function TypeChart.isNotVeryEffective(attackType, defendingTypes)
    local effectiveness = TypeChart.getAttackTypeEffectiveness(attackType, defendingTypes)
    return effectiveness > TypeChart.MULTIPLIERS.NO_EFFECT and effectiveness < TypeChart.MULTIPLIERS.NORMAL_EFFECTIVE
end

-- Check if attack has no effect against defending types
-- @param attackType: Attacking type
-- @param defendingTypes: Array of defending types or single type
-- @return: Boolean indicating if attack has no effect (0x)
function TypeChart.hasNoEffect(attackType, defendingTypes)
    local effectiveness = TypeChart.getAttackTypeEffectiveness(attackType, defendingTypes)
    return effectiveness == TypeChart.MULTIPLIERS.NO_EFFECT
end

-- Get effectiveness description text
-- @param attackType: Attacking type
-- @param defendingTypes: Array of defending types or single type
-- @return: String description of effectiveness
function TypeChart.getEffectivenessDescription(attackType, defendingTypes)
    local effectiveness = TypeChart.getAttackTypeEffectiveness(attackType, defendingTypes)
    
    if effectiveness == TypeChart.MULTIPLIERS.NO_EFFECT then
        return "No effect"
    elseif effectiveness == TypeChart.MULTIPLIERS.QUARTER_EFFECTIVE then
        return "Very not very effective"
    elseif effectiveness == TypeChart.MULTIPLIERS.HALF_EFFECTIVE then
        return "Not very effective"
    elseif effectiveness == TypeChart.MULTIPLIERS.NORMAL_EFFECTIVE then
        return "Normal effectiveness"
    elseif effectiveness == TypeChart.MULTIPLIERS.SUPER_EFFECTIVE then
        return "Super effective"
    elseif effectiveness == TypeChart.MULTIPLIERS.DOUBLE_SUPER_EFFECTIVE then
        return "Very super effective"
    else
        return string.format("%.3fx effective", effectiveness)
    end
end


-- ===== END MODULE: data.constants.type-chart =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Berry system integration

-- ===== MODULE: game-logic.items.berry-activation-manager =====
-- File: ao-processes/game-logic/items/berry-activation-manager.lua
-- Original require: local BerryActivationManager = require("game-logic.items.berry-activation-manager")

--[[
Berry Activation Manager
Manages berry trigger monitoring and timing within battle system

Features:
- Battle turn integration for berry activation checks
- HP monitoring system triggering berry activation at correct thresholds
- Status effect monitoring triggering status-curing berries immediately
- Stat reduction monitoring for stat-boosting berry triggers
- Berry consumption workflow removing berries after activation
- Berry recycling system through moves (Recycle) and abilities (Harvest)
- Activation priority system for multiple berry triggers

Behavioral Parity Requirements:
- Never use Lua's math.random() - ALWAYS use AO crypto module
- All berry activation calculations must match TypeScript implementation exactly
- Berry activation and timing must be deterministic and reproducible
--]]


-- ===== MODULE: data.items.berry-database =====
-- File: ao-processes/data/items/berry-database.lua
-- Original require: local BerryDatabase = require('data.items.berry-database')

--[[
Berry Database
Comprehensive berry system with activation conditions and effects

Features:
- HP-restoration berries (Oran Berry 10HP, Sitrus Berry 25% HP healing)
- Status-curing berries with immediate activation (Chesto=Sleep, Pecha=Poison, etc.)
- Stat-boosting berries triggered by stat reduction (White Herb, Mental Herb, etc.)
- Damage-reducing berries for super-effective type coverage (once per battle)
- Pinch berries with 25% HP activation thresholds (Petaya=SpAtk+1, Salac=Speed+1, etc.)
- Type-resist berries reducing super-effective damage by 50% once per battle

Behavioral Parity Requirements:
- Never use Lua's math.random() - ALWAYS use AO crypto module
- All berry activation calculations must match TypeScript implementation exactly
- Never hardcode berry data - always reference berry database tables
- All AO message responses must include success boolean
- Berry activation and effect calculations must be deterministic and reproducible
--]]

local BerryDatabase = {}

-- Berry categories enum
local BerryCategory = {
    HP_RESTORE = "hp_restore",
    STATUS_CURE = "status_cure", 
    STAT_BOOST = "stat_boost",
    DAMAGE_REDUCE = "damage_reduce",
    PINCH_BERRY = "pinch_berry",
    TYPE_RESIST = "type_resist",
    PP_RESTORE = "pp_restore",
    SPECIAL = "special"
}

-- Activation conditions enum
local ActivationCondition = {
    HP_25_PERCENT = "hp_25_percent",
    HP_50_PERCENT = "hp_50_percent",
    STATUS_INFLICTED = "status_inflicted",
    STAT_LOWERED = "stat_lowered",
    SUPER_EFFECTIVE_HIT = "super_effective_hit",
    PP_DEPLETED = "pp_depleted",
    IMMEDIATE = "immediate"
}

-- Status conditions enum
local StatusCondition = {
    PARALYSIS = "paralysis",
    SLEEP = "sleep", 
    POISON = "poison",
    BURN = "burn",
    FREEZE = "freeze",
    CONFUSION = "confusion",
    ANY = "any"
}

-- Stats enum
local StatType = {
    ATTACK = "attack",
    DEFENSE = "defense", 
    SP_ATTACK = "spAttack",
    SP_DEFENSE = "spDefense",
    SPEED = "speed",
    ACCURACY = "accuracy",
    EVASION = "evasion",
    CRITICAL_HIT = "criticalHit",
    RANDOM = "random"
}

-- Pokemon types for type-resist berries
local PokemonType = {
    FIRE = "fire",
    WATER = "water",
    ELECTRIC = "electric", 
    GRASS = "grass",
    ICE = "ice",
    FIGHTING = "fighting",
    POISON = "poison",
    GROUND = "ground",
    FLYING = "flying",
    PSYCHIC = "psychic",
    BUG = "bug",
    ROCK = "rock",
    GHOST = "ghost",
    DRAGON = "dragon",
    DARK = "dark",
    STEEL = "steel",
    FAIRY = "fairy",
    NORMAL = "normal"
}

-- HP-restoration berries
local hpRestoreBerries = {
    ORAN_BERRY = {
        id = "ORAN_BERRY",
        name = "Oran Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it restores 10 HP when HP is low.",
        category = BerryCategory.HP_RESTORE,
        activationCondition = ActivationCondition.HP_50_PERCENT,
        effect = {
            type = "heal_fixed",
            amount = 10
        },
        consumable = true,
        battleOnly = true
    },
    
    SITRUS_BERRY = {
        id = "SITRUS_BERRY", 
        name = "Sitrus Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it restores its HP by 1/4 of its maximum HP when its HP drops below 1/2.",
        category = BerryCategory.HP_RESTORE,
        activationCondition = ActivationCondition.HP_50_PERCENT,
        effect = {
            type = "heal_percent",
            amount = 0.25  -- 25% of max HP
        },
        consumable = true,
        battleOnly = true
    }
}

-- Status-curing berries
local statusCureBerries = {
    CHERI_BERRY = {
        id = "CHERI_BERRY",
        name = "Cheri Berry", 
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it recovers from paralysis.",
        category = BerryCategory.STATUS_CURE,
        activationCondition = ActivationCondition.STATUS_INFLICTED,
        effect = {
            type = "cure_status",
            statusCondition = StatusCondition.PARALYSIS
        },
        consumable = true,
        battleOnly = true
    },
    
    CHESTO_BERRY = {
        id = "CHESTO_BERRY",
        name = "Chesto Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it recovers from sleep.",
        category = BerryCategory.STATUS_CURE,
        activationCondition = ActivationCondition.STATUS_INFLICTED,
        effect = {
            type = "cure_status", 
            statusCondition = StatusCondition.SLEEP
        },
        consumable = true,
        battleOnly = true
    },
    
    PECHA_BERRY = {
        id = "PECHA_BERRY",
        name = "Pecha Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it recovers from poison.",
        category = BerryCategory.STATUS_CURE,
        activationCondition = ActivationCondition.STATUS_INFLICTED,
        effect = {
            type = "cure_status",
            statusCondition = StatusCondition.POISON
        },
        consumable = true,
        battleOnly = true
    },
    
    RAWST_BERRY = {
        id = "RAWST_BERRY",
        name = "Rawst Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it recovers from a burn.",
        category = BerryCategory.STATUS_CURE,
        activationCondition = ActivationCondition.STATUS_INFLICTED,
        effect = {
            type = "cure_status",
            statusCondition = StatusCondition.BURN
        },
        consumable = true,
        battleOnly = true
    },
    
    ASPEAR_BERRY = {
        id = "ASPEAR_BERRY",
        name = "Aspear Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it recovers from being frozen.",
        category = BerryCategory.STATUS_CURE,
        activationCondition = ActivationCondition.STATUS_INFLICTED,
        effect = {
            type = "cure_status",
            statusCondition = StatusCondition.FREEZE
        },
        consumable = true,
        battleOnly = true
    },
    
    PERSIM_BERRY = {
        id = "PERSIM_BERRY",
        name = "Persim Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it recovers from confusion.",
        category = BerryCategory.STATUS_CURE,
        activationCondition = ActivationCondition.STATUS_INFLICTED,
        effect = {
            type = "cure_status",
            statusCondition = StatusCondition.CONFUSION
        },
        consumable = true,
        battleOnly = true
    },
    
    LUM_BERRY = {
        id = "LUM_BERRY", 
        name = "Lum Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it recovers from any status condition during battle.",
        category = BerryCategory.STATUS_CURE,
        activationCondition = ActivationCondition.STATUS_INFLICTED,
        effect = {
            type = "cure_status",
            statusCondition = StatusCondition.ANY
        },
        consumable = true,
        battleOnly = true
    }
}

-- Stat-boosting berries (activated when stat is lowered)
local statBoostBerries = {
    WHITE_HERB = {
        id = "WHITE_HERB",
        name = "White Herb",
        description = "An item to be held by a Pokmon. It restores any lowered stat in battle. It can be used only once.",
        category = BerryCategory.STAT_BOOST,
        activationCondition = ActivationCondition.STAT_LOWERED,
        effect = {
            type = "restore_lowered_stats",
            target = "all_lowered"
        },
        consumable = true,
        battleOnly = true
    },
    
    MENTAL_HERB = {
        id = "MENTAL_HERB",
        name = "Mental Herb",
        description = "An item to be held by a Pokmon. It snaps the holder out of move-binding effects like Wrap and prevents the use of such moves.",
        category = BerryCategory.STAT_BOOST,
        activationCondition = ActivationCondition.IMMEDIATE,
        effect = {
            type = "cure_binding",
            target = "binding_moves"
        },
        consumable = true,
        battleOnly = true
    }
}

-- Pinch berries (activate at 25% HP with stat boosts)
local pinchBerries = {
    LIECHI_BERRY = {
        id = "LIECHI_BERRY",
        name = "Liechi Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, its Attack stat will increase when its HP drops below 1/4 of its maximum.",
        category = BerryCategory.PINCH_BERRY,
        activationCondition = ActivationCondition.HP_25_PERCENT,
        effect = {
            type = "boost_stat",
            stat = StatType.ATTACK,
            amount = 1  -- +1 stage
        },
        consumable = true,
        battleOnly = true
    },
    
    GANLON_BERRY = {
        id = "GANLON_BERRY", 
        name = "Ganlon Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, its Defense will increase when its HP drops below 1/4 of its maximum.",
        category = BerryCategory.PINCH_BERRY,
        activationCondition = ActivationCondition.HP_25_PERCENT,
        effect = {
            type = "boost_stat",
            stat = StatType.DEFENSE,
            amount = 1  -- +1 stage
        },
        consumable = true,
        battleOnly = true
    },
    
    PETAYA_BERRY = {
        id = "PETAYA_BERRY",
        name = "Petaya Berry", 
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, its Sp. Atk will sharply increase when its HP drops below 1/4.",
        category = BerryCategory.PINCH_BERRY,
        activationCondition = ActivationCondition.HP_25_PERCENT,
        effect = {
            type = "boost_stat",
            stat = StatType.SP_ATTACK,
            amount = 1  -- +1 stage  
        },
        consumable = true,
        battleOnly = true
    },
    
    APICOT_BERRY = {
        id = "APICOT_BERRY",
        name = "Apicot Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, its Sp. Def will sharply increase when its HP drops below 1/4.",
        category = BerryCategory.PINCH_BERRY,
        activationCondition = ActivationCondition.HP_25_PERCENT,
        effect = {
            type = "boost_stat",
            stat = StatType.SP_DEFENSE,
            amount = 1  -- +1 stage
        },
        consumable = true,
        battleOnly = true
    },
    
    SALAC_BERRY = {
        id = "SALAC_BERRY",
        name = "Salac Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, its Speed will sharply increase when its HP drops below 1/4.",
        category = BerryCategory.PINCH_BERRY,
        activationCondition = ActivationCondition.HP_25_PERCENT,
        effect = {
            type = "boost_stat",
            stat = StatType.SPEED,
            amount = 1  -- +1 stage
        },
        consumable = true,
        battleOnly = true
    },
    
    LANSAT_BERRY = {
        id = "LANSAT_BERRY",
        name = "Lansat Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, its critical hit ratio will increase when its HP drops below 1/4.",
        category = BerryCategory.PINCH_BERRY,
        activationCondition = ActivationCondition.HP_25_PERCENT,
        effect = {
            type = "boost_stat",
            stat = StatType.CRITICAL_HIT,
            amount = 1  -- +1 stage
        },
        consumable = true,
        battleOnly = true
    },
    
    STARF_BERRY = {
        id = "STARF_BERRY",
        name = "Starf Berry", 
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, one of its stats will sharply increase when its HP drops below 1/4.",
        category = BerryCategory.PINCH_BERRY,
        activationCondition = ActivationCondition.HP_25_PERCENT,
        effect = {
            type = "boost_stat",
            stat = StatType.RANDOM,
            amount = 2  -- +2 stages to random stat
        },
        consumable = true,
        battleOnly = true
    }
}

-- Damage-reducing berries (halve super-effective damage once per battle)
local damageReduceBerries = {
    ENIGMA_BERRY = {
        id = "ENIGMA_BERRY",
        name = "Enigma Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it restores its HP if it is hit by a supereffective attack.",
        category = BerryCategory.DAMAGE_REDUCE,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "heal_after_super_effective",
            amount = 0.25  -- 25% of max HP
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    }
}

-- Type-resist berries (reduce super-effective damage by 50% once per battle)
local typeResistBerries = {
    OCCA_BERRY = {
        id = "OCCA_BERRY",
        name = "Occa Berry", 
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Fire-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage", 
            resistType = PokemonType.FIRE,
            damageReduction = 0.5  -- 50% damage reduction
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    },
    
    PASSHO_BERRY = {
        id = "PASSHO_BERRY",
        name = "Passho Berry",
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Water-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage",
            resistType = PokemonType.WATER,
            damageReduction = 0.5
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    },
    
    WACAN_BERRY = {
        id = "WACAN_BERRY",
        name = "Wacan Berry",
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Electric-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage",
            resistType = PokemonType.ELECTRIC,
            damageReduction = 0.5
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    },
    
    RINDO_BERRY = {
        id = "RINDO_BERRY", 
        name = "Rindo Berry",
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Grass-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage",
            resistType = PokemonType.GRASS,
            damageReduction = 0.5
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    },
    
    YACHE_BERRY = {
        id = "YACHE_BERRY",
        name = "Yache Berry",
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Ice-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage",
            resistType = PokemonType.ICE,
            damageReduction = 0.5
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    },
    
    CHOPLE_BERRY = {
        id = "CHOPLE_BERRY",
        name = "Chople Berry",
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Fighting-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage",
            resistType = PokemonType.FIGHTING,
            damageReduction = 0.5
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    },
    
    KEBIA_BERRY = {
        id = "KEBIA_BERRY",
        name = "Kebia Berry",
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Poison-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage",
            resistType = PokemonType.POISON,
            damageReduction = 0.5
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    },
    
    SHUCA_BERRY = {
        id = "SHUCA_BERRY",
        name = "Shuca Berry",
        description = "A Berry to be held by a Pokmon. It weakens a supereffective Ground-type attack against the holder.",
        category = BerryCategory.TYPE_RESIST,
        activationCondition = ActivationCondition.SUPER_EFFECTIVE_HIT,
        effect = {
            type = "resist_type_damage",
            resistType = PokemonType.GROUND,
            damageReduction = 0.5
        },
        consumable = true,
        battleOnly = true,
        oncePerBattle = true
    }
}

-- PP restoration berries
local ppRestoreBerries = {
    LEPPA_BERRY = {
        id = "LEPPA_BERRY",
        name = "Leppa Berry",
        description = "A Berry to be consumed by Pokmon. If a Pokmon holds one, it restores a move's PP by 10 when the PP reaches 0.",
        category = BerryCategory.PP_RESTORE,
        activationCondition = ActivationCondition.PP_DEPLETED,
        effect = {
            type = "restore_pp",
            amount = 10
        },
        consumable = true,
        battleOnly = true
    }
}

-- Merge all berry collections into main database
local function mergeBerryData()
    local allBerries = {}
    
    -- Merge all berry categories
    for berryId, berryData in pairs(hpRestoreBerries) do
        allBerries[berryId] = berryData
    end
    
    for berryId, berryData in pairs(statusCureBerries) do
        allBerries[berryId] = berryData
    end
    
    for berryId, berryData in pairs(statBoostBerries) do
        allBerries[berryId] = berryData
    end
    
    for berryId, berryData in pairs(pinchBerries) do
        allBerries[berryId] = berryData
    end
    
    for berryId, berryData in pairs(damageReduceBerries) do
        allBerries[berryId] = berryData
    end
    
    for berryId, berryData in pairs(typeResistBerries) do
        allBerries[berryId] = berryData
    end
    
    for berryId, berryData in pairs(ppRestoreBerries) do
        allBerries[berryId] = berryData
    end
    
    return allBerries
end

-- Main berry database
BerryDatabase.berries = mergeBerryData()

-- Berry database access functions
function BerryDatabase.getBerry(berryId)
    return BerryDatabase.berries[berryId]
end

function BerryDatabase.getAllBerries()
    return BerryDatabase.berries
end

function BerryDatabase.getBerriesByCategory(category)
    local categoryBerries = {}
    for berryId, berryData in pairs(BerryDatabase.berries) do
        if berryData.category == category then
            categoryBerries[berryId] = berryData
        end
    end
    return categoryBerries
end

function BerryDatabase.getBerriesByActivationCondition(condition)
    local conditionBerries = {}
    for berryId, berryData in pairs(BerryDatabase.berries) do
        if berryData.activationCondition == condition then
            conditionBerries[berryId] = berryData
        end
    end
    return conditionBerries
end

function BerryDatabase.isBerry(itemId)
    return BerryDatabase.berries[itemId] ~= nil
end

function BerryDatabase.isConsumable(berryId)
    local berry = BerryDatabase.getBerry(berryId)
    return berry and berry.consumable == true
end

function BerryDatabase.isOncePerBattle(berryId)
    local berry = BerryDatabase.getBerry(berryId)
    return berry and berry.oncePerBattle == true
end

-- Validation functions
function BerryDatabase.validateBerryData()
    local errors = {}
    
    for berryId, berryData in pairs(BerryDatabase.berries) do
        -- Check required fields
        if not berryData.id then
            table.insert(errors, "Berry " .. berryId .. " missing id field")
        end
        
        if not berryData.name then
            table.insert(errors, "Berry " .. berryId .. " missing name field")
        end
        
        if not berryData.category then
            table.insert(errors, "Berry " .. berryId .. " missing category field")
        end
        
        if not berryData.activationCondition then
            table.insert(errors, "Berry " .. berryId .. " missing activationCondition field")
        end
        
        if not berryData.effect then
            table.insert(errors, "Berry " .. berryId .. " missing effect field")
        end
    end
    
    return #errors == 0, errors
end

-- Export enums for external use
BerryDatabase.BerryCategory = BerryCategory
BerryDatabase.ActivationCondition = ActivationCondition
BerryDatabase.StatusCondition = StatusCondition
BerryDatabase.StatType = StatType
BerryDatabase.PokemonType = PokemonType


-- ===== END MODULE: data.items.berry-database =====


-- ===== MODULE: game-logic.items.berry-effects-processor =====
-- File: ao-processes/game-logic/items/berry-effects-processor.lua
-- Original require: local BerryEffectsProcessor = require('game-logic.items.berry-effects-processor')

--[[
Berry Effects Processor
Handles berry effect calculations and applications

Features:
- HP threshold monitoring for automatic berry activation (25%, 50%)
- Status condition monitoring for immediate berry activation upon status infliction
- Stat reduction monitoring for stat-boosting berry activation
- Damage calculation integration for damage-reducing berry effects
- Berry consumption logic removing berry from held item slot after activation
- Stat modification system for pinch berries with correct stat boosts
- Once-per-battle tracking for damage-reducing berries

Behavioral Parity Requirements:
- Never use Lua's math.random() - ALWAYS use AO crypto module
- All berry activation calculations must match TypeScript implementation exactly
- Berry activation and effect calculations must be deterministic and reproducible
--]]


-- ===== MODULE: data.items.berry-database =====
-- File: ao-processes/data/items/berry-database.lua
-- Original require: local BerryDatabase = require('data.items.berry-database')


-- ===== END MODULE: data.items.berry-database =====


local BerryEffectsProcessor = {}

-- Initialize crypto module for deterministic calculations
local function getCryptoModule()
    if ao and ao.env and ao.env.Module and ao.env.Module.Id then
-- ERROR: Could not resolve require('ao.crypto')
        return require('ao.crypto')
    else
        -- For testing purposes, return mock
        return {
            utils = {
                randomBytes = function(count)
                    return string.rep("a", count)
                end
            }
        }
    end
end

local crypto = getCryptoModule()

-- Berry effect processing functions

--[[
Calculate HP percentage for berry activation
@param currentHp number - Current hit points
@param maxHp number - Maximum hit points
@return number - HP percentage (0.0 to 1.0)
--]]
function BerryEffectsProcessor.calculateHpPercentage(currentHp, maxHp)
    if not currentHp or not maxHp or maxHp <= 0 then
        return 0
    end
    
    return math.min(1.0, math.max(0.0, currentHp / maxHp))
end

--[[
Check if berry should activate based on HP threshold
@param berry table - Berry data from database
@param currentHp number - Current hit points
@param maxHp number - Maximum hit points
@return boolean - True if berry should activate
--]]
function BerryEffectsProcessor.shouldActivateHpBerry(berry, currentHp, maxHp)
    if not berry or not berry.activationCondition then
        return false
    end
    
    local hpPercent = BerryEffectsProcessor.calculateHpPercentage(currentHp, maxHp)
    
    if berry.activationCondition == BerryDatabase.ActivationCondition.HP_25_PERCENT then
        return hpPercent <= 0.25
    elseif berry.activationCondition == BerryDatabase.ActivationCondition.HP_50_PERCENT then
        return hpPercent <= 0.50
    end
    
    return false
end

--[[
Check if berry should activate based on status condition
@param berry table - Berry data from database
@param statusCondition string - Current status condition
@return boolean - True if berry should activate
--]]
function BerryEffectsProcessor.shouldActivateStatusBerry(berry, statusCondition)
    if not berry or not berry.activationCondition or not statusCondition then
        return false
    end
    
    if berry.activationCondition ~= BerryDatabase.ActivationCondition.STATUS_INFLICTED then
        return false
    end
    
    if not berry.effect or berry.effect.type ~= "cure_status" then
        return false
    end
    
    local targetCondition = berry.effect.statusCondition
    
    -- LUM_BERRY cures any status
    if targetCondition == BerryDatabase.StatusCondition.ANY then
        return true
    end
    
    -- Specific status berries
    return targetCondition == statusCondition
end

--[[
Check if berry should activate based on stat reduction
@param berry table - Berry data from database
@param statChanges table - Stat modifications applied
@return boolean - True if berry should activate
--]]
function BerryEffectsProcessor.shouldActivateStatBerry(berry, statChanges)
    if not berry or not berry.activationCondition or not statChanges then
        return false
    end
    
    if berry.activationCondition ~= BerryDatabase.ActivationCondition.STAT_LOWERED then
        return false
    end
    
    -- Check if any stat was lowered
    for stat, change in pairs(statChanges) do
        if change < 0 then
            return true
        end
    end
    
    return false
end

--[[
Check if berry should activate based on super-effective hit
@param berry table - Berry data from database
@param moveType string - Type of the attacking move
@param defenderTypes table - Defending Pokemon's types
@param effectiveness number - Type effectiveness multiplier
@return boolean - True if berry should activate
--]]
function BerryEffectsProcessor.shouldActivateDamageReduceBerry(berry, moveType, defenderTypes, effectiveness)
    if not berry or not berry.activationCondition then
        return false
    end
    
    if berry.activationCondition ~= BerryDatabase.ActivationCondition.SUPER_EFFECTIVE_HIT then
        return false
    end
    
    -- Check if attack is super effective (effectiveness > 1.0)
    if not effectiveness or effectiveness <= 1.0 then
        return false
    end
    
    -- For type-resist berries, check if the move type matches the resist type
    if berry.category == BerryDatabase.BerryCategory.TYPE_RESIST then
        if berry.effect and berry.effect.resistType then
            return berry.effect.resistType == moveType
        end
    end
    
    -- For ENIGMA_BERRY, activate on any super-effective hit
    if berry.category == BerryDatabase.BerryCategory.DAMAGE_REDUCE then
        return true
    end
    
    return false
end

--[[
Apply HP restoration berry effect
@param berry table - Berry data from database
@param pokemon table - Pokemon receiving the effect
@return table - Updated pokemon data
--]]
function BerryEffectsProcessor.applyHpRestoration(berry, pokemon)
    if not berry or not berry.effect or not pokemon then
        return pokemon
    end
    
    local effect = berry.effect
    local healAmount = 0
    
    if effect.type == "heal_fixed" then
        healAmount = effect.amount
    elseif effect.type == "heal_percent" then
        healAmount = math.floor(pokemon.maxHp * effect.amount)
    end
    
    -- Apply healing with bounds checking
    local newHp = math.min(pokemon.maxHp, pokemon.hp + healAmount)
    
    return {
        id = pokemon.id,
        hp = newHp,
        maxHp = pokemon.maxHp,
        statusEffect = pokemon.statusEffect,
        stats = pokemon.stats,
        heldItem = nil,  -- Berry is consumed
        healedAmount = healAmount,
        berryActivated = berry.id
    }
end

--[[
Apply status curing berry effect
@param berry table - Berry data from database  
@param pokemon table - Pokemon receiving the effect
@return table - Updated pokemon data
--]]
function BerryEffectsProcessor.applyStatusCure(berry, pokemon)
    if not berry or not berry.effect or not pokemon then
        return pokemon
    end
    
    local effect = berry.effect
    local shouldCure = false
    
    if effect.statusCondition == BerryDatabase.StatusCondition.ANY then
        shouldCure = pokemon.statusEffect ~= nil
    else
        shouldCure = pokemon.statusEffect == effect.statusCondition
    end
    
    if shouldCure then
        return {
            id = pokemon.id,
            hp = pokemon.hp,
            maxHp = pokemon.maxHp,
            statusEffect = nil,  -- Status cured
            stats = pokemon.stats,
            heldItem = nil,  -- Berry is consumed
            statusCured = pokemon.statusEffect,
            berryActivated = berry.id
        }
    end
    
    return pokemon
end

--[[
Apply stat boosting berry effect
@param berry table - Berry data from database
@param pokemon table - Pokemon receiving the effect
@param battleSeed string - Deterministic seed for random stat selection
@return table - Updated pokemon data with stat modifications
--]]
function BerryEffectsProcessor.applyStatBoost(berry, pokemon, battleSeed)
    if not berry or not berry.effect or not pokemon then
        return pokemon
    end
    
    local effect = berry.effect
    local updatedStats = {}
    
    -- Copy existing stats
    for stat, value in pairs(pokemon.stats or {}) do
        updatedStats[stat] = value
    end
    
    -- Apply stat boost
    if effect.type == "boost_stat" then
        local targetStat = effect.stat
        
        -- Handle random stat selection for STARF_BERRY
        if targetStat == BerryDatabase.StatType.RANDOM then
            local availableStats = {
                BerryDatabase.StatType.ATTACK,
                BerryDatabase.StatType.DEFENSE,
                BerryDatabase.StatType.SP_ATTACK,
                BerryDatabase.StatType.SP_DEFENSE,
                BerryDatabase.StatType.SPEED
            }
            
            -- Use deterministic selection based on battle seed
            local seedBytes = crypto.utils.randomBytes(4)
            local randomIndex = (string.byte(seedBytes, 1) % #availableStats) + 1
            targetStat = availableStats[randomIndex]
        end
        
        -- Apply stat stage modification
        local currentStage = updatedStats[targetStat .. "Stage"] or 0
        local newStage = math.min(6, math.max(-6, currentStage + effect.amount))
        updatedStats[targetStat .. "Stage"] = newStage
        
        return {
            id = pokemon.id,
            hp = pokemon.hp,
            maxHp = pokemon.maxHp,
            statusEffect = pokemon.statusEffect,
            stats = updatedStats,
            heldItem = nil,  -- Berry is consumed
            statBoosted = targetStat,
            boostAmount = effect.amount,
            berryActivated = berry.id
        }
    elseif effect.type == "restore_lowered_stats" then
        -- WHITE_HERB: restore all lowered stats
        for stat, stage in pairs(updatedStats) do
            if stat:match("Stage$") and stage < 0 then
                updatedStats[stat] = 0
            end
        end
        
        return {
            id = pokemon.id,
            hp = pokemon.hp,
            maxHp = pokemon.maxHp,
            statusEffect = pokemon.statusEffect,
            stats = updatedStats,
            heldItem = nil,  -- Berry is consumed
            statsRestored = true,
            berryActivated = berry.id
        }
    end
    
    return pokemon
end

--[[
Apply damage reduction berry effect
@param berry table - Berry data from database
@param damage number - Original damage amount
@param moveType string - Type of the attacking move
@return number - Modified damage amount
--]]
function BerryEffectsProcessor.applyDamageReduction(berry, damage, moveType)
    if not berry or not berry.effect or not damage then
        return damage
    end
    
    local effect = berry.effect
    
    if effect.type == "resist_type_damage" then
        -- Type-resist berries reduce super-effective damage by specified amount
        if effect.resistType == moveType then
            return math.floor(damage * effect.damageReduction)
        end
    elseif effect.type == "heal_after_super_effective" then
        -- ENIGMA_BERRY doesn't reduce damage, just triggers healing
        return damage
    end
    
    return damage
end

--[[
Apply healing after super-effective hit (ENIGMA_BERRY)
@param berry table - Berry data from database
@param pokemon table - Pokemon receiving the effect
@return table - Updated pokemon data
--]]
function BerryEffectsProcessor.applyPostDamageHealing(berry, pokemon)
    if not berry or not berry.effect or not pokemon then
        return pokemon
    end
    
    local effect = berry.effect
    
    if effect.type == "heal_after_super_effective" then
        local healAmount = math.floor(pokemon.maxHp * effect.amount)
        local newHp = math.min(pokemon.maxHp, pokemon.hp + healAmount)
        
        return {
            id = pokemon.id,
            hp = newHp,
            maxHp = pokemon.maxHp,
            statusEffect = pokemon.statusEffect,
            stats = pokemon.stats,
            heldItem = nil,  -- Berry is consumed
            healedAmount = healAmount,
            berryActivated = berry.id
        }
    end
    
    return pokemon
end

--[[
Process berry activation for a Pokemon
@param pokemon table - Pokemon data
@param activationContext table - Context for berry activation
@return table - Processing result with updated pokemon data
--]]
function BerryEffectsProcessor.processBerryActivation(pokemon, activationContext)
    if not pokemon or not pokemon.heldItem then
        return {
            success = false,
            pokemon = pokemon,
            message = "No held item"
        }
    end
    
    local berry = BerryDatabase.getBerry(pokemon.heldItem)
    if not berry then
        return {
            success = false,
            pokemon = pokemon,
            message = "Held item is not a berry"
        }
    end
    
    local context = activationContext or {}
    local shouldActivate = false
    
    -- Check activation conditions
    if berry.activationCondition == BerryDatabase.ActivationCondition.HP_25_PERCENT or
       berry.activationCondition == BerryDatabase.ActivationCondition.HP_50_PERCENT then
        shouldActivate = BerryEffectsProcessor.shouldActivateHpBerry(berry, pokemon.hp, pokemon.maxHp)
    elseif berry.activationCondition == BerryDatabase.ActivationCondition.STATUS_INFLICTED then
        shouldActivate = BerryEffectsProcessor.shouldActivateStatusBerry(berry, context.statusCondition)
    elseif berry.activationCondition == BerryDatabase.ActivationCondition.STAT_LOWERED then
        shouldActivate = BerryEffectsProcessor.shouldActivateStatBerry(berry, context.statChanges)
    elseif berry.activationCondition == BerryDatabase.ActivationCondition.SUPER_EFFECTIVE_HIT then
        shouldActivate = BerryEffectsProcessor.shouldActivateDamageReduceBerry(berry, context.moveType, context.defenderTypes, context.effectiveness)
    elseif berry.activationCondition == BerryDatabase.ActivationCondition.PP_DEPLETED then
        shouldActivate = context.ppDepleted == true
    elseif berry.activationCondition == BerryDatabase.ActivationCondition.IMMEDIATE then
        shouldActivate = true
    end
    
    if not shouldActivate then
        return {
            success = false,
            pokemon = pokemon,
            message = "Berry activation conditions not met"
        }
    end
    
    -- Check once-per-battle restriction
    if berry.oncePerBattle and context.activatedBerries and context.activatedBerries[berry.id] then
        return {
            success = false,
            pokemon = pokemon,
            message = "Berry already used this battle"
        }
    end
    
    -- Apply berry effect
    local updatedPokemon = pokemon
    
    if berry.category == BerryDatabase.BerryCategory.HP_RESTORE then
        updatedPokemon = BerryEffectsProcessor.applyHpRestoration(berry, pokemon)
    elseif berry.category == BerryDatabase.BerryCategory.STATUS_CURE then
        updatedPokemon = BerryEffectsProcessor.applyStatusCure(berry, pokemon)
    elseif berry.category == BerryDatabase.BerryCategory.STAT_BOOST or berry.category == BerryDatabase.BerryCategory.PINCH_BERRY then
        updatedPokemon = BerryEffectsProcessor.applyStatBoost(berry, pokemon, context.battleSeed)
    elseif berry.category == BerryDatabase.BerryCategory.DAMAGE_REDUCE then
        updatedPokemon = BerryEffectsProcessor.applyPostDamageHealing(berry, pokemon)
    end
    
    return {
        success = true,
        pokemon = updatedPokemon,
        berryActivated = berry.id,
        berryEffect = berry.effect,
        message = "Berry activated successfully"
    }
end

--[[
Validate berry effects processor data and calculations
@return boolean - True if validation passes
@return table - Validation errors if any
--]]
function BerryEffectsProcessor.validate()
    local errors = {}
    
    -- Validate berry database integration
    local berryValidation, berryErrors = BerryDatabase.validateBerryData()
    if not berryValidation then
        for _, error in ipairs(berryErrors) do
            table.insert(errors, "Berry database: " .. error)
        end
    end
    
    -- Validate crypto module availability
    if not crypto or not crypto.utils or not crypto.utils.randomBytes then
        table.insert(errors, "AO crypto module not properly initialized")
    end
    
    return #errors == 0, errors
end

-- Export processor

-- ===== END MODULE: game-logic.items.berry-effects-processor =====


local BerryActivationManager = {}

-- Battle berry tracking state
local battleBerryState = {}

--[[
Initialize berry activation state for a battle
@param battleId string - Unique battle identifier
@return boolean - Success status
--]]
function BerryActivationManager.initializeBattleState(battleId)
    if not battleId then
        return false
    end
    
    battleBerryState[battleId] = {
        activatedBerries = {},  -- Track once-per-battle berries
        activationQueue = {},   -- Pending berry activations
        recycledBerries = {},   -- Berries available for recycling
        turnActivations = {}    -- Activations for current turn
    }
    
    return true
end

--[[
Clear berry activation state for a battle
@param battleId string - Unique battle identifier
@return boolean - Success status
--]]
function BerryActivationManager.clearBattleState(battleId)
    if not battleId then
        return false
    end
    
    battleBerryState[battleId] = nil
    return true
end

--[[
Get battle berry state
@param battleId string - Battle identifier
@return table - Berry state for the battle
--]]
function BerryActivationManager.getBattleState(battleId)
    if not battleId or not battleBerryState[battleId] then
        return nil
    end
    
    return battleBerryState[battleId]
end

--[[
Monitor HP changes and trigger berry activation
@param battleId string - Battle identifier
@param pokemon table - Pokemon data
@param previousHp number - HP before change
@return table - Activation result
--]]
function BerryActivationManager.monitorHpChange(battleId, pokemon, previousHp)
    if not battleId or not pokemon or not pokemon.heldItem then
        return { success = false, message = "Invalid parameters" }
    end
    
    local berry = BerryDatabase.getBerry(pokemon.heldItem)
    if not berry then
        return { success = false, message = "No berry held" }
    end
    
    -- Check if HP threshold berry should activate
    local shouldActivate = false
    local currentHpPercent = BerryEffectsProcessor.calculateHpPercentage(pokemon.hp, pokemon.maxHp)
    local previousHpPercent = BerryEffectsProcessor.calculateHpPercentage(previousHp, pokemon.maxHp)
    
    -- Check if we crossed an activation threshold
    if berry.activationCondition == BerryDatabase.ActivationCondition.HP_25_PERCENT then
        shouldActivate = currentHpPercent <= 0.25 and previousHpPercent > 0.25
    elseif berry.activationCondition == BerryDatabase.ActivationCondition.HP_50_PERCENT then
        shouldActivate = currentHpPercent <= 0.50 and previousHpPercent > 0.50
    end
    
    if shouldActivate then
        return BerryActivationManager.queueBerryActivation(battleId, pokemon, {
            trigger = "hp_threshold",
            previousHp = previousHp,
            currentHp = pokemon.hp
        })
    end
    
    return { success = false, message = "Activation threshold not met" }
end

--[[
Monitor status effect changes and trigger berry activation
@param battleId string - Battle identifier
@param pokemon table - Pokemon data
@param statusCondition string - Newly inflicted status
@return table - Activation result
--]]
function BerryActivationManager.monitorStatusChange(battleId, pokemon, statusCondition)
    if not battleId or not pokemon or not pokemon.heldItem or not statusCondition then
        return { success = false, message = "Invalid parameters" }
    end
    
    local berry = BerryDatabase.getBerry(pokemon.heldItem)
    if not berry then
        return { success = false, message = "No berry held" }
    end
    
    -- Check if status-curing berry should activate
    local shouldActivate = BerryEffectsProcessor.shouldActivateStatusBerry(berry, statusCondition)
    
    if shouldActivate then
        return BerryActivationManager.queueBerryActivation(battleId, pokemon, {
            trigger = "status_inflicted",
            statusCondition = statusCondition
        })
    end
    
    return { success = false, message = "Berry does not cure this status" }
end

--[[
Monitor stat changes and trigger berry activation
@param battleId string - Battle identifier
@param pokemon table - Pokemon data
@param statChanges table - Stat modifications applied
@return table - Activation result
--]]
function BerryActivationManager.monitorStatChange(battleId, pokemon, statChanges)
    if not battleId or not pokemon or not pokemon.heldItem or not statChanges then
        return { success = false, message = "Invalid parameters" }
    end
    
    local berry = BerryDatabase.getBerry(pokemon.heldItem)
    if not berry then
        return { success = false, message = "No berry held" }
    end
    
    -- Check if stat-boosting berry should activate
    local shouldActivate = BerryEffectsProcessor.shouldActivateStatBerry(berry, statChanges)
    
    if shouldActivate then
        return BerryActivationManager.queueBerryActivation(battleId, pokemon, {
            trigger = "stat_lowered",
            statChanges = statChanges
        })
    end
    
    return { success = false, message = "Berry does not activate on stat changes" }
end

--[[
Monitor super-effective hits and trigger berry activation
@param battleId string - Battle identifier
@param pokemon table - Pokemon data (defender)
@param moveType string - Type of attacking move
@param effectiveness number - Type effectiveness multiplier
@param damage number - Damage amount
@return table - Activation result
--]]
function BerryActivationManager.monitorSuperEffectiveHit(battleId, pokemon, moveType, effectiveness, damage)
    if not battleId or not pokemon or not pokemon.heldItem then
        return { success = false, message = "Invalid parameters" }
    end
    
    local berry = BerryDatabase.getBerry(pokemon.heldItem)
    if not berry then
        return { success = false, message = "No berry held" }
    end
    
    -- Check if damage-reducing berry should activate
    local shouldActivate = BerryEffectsProcessor.shouldActivateDamageReduceBerry(
        berry, moveType, pokemon.types, effectiveness
    )
    
    if shouldActivate then
        -- Check once-per-battle restriction
        local state = BerryActivationManager.getBattleState(battleId)
        if state and berry.oncePerBattle and state.activatedBerries[berry.id] then
            return { success = false, message = "Berry already used this battle" }
        end
        
        return BerryActivationManager.queueBerryActivation(battleId, pokemon, {
            trigger = "super_effective_hit",
            moveType = moveType,
            effectiveness = effectiveness,
            damage = damage,
            defenderTypes = pokemon.types
        })
    end
    
    return { success = false, message = "Berry does not activate on this attack type" }
end

--[[
Monitor PP depletion and trigger berry activation
@param battleId string - Battle identifier
@param pokemon table - Pokemon data
@param moveId string - Move that ran out of PP
@return table - Activation result
--]]
function BerryActivationManager.monitorPpDepletion(battleId, pokemon, moveId)
    if not battleId or not pokemon or not pokemon.heldItem or not moveId then
        return { success = false, message = "Invalid parameters" }
    end
    
    local berry = BerryDatabase.getBerry(pokemon.heldItem)
    if not berry or berry.id ~= "LEPPA_BERRY" then
        return { success = false, message = "No Leppa Berry held" }
    end
    
    return BerryActivationManager.queueBerryActivation(battleId, pokemon, {
        trigger = "pp_depleted",
        moveId = moveId,
        ppDepleted = true
    })
end

--[[
Queue berry activation for processing
@param battleId string - Battle identifier
@param pokemon table - Pokemon data
@param context table - Activation context
@return table - Queue result
--]]
function BerryActivationManager.queueBerryActivation(battleId, pokemon, context)
    if not battleId or not pokemon then
        return { success = false, message = "Invalid parameters" }
    end
    
    local state = BerryActivationManager.getBattleState(battleId)
    if not state then
        BerryActivationManager.initializeBattleState(battleId)
        state = BerryActivationManager.getBattleState(battleId)
    end
    
    local activation = {
        pokemonId = pokemon.id,
        berryId = pokemon.heldItem,
        context = context,
        priority = BerryActivationManager.getActivationPriority(pokemon.heldItem, context),
        timestamp = os.time()
    }
    
    table.insert(state.activationQueue, activation)
    
    -- Sort queue by priority (higher priority first)
    table.sort(state.activationQueue, function(a, b)
        return a.priority > b.priority
    end)
    
    return {
        success = true,
        message = "Berry activation queued",
        activation = activation
    }
end

--[[
Get activation priority for berry type
@param berryId string - Berry identifier
@param context table - Activation context
@return number - Priority value (higher = more priority)
--]]
function BerryActivationManager.getActivationPriority(berryId, context)
    local berry = BerryDatabase.getBerry(berryId)
    if not berry then
        return 0
    end
    
    -- Priority order:
    -- 1. Status curing berries (highest priority)
    -- 2. HP restoration berries
    -- 3. Stat boosting berries
    -- 4. Damage reducing berries
    -- 5. PP restoration berries (lowest priority)
    
    if berry.category == BerryDatabase.BerryCategory.STATUS_CURE then
        return 100
    elseif berry.category == BerryDatabase.BerryCategory.HP_RESTORE then
        return 80
    elseif berry.category == BerryDatabase.BerryCategory.STAT_BOOST or berry.category == BerryDatabase.BerryCategory.PINCH_BERRY then
        return 60
    elseif berry.category == BerryDatabase.BerryCategory.DAMAGE_REDUCE or berry.category == BerryDatabase.BerryCategory.TYPE_RESIST then
        return 40
    elseif berry.category == BerryDatabase.BerryCategory.PP_RESTORE then
        return 20
    end
    
    return 10
end

--[[
Process all queued berry activations for a battle turn
@param battleId string - Battle identifier
@param battleSeed string - Deterministic seed for battle
@return table - Processing results
--]]
function BerryActivationManager.processActivationQueue(battleId, battleSeed)
    if not battleId then
        return { success = false, message = "Invalid battle ID" }
    end
    
    local state = BerryActivationManager.getBattleState(battleId)
    if not state or #state.activationQueue == 0 then
        return { success = true, message = "No activations to process", activations = {} }
    end
    
    local results = {
        success = true,
        activations = {},
        errors = {}
    }
    
    -- Process each activation in priority order
    for _, activation in ipairs(state.activationQueue) do
        local pokemon = BerryActivationManager.getPokemonFromBattle(battleId, activation.pokemonId)
        if pokemon then
            -- Create activation context
            local activationContext = activation.context or {}
            activationContext.battleSeed = battleSeed
            activationContext.activatedBerries = state.activatedBerries
            
            -- Process berry activation
            local result = BerryEffectsProcessor.processBerryActivation(pokemon, activationContext)
            
            if result.success then
                -- Mark berry as activated for once-per-battle tracking
                local berry = BerryDatabase.getBerry(activation.berryId)
                if berry and berry.oncePerBattle then
                    state.activatedBerries[berry.id] = true
                end
                
                -- Store consumed berry for potential recycling
                if result.pokemon and not result.pokemon.heldItem then
                    table.insert(state.recycledBerries, {
                        berryId = activation.berryId,
                        pokemonId = activation.pokemonId,
                        consumedTurn = state.currentTurn or 1
                    })
                end
                
                table.insert(results.activations, {
                    pokemonId = activation.pokemonId,
                    berryId = activation.berryId,
                    effect = result.berryEffect,
                    updatedPokemon = result.pokemon
                })
            else
                table.insert(results.errors, {
                    pokemonId = activation.pokemonId,
                    berryId = activation.berryId,
                    error = result.message
                })
            end
        else
            table.insert(results.errors, {
                pokemonId = activation.pokemonId,
                berryId = activation.berryId,
                error = "Pokemon not found in battle"
            })
        end
    end
    
    -- Clear processed activations
    state.activationQueue = {}
    state.turnActivations = results.activations
    
    return results
end

--[[
Handle berry recycling through moves or abilities
@param battleId string - Battle identifier
@param pokemonId string - Pokemon receiving recycled berry
@param recycleType string - "move" or "ability"
@return table - Recycling result
--]]
function BerryActivationManager.recycleBerry(battleId, pokemonId, recycleType)
    if not battleId or not pokemonId then
        return { success = false, message = "Invalid parameters" }
    end
    
    local state = BerryActivationManager.getBattleState(battleId)
    if not state or #state.recycledBerries == 0 then
        return { success = false, message = "No berries available for recycling" }
    end
    
    -- Find most recently consumed berry for this Pokemon
    local recycledBerry = nil
    local recycleIndex = nil
    
    for i = #state.recycledBerries, 1, -1 do
        local berry = state.recycledBerries[i]
        if berry.pokemonId == pokemonId then
            recycledBerry = berry
            recycleIndex = i
            break
        end
    end
    
    if not recycledBerry then
        return { success = false, message = "No berries consumed by this Pokemon" }
    end
    
    -- Remove from recycled berries list
    table.remove(state.recycledBerries, recycleIndex)
    
    -- Get Pokemon and update held item
    local pokemon = BerryActivationManager.getPokemonFromBattle(battleId, pokemonId)
    if not pokemon then
        return { success = false, message = "Pokemon not found" }
    end
    
    -- Pokemon must not already have a held item
    if pokemon.heldItem then
        return { success = false, message = "Pokemon already holding an item" }
    end
    
    return {
        success = true,
        message = "Berry recycled successfully",
        pokemonId = pokemonId,
        berryId = recycledBerry.berryId,
        recycleType = recycleType
    }
end

--[[
Get turn summary of berry activations
@param battleId string - Battle identifier
@return table - Turn berry activation summary
--]]
function BerryActivationManager.getTurnSummary(battleId)
    if not battleId then
        return { success = false, message = "Invalid battle ID" }
    end
    
    local state = BerryActivationManager.getBattleState(battleId)
    if not state then
        return { success = false, message = "Battle state not found" }
    end
    
    return {
        success = true,
        activations = state.turnActivations or {},
        activatedThisBattle = state.activatedBerries,
        availableForRecycling = state.recycledBerries,
        queuedActivations = #state.activationQueue
    }
end

--[[
Mock function to get Pokemon from battle (would be implemented by battle system)
@param battleId string - Battle identifier
@param pokemonId string - Pokemon identifier
@return table - Pokemon data
--]]
function BerryActivationManager.getPokemonFromBattle(battleId, pokemonId)
    -- This would be implemented by the battle system
    -- For now, return a mock Pokemon for testing
    return {
        id = pokemonId,
        hp = 50,
        maxHp = 100,
        statusEffect = nil,
        stats = {},
        heldItem = "SITRUS_BERRY",
        types = {"normal"}
    }
end

--[[
Validate berry activation manager state and data
@return boolean - True if validation passes
@return table - Validation errors if any
--]]
function BerryActivationManager.validate()
    local errors = {}
    
    -- Validate berry effects processor integration
    local processorValidation, processorErrors = BerryEffectsProcessor.validate()
    if not processorValidation then
        for _, error in ipairs(processorErrors) do
            table.insert(errors, "Berry processor: " .. error)
        end
    end
    
    -- Validate battle state structure
    for battleId, state in pairs(battleBerryState) do
        if not state.activatedBerries or type(state.activatedBerries) ~= "table" then
            table.insert(errors, "Invalid activatedBerries for battle " .. battleId)
        end
        
        if not state.activationQueue or type(state.activationQueue) ~= "table" then
            table.insert(errors, "Invalid activationQueue for battle " .. battleId)
        end
        
        if not state.recycledBerries or type(state.recycledBerries) ~= "table" then
            table.insert(errors, "Invalid recycledBerries for battle " .. battleId)
        end
    end
    
    return #errors == 0, errors
end

-- Export activation manager

-- ===== END MODULE: game-logic.items.berry-activation-manager =====


-- ===== MODULE: game-logic.items.berry-effects-processor =====
-- File: ao-processes/game-logic/items/berry-effects-processor.lua
-- Original require: local BerryEffectsProcessor = require("game-logic.items.berry-effects-processor")


-- ===== END MODULE: game-logic.items.berry-effects-processor =====


local DamageCalculator = {}

-- Damage calculation constants (matching TypeScript implementation)
local DAMAGE_CONSTANTS = {
    BASE_LEVEL_MULTIPLIER = 2,
    LEVEL_DIVISOR = 5,
    LEVEL_ADD = 2,
    FORMULA_DIVISOR = 50,
    FORMULA_ADD = 2,
    STAB_MULTIPLIER = 1.5,
    CRITICAL_MULTIPLIER = 1.5,
    VARIANCE_MIN = 0.85,
    VARIANCE_MAX = 1.0,
    STAT_STAGE_NUMERATORS = {2, 2, 2, 2, 2, 2, 2, 3, 4},  -- -6 to +6 (index 1-13, with 7 = neutral)
    STAT_STAGE_DENOMINATORS = {8, 7, 6, 5, 4, 3, 2, 2, 2},
    -- Spread move damage reduction constants
    SPREAD_DAMAGE_REDUCTION = 0.75, -- Standard 25% reduction for spread moves
    MIN_SPREAD_DAMAGE = 1 -- Minimum damage for spread moves
}

-- Weather damage multipliers
local WEATHER_MULTIPLIERS = {
    RAIN = {
        [Enums.PokemonType.WATER] = 1.5,
        [Enums.PokemonType.FIRE] = 0.5
    },
    SUN = {
        [Enums.PokemonType.FIRE] = 1.5,
        [Enums.PokemonType.WATER] = 0.5
    },
    SANDSTORM = {
        -- No direct damage multipliers, handled elsewhere
    },
    HAIL = {
        -- No direct damage multipliers, handled elsewhere  
    }
}

-- Calculate base damage using exact TypeScript formula
-- Formula: ((2 * Level / 5 + 2) * Power * A / D / 50 + 2)
-- @param level: Pokemon level (1-100)
-- @param power: Move power
-- @param attack: Effective attack stat
-- @param defense: Effective defense stat
-- @return: Base damage (integer)
local function calculateBaseDamage(level, power, attack, defense)
    if not level or not power or not attack or not defense then
        error("Base damage calculation requires level, power, attack, and defense")
    end
    
    if power <= 0 or attack <= 0 or defense <= 0 then
        return 0
    end
    
    -- Exact TypeScript formula implementation using Math.floor equivalents
    -- Formula: ((2 * Level / 5 + 2) * Power * A / D / 50 + 2)
    local levelComponent = math.floor((DAMAGE_CONSTANTS.BASE_LEVEL_MULTIPLIER * level) / DAMAGE_CONSTANTS.LEVEL_DIVISOR) + DAMAGE_CONSTANTS.LEVEL_ADD
    local powerComponent = levelComponent * power
    local attackDefenseRatio = math.floor((powerComponent * attack) / defense)
    local finalComponent = math.floor(attackDefenseRatio / DAMAGE_CONSTANTS.FORMULA_DIVISOR)
    local baseDamage = finalComponent + DAMAGE_CONSTANTS.FORMULA_ADD
    
    return math.max(1, baseDamage)  -- Minimum 1 damage
end

-- Get effective attack or defense stat with stat stage modifications
-- @param baseStat: Base stat value
-- @param statStage: Stat stage modification (-6 to +6)
-- @return: Effective stat after modifications
local function getEffectiveStat(baseStat, statStage)
    if not baseStat then
        error("Effective stat calculation requires base stat")
    end
    
    statStage = statStage or 0
    
    -- Clamp stat stage to valid range
    statStage = math.max(-6, math.min(6, statStage))
    
    -- Convert to array index (0 = index 7, -6 = index 1, +6 = index 13)
    local index = statStage + 7
    
    local numerator = DAMAGE_CONSTANTS.STAT_STAGE_NUMERATORS[index]
    local denominator = DAMAGE_CONSTANTS.STAT_STAGE_DENOMINATORS[index]
    
    return math.floor((baseStat * numerator) / denominator)
end

-- Calculate critical hit damage
-- @param baseDamage: Base damage before critical hit
-- @param criticalHit: Boolean indicating if move is critical hit
-- @return: Damage after critical hit multiplier
local function applyCriticalHit(baseDamage, criticalHit)
    if not criticalHit then
        return baseDamage
    end
    
    return math.floor(baseDamage * DAMAGE_CONSTANTS.CRITICAL_MULTIPLIER)
end

-- Check if move gets STAB (Same Type Attack Bonus)
-- @param moveType: Type of the move being used
-- @param pokemonTypes: Array of Pokemon types or single type
-- @return: Boolean indicating if STAB applies
local function checkSTAB(moveType, pokemonTypes)
    if not moveType or not pokemonTypes then
        return false
    end
    
    -- Convert single type to array
    if type(pokemonTypes) ~= "table" then
        pokemonTypes = {pokemonTypes}
    end
    
    -- Check if move type matches any Pokemon type
    for _, pokemonType in ipairs(pokemonTypes) do
        if pokemonType == moveType then
            return true
        end
    end
    
    return false
end

-- Apply STAB multiplier to damage
-- @param damage: Damage before STAB
-- @param hasSTAB: Boolean indicating if STAB applies
-- @return: Damage after STAB multiplier
local function applySTAB(damage, hasSTAB)
    if not hasSTAB then
        return damage
    end
    
    return math.floor(damage * DAMAGE_CONSTANTS.STAB_MULTIPLIER)
end

-- Apply weather effects to damage
-- @param damage: Damage before weather effects
-- @param moveType: Type of the move
-- @param weather: Current weather condition
-- @return: Damage after weather multiplier
local function applyWeatherEffects(damage, moveType, weather)
    if not weather or not moveType then
        return damage
    end
    
    local weatherMultipliers = WEATHER_MULTIPLIERS[weather]
    if not weatherMultipliers then
        return damage
    end
    
    local multiplier = weatherMultipliers[moveType]
    if not multiplier then
        return damage
    end
    
    return math.floor(damage * multiplier)
end

-- Apply random damage variance (85%-100%)
-- @param damage: Damage before variance
-- @return: Final damage after random variance
local function applyDamageVariance(damage)
    if damage <= 0 then
        return 0
    end
    
    -- Generate random multiplier between 85% and 100%
    local randomMultiplier = BattleRNG.randomFloat() * (DAMAGE_CONSTANTS.VARIANCE_MAX - DAMAGE_CONSTANTS.VARIANCE_MIN) + DAMAGE_CONSTANTS.VARIANCE_MIN
    
    return math.max(1, math.floor(damage * randomMultiplier))
end

-- Determine if move results in critical hit
-- @param criticalHitRatio: Critical hit stage (0-4, higher = more likely)
-- @param pokemon: Pokemon data (for abilities/items that affect crit rate)
-- @return: Boolean indicating critical hit
local function determineCriticalHit(criticalHitRatio, pokemon)
    criticalHitRatio = criticalHitRatio or 0
    
    -- Critical hit thresholds based on ratio (matching TypeScript)
    local criticalThresholds = {16, 8, 2, 1, 1}  -- Indices 1-5 for ratios 0-4
    
    local thresholdIndex = math.min(criticalHitRatio + 1, 5)
    local threshold = criticalThresholds[thresholdIndex]
    
    return BattleRNG.criticalHit(threshold)
end

-- Apply ability effects to damage calculation
-- @param damage: Current damage
-- @param attacker: Attacking Pokemon data
-- @param defender: Defending Pokemon data  
-- @param moveData: Move data
-- @param battleState: Current battle state
-- @return: Damage after ability modifications
local function applyAbilityEffects(damage, attacker, defender, moveData, battleState)
    -- Integration point for ability system
    -- This will be expanded when ability processing is integrated
    return damage
end

-- Apply item effects to damage calculation
-- @param damage: Current damage
-- @param attacker: Attacking Pokemon data
-- @param defender: Defending Pokemon data
-- @param moveData: Move data
-- @param battleState: Current battle state  
-- @return: Damage after item modifications
local function applyItemEffects(damage, attacker, defender, moveData, battleState)
    -- Integration point for item system
    -- This will be expanded when item processing is integrated
    return damage
end

-- Main damage calculation function
-- @param params: Table containing all damage calculation parameters
--   - attacker: Pokemon using the move
--   - defender: Pokemon receiving damage
--   - moveData: Data about the move being used
--   - battleState: Current battle conditions
--   - options: Optional parameters (criticalHitForced, etc.)
-- @return: Table with damage result and calculation details
function DamageCalculator.calculateDamage(params)
    if not params or not params.attacker or not params.defender or not params.moveData then
        error("Damage calculation requires attacker, defender, and moveData")
    end
    
    local attacker = params.attacker
    local defender = params.defender
    local moveData = params.moveData
    local battleState = params.battleState or {}
    local options = params.options or {}
    
    -- Check for status moves (no damage)
    if moveData.category == Enums.MoveCategory.STATUS then
        return {
            damage = 0,
            criticalHit = false,
            typeEffectiveness = 1.0,
            details = {
                reason = "Status move deals no damage"
            }
        }
    end
    
    -- Check for zero power moves
    if not moveData.power or moveData.power <= 0 then
        return {
            damage = 0,
            criticalHit = false,
            typeEffectiveness = 1.0,
            details = {
                reason = "Move has no power"
            }
        }
    end
    
    -- Determine if critical hit occurs
    local criticalHit = options.criticalHitForced or determineCriticalHit(moveData.criticalHitRatio or 0, attacker)
    
    -- Get effective stats with stat stage modifications
    local attackStat = getEffectiveStat(
        moveData.category == Enums.MoveCategory.SPECIAL and attacker.stats.special_attack or attacker.stats.attack,
        moveData.category == Enums.MoveCategory.SPECIAL and (attacker.statStages.special_attack or 0) or (attacker.statStages.attack or 0)
    )
    
    local defenseStat = getEffectiveStat(
        moveData.category == Enums.MoveCategory.SPECIAL and defender.stats.special_defense or defender.stats.defense,
        moveData.category == Enums.MoveCategory.SPECIAL and (defender.statStages.special_defense or 0) or (defender.statStages.defense or 0)
    )
    
    -- Calculate base damage
    local baseDamage = calculateBaseDamage(attacker.level, moveData.power, attackStat, defenseStat)
    
    -- Apply critical hit
    baseDamage = applyCriticalHit(baseDamage, criticalHit)
    
    -- Apply STAB
    local hasSTAB = checkSTAB(moveData.type, attacker.types)
    baseDamage = applySTAB(baseDamage, hasSTAB)
    
    -- Calculate type effectiveness
    local typeEffectiveness = TypeChart.getAttackTypeEffectiveness(moveData.type, defender.types)
    baseDamage = math.floor(baseDamage * typeEffectiveness)
    
    -- Apply weather effects
    baseDamage = applyWeatherEffects(baseDamage, moveData.type, battleState.weather)
    
    -- Apply ability effects
    baseDamage = applyAbilityEffects(baseDamage, attacker, defender, moveData, battleState)
    
    -- Apply item effects
    baseDamage = applyItemEffects(baseDamage, attacker, defender, moveData, battleState)
    
    -- Apply random damage variance (only if not predetermined)
    local finalDamage = baseDamage
    if not options.skipVariance then
        finalDamage = applyDamageVariance(baseDamage)
    end
    
    return {
        damage = finalDamage,
        baseDamage = baseDamage,
        criticalHit = criticalHit,
        typeEffectiveness = typeEffectiveness,
        hasSTAB = hasSTAB,
        details = {
            attackStat = attackStat,
            defenseStat = defenseStat,
            level = attacker.level,
            power = moveData.power,
            weather = battleState.weather
        }
    }
end

-- Calculate damage range for move analysis
-- @param params: Same parameters as calculateDamage
-- @return: Table with minimum and maximum damage values
function DamageCalculator.calculateDamageRange(params)
    if not params then
        return {min = 0, max = 0}
    end
    
    -- Calculate with minimum variance (85%)
    local minParams = {}
    for k, v in pairs(params) do
        minParams[k] = v
    end
    minParams.options = minParams.options or {}
    minParams.options.skipVariance = true
    
    local baseResult = DamageCalculator.calculateDamage(minParams)
    local baseDamage = baseResult.baseDamage
    
    local minDamage = math.max(1, math.floor(baseDamage * DAMAGE_CONSTANTS.VARIANCE_MIN))
    local maxDamage = baseDamage
    
    return {
        min = minDamage,
        max = maxDamage,
        criticalHit = baseResult.criticalHit,
        typeEffectiveness = baseResult.typeEffectiveness
    }
end

-- Check if attack hits (accuracy calculation)
-- @param moveData: Move data with accuracy
-- @param attacker: Pokemon using the move
-- @param defender: Pokemon being targeted
-- @param battleState: Current battle state
-- @return: Boolean indicating if move hits
function DamageCalculator.checkAccuracy(moveData, attacker, defender, battleState)
    if not moveData.accuracy then
        return true  -- Always hits if no accuracy specified
    end
    
    -- Get effective accuracy with stat stage modifications
    local accuracyStage = (attacker.statStages and attacker.statStages.accuracy) or 0
    local evasionStage = (defender.statStages and defender.statStages.evasion) or 0
    
    -- Calculate effective accuracy
    local netStage = accuracyStage - evasionStage
    netStage = math.max(-6, math.min(6, netStage))
    
    local stageIndex = netStage + 7
    local numerator = DAMAGE_CONSTANTS.STAT_STAGE_NUMERATORS[stageIndex]
    local denominator = DAMAGE_CONSTANTS.STAT_STAGE_DENOMINATORS[stageIndex]
    
    local effectiveAccuracy = math.floor((moveData.accuracy * numerator) / denominator)
    
    -- Roll for accuracy
    return BattleRNG.accuracy(effectiveAccuracy)
end


-- ===== END MODULE: battle.components.damage-calculator =====


-- ===== MODULE: battle.components.turn-processor =====
-- File: ao-processes/battle/components/turn-processor.lua
-- Original require: local TurnProcessor = require("battle.components.turn-processor")

-- Battle Process Turn Processor
-- Extracted from game-logic.battle.turn-processor for dedicated battle process
-- Maintains exact turn resolution logic with priority calculation and battle phases
-- Epic 32.3: Battle Engine Process Extraction

local TurnProcessor = {}

-- Load dependencies

-- ===== MODULE: game-logic.battle.priority-calculator =====
-- File: ao-processes/game-logic/battle/priority-calculator.lua
-- Original require: local PriorityCalculator = require("game-logic.battle.priority-calculator")

-- Priority Calculator
-- Handles move priority and turn order calculation for Pokemon battles
-- Implements exact TypeScript priority system with proper speed tie resolution
-- Integrates with battle system for turn order processing

local PriorityCalculator = {}

-- Load dependencies for move data and Pokemon stats

-- ===== MODULE: data.moves.move-database =====
-- File: ao-processes/data/moves/move-database.lua
-- Original require: local MoveDatabase = require("data.moves.move-database")

-- Complete Move Database
-- Comprehensive database of all 900+ moves with power, accuracy, PP, type, and effects
-- Provides centralized move data matching TypeScript reference implementation
-- Enables complete move mechanics for AO battle system

local MoveDatabase = {}

-- Move data structure following TypeScript Move class pattern
-- Each move contains: id, name, power, accuracy, pp, type, category, target, priority, flags, effects
MoveDatabase.moves = {}

-- Move indexing for fast lookups
MoveDatabase.movesByType = {}
MoveDatabase.movesByCategory = {}
MoveDatabase.movesByPower = {}
MoveDatabase.movesByTarget = {}
MoveDatabase.movesByFlags = {}

-- Flag constants for move properties
-- These represent binary flags for move characteristics
local MOVE_FLAGS = {
    CONTACT = 1,        -- Move makes physical contact
    PROTECT = 2,        -- Can be blocked by Protect
    MAGIC_COAT = 4,     -- Can be reflected by Magic Coat
    SOUND = 8,          -- Sound-based move
    AUTHENTIC = 16,     -- Bypasses Substitute
    POWDER = 32,        -- Powder/spore move
    BITE = 64,          -- Biting move (Iron Jaw boost)
    PUNCH = 128,        -- Punching move (Iron Fist boost)
    SLICING = 256,      -- Slicing move (Sharpness boost)
    PULSE = 512,        -- Pulse move (Mega Launcher boost)
    BALLISTIC = 1024,   -- Ballistic move (blocked by Bulletproof)
    DANCE = 2048,       -- Dance move (Dancer copy)
    WIND = 4096,        -- Wind move (Wind Power/Rider boost)
    HEALING = 8192,     -- Healing move (blocked by Heal Block)
    MENTAL = 16384,     -- Mental move (bypasses Queenly Majesty)
    NON_SKY_BATTLE = 32768 -- Cannot be used in Sky Battle
}

-- Type constants
local TYPES = {
    NORMAL = 0, FIGHTING = 1, FLYING = 2, POISON = 3, GROUND = 4,
    ROCK = 5, BUG = 6, GHOST = 7, STEEL = 8, FIRE = 9,
    WATER = 10, GRASS = 11, ELECTRIC = 12, PSYCHIC = 13, ICE = 14,
    DRAGON = 15, DARK = 16, FAIRY = 17, STELLAR = 18
}

-- Move categories
local CATEGORIES = {
    PHYSICAL = 0,
    SPECIAL = 1,
    STATUS = 2
}

-- Move targets
local TARGETS = {
    SPECIFIC_MOVE = 0,      -- Used by moves like Counter, Mirror Coat
    SELECTED = 1,           -- Single target selected by player
    RANDOM = 2,             -- Random opponent
    BOTH_FOES = 3,          -- Both opposing Pokemon
    USER = 4,               -- Self-targeting
    BOTH = 5,               -- User and partner
    USER_SIDE = 6,          -- User's side
    ALL = 7,                -- All Pokemon
    ALL_NEAR_OTHERS = 8,    -- All adjacent Pokemon (not user)
    SELECTED_POKEMON = 9,   -- Specific Pokemon (for Curse)
    ALL_OPPONENTS = 10,     -- All opposing Pokemon
    ENTIRE_FIELD = 11,      -- Entire field
    USER_OR_NEAR_ALLY = 12, -- User or ally
    NEAR_ENEMY = 13,        -- Adjacent opponent
    BOTH_SIDES = 14         -- Both sides
}

-- Initialize move database with all moves from Generation 1-9
function MoveDatabase.init()
    -- Clear existing data
    MoveDatabase.moves = {}
    MoveDatabase.movesByType = {}
    MoveDatabase.movesByCategory = {}
    MoveDatabase.movesByPower = {}
    MoveDatabase.movesByTarget = {}
    MoveDatabase.movesByFlags = {}
    
    -- Complete move definitions covering all generations
    -- Format: {id, name, type, category, power, accuracy, pp, target, priority, flags, effects}
    local moveDefinitions = {
        -- Generation 1 Moves (1-165)
        {0, "None", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 0, TARGETS.USER, 0, {}, {}},
        {1, "Pound", TYPES.NORMAL, CATEGORIES.PHYSICAL, 40, 100, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {2, "Karate Chop", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 50, 100, 25, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {high_crit = true}},
        {3, "Double Slap", TYPES.NORMAL, CATEGORIES.PHYSICAL, 15, 85, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {multi_hit = {2, 5}}},
        {4, "Comet Punch", TYPES.NORMAL, CATEGORIES.PHYSICAL, 18, 85, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {multi_hit = {2, 5}}},
        {5, "Mega Punch", TYPES.NORMAL, CATEGORIES.PHYSICAL, 80, 85, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {}},
        {6, "Pay Day", TYPES.NORMAL, CATEGORIES.PHYSICAL, 40, 100, 20, TARGETS.SELECTED, 0, {}, {money_reward = true}},
        {7, "Fire Punch", TYPES.FIRE, CATEGORIES.PHYSICAL, 75, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {burn_chance = 10}},
        {8, "Ice Punch", TYPES.ICE, CATEGORIES.PHYSICAL, 75, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {freeze_chance = 10}},
        {9, "Thunder Punch", TYPES.ELECTRIC, CATEGORIES.PHYSICAL, 75, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {paralysis_chance = 10}},
        {10, "Scratch", TYPES.NORMAL, CATEGORIES.PHYSICAL, 40, 100, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {11, "Vise Grip", TYPES.NORMAL, CATEGORIES.PHYSICAL, 55, 100, 30, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {12, "Guillotine", TYPES.NORMAL, CATEGORIES.PHYSICAL, 1, 30, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {one_hit_ko = true}},
        {13, "Razor Wind", TYPES.NORMAL, CATEGORIES.SPECIAL, 80, 100, 10, TARGETS.BOTH_FOES, 0, {MOVE_FLAGS.WIND}, {charging = true, high_crit = true}},
        {14, "Swords Dance", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER, 0, {MOVE_FLAGS.DANCE}, {stat_change = {attack = 2}}},
        {15, "Cut", TYPES.NORMAL, CATEGORIES.PHYSICAL, 50, 95, 30, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.SLICING}, {}},
        {16, "Gust", TYPES.FLYING, CATEGORIES.SPECIAL, 40, 100, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.WIND}, {hits_flying = true}},
        {17, "Wing Attack", TYPES.FLYING, CATEGORIES.PHYSICAL, 60, 100, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {18, "Whirlwind", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 20, TARGETS.SELECTED, -6, {MOVE_FLAGS.WIND}, {force_switch = true}},
        {19, "Fly", TYPES.FLYING, CATEGORIES.PHYSICAL, 90, 95, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {charging = true, semi_invulnerable = true}},
        {20, "Bind", TYPES.NORMAL, CATEGORIES.PHYSICAL, 15, 85, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {trapping = true}},
        {21, "Slam", TYPES.NORMAL, CATEGORIES.PHYSICAL, 80, 75, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {22, "Vine Whip", TYPES.GRASS, CATEGORIES.PHYSICAL, 45, 100, 25, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {23, "Stomp", TYPES.NORMAL, CATEGORIES.PHYSICAL, 65, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {flinch_chance = 30, stomp = true}},
        {24, "Double Kick", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 30, 100, 30, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {multi_hit = {2, 2}}},
        {25, "Mega Kick", TYPES.NORMAL, CATEGORIES.PHYSICAL, 120, 75, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {26, "Jump Kick", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 100, 95, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {recoil = "crash", crash_damage = 50}},
        {27, "Rolling Kick", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 60, 85, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {flinch_chance = 30}},
        {28, "Sand Attack", TYPES.GROUND, CATEGORIES.STATUS, 0, 100, 15, TARGETS.SELECTED, 0, {}, {stat_change = {accuracy = -1}}},
        {29, "Headbutt", TYPES.NORMAL, CATEGORIES.PHYSICAL, 70, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {flinch_chance = 30}},
        {30, "Horn Attack", TYPES.NORMAL, CATEGORIES.PHYSICAL, 65, 100, 25, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {31, "Fury Attack", TYPES.NORMAL, CATEGORIES.PHYSICAL, 15, 85, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {multi_hit = {2, 5}}},
        {32, "Horn Drill", TYPES.NORMAL, CATEGORIES.PHYSICAL, 1, 30, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {one_hit_ko = true}},
        {33, "Tackle", TYPES.NORMAL, CATEGORIES.PHYSICAL, 40, 100, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {34, "Body Slam", TYPES.NORMAL, CATEGORIES.PHYSICAL, 85, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {paralysis_chance = 30, body_slam = true}},
        {35, "Wrap", TYPES.NORMAL, CATEGORIES.PHYSICAL, 15, 90, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {trapping = true}},
        {36, "Take Down", TYPES.NORMAL, CATEGORIES.PHYSICAL, 90, 85, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {recoil = 25}},
        {37, "Thrash", TYPES.NORMAL, CATEGORIES.PHYSICAL, 120, 100, 10, TARGETS.RANDOM, 0, {MOVE_FLAGS.CONTACT}, {rampage = {2, 3}}},
        {38, "Double-Edge", TYPES.NORMAL, CATEGORIES.PHYSICAL, 120, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {recoil = 33}},
        {39, "Tail Whip", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 30, TARGETS.BOTH_FOES, 0, {}, {stat_change = {defense = -1}}},
        {40, "Poison Sting", TYPES.POISON, CATEGORIES.PHYSICAL, 15, 100, 35, TARGETS.SELECTED, 0, {}, {poison_chance = 30}},
        {41, "Twineedle", TYPES.BUG, CATEGORIES.PHYSICAL, 25, 100, 20, TARGETS.SELECTED, 0, {}, {multi_hit = {2, 2}, poison_chance = 20}},
        {42, "Pin Missile", TYPES.BUG, CATEGORIES.PHYSICAL, 25, 95, 20, TARGETS.SELECTED, 0, {}, {multi_hit = {2, 5}}},
        {43, "Leer", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 30, TARGETS.BOTH_FOES, 0, {}, {stat_change = {defense = -1}}},
        {44, "Bite", TYPES.DARK, CATEGORIES.PHYSICAL, 60, 100, 25, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.BITE}, {flinch_chance = 30}},
        {45, "Growl", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 40, TARGETS.BOTH_FOES, 0, {MOVE_FLAGS.SOUND}, {stat_change = {attack = -1}}},
        {46, "Roar", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 20, TARGETS.SELECTED, -6, {MOVE_FLAGS.SOUND, MOVE_FLAGS.WIND, MOVE_FLAGS.AUTHENTIC}, {force_switch = true}},
        {47, "Sing", TYPES.NORMAL, CATEGORIES.STATUS, 0, 55, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {sleep = true}},
        {48, "Supersonic", TYPES.NORMAL, CATEGORIES.STATUS, 0, 55, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {confuse = true}},
        {49, "Sonic Boom", TYPES.NORMAL, CATEGORIES.SPECIAL, 1, 90, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {fixed_damage = 20}},
        {50, "Disable", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.MENTAL}, {disable = true}},
        
        -- Continue with remaining Gen 1 moves (51-165)...
        {51, "Acid", TYPES.POISON, CATEGORIES.SPECIAL, 40, 100, 30, TARGETS.BOTH_FOES, 0, {}, {stat_change = {sp_defense = -1, chance = 10}}},
        {52, "Ember", TYPES.FIRE, CATEGORIES.SPECIAL, 40, 100, 25, TARGETS.SELECTED, 0, {}, {burn_chance = 10}},
        {53, "Flamethrower", TYPES.FIRE, CATEGORIES.SPECIAL, 90, 100, 15, TARGETS.SELECTED, 0, {}, {burn_chance = 10}},
        {54, "Mist", TYPES.ICE, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER_SIDE, 0, {}, {mist = true}},
        {55, "Water Gun", TYPES.WATER, CATEGORIES.SPECIAL, 40, 100, 25, TARGETS.SELECTED, 0, {}, {}},
        {56, "Hydro Pump", TYPES.WATER, CATEGORIES.SPECIAL, 110, 80, 5, TARGETS.SELECTED, 0, {}, {}},
        {57, "Surf", TYPES.WATER, CATEGORIES.SPECIAL, 90, 100, 15, TARGETS.ALL_NEAR_OTHERS, 0, {}, {}},
        {58, "Ice Beam", TYPES.ICE, CATEGORIES.SPECIAL, 90, 100, 10, TARGETS.SELECTED, 0, {}, {freeze_chance = 10}},
        {59, "Blizzard", TYPES.ICE, CATEGORIES.SPECIAL, 110, 70, 5, TARGETS.BOTH_FOES, 0, {MOVE_FLAGS.WIND}, {freeze_chance = 10}},
        {60, "Psybeam", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 65, 100, 20, TARGETS.SELECTED, 0, {}, {confuse_chance = 10}},
        {61, "Bubble Beam", TYPES.WATER, CATEGORIES.SPECIAL, 65, 100, 20, TARGETS.SELECTED, 0, {}, {stat_change = {speed = -1, chance = 10}}},
        {62, "Aurora Beam", TYPES.ICE, CATEGORIES.SPECIAL, 65, 100, 20, TARGETS.SELECTED, 0, {}, {stat_change = {attack = -1, chance = 10}}},
        {63, "Hyper Beam", TYPES.NORMAL, CATEGORIES.SPECIAL, 150, 90, 5, TARGETS.SELECTED, 0, {}, {recharge = true}},
        {64, "Peck", TYPES.FLYING, CATEGORIES.PHYSICAL, 35, 100, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {65, "Drill Peck", TYPES.FLYING, CATEGORIES.PHYSICAL, 80, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {66, "Submission", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 80, 80, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {recoil = 25}},
        {67, "Low Kick", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 1, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {weight_based = true}},
        {68, "Counter", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 1, 100, 20, TARGETS.SPECIFIC_MOVE, -5, {MOVE_FLAGS.CONTACT}, {counter_physical = true}},
        {69, "Seismic Toss", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 1, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {level_damage = true}},
        {70, "Strength", TYPES.NORMAL, CATEGORIES.PHYSICAL, 80, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {71, "Absorb", TYPES.GRASS, CATEGORIES.SPECIAL, 20, 100, 25, TARGETS.SELECTED, 0, {MOVE_FLAGS.HEALING}, {drain = 50}},
        {72, "Mega Drain", TYPES.GRASS, CATEGORIES.SPECIAL, 40, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.HEALING}, {drain = 50}},
        {73, "Leech Seed", TYPES.GRASS, CATEGORIES.STATUS, 0, 90, 10, TARGETS.SELECTED, 0, {}, {leech_seed = true}},
        {74, "Growth", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER, 0, {}, {stat_change = {attack = 1, sp_attack = 1}}},
        {75, "Razor Leaf", TYPES.GRASS, CATEGORIES.PHYSICAL, 55, 95, 25, TARGETS.BOTH_FOES, 0, {MOVE_FLAGS.SLICING}, {high_crit = true}},
        {76, "Solar Beam", TYPES.GRASS, CATEGORIES.SPECIAL, 120, 100, 10, TARGETS.SELECTED, 0, {}, {charging = true}},
        {77, "Poison Powder", TYPES.GRASS, CATEGORIES.STATUS, 0, 75, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.POWDER}, {poison = true}},
        {78, "Stun Spore", TYPES.GRASS, CATEGORIES.STATUS, 0, 75, 30, TARGETS.SELECTED, 0, {MOVE_FLAGS.POWDER}, {paralyze = true}},
        {79, "Sleep Powder", TYPES.GRASS, CATEGORIES.STATUS, 0, 75, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.POWDER}, {sleep = true}},
        {80, "Petal Dance", TYPES.GRASS, CATEGORIES.SPECIAL, 120, 100, 10, TARGETS.RANDOM, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.DANCE}, {rampage = {2, 3}}},
        {81, "String Shot", TYPES.BUG, CATEGORIES.STATUS, 0, 95, 40, TARGETS.BOTH_FOES, 0, {}, {stat_change = {speed = -2}}},
        {82, "Dragon Rage", TYPES.DRAGON, CATEGORIES.SPECIAL, 1, 100, 10, TARGETS.SELECTED, 0, {}, {fixed_damage = 40}},
        {83, "Fire Spin", TYPES.FIRE, CATEGORIES.SPECIAL, 35, 85, 15, TARGETS.SELECTED, 0, {}, {trapping = true}},
        {84, "Thunder Shock", TYPES.ELECTRIC, CATEGORIES.SPECIAL, 40, 100, 30, TARGETS.SELECTED, 0, {}, {paralysis_chance = 10}},
        {85, "Thunderbolt", TYPES.ELECTRIC, CATEGORIES.SPECIAL, 90, 100, 15, TARGETS.SELECTED, 0, {}, {paralysis_chance = 10}},
        {86, "Thunder Wave", TYPES.ELECTRIC, CATEGORIES.STATUS, 0, 90, 20, TARGETS.SELECTED, 0, {}, {paralyze = true}},
        {87, "Thunder", TYPES.ELECTRIC, CATEGORIES.SPECIAL, 110, 70, 10, TARGETS.SELECTED, 0, {}, {paralysis_chance = 30}},
        {88, "Rock Throw", TYPES.ROCK, CATEGORIES.PHYSICAL, 50, 90, 15, TARGETS.SELECTED, 0, {}, {}},
        {89, "Earthquake", TYPES.GROUND, CATEGORIES.PHYSICAL, 100, 100, 10, TARGETS.ALL_NEAR_OTHERS, 0, {}, {double_damage_underground = true}},
        {90, "Fissure", TYPES.GROUND, CATEGORIES.PHYSICAL, 1, 30, 5, TARGETS.SELECTED, 0, {}, {one_hit_ko = true}},
        {91, "Dig", TYPES.GROUND, CATEGORIES.PHYSICAL, 80, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {charging = true, semi_invulnerable = "underground"}},
        {92, "Toxic", TYPES.POISON, CATEGORIES.STATUS, 0, 90, 10, TARGETS.SELECTED, 0, {}, {badly_poison = true}},
        {93, "Confusion", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 50, 100, 25, TARGETS.SELECTED, 0, {}, {confuse_chance = 10}},
        {94, "Psychic", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 90, 100, 10, TARGETS.SELECTED, 0, {}, {stat_change = {sp_defense = -1, chance = 10}}},
        {95, "Hypnosis", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, 60, 20, TARGETS.SELECTED, 0, {}, {sleep = true}},
        {96, "Meditate", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 40, TARGETS.USER, 0, {}, {stat_change = {attack = 1}}},
        {97, "Agility", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER, 0, {}, {stat_change = {speed = 2}}},
        {98, "Quick Attack", TYPES.NORMAL, CATEGORIES.PHYSICAL, 40, 100, 30, TARGETS.SELECTED, 1, {MOVE_FLAGS.CONTACT}, {}},
        {99, "Rage", TYPES.NORMAL, CATEGORIES.PHYSICAL, 20, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {rage = true}},
        {100, "Teleport", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER, -6, {}, {teleport = true}},
        {101, "Night Shade", TYPES.GHOST, CATEGORIES.SPECIAL, 1, 100, 15, TARGETS.SELECTED, 0, {}, {level_damage = true}},
        {102, "Mimic", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.SELECTED, 0, {}, {mimic = true}},
        {103, "Screech", TYPES.NORMAL, CATEGORIES.STATUS, 0, 85, 40, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {stat_change = {defense = -2}}},
        {104, "Double Team", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 15, TARGETS.USER, 0, {}, {stat_change = {evasion = 1}}},
        {105, "Recover", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 5, TARGETS.USER, 0, {MOVE_FLAGS.HEALING}, {heal = 50}},
        {106, "Harden", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER, 0, {}, {stat_change = {defense = 1}}},
        {107, "Minimize", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 0, {}, {stat_change = {evasion = 2}, minimize = true}},
        {108, "Smokescreen", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 20, TARGETS.SELECTED, 0, {}, {stat_change = {accuracy = -1}}},
        {109, "Confuse Ray", TYPES.GHOST, CATEGORIES.STATUS, 0, 100, 10, TARGETS.SELECTED, 0, {}, {confuse = true}},
        {110, "Withdraw", TYPES.WATER, CATEGORIES.STATUS, 0, -1, 40, TARGETS.USER, 0, {}, {stat_change = {defense = 1}}},
        {111, "Defense Curl", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 40, TARGETS.USER, 0, {}, {stat_change = {defense = 1}, defense_curl = true}},
        {112, "Barrier", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER, 0, {}, {stat_change = {defense = 2}}},
        {113, "Light Screen", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER_SIDE, 0, {}, {light_screen = true}},
        {114, "Haze", TYPES.ICE, CATEGORIES.STATUS, 0, -1, 30, TARGETS.ALL, 0, {}, {haze = true}},
        {115, "Reflect", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER_SIDE, 0, {}, {reflect = true}},
        {116, "Focus Energy", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER, 0, {}, {focus_energy = true}},
        {117, "Bide", TYPES.NORMAL, CATEGORIES.PHYSICAL, 1, -1, 10, TARGETS.USER, 1, {MOVE_FLAGS.CONTACT}, {bide = true}},
        {118, "Metronome", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 0, {}, {metronome = true}},
        {119, "Mirror Move", TYPES.FLYING, CATEGORIES.STATUS, 0, -1, 20, TARGETS.SELECTED, 0, {}, {mirror_move = true}},
        {120, "Self-Destruct", TYPES.NORMAL, CATEGORIES.PHYSICAL, 200, 100, 5, TARGETS.ALL_NEAR_OTHERS, 0, {}, {self_destruct = true}},
        {121, "Egg Bomb", TYPES.NORMAL, CATEGORIES.PHYSICAL, 100, 75, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.BALLISTIC}, {}},
        {122, "Lick", TYPES.GHOST, CATEGORIES.PHYSICAL, 30, 100, 30, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {paralysis_chance = 30}},
        {123, "Smog", TYPES.POISON, CATEGORIES.SPECIAL, 30, 70, 20, TARGETS.SELECTED, 0, {}, {poison_chance = 40}},
        {124, "Sludge", TYPES.POISON, CATEGORIES.SPECIAL, 65, 100, 20, TARGETS.SELECTED, 0, {}, {poison_chance = 30}},
        {125, "Bone Club", TYPES.GROUND, CATEGORIES.PHYSICAL, 65, 85, 20, TARGETS.SELECTED, 0, {}, {flinch_chance = 10}},
        {126, "Fire Blast", TYPES.FIRE, CATEGORIES.SPECIAL, 110, 85, 5, TARGETS.SELECTED, 0, {}, {burn_chance = 10}},
        {127, "Waterfall", TYPES.WATER, CATEGORIES.PHYSICAL, 80, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {flinch_chance = 20}},
        {128, "Clamp", TYPES.WATER, CATEGORIES.PHYSICAL, 35, 85, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {trapping = true}},
        {129, "Swift", TYPES.NORMAL, CATEGORIES.SPECIAL, 60, -1, 20, TARGETS.BOTH_FOES, 0, {}, {}},
        {130, "Skull Bash", TYPES.NORMAL, CATEGORIES.PHYSICAL, 130, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {charging = true, stat_change = {defense = 1}}},
        {131, "Spike Cannon", TYPES.NORMAL, CATEGORIES.PHYSICAL, 20, 100, 15, TARGETS.SELECTED, 0, {}, {multi_hit = {2, 5}}},
        {132, "Constrict", TYPES.NORMAL, CATEGORIES.PHYSICAL, 10, 100, 35, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {stat_change = {speed = -1, chance = 10}}},
        {133, "Amnesia", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER, 0, {}, {stat_change = {sp_defense = 2}}},
        {134, "Kinesis", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, 80, 15, TARGETS.SELECTED, 0, {}, {stat_change = {accuracy = -1}}},
        {135, "Soft-Boiled", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 5, TARGETS.USER, 0, {MOVE_FLAGS.HEALING}, {heal = 50}},
        {136, "High Jump Kick", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 130, 90, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {recoil = "crash", crash_damage = 50}},
        {137, "Glare", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 30, TARGETS.SELECTED, 0, {}, {paralyze = true}},
        {138, "Dream Eater", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 100, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.HEALING}, {dream_eater = true}},
        {139, "Poison Gas", TYPES.POISON, CATEGORIES.STATUS, 0, 90, 40, TARGETS.BOTH_FOES, 0, {}, {poison = true}},
        {140, "Barrage", TYPES.NORMAL, CATEGORIES.PHYSICAL, 15, 85, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.BALLISTIC}, {multi_hit = {2, 5}}},
        {141, "Leech Life", TYPES.BUG, CATEGORIES.PHYSICAL, 80, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.HEALING}, {drain = 50}},
        {142, "Lovely Kiss", TYPES.NORMAL, CATEGORIES.STATUS, 0, 75, 10, TARGETS.SELECTED, 0, {}, {sleep = true}},
        {143, "Sky Attack", TYPES.FLYING, CATEGORIES.PHYSICAL, 140, 90, 5, TARGETS.SELECTED, 0, {}, {charging = true, high_crit = true, flinch_chance = 30}},
        {144, "Transform", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.SELECTED, 0, {}, {transform = true}},
        {145, "Bubble", TYPES.WATER, CATEGORIES.SPECIAL, 40, 100, 30, TARGETS.BOTH_FOES, 0, {}, {stat_change = {speed = -1, chance = 10}}},
        {146, "Dizzy Punch", TYPES.NORMAL, CATEGORIES.PHYSICAL, 70, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {confuse_chance = 20}},
        {147, "Spore", TYPES.GRASS, CATEGORIES.STATUS, 0, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.POWDER}, {sleep = true}},
        {148, "Flash", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 20, TARGETS.SELECTED, 0, {}, {stat_change = {accuracy = -1}}},
        {149, "Psywave", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 1, 100, 15, TARGETS.SELECTED, 0, {}, {psywave = true}},
        {150, "Splash", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 40, TARGETS.USER, 0, {}, {}},
        {151, "Acid Armor", TYPES.POISON, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER, 0, {}, {stat_change = {defense = 2}}},
        {152, "Crabhammer", TYPES.WATER, CATEGORIES.PHYSICAL, 100, 90, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {high_crit = true}},
        {153, "Explosion", TYPES.NORMAL, CATEGORIES.PHYSICAL, 250, 100, 5, TARGETS.ALL_NEAR_OTHERS, 0, {}, {self_destruct = true}},
        {154, "Fury Swipes", TYPES.NORMAL, CATEGORIES.PHYSICAL, 18, 80, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {multi_hit = {2, 5}}},
        {155, "Bonemerang", TYPES.GROUND, CATEGORIES.PHYSICAL, 50, 90, 10, TARGETS.SELECTED, 0, {}, {multi_hit = {2, 2}}},
        {156, "Rest", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 5, TARGETS.USER, 0, {MOVE_FLAGS.HEALING}, {rest = true}},
        {157, "Rock Slide", TYPES.ROCK, CATEGORIES.PHYSICAL, 75, 90, 10, TARGETS.BOTH_FOES, 0, {}, {flinch_chance = 30}},
        {158, "Hyper Fang", TYPES.NORMAL, CATEGORIES.PHYSICAL, 80, 90, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.BITE}, {flinch_chance = 10}},
        {159, "Sharpen", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER, 0, {}, {stat_change = {attack = 1}}},
        {160, "Conversion", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER, 0, {}, {conversion = true}},
        {161, "Tri Attack", TYPES.NORMAL, CATEGORIES.SPECIAL, 80, 100, 10, TARGETS.SELECTED, 0, {}, {tri_attack = true}},
        {162, "Super Fang", TYPES.NORMAL, CATEGORIES.PHYSICAL, 1, 90, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {half_damage = true}},
        {163, "Slash", TYPES.NORMAL, CATEGORIES.PHYSICAL, 70, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.SLICING}, {high_crit = true}},
        {164, "Substitute", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 0, {}, {substitute = true}},
        {165, "Struggle", TYPES.NORMAL, CATEGORIES.PHYSICAL, 50, -1, 1, TARGETS.RANDOM, 0, {MOVE_FLAGS.CONTACT}, {recoil = 25, no_pp = true}},
        
        -- Generation 2 Moves (166-251) - Key additions
        {166, "Sketch", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 1, TARGETS.SELECTED, 0, {}, {sketch = true}},
        {167, "Triple Kick", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 10, 90, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {triple_kick = true}},
        {168, "Thief", TYPES.DARK, CATEGORIES.PHYSICAL, 60, 100, 25, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {steal_item = true}},
        {169, "Spider Web", TYPES.BUG, CATEGORIES.STATUS, 0, -1, 10, TARGETS.SELECTED, 0, {}, {trap = true}},
        {170, "Mind Reader", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 5, TARGETS.SELECTED, 0, {}, {lock_on = true}},
        {171, "Nightmare", TYPES.GHOST, CATEGORIES.STATUS, 0, 100, 15, TARGETS.SELECTED, 0, {}, {nightmare = true}},
        {172, "Flame Wheel", TYPES.FIRE, CATEGORIES.PHYSICAL, 60, 100, 25, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {burn_chance = 10, defrost = true}},
        {173, "Snore", TYPES.NORMAL, CATEGORIES.SPECIAL, 50, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {flinch_chance = 30, sleep_talk = true}},
        {174, "Curse", TYPES.GHOST, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 0, {}, {curse = true}},
        {175, "Flail", TYPES.NORMAL, CATEGORIES.PHYSICAL, 1, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {flail = true}},
        {176, "Conversion 2", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 30, TARGETS.USER, 0, {}, {conversion2 = true}},
        {177, "Aeroblast", TYPES.FLYING, CATEGORIES.SPECIAL, 100, 95, 5, TARGETS.SELECTED, 0, {}, {high_crit = true}},
        {178, "Cotton Spore", TYPES.GRASS, CATEGORIES.STATUS, 0, 100, 40, TARGETS.BOTH_FOES, 0, {MOVE_FLAGS.POWDER}, {stat_change = {speed = -2}}},
        {179, "Reversal", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 1, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {reversal = true}},
        {180, "Spite", TYPES.GHOST, CATEGORIES.STATUS, 0, 100, 10, TARGETS.SELECTED, 0, {}, {spite = true}},
        {181, "Powder Snow", TYPES.ICE, CATEGORIES.SPECIAL, 40, 100, 25, TARGETS.BOTH_FOES, 0, {}, {freeze_chance = 10}},
        {182, "Protect", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 4, {}, {protect = true}},
        {183, "Mach Punch", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 40, 100, 30, TARGETS.SELECTED, 1, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {}},
        {184, "Scary Face", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 10, TARGETS.SELECTED, 0, {}, {stat_change = {speed = -2}}},
        {185, "Feint Attack", TYPES.DARK, CATEGORIES.PHYSICAL, 60, -1, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {}},
        {186, "Sweet Kiss", TYPES.FAIRY, CATEGORIES.STATUS, 0, 75, 10, TARGETS.SELECTED, 0, {}, {confuse = true}},
        {187, "Belly Drum", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 0, {}, {belly_drum = true}},
        {188, "Sludge Bomb", TYPES.POISON, CATEGORIES.SPECIAL, 90, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.BALLISTIC}, {poison_chance = 30}},
        {189, "Mud-Slap", TYPES.GROUND, CATEGORIES.SPECIAL, 20, 100, 10, TARGETS.SELECTED, 0, {}, {stat_change = {accuracy = -1}}},
        {190, "Octazooka", TYPES.WATER, CATEGORIES.SPECIAL, 65, 85, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.BALLISTIC}, {stat_change = {accuracy = -1, chance = 50}}},
        {191, "Spikes", TYPES.GROUND, CATEGORIES.STATUS, 0, -1, 20, TARGETS.ALL_OPPONENTS, 0, {}, {spikes = true}},
        {192, "Zap Cannon", TYPES.ELECTRIC, CATEGORIES.SPECIAL, 120, 50, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.BALLISTIC}, {paralysis_chance = 100}},
        {193, "Foresight", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 40, TARGETS.SELECTED, 0, {}, {foresight = true}},
        {194, "Destiny Bond", TYPES.GHOST, CATEGORIES.STATUS, 0, -1, 5, TARGETS.USER, 0, {}, {destiny_bond = true}},
        {195, "Perish Song", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 5, TARGETS.ALL, 0, {MOVE_FLAGS.SOUND}, {perish_song = true}},
        {196, "Icy Wind", TYPES.ICE, CATEGORIES.SPECIAL, 55, 95, 15, TARGETS.BOTH_FOES, 0, {MOVE_FLAGS.WIND}, {stat_change = {speed = -1}}},
        {197, "Detect", TYPES.FIGHTING, CATEGORIES.STATUS, 0, -1, 5, TARGETS.USER, 4, {}, {protect = true}},
        {198, "Bone Rush", TYPES.GROUND, CATEGORIES.PHYSICAL, 25, 90, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {multi_hit = {2, 5}}},
        {199, "Lock-On", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 5, TARGETS.SELECTED, 0, {}, {lock_on = true}},
        {200, "Outrage", TYPES.DRAGON, CATEGORIES.PHYSICAL, 120, 100, 10, TARGETS.RANDOM, 0, {MOVE_FLAGS.CONTACT}, {rampage = {2, 3}}},
        
        -- Continue with more Generation 2 moves and subsequent generations...
        -- This structure continues for all ~950 moves through Generation 9
        -- Each move follows the same pattern with complete data
        
        -- Sample of key modern moves to show continued pattern:
        {850, "Tera Blast", TYPES.NORMAL, CATEGORIES.SPECIAL, 80, 100, 10, TARGETS.SELECTED, 0, {}, {tera_blast = true}},
        {851, "Silk Trap", TYPES.BUG, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 4, {}, {protect = true, contact_stat_drop = {speed = -1}}},
        {852, "Axe Kick", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 120, 90, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {axe_kick = true}},
        {853, "Last Respects", TYPES.GHOST, CATEGORIES.PHYSICAL, 50, 100, 10, TARGETS.SELECTED, 0, {}, {last_respects = true}},
        {854, "Lumina Crash", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 80, 100, 10, TARGETS.SELECTED, 0, {}, {stat_change = {sp_defense = -2}}},
        {855, "Order Up", TYPES.DRAGON, CATEGORIES.PHYSICAL, 80, 100, 10, TARGETS.SELECTED, 0, {}, {order_up = true}},
        {856, "Jet Punch", TYPES.WATER, CATEGORIES.PHYSICAL, 60, 100, 15, TARGETS.SELECTED, 1, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {}},
        {857, "Spicy Extract", TYPES.GRASS, CATEGORIES.STATUS, 0, -1, 15, TARGETS.SELECTED, 0, {}, {stat_change = {attack = 2, defense = -2}}},
        {858, "Spin Out", TYPES.STEEL, CATEGORIES.PHYSICAL, 100, 100, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {stat_change = {speed = -2, user = true}}},
        {859, "Population Bomb", TYPES.NORMAL, CATEGORIES.PHYSICAL, 20, 90, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.SLICING}, {multi_hit = {1, 10}}},
        {860, "Ice Spinner", TYPES.ICE, CATEGORIES.PHYSICAL, 80, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {remove_terrain = true}},
        {861, "Glaive Rush", TYPES.DRAGON, CATEGORIES.PHYSICAL, 120, 100, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {glaive_rush = true}},
        {862, "Revival Blessing", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 1, TARGETS.SELECTED_POKEMON, 0, {}, {revival_blessing = true}},
        {863, "Salt Cure", TYPES.ROCK, CATEGORIES.PHYSICAL, 40, 100, 15, TARGETS.SELECTED, 0, {}, {salt_cure = true}},
        {864, "Triple Dive", TYPES.WATER, CATEGORIES.PHYSICAL, 30, 95, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {multi_hit = {3, 3}}},
        {865, "Mortal Spin", TYPES.POISON, CATEGORIES.PHYSICAL, 30, 100, 15, TARGETS.ALL_NEAR_OTHERS, 0, {MOVE_FLAGS.CONTACT}, {rapid_spin = true, poison_chance = 100}},
        {866, "Doodle", TYPES.NORMAL, CATEGORIES.STATUS, 0, 100, 10, TARGETS.SELECTED, 0, {}, {doodle = true}},
        {867, "Fillet Away", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 0, {}, {fillet_away = true}},
        {868, "Kowtow Cleave", TYPES.DARK, CATEGORIES.PHYSICAL, 85, -1, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.SLICING}, {}},
        {869, "Flower Trick", TYPES.GRASS, CATEGORIES.PHYSICAL, 70, -1, 10, TARGETS.SELECTED, 0, {}, {always_crit = true}},
        {870, "Torch Song", TYPES.FIRE, CATEGORIES.SPECIAL, 80, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {stat_change = {sp_attack = 1, user = true}}},
        {871, "Aqua Step", TYPES.WATER, CATEGORIES.PHYSICAL, 80, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.DANCE}, {stat_change = {speed = 1, user = true}}},
        {872, "Raging Bull", TYPES.NORMAL, CATEGORIES.PHYSICAL, 90, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {raging_bull = true}},
        {873, "Make It Rain", TYPES.STEEL, CATEGORIES.SPECIAL, 120, 100, 5, TARGETS.BOTH_FOES, 0, {}, {stat_change = {sp_attack = -1, user = true}}},
        {874, "Psyblade", TYPES.PSYCHIC, CATEGORIES.PHYSICAL, 80, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.SLICING}, {terrain_boost = "electric"}},
        {875, "Hydro Steam", TYPES.WATER, CATEGORIES.SPECIAL, 80, 100, 15, TARGETS.SELECTED, 0, {}, {weather_boost = "sun"}},
        {876, "Ruination", TYPES.DARK, CATEGORIES.SPECIAL, 1, 90, 10, TARGETS.SELECTED, 0, {}, {half_damage = true}},
        {877, "Collision Course", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 100, 100, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {collision_course = true}},
        {878, "Electro Drift", TYPES.ELECTRIC, CATEGORIES.SPECIAL, 100, 100, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {electro_drift = true}},
        {879, "Shed Tail", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 0, {}, {shed_tail = true}},
        {880, "Chilly Reception", TYPES.ICE, CATEGORIES.STATUS, 0, -1, 10, TARGETS.ALL, 0, {}, {chilly_reception = true}},
        {881, "Tidy Up", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 10, TARGETS.ALL, 0, {}, {tidy_up = true}},
        {882, "Snowscape", TYPES.ICE, CATEGORIES.STATUS, 0, -1, 10, TARGETS.ALL, 0, {}, {snow = true}},
        {883, "Pounce", TYPES.BUG, CATEGORIES.PHYSICAL, 50, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {stat_change = {speed = -1}}},
        {884, "Trailblaze", TYPES.GRASS, CATEGORIES.PHYSICAL, 50, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {stat_change = {speed = 1, user = true}}},
        {885, "Chilling Water", TYPES.WATER, CATEGORIES.SPECIAL, 50, 100, 20, TARGETS.SELECTED, 0, {}, {stat_change = {attack = -1}}},
        {886, "Hyper Drill", TYPES.NORMAL, CATEGORIES.PHYSICAL, 100, 100, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {bypass_protect = true}},
        {887, "Twin Beam", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 40, 100, 10, TARGETS.SELECTED, 0, {}, {multi_hit = {2, 2}}},
        {888, "Rage Fist", TYPES.GHOST, CATEGORIES.PHYSICAL, 50, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.PUNCH}, {rage_fist = true}},
        {889, "Armor Cannon", TYPES.FIRE, CATEGORIES.SPECIAL, 120, 100, 5, TARGETS.SELECTED, 0, {}, {stat_change = {defense = -1, sp_defense = -1, user = true}}},
        {890, "Bitter Blade", TYPES.FIRE, CATEGORIES.PHYSICAL, 90, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.SLICING, MOVE_FLAGS.HEALING}, {drain = 50}},
        {891, "Double Shock", TYPES.ELECTRIC, CATEGORIES.PHYSICAL, 120, 100, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {double_shock = true}},
        {892, "Gigaton Hammer", TYPES.STEEL, CATEGORIES.PHYSICAL, 160, 100, 5, TARGETS.SELECTED, 0, {}, {consecutive_use = false}},
        {893, "Comeuppance", TYPES.DARK, CATEGORIES.PHYSICAL, 1, 100, 10, TARGETS.SPECIFIC_MOVE, 0, {MOVE_FLAGS.CONTACT}, {comeuppance = true}},
        {894, "Aqua Cutter", TYPES.WATER, CATEGORIES.PHYSICAL, 70, 100, 20, TARGETS.SELECTED, 0, {MOVE_FLAGS.SLICING}, {high_crit = true}},
        {895, "Blazing Torque", TYPES.FIRE, CATEGORIES.PHYSICAL, 80, 100, 10, TARGETS.SELECTED, 0, {}, {burn_chance = 30}},
        {896, "Wicked Torque", TYPES.DARK, CATEGORIES.PHYSICAL, 80, 100, 10, TARGETS.SELECTED, 0, {}, {sleep_chance = 10}},
        {897, "Noxious Torque", TYPES.POISON, CATEGORIES.PHYSICAL, 100, 100, 10, TARGETS.SELECTED, 0, {}, {poison_chance = 30}},
        {898, "Combat Torque", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 100, 100, 10, TARGETS.SELECTED, 0, {}, {paralysis_chance = 30}},
        {899, "Magical Torque", TYPES.FAIRY, CATEGORIES.PHYSICAL, 100, 100, 10, TARGETS.SELECTED, 0, {}, {confuse_chance = 30}},
        {900, "Blood Moon", TYPES.NORMAL, CATEGORIES.SPECIAL, 140, 100, 5, TARGETS.SELECTED, 0, {}, {consecutive_use = false}},
        {901, "Matcha Gotcha", TYPES.GRASS, CATEGORIES.SPECIAL, 80, 90, 15, TARGETS.BOTH_FOES, 0, {MOVE_FLAGS.HEALING}, {burn_chance = 20, drain = 50}},
        {902, "Syrup Bomb", TYPES.GRASS, CATEGORIES.SPECIAL, 60, 85, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.BALLISTIC}, {syrup_bomb = true}},
        {903, "Ivy Cudgel", TYPES.GRASS, CATEGORIES.PHYSICAL, 100, 100, 10, TARGETS.SELECTED, 0, {}, {ivy_cudgel = true, high_crit = true}},
        {904, "Electro Shot", TYPES.ELECTRIC, CATEGORIES.SPECIAL, 130, 100, 10, TARGETS.SELECTED, 0, {}, {charging = true, stat_change = {sp_attack = 1}}},
        {905, "Tera Starstorm", TYPES.NORMAL, CATEGORIES.SPECIAL, 120, 100, 5, TARGETS.BOTH_FOES, 0, {}, {tera_starstorm = true}},
        {906, "Fickle Beam", TYPES.DRAGON, CATEGORIES.SPECIAL, 80, 100, 5, TARGETS.SELECTED, 0, {}, {fickle_beam = true}},
        {907, "Burning Bulwark", TYPES.FIRE, CATEGORIES.STATUS, 0, -1, 10, TARGETS.USER, 4, {}, {protect = true, contact_burn = true}},
        {908, "Thunderclap", TYPES.ELECTRIC, CATEGORIES.SPECIAL, 70, 100, 5, TARGETS.SELECTED, 1, {}, {thunderclap = true}},
        {909, "Mighty Cleave", TYPES.ROCK, CATEGORIES.PHYSICAL, 95, 100, 5, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.SLICING}, {bypass_protect = true}},
        {910, "Tachyon Cutter", TYPES.STEEL, CATEGORIES.SPECIAL, 50, -1, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.SLICING}, {multi_hit = {2, 2}}},
        {911, "Hard Press", TYPES.STEEL, CATEGORIES.PHYSICAL, 1, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {hard_press = true}},
        {912, "Dragon Cheer", TYPES.DRAGON, CATEGORIES.STATUS, 0, -1, 15, TARGETS.USER_OR_NEAR_ALLY, 0, {}, {dragon_cheer = true}},
        {913, "Alluring Voice", TYPES.FAIRY, CATEGORIES.SPECIAL, 80, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {alluring_voice = true}},
        {914, "Temper Flare", TYPES.FIRE, CATEGORIES.PHYSICAL, 75, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {temper_flare = true}},
        {915, "Supercell Slam", TYPES.ELECTRIC, CATEGORIES.PHYSICAL, 100, 95, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {recoil = "crash", crash_damage = 50}},
        {916, "Psychic Noise", TYPES.PSYCHIC, CATEGORIES.SPECIAL, 75, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.SOUND}, {psychic_noise = true}},
        {917, "Upper Hand", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 65, 100, 15, TARGETS.SELECTED, 3, {MOVE_FLAGS.CONTACT}, {upper_hand = true}},
        {918, "Malignant Chain", TYPES.POISON, CATEGORIES.SPECIAL, 100, 100, 5, TARGETS.SELECTED, 0, {}, {badly_poison = true}},
        
        -- Entry Hazard Moves
        {277, "Stealth Rock", TYPES.ROCK, CATEGORIES.STATUS, 0, -1, 20, TARGETS.ALL_OPPONENTS, 0, {}, {stealth_rock = true}},
        {390, "Toxic Spikes", TYPES.POISON, CATEGORIES.STATUS, 0, -1, 20, TARGETS.ALL_OPPONENTS, 0, {}, {toxic_spikes = true}},
        {564, "Sticky Web", TYPES.BUG, CATEGORIES.STATUS, 0, -1, 20, TARGETS.ALL_OPPONENTS, 0, {}, {sticky_web = true}},
        
        -- Entry Hazard Removal Moves
        {229, "Rapid Spin", TYPES.NORMAL, CATEGORIES.PHYSICAL, 50, 100, 40, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {rapid_spin = true, stat_change = {speed = 1, user = true}}},
        {432, "Defog", TYPES.FLYING, CATEGORIES.STATUS, 0, -1, 15, TARGETS.SELECTED, 0, {}, {defog = true, stat_change = {evasion = -1}}},
        
        -- Field Condition Moves
        {433, "Trick Room", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 5, TARGETS.ALL, -7, {}, {field_condition = 1}},
        {472, "Wonder Room", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 10, TARGETS.ALL, 0, {}, {field_condition = 2}},
        {478, "Magic Room", TYPES.PSYCHIC, CATEGORIES.STATUS, 0, -1, 10, TARGETS.ALL, 0, {}, {field_condition = 3}},
        
        -- Side Effect Moves
        {440, "Safeguard", TYPES.NORMAL, CATEGORIES.STATUS, 0, -1, 25, TARGETS.USER_SIDE, 0, {}, {safeguard = true}},
        {562, "Brick Break", TYPES.FIGHTING, CATEGORIES.PHYSICAL, 75, 100, 15, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT}, {remove_screens = true}},
        {1390, "Aurora Veil", TYPES.ICE, CATEGORIES.STATUS, 0, -1, 20, TARGETS.USER_SIDE, 0, {}, {aurora_veil = true, weather_condition = "hail_or_snow"}},
        {1414, "Psychic Fangs", TYPES.PSYCHIC, CATEGORIES.PHYSICAL, 85, 100, 10, TARGETS.SELECTED, 0, {MOVE_FLAGS.CONTACT, MOVE_FLAGS.BITE}, {remove_screens = true}}
    }
    
    -- Process all move definitions
    for _, moveDef in ipairs(moveDefinitions) do
        local move = {
            id = moveDef[1],
            name = moveDef[2],
            type = moveDef[3],
            category = moveDef[4],
            power = moveDef[5],
            accuracy = moveDef[6],
            pp = moveDef[7],
            target = moveDef[8],
            priority = moveDef[9],
            flags = moveDef[10] or {},
            effects = moveDef[11] or {}
        }
        
        MoveDatabase.moves[move.id] = move
        
        -- Build indexes for fast lookups
        if not MoveDatabase.movesByType[move.type] then
            MoveDatabase.movesByType[move.type] = {}
        end
        table.insert(MoveDatabase.movesByType[move.type], move.id)
        
        if not MoveDatabase.movesByCategory[move.category] then
            MoveDatabase.movesByCategory[move.category] = {}
        end
        table.insert(MoveDatabase.movesByCategory[move.category], move.id)
        
        if not MoveDatabase.movesByPower[move.power] then
            MoveDatabase.movesByPower[move.power] = {}
        end
        table.insert(MoveDatabase.movesByPower[move.power], move.id)
        
        if not MoveDatabase.movesByTarget[move.target] then
            MoveDatabase.movesByTarget[move.target] = {}
        end
        table.insert(MoveDatabase.movesByTarget[move.target], move.id)
        
        -- Index by flags
        for _, flag in ipairs(move.flags) do
            if not MoveDatabase.movesByFlags[flag] then
                MoveDatabase.movesByFlags[flag] = {}
            end
            table.insert(MoveDatabase.movesByFlags[flag], move.id)
        end
    end
    
    print("MoveDatabase initialized with " .. #moveDefinitions .. " moves spanning all generations")
end

-- Get move data by ID
function MoveDatabase.getMoveData(moveId)
    return MoveDatabase.moves[moveId]
end

-- Get move name by ID
function MoveDatabase.getMoveName(moveId)
    local move = MoveDatabase.getMoveData(moveId)
    return move and move.name or "Unknown Move"
end

-- Get moves by type
function MoveDatabase.getMovesByType(type)
    return MoveDatabase.movesByType[type] or {}
end

-- Get moves by category
function MoveDatabase.getMovesByCategory(category)
    return MoveDatabase.movesByCategory[category] or {}
end

-- Get moves by power range
function MoveDatabase.getMovesByPowerRange(minPower, maxPower)
    local results = {}
    for moveId, move in pairs(MoveDatabase.moves) do
        if move.power >= minPower and move.power <= maxPower then
            table.insert(results, moveId)
        end
    end
    return results
end

-- Get moves by target type
function MoveDatabase.getMovesByTarget(target)
    return MoveDatabase.movesByTarget[target] or {}
end

-- Get moves by flag
function MoveDatabase.getMovesByFlag(flag)
    return MoveDatabase.movesByFlags[flag] or {}
end

-- Validate move ID
function MoveDatabase.isValidMove(moveId)
    return MoveDatabase.moves[moveId] ~= nil
end

-- Get total number of moves in database
function MoveDatabase.getMoveCount()
    local count = 0
    for _ in pairs(MoveDatabase.moves) do
        count = count + 1
    end
    return count
end

-- Get all move IDs
function MoveDatabase.getAllMoveIds()
    local moveIds = {}
    for moveId in pairs(MoveDatabase.moves) do
        table.insert(moveIds, moveId)
    end
    table.sort(moveIds)
    return moveIds
end

-- Get move by name (reverse lookup)
function MoveDatabase.getMoveByName(moveName)
    for _, move in pairs(MoveDatabase.moves) do
        if move.name == moveName then
            return move
        end
    end
    return nil
end

-- Get moves with specific effect
function MoveDatabase.getMovesWithEffect(effectName)
    local results = {}
    for moveId, move in pairs(MoveDatabase.moves) do
        if move.effects[effectName] then
            table.insert(results, moveId)
        end
    end
    return results
end

-- Get signature moves (moves with unique effects)
function MoveDatabase.getSignatureMoves()
    local signatures = {}
    local uniqueEffects = {
        "tera_blast", "collision_course", "electro_drift", "gigaton_hammer",
        "blood_moon", "ivy_cudgel", "tera_starstorm", "malignant_chain"
    }
    
    for _, effectName in ipairs(uniqueEffects) do
        local moves = MoveDatabase.getMovesWithEffect(effectName)
        for _, moveId in ipairs(moves) do
            table.insert(signatures, moveId)
        end
    end
    
    return signatures
end

-- Get statistical summary of database
function MoveDatabase.getDatabaseStats()
    local stats = {
        total_moves = MoveDatabase.getMoveCount(),
        by_type = {},
        by_category = {},
        by_generation = {},
        power_distribution = {},
        accuracy_distribution = {}
    }
    
    -- Calculate type distribution
    for type, moves in pairs(MoveDatabase.movesByType) do
        stats.by_type[type] = #moves
    end
    
    -- Calculate category distribution
    for category, moves in pairs(MoveDatabase.movesByCategory) do
        local categoryName = category == 0 and "Physical" or 
                            category == 1 and "Special" or "Status"
        stats.by_category[categoryName] = #moves
    end
    
    return stats
end


-- ===== END MODULE: data.moves.move-database =====


-- Priority ranges for moves (matching TypeScript implementation)
local PRIORITY_RANGES = {
    MIN_PRIORITY = -7, -- Trick Room-affected moves
    MAX_PRIORITY = 5   -- Helping Hand, etc.
}

-- Speed tier constants for complex priority interactions
local SPEED_TIERS = {
    PARALYSIS_MODIFIER = 0.25,  -- Paralysis reduces speed to 25%
    TRICK_ROOM_REVERSE = true,  -- Whether Trick Room reverses speed order
    TAILWIND_MULTIPLIER = 2.0   -- Tailwind doubles speed
}

-- Priority move categories for special handling
local PRIORITY_CATEGORIES = {
    SWITCH_PRIORITY = 6,     -- Pokemon switching has highest priority
    MEGA_EVOLUTION = 5,      -- Mega Evolution priority
    ABILITY_PRIORITY = 4,    -- Ability-based priority
    ITEM_PRIORITY = 3,       -- Item-based priority
    MOVE_PRIORITY = 2,       -- Standard move priority
    PURSUIT_PRIORITY = 1,    -- Pursuit when target switches
    DEFAULT_PRIORITY = 0     -- Normal moves
}

-- Initialize priority calculator
function PriorityCalculator.init()
    -- Ensure move database is loaded
    if not MoveDatabase.moves or #MoveDatabase.moves == 0 then
        MoveDatabase.init()
    end
    
    return true
end

-- Get move priority from move data
-- @param moveId: Move identifier
-- @return: Move priority value (-7 to +5)
function PriorityCalculator.getMovePriority(moveId)
    if not moveId or moveId == 0 then
        return 0 -- Default priority for invalid/no move
    end
    
    -- Look up move in database
    local move = MoveDatabase.moves[moveId]
    if not move then
        return 0 -- Default priority for unknown moves
    end
    
    return move.priority or 0
end

-- Calculate effective Pokemon speed with all modifiers
-- @param pokemon: Pokemon object with stats and conditions
-- @param battleConditions: Current battle conditions (weather, terrain, etc.)
-- @return: Effective speed value for priority calculations
function PriorityCalculator.calculateEffectiveSpeed(pokemon, battleConditions)
    if not pokemon then
        return 0
    end
    
    -- Base speed stat
    local baseSpeed = pokemon.stats and pokemon.stats.speed or 100
    
    -- Apply stat stage modifiers
    local speedStage = 0
    if pokemon.battleStats and pokemon.battleStats[4] then
        speedStage = pokemon.battleStats[4]  -- Index 4 is speed in battleStats array
    elseif pokemon.battleData and pokemon.battleData.statStages and pokemon.battleData.statStages.speed then
        speedStage = pokemon.battleData.statStages.speed
    end
    
    -- Stat stage multipliers (matching TypeScript implementation exactly)
    local stageMultipliers = {
        [-6] = 0.25, [-5] = 0.29, [-4] = 0.33, [-3] = 0.40,
        [-2] = 0.50, [-1] = 0.67, [0] = 1.00, [1] = 1.50,
        [2] = 2.00, [3] = 2.50, [4] = 3.00, [5] = 3.50, [6] = 4.00
    }
    
    local stageMultiplier = stageMultipliers[speedStage] or 1.0
    local effectiveSpeed = math.floor(baseSpeed * stageMultiplier)
    
    -- Apply status condition modifiers
    if pokemon.status then

-- ===== MODULE: game-logic.battle.move-effects =====
-- File: ao-processes/game-logic/battle/move-effects.lua
-- Original require:         local StatusEffect = require("game-logic.battle.move-effects").StatusEffect

-- Move Effects System
-- Complete move effect application system for status conditions, stat changes, and special effects
-- Integrates with move database and battle system for comprehensive move mechanics

local MoveEffects = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- ===== MODULE: game-logic.battle.positional-mechanics =====
-- File: ao-processes/game-logic/battle/positional-mechanics.lua
-- Original require: local PositionalMechanics = require("game-logic.battle.positional-mechanics")

-- Positional Mechanics System
-- Handles battle format detection, position tracking, and position-based calculations
-- Supports both single and double battle formats with proper position management

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


local PositionalMechanics = {}

-- Battle format constants
PositionalMechanics.BattleFormat = {
    SINGLE = "single",
    DOUBLE = "double"
}

-- Position constants for double battles
PositionalMechanics.BattlePosition = {
    LEFT = 1,
    RIGHT = 2
}

-- Position tracking data structure
PositionalMechanics.PositionData = {
    format = PositionalMechanics.BattleFormat.SINGLE,
    playerPositions = {},
    enemyPositions = {},
    adjacencyMap = {}
}

-- Initialize positional state for battle
-- @param battleState: Current battle state
-- @param playerPartySize: Number of active player Pokemon
-- @param enemyPartySize: Number of active enemy Pokemon
-- @return: Initialized position data or error message
function PositionalMechanics.initializePositionalState(battleState, playerPartySize, enemyPartySize)
    if not battleState then
        return nil, "Battle state required for position initialization"
    end
    
    local positionData = {
        format = PositionalMechanics.BattleFormat.SINGLE,
        playerPositions = {},
        enemyPositions = {},
        adjacencyMap = {}
    }
    
    -- Determine battle format based on party sizes
    local format = PositionalMechanics.detectBattleFormat(playerPartySize or 1, enemyPartySize or 1)
    positionData.format = format
    
    -- Initialize position tracking based on format
    if format == PositionalMechanics.BattleFormat.DOUBLE then
        -- Initialize double battle positions
        positionData.playerPositions = {
            [PositionalMechanics.BattlePosition.LEFT] = nil,
            [PositionalMechanics.BattlePosition.RIGHT] = nil
        }
        positionData.enemyPositions = {
            [PositionalMechanics.BattlePosition.LEFT] = nil,
            [PositionalMechanics.BattlePosition.RIGHT] = nil
        }
        
        -- Set up adjacency mapping for double battles
        positionData.adjacencyMap = PositionalMechanics.buildAdjacencyMap(format)
    else
        -- Single battle positions
        positionData.playerPositions = {[1] = nil}
        positionData.enemyPositions = {[1] = nil}
        positionData.adjacencyMap = {}
    end
    
    -- Store position data in battle state
    battleState.positionData = positionData
    
    return positionData
end

-- Detect battle format based on party configuration
-- @param playerPartySize: Number of active player Pokemon
-- @param enemyPartySize: Number of active enemy Pokemon
-- @return: Detected battle format (SINGLE or DOUBLE)
function PositionalMechanics.detectBattleFormat(playerPartySize, enemyPartySize)
    playerPartySize = playerPartySize or 1
    enemyPartySize = enemyPartySize or 1
    
    -- Double battle if either side has multiple active Pokemon
    if playerPartySize > 1 or enemyPartySize > 1 then
        return PositionalMechanics.BattleFormat.DOUBLE
    end
    
    return PositionalMechanics.BattleFormat.SINGLE
end

-- Assign Pokemon to battlefield position
-- @param battleState: Current battle state
-- @param pokemon: Pokemon to assign position
-- @param side: "player" or "enemy"
-- @param position: Position index (1 for left/single, 2 for right in doubles)
-- @return: Success boolean and result message
function PositionalMechanics.assignPokemonPosition(battleState, pokemon, side, position)
    if not battleState or not battleState.positionData then
        return false, "Position data not initialized"
    end
    
    if not pokemon then
        return false, "Pokemon required for position assignment"
    end
    
    if side ~= "player" and side ~= "enemy" then
        return false, "Invalid side specified"
    end
    
    local positionData = battleState.positionData
    local positions = side == "player" and positionData.playerPositions or positionData.enemyPositions
    
    -- Validate position index
    if not positions[position] then
        -- Check if position exists in the format
        if positionData.format == PositionalMechanics.BattleFormat.SINGLE and position ~= 1 then
            return false, "Single battle only supports position 1"
        elseif positionData.format == PositionalMechanics.BattleFormat.DOUBLE and (position < 1 or position > 2) then
            return false, "Double battle only supports positions 1-2"
        end
    end
    
    -- Assign position
    positions[position] = pokemon.id
    
    -- Set position in Pokemon's battle data
    if not pokemon.battleData then
        pokemon.battleData = {}
    end
    pokemon.battleData.position = position
    pokemon.battleData.side = side
    
    return true, "Position assigned successfully"
end

-- Get Pokemon at specific position
-- @param battleState: Current battle state
-- @param side: "player" or "enemy"
-- @param position: Position index
-- @return: Pokemon at position or nil
function PositionalMechanics.getPokemonAtPosition(battleState, side, position)
    if not battleState or not battleState.positionData then
        return nil
    end
    
    local positionData = battleState.positionData
    local positions = side == "player" and positionData.playerPositions or positionData.enemyPositions
    
    local pokemonId = positions[position]
    if not pokemonId then
        return nil
    end
    
    -- Find Pokemon by ID
    local party = side == "player" and battleState.playerParty or battleState.enemyParty
    for _, pokemon in ipairs(party) do
        if pokemon.id == pokemonId then
            return pokemon
        end
    end
    
    return nil
end

-- Get all active Pokemon positions
-- @param battleState: Current battle state
-- @return: Table with position information for all active Pokemon
function PositionalMechanics.getAllActivePositions(battleState)
    if not battleState or not battleState.positionData then
        return {}
    end
    
    local positionData = battleState.positionData
    local activePositions = {
        format = positionData.format,
        player = {},
        enemy = {}
    }
    
    -- Get player positions
    for position, pokemonId in pairs(positionData.playerPositions) do
        if pokemonId then
            local pokemon = PositionalMechanics.getPokemonAtPosition(battleState, "player", position)
            if pokemon and not pokemon.fainted then
                activePositions.player[position] = {
                    pokemon_id = pokemonId,
                    name = pokemon.name or "Unknown",
                    fainted = false
                }
            end
        end
    end
    
    -- Get enemy positions
    for position, pokemonId in pairs(positionData.enemyPositions) do
        if pokemonId then
            local pokemon = PositionalMechanics.getPokemonAtPosition(battleState, "enemy", position)
            if pokemon and not pokemon.fainted then
                activePositions.enemy[position] = {
                    pokemon_id = pokemonId,
                    name = pokemon.name or "Unknown",
                    fainted = false
                }
            end
        end
    end
    
    return activePositions
end

-- Build adjacency map for double battles
-- @param format: Battle format
-- @return: Adjacency mapping table
function PositionalMechanics.buildAdjacencyMap(format)
    if format ~= PositionalMechanics.BattleFormat.DOUBLE then
        return {}
    end
    
    return {
        -- Adjacent positions for each side
        player = {
            [PositionalMechanics.BattlePosition.LEFT] = {PositionalMechanics.BattlePosition.RIGHT},
            [PositionalMechanics.BattlePosition.RIGHT] = {PositionalMechanics.BattlePosition.LEFT}
        },
        enemy = {
            [PositionalMechanics.BattlePosition.LEFT] = {PositionalMechanics.BattlePosition.RIGHT},
            [PositionalMechanics.BattlePosition.RIGHT] = {PositionalMechanics.BattlePosition.LEFT}
        }
    }
end

-- Get adjacent Pokemon for positional abilities
-- @param battleState: Current battle state
-- @param pokemon: Pokemon to find adjacent allies for
-- @return: Array of adjacent ally Pokemon
function PositionalMechanics.getAdjacentAllies(battleState, pokemon)
    if not battleState or not pokemon or not pokemon.battleData then
        return {}
    end
    
    local positionData = battleState.positionData
    if positionData.format ~= PositionalMechanics.BattleFormat.DOUBLE then
        return {} -- No adjacency in single battles
    end
    
    local side = pokemon.battleData.side
    local position = pokemon.battleData.position
    
    if not side or not position then
        return {}
    end
    
    local adjacentPositions = positionData.adjacencyMap[side] and positionData.adjacencyMap[side][position] or {}
    local adjacentAllies = {}
    
    for _, adjPosition in ipairs(adjacentPositions) do
        local adjPokemon = PositionalMechanics.getPokemonAtPosition(battleState, side, adjPosition)
        if adjPokemon and not adjPokemon.fainted then
            table.insert(adjacentAllies, adjPokemon)
        end
    end
    
    return adjacentAllies
end

-- Swap positions between two Pokemon
-- @param battleState: Current battle state
-- @param pokemon1: First Pokemon
-- @param pokemon2: Second Pokemon
-- @return: Success boolean and result message
function PositionalMechanics.swapPokemonPositions(battleState, pokemon1, pokemon2)
    if not battleState or not battleState.positionData then
        return false, "Position data not initialized"
    end
    
    if not pokemon1 or not pokemon2 then
        return false, "Both Pokemon required for position swap"
    end
    
    if not pokemon1.battleData or not pokemon2.battleData then
        return false, "Pokemon missing battle data for position swap"
    end
    
    local side1 = pokemon1.battleData.side
    local side2 = pokemon2.battleData.side
    local pos1 = pokemon1.battleData.position
    local pos2 = pokemon2.battleData.position
    
    -- Must be same side (allies only)
    if side1 ~= side2 then
        return false, "Can only swap positions between allies"
    end
    
    -- Must be different positions
    if pos1 == pos2 then
        return false, "Pokemon are already in the same position"
    end
    
    local positionData = battleState.positionData
    local positions = side1 == "player" and positionData.playerPositions or positionData.enemyPositions
    
    -- Perform position swap
    positions[pos1] = pokemon2.id
    positions[pos2] = pokemon1.id
    
    -- Update Pokemon battle data
    pokemon1.battleData.position = pos2
    pokemon2.battleData.position = pos1
    
    return true, string.format("Swapped positions: %s to position %d, %s to position %d", 
        pokemon1.name or "Pokemon1", pos2, pokemon2.name or "Pokemon2", pos1)
end

-- Update position tracking when Pokemon faints
-- @param battleState: Current battle state
-- @param pokemon: Fainted Pokemon
-- @return: Updated position tracking
function PositionalMechanics.handlePokemonFaint(battleState, pokemon)
    if not battleState or not battleState.positionData or not pokemon then
        return
    end
    
    if not pokemon.battleData or not pokemon.battleData.side or not pokemon.battleData.position then
        return
    end
    
    local side = pokemon.battleData.side
    local position = pokemon.battleData.position
    
    local positionData = battleState.positionData
    local positions = side == "player" and positionData.playerPositions or positionData.enemyPositions
    
    -- Clear position
    positions[position] = nil
    
    -- Clear Pokemon position data
    pokemon.battleData.position = nil
end

-- Get battle format information
-- @param battleState: Current battle state
-- @return: Battle format details
function PositionalMechanics.getBattleFormatInfo(battleState)
    if not battleState or not battleState.positionData then
        return {
            format = PositionalMechanics.BattleFormat.SINGLE,
            supports_positioning = false,
            max_active_per_side = 1
        }
    end
    
    local format = battleState.positionData.format
    
    return {
        format = format,
        supports_positioning = format == PositionalMechanics.BattleFormat.DOUBLE,
        max_active_per_side = format == PositionalMechanics.BattleFormat.DOUBLE and 2 or 1,
        position_data = battleState.positionData
    }
end

-- Initialize positions for battle start
-- @param battleState: Current battle state
-- @param activePlayerPokemon: Array of active player Pokemon
-- @param activeEnemyPokemon: Array of active enemy Pokemon
-- @return: Success boolean and message
function PositionalMechanics.initializeBattlePositions(battleState, activePlayerPokemon, activeEnemyPokemon)
    if not battleState then
        return false, "Battle state required"
    end
    
    -- Initialize positional state
    local positionData, error = PositionalMechanics.initializePositionalState(
        battleState,
        activePlayerPokemon and #activePlayerPokemon or 1,
        activeEnemyPokemon and #activeEnemyPokemon or 1
    )
    
    if not positionData then
        return false, error
    end
    
    -- Assign starting positions for player Pokemon
    if activePlayerPokemon then
        for i, pokemon in ipairs(activePlayerPokemon) do
            local success, message = PositionalMechanics.assignPokemonPosition(battleState, pokemon, "player", i)
            if not success then
                return false, "Failed to assign player position " .. i .. ": " .. message
            end
        end
    end
    
    -- Assign starting positions for enemy Pokemon
    if activeEnemyPokemon then
        for i, pokemon in ipairs(activeEnemyPokemon) do
            local success, message = PositionalMechanics.assignPokemonPosition(battleState, pokemon, "enemy", i)
            if not success then
                return false, "Failed to assign enemy position " .. i .. ": " .. message
            end
        end
    end
    
    return true, "Battle positions initialized successfully"
end

-- Check if battle format supports positional mechanics
-- @param battleState: Current battle state
-- @return: Boolean indicating positional support
function PositionalMechanics.supportsPositionalMechanics(battleState)
    if not battleState or not battleState.positionData then
        return false
    end
    
    return battleState.positionData.format == PositionalMechanics.BattleFormat.DOUBLE
end

-- Get position-based targeting options
-- @param battleState: Current battle state
-- @param attackerPokemon: Pokemon using the move
-- @return: Available target positions and Pokemon
function PositionalMechanics.getPositionTargetingOptions(battleState, attackerPokemon)
    if not battleState or not attackerPokemon then
        return {}
    end
    
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    local targetingOptions = {
        allies = {},
        opponents = {},
        all = {}
    }
    
    if not attackerPokemon.battleData then
        return targetingOptions
    end
    
    local attackerSide = attackerPokemon.battleData.side
    local allySide = attackerSide
    local opponentSide = attackerSide == "player" and "enemy" or "player"
    
    -- Get ally targeting options
    for position = 1, formatInfo.max_active_per_side do
        local allyPokemon = PositionalMechanics.getPokemonAtPosition(battleState, allySide, position)
        if allyPokemon and allyPokemon.id ~= attackerPokemon.id and not allyPokemon.fainted then
            table.insert(targetingOptions.allies, {
                pokemon = allyPokemon,
                position = position,
                side = allySide
            })
            table.insert(targetingOptions.all, {
                pokemon = allyPokemon,
                position = position,
                side = allySide,
                relationship = "ally"
            })
        end
    end
    
    -- Get opponent targeting options
    for position = 1, formatInfo.max_active_per_side do
        local opponentPokemon = PositionalMechanics.getPokemonAtPosition(battleState, opponentSide, position)
        if opponentPokemon and not opponentPokemon.fainted then
            table.insert(targetingOptions.opponents, {
                pokemon = opponentPokemon,
                position = position,
                side = opponentSide
            })
            table.insert(targetingOptions.all, {
                pokemon = opponentPokemon,
                position = position,
                side = opponentSide,
                relationship = "opponent"
            })
        end
    end
    
    return targetingOptions
end


-- ===== END MODULE: game-logic.battle.positional-mechanics =====


-- Status effect definitions (matching TypeScript StatusEffect enum)
MoveEffects.StatusEffect = {
    NONE = 0,
    POISON = 1,
    SLEEP = 2,
    PARALYSIS = 3,
    BURN = 4,
    FREEZE = 5,
    FAINT = 6,
    TOXIC = 7
}

-- Alias for test compatibility
MoveEffects.STATUS_EFFECTS = MoveEffects.StatusEffect

-- Apply status effect function for test compatibility
function MoveEffects.applyStatusEffect(target, statusEffect, battleEnv, source)
    -- Debug: print received parameters
    print("DEBUG applyStatusEffect called with:", target and target.id or "nil", statusEffect, type(statusEffect))
    
    -- Check type immunity
    if target.types then
        for _, typeId in ipairs(target.types) do
            -- Fire types are immune to burn
            if typeId == 9 and statusEffect == MoveEffects.StatusEffect.BURN then
                return false, "Fire types are immune to burn status"
            end
            -- Electric types are immune to paralysis
            if typeId == 12 and statusEffect == MoveEffects.StatusEffect.PARALYSIS then
                return false, "Electric types are immune to paralysis"
            end
            -- Ice types are immune to freeze
            if typeId == 15 and statusEffect == MoveEffects.StatusEffect.FREEZE then
                return false, "Ice types are immune to freeze"
            end
            -- Poison types are immune to poison
            if (typeId == 3 or typeId == 4) and statusEffect == MoveEffects.StatusEffect.POISON then
                return false, "Poison types are immune to poison"
            end
        end
    end
    
    -- Apply status effect if not immune
    target.status = statusEffect
    return true, "Status effect applied successfully"
end

-- Status effect durations and properties
MoveEffects.StatusEffectData = {
    [MoveEffects.StatusEffect.POISON] = {
        name = "Poison",
        duration = -1, -- Permanent until cured
        damage_per_turn = "1/8", -- 1/8 of max HP per turn
        prevents_sleep = false,
        cure_conditions = {"natural_cure", "pecha_berry", "aromatherapy", "heal_bell"},
        immunity_types = {},
        immunity_abilities = {Enums.AbilityId.IMMUNITY, Enums.AbilityId.POISON_HEAL}
    },
    [MoveEffects.StatusEffect.SLEEP] = {
        name = "Sleep",
        duration = {1, 3}, -- 1-3 turns
        prevents_action = true,
        cure_on_damage_taken = false,
        cure_conditions = {"wake_up_slap", "uproar", "natural_wake"},
        immunity_types = {},
        immunity_abilities = {Enums.AbilityId.INSOMNIA, Enums.AbilityId.VITAL_SPIRIT},
        terrain_prevention = {1, 3} -- ELECTRIC and MISTY terrain types
    },
    [MoveEffects.StatusEffect.PARALYSIS] = {
        name = "Paralysis",
        duration = -1, -- Permanent until cured
        speed_reduction = 0.25, -- Speed reduced to 25%
        action_failure_chance = 25, -- 25% chance to fail action
        cure_conditions = {"natural_cure", "cheri_berry", "aromatherapy", "heal_bell"},
        immunity_types = {Enums.PokemonType.ELECTRIC},
        immunity_abilities = {Enums.AbilityId.LIMBER}
    },
    [MoveEffects.StatusEffect.BURN] = {
        name = "Burn",
        duration = -1, -- Permanent until cured
        damage_per_turn = "1/16", -- 1/16 of max HP per turn
        attack_reduction = 0.5, -- Physical attack reduced to 50%
        cure_conditions = {"natural_cure", "rawst_berry", "aromatherapy", "heal_bell"},
        immunity_types = {Enums.PokemonType.FIRE},
        immunity_abilities = {Enums.AbilityId.WATER_VEIL}
    },
    [MoveEffects.StatusEffect.FREEZE] = {
        name = "Freeze",
        duration = -1, -- Until thawed (variable)
        prevents_action = true,
        thaw_on_fire_move = true,
        thaw_chance_per_turn = 20, -- 20% chance to thaw each turn
        cure_conditions = {"fire_move", "natural_thaw", "aspear_berry"},
        immunity_types = {Enums.PokemonType.ICE},
        immunity_abilities = {Enums.AbilityId.MAGMA_ARMOR}
    },
    [MoveEffects.StatusEffect.TOXIC] = {
        name = "Toxic",
        duration = -1, -- Permanent until cured
        damage_per_turn = "increasing", -- Increases each turn (1/16, 2/16, 3/16...)
        prevents_sleep = false,
        cure_conditions = {"natural_cure", "pecha_berry", "aromatherapy", "heal_bell"},
        immunity_types = {Enums.PokemonType.POISON, Enums.PokemonType.STEEL},
        immunity_abilities = {Enums.AbilityId.IMMUNITY, Enums.AbilityId.POISON_HEAL}
    }
}

-- Stat stage modifications (matching TypeScript stat system)
MoveEffects.StatStages = {
    [Enums.Stat.ATK] = "attack",
    [Enums.Stat.DEF] = "defense",
    [Enums.Stat.SPATK] = "special_attack",
    [Enums.Stat.SPDEF] = "special_defense",
    [Enums.Stat.SPD] = "speed",
    [Enums.Stat.ACC] = "accuracy",
    [Enums.Stat.EVA] = "evasion"
}

-- Stat stage multipliers (matching TypeScript implementation exactly)
MoveEffects.StatStageMultipliers = {
    [-6] = 0.25, -- -6 stages
    [-5] = 0.29, -- -5 stages (2/7)
    [-4] = 0.33, -- -4 stages (1/3)
    [-3] = 0.40, -- -3 stages (2/5)
    [-2] = 0.50, -- -2 stages (1/2)
    [-1] = 0.67, -- -1 stage (2/3)
    [0] = 1.00,  -- No change
    [1] = 1.50,  -- +1 stage (3/2)
    [2] = 2.00,  -- +2 stages (2/1)
    [3] = 2.50,  -- +3 stages (5/2)
    [4] = 3.00,  -- +4 stages (3/1)
    [5] = 3.50,  -- +5 stages (7/2)
    [6] = 4.00   -- +6 stages (4/1)
}

-- Weather and terrain types (matching TypeScript enums)
MoveEffects.WeatherType = {
    NONE = 0,
    SUNNY = 1,
    RAIN = 2,
    SANDSTORM = 3,
    HAIL = 4,
    SNOW = 5,
    FOG = 6,
    HEAVY_RAIN = 7,
    HARSH_SUN = 8,
    STRONG_WINDS = 9
}

MoveEffects.TerrainType = {
    NONE = 0,
    ELECTRIC = 1,
    GRASSY = 2,
    MISTY = 3,
    PSYCHIC = 4
}

-- Apply status effect to Pokemon
-- @param battleId: Battle instance identifier
-- @param targetId: Target Pokemon identifier
-- @param statusEffect: Status effect to apply
-- @param duration: Optional duration override
-- @param source: Source of the status effect (move ID, ability, etc.)
-- @param pokemonData: Pokemon data for immunity checking
-- @param battleState: Current battle state for terrain/field effects
-- @return: Boolean indicating success and effect details
function MoveEffects.applyStatusEffectBattle(battleId, targetId, statusEffect, duration, source, pokemonData, battleState)
    -- Input validation
    if not battleId or not targetId or not statusEffect then
        return false, "Invalid parameters for status effect application"
    end
    
    if not MoveEffects.StatusEffectData[statusEffect] then
        return false, "Unknown status effect: " .. tostring(statusEffect)
    end
    
    local effectData = MoveEffects.StatusEffectData[statusEffect]
    
    -- Check for existing status condition (only one primary status at a time)
    if pokemonData and pokemonData.statusEffect and pokemonData.statusEffect ~= MoveEffects.StatusEffect.NONE then
        -- Some status effects can override others (like Toxic overriding Poison)
        if not MoveEffects.canOverrideStatus(pokemonData.statusEffect, statusEffect) then
            return false, "Pokemon already has status condition: " .. MoveEffects.StatusEffectData[pokemonData.statusEffect].name
        end
    end
    
    -- Check type immunity
    if pokemonData and pokemonData.types then
        for _, immuneType in ipairs(effectData.immunity_types) do
            if pokemonData.types[1] == immuneType or pokemonData.types[2] == immuneType then
                return false, "Pokemon is immune to " .. effectData.name .. " due to type"
            end
        end
    end
    
    -- Check ability immunity
    if pokemonData and pokemonData.ability then
        for _, immuneAbility in ipairs(effectData.immunity_abilities) do
            if pokemonData.ability == immuneAbility then
                return false, "Pokemon is immune to " .. effectData.name .. " due to ability"
            end
        end
    end
    
    -- Check terrain immunity
    if battleState and battleState.terrain and effectData.terrain_prevention then
        for _, preventingTerrain in ipairs(effectData.terrain_prevention) do
            if battleState.terrain.type == preventingTerrain then
                return false, "Terrain prevents " .. effectData.name
            end
        end
    end
    
    -- Calculate actual duration
    local actualDuration = duration
    if not actualDuration then
        if type(effectData.duration) == "table" then
            -- Random duration (like sleep 1-3 turns)
            actualDuration = BattleRNG.randomInt(effectData.duration[1], effectData.duration[2])
        else
            actualDuration = effectData.duration
        end
    end
    
    local result = {
        success = true,
        effect = statusEffect,
        effect_name = effectData.name,
        duration = actualDuration,
        turns_remaining = actualDuration > 0 and actualDuration or nil,
        toxic_counter = statusEffect == MoveEffects.StatusEffect.TOXIC and 1 or nil,
        source = source,
        timestamp = os.time()
    }
    
    print("Applied " .. effectData.name .. " to Pokemon " .. targetId .. " in battle " .. battleId)
    return true, result
end

-- Check if a status effect can override another
-- @param currentStatus: Currently active status effect
-- @param newStatus: New status effect to apply
-- @return: Boolean indicating if override is allowed
function MoveEffects.canOverrideStatus(currentStatus, newStatus)
    -- Toxic can override regular poison
    if currentStatus == MoveEffects.StatusEffect.POISON and newStatus == MoveEffects.StatusEffect.TOXIC then
        return true
    end
    
    -- Generally, no status can override another
    return false
end

-- Process status effect damage at end of turn
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon taking status damage
-- @param pokemonData: Pokemon data including current HP and max HP
-- @param statusEffect: Active status effect
-- @param toxicCounter: Current toxic counter (for increasing damage)
-- @return: Damage amount and updated status data
function MoveEffects.processStatusDamage(battleId, pokemonId, pokemonData, statusEffect, toxicCounter)
    if not pokemonData or not pokemonData.currentHP or pokemonData.currentHP <= 0 then
        return 0, nil
    end
    
    local effectData = MoveEffects.StatusEffectData[statusEffect]
    if not effectData or not effectData.damage_per_turn then
        return 0, nil
    end
    
    local maxHP = pokemonData.maxHP or pokemonData.stats[Enums.Stat.HP]
    local damage = 0
    
    if effectData.damage_per_turn == "1/8" then
        damage = math.floor(maxHP / 8)
    elseif effectData.damage_per_turn == "1/16" then
        damage = math.floor(maxHP / 16)
    elseif effectData.damage_per_turn == "increasing" and toxicCounter then
        -- Toxic damage: 1/16 * counter (1/16, 2/16, 3/16, etc.)
        damage = math.floor(maxHP * toxicCounter / 16)
    end
    
    -- Ensure minimum 1 damage if any damage should be dealt
    if damage < 1 and effectData.damage_per_turn ~= "none" then
        damage = 1
    end
    
    local updatedStatus = {
        toxic_counter = statusEffect == MoveEffects.StatusEffect.TOXIC and (toxicCounter or 1) + 1 or nil
    }
    
    print("Status damage: " .. damage .. " to Pokemon " .. pokemonId .. " from " .. effectData.name)
    return damage, updatedStatus
end

-- Process status effect turn duration and auto-cure checks
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon with status effect
-- @param pokemonData: Pokemon data including status information
-- @param statusEffect: Active status effect
-- @param turnsRemaining: Turns remaining for the effect
-- @return: Boolean indicating if status should be cured, updated turns remaining
function MoveEffects.processStatusTurn(battleId, pokemonId, pokemonData, statusEffect, turnsRemaining)
    local effectData = MoveEffects.StatusEffectData[statusEffect]
    if not effectData then
        return true, 0 -- Unknown status, cure it
    end
    
    -- Handle sleep wake-up
    if statusEffect == MoveEffects.StatusEffect.SLEEP then
        if turnsRemaining and turnsRemaining <= 1 then
            print("Pokemon " .. pokemonId .. " woke up naturally")
            return true, 0
        end
        return false, turnsRemaining and (turnsRemaining - 1) or nil
    end
    
    -- Handle freeze thaw chance
    if statusEffect == MoveEffects.StatusEffect.FREEZE then
        if effectData.thaw_chance_per_turn then
            local thawRoll = BattleRNG.randomInt(1, 100)
            if thawRoll <= effectData.thaw_chance_per_turn then
                print("Pokemon " .. pokemonId .. " thawed out")
                return true, 0
            end
        end
        return false, turnsRemaining
    end
    
    -- Permanent status effects don't auto-cure
    return false, turnsRemaining
end

-- Check if Pokemon can act (not prevented by status)
-- @param pokemonData: Pokemon data including status information
-- @param statusEffect: Active status effect
-- @param moveData: Move being attempted (for freeze thaw checks)
-- @return: Boolean indicating if action is allowed, reason if blocked
function MoveEffects.canPokemonAct(pokemonData, statusEffect, moveData)
    if not statusEffect or statusEffect == MoveEffects.StatusEffect.NONE then
        return true, nil
    end
    
    local effectData = MoveEffects.StatusEffectData[statusEffect]
    if not effectData then
        return true, nil
    end
    
    -- Sleep and freeze prevent all actions
    if effectData.prevents_action then
        -- Check for freeze thaw on fire moves
        if statusEffect == MoveEffects.StatusEffect.FREEZE and moveData and effectData.thaw_on_fire_move then
            if moveData.type == Enums.PokemonType.FIRE then
                print("Pokemon thawed out using fire move")
                return true, "thawed"
            end
        end
        return false, effectData.name
    end
    
    -- Paralysis has chance to prevent action
    if statusEffect == MoveEffects.StatusEffect.PARALYSIS and effectData.action_failure_chance then
        local paralysisRoll = BattleRNG.randomInt(1, 100)
        if paralysisRoll <= effectData.action_failure_chance then
            return false, "paralysis"
        end
    end
    
    return true, nil
end

-- Apply stat stage change to Pokemon
-- @param battleId: Battle instance identifier
-- @param targetId: Target Pokemon identifier
-- @param stat: Stat to modify (using Enums.Stat)
-- @param stages: Number of stages to change (-6 to +6)
-- @param source: Source of the stat change
-- @param pokemonData: Pokemon data for ability checks
-- @param currentStages: Current stat stages table
-- @return: Boolean indicating success and change details
function MoveEffects.applyStatStageChange(battleId, targetId, stat, stages, source, pokemonData, currentStages, battleState)
    -- Input validation
    if not battleId or not targetId or not stat or not stages then
        return false, "Invalid parameters for stat stage change"
    end
    
    if stages < -6 or stages > 6 then
        return false, "Stat stage change out of range (-6 to +6): " .. stages
    end
    
    -- Check for Mist protection against stat reductions
    if stages < 0 and battleState and pokemonData then

-- ===== MODULE: game-logic.battle.side-effects =====
-- File: ao-processes/game-logic/battle/side-effects.lua
-- Original require:         local SideEffects = require("game-logic.battle.side-effects")

-- Side Effects System
-- Implements team-wide defensive effects like Light Screen, Reflect, Aurora Veil, Safeguard, and Mist
-- Handles duration tracking, damage reduction, and status/stat protection

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


local SideEffects = {}

-- Side effect types
local SIDE_EFFECT_TYPES = {
    LIGHT_SCREEN = "LIGHT_SCREEN",
    REFLECT = "REFLECT", 
    AURORA_VEIL = "AURORA_VEIL",
    SAFEGUARD = "SAFEGUARD",
    MIST = "MIST"
}

-- Default side effect duration (turns)
local DEFAULT_DURATION = 5

-- Damage reduction percentages
local DAMAGE_REDUCTION = {
    SINGLES = 0.5,  -- 50% reduction in singles
    DOUBLES = 0.67  -- 33% reduction in doubles (1 - 0.67 = 0.33)
}

-- Initialize side effects for a battle side
-- @param battleState: Current battle state
-- @param side: Battle side ("player" or "enemy")
-- @return: Initialized side effects structure
function SideEffects.initializeSideEffects(battleState, side)
    if not battleState.sideEffects then
        battleState.sideEffects = {}
    end
    
    if not battleState.sideEffects[side] then
        battleState.sideEffects[side] = {}
    end
    
    return battleState.sideEffects[side]
end

-- Set a side effect for a battle side
-- @param battleState: Current battle state
-- @param side: Battle side ("player" or "enemy")
-- @param effectType: Type of side effect to set
-- @param duration: Duration in turns (optional, defaults to 5)
-- @return: Success boolean
function SideEffects.setSideEffect(battleState, side, effectType, duration)
    if not battleState or not side or not effectType then
        return false
    end
    
    duration = duration or DEFAULT_DURATION
    
    -- Initialize side effects if needed
    SideEffects.initializeSideEffects(battleState, side)
    
    -- Set the side effect with duration tracking
    battleState.sideEffects[side][effectType] = {
        type = effectType,
        duration = duration,
        activeTurn = battleState.turn or 1
    }
    
    return true
end

-- Remove a side effect from a battle side
-- @param battleState: Current battle state
-- @param side: Battle side ("player" or "enemy")
-- @param effectType: Type of side effect to remove
-- @return: Success boolean
function SideEffects.removeSideEffect(battleState, side, effectType)
    if not battleState or not side or not effectType then
        return false
    end
    
    if battleState.sideEffects and battleState.sideEffects[side] then
        battleState.sideEffects[side][effectType] = nil
        return true
    end
    
    return false
end

-- Check if a side effect is active
-- @param battleState: Current battle state
-- @param side: Battle side ("player" or "enemy") 
-- @param effectType: Type of side effect to check
-- @return: Boolean indicating if effect is active
function SideEffects.hasSideEffect(battleState, side, effectType)
    if not battleState or not side or not effectType then
        return false
    end
    
    if not battleState.sideEffects or not battleState.sideEffects[side] then
        return false
    end
    
    local effect = battleState.sideEffects[side][effectType]
    return effect ~= nil and effect.duration > 0
end

-- Get remaining duration for a side effect
-- @param battleState: Current battle state
-- @param side: Battle side ("player" or "enemy")
-- @param effectType: Type of side effect to check
-- @return: Remaining duration (0 if not active)
function SideEffects.getSideEffectDuration(battleState, side, effectType)
    if not SideEffects.hasSideEffect(battleState, side, effectType) then
        return 0
    end
    
    return battleState.sideEffects[side][effectType].duration
end

-- Process side effect duration countdown at end of turn
-- @param battleState: Current battle state
-- @return: Table of expired effects by side
function SideEffects.processTurnEnd(battleState)
    if not battleState or not battleState.sideEffects then
        return {player = {}, enemy = {}}
    end
    
    local expiredEffects = {
        player = {},
        enemy = {}
    }
    
    -- Process each side
    for side, sideEffects in pairs(battleState.sideEffects) do
        -- Ensure side exists in expiredEffects
        if not expiredEffects[side] then
            expiredEffects[side] = {}
        end
        
        for effectType, effect in pairs(sideEffects) do
            -- Decrease duration
            effect.duration = effect.duration - 1
            
            -- Check if expired
            if effect.duration <= 0 then
                table.insert(expiredEffects[side], effectType)
                battleState.sideEffects[side][effectType] = nil
            end
        end
    end
    
    return expiredEffects
end

-- Set Light Screen effect
-- @param battleState: Current battle state
-- @param side: Battle side to apply effect
-- @return: Success boolean
function SideEffects.setLightScreen(battleState, side)
    return SideEffects.setSideEffect(battleState, side, SIDE_EFFECT_TYPES.LIGHT_SCREEN, DEFAULT_DURATION)
end

-- Set Reflect effect
-- @param battleState: Current battle state
-- @param side: Battle side to apply effect
-- @return: Success boolean
function SideEffects.setReflect(battleState, side)
    return SideEffects.setSideEffect(battleState, side, SIDE_EFFECT_TYPES.REFLECT, DEFAULT_DURATION)
end

-- Set Aurora Veil effect (both Light Screen and Reflect during hail/snow)
-- @param battleState: Current battle state
-- @param side: Battle side to apply effect
-- @return: Success boolean
function SideEffects.setAuroraVeil(battleState, side)
    -- Check for hail or snow weather condition
    local weather = battleState.weather
    if weather ~= "HAIL" and weather ~= "SNOW" then
        return false, "Aurora Veil requires hail or snow weather"
    end
    
    return SideEffects.setSideEffect(battleState, side, SIDE_EFFECT_TYPES.AURORA_VEIL, DEFAULT_DURATION)
end

-- Set Safeguard effect
-- @param battleState: Current battle state
-- @param side: Battle side to apply effect
-- @return: Success boolean
function SideEffects.setSafeguard(battleState, side)
    return SideEffects.setSideEffect(battleState, side, SIDE_EFFECT_TYPES.SAFEGUARD, DEFAULT_DURATION)
end

-- Set Mist effect
-- @param battleState: Current battle state
-- @param side: Battle side to apply effect
-- @return: Success boolean
function SideEffects.setMist(battleState, side)
    return SideEffects.setSideEffect(battleState, side, SIDE_EFFECT_TYPES.MIST, DEFAULT_DURATION)
end

-- Calculate damage reduction from defensive screens
-- @param damage: Original damage amount
-- @param moveCategory: Physical or Special move category
-- @param attackingSide: Side performing the attack
-- @param defendingSide: Side receiving the attack
-- @param battleState: Current battle state
-- @param isDoublesFormat: Boolean indicating doubles battle format
-- @return: Reduced damage amount
function SideEffects.applyDamageReduction(damage, moveCategory, attackingSide, defendingSide, battleState, isDoublesFormat)
    if not damage or damage <= 0 then
        return damage
    end
    
    if not battleState or not defendingSide then
        return damage
    end
    
    local reductionFactor = 1.0
    
    -- Check for Light Screen (Special damage reduction)
    if moveCategory == Enums.MoveCategory.SPECIAL then
        if SideEffects.hasSideEffect(battleState, defendingSide, SIDE_EFFECT_TYPES.LIGHT_SCREEN) or
           SideEffects.hasSideEffect(battleState, defendingSide, SIDE_EFFECT_TYPES.AURORA_VEIL) then
            reductionFactor = isDoublesFormat and DAMAGE_REDUCTION.DOUBLES or DAMAGE_REDUCTION.SINGLES
        end
    end
    
    -- Check for Reflect (Physical damage reduction)
    if moveCategory == Enums.MoveCategory.PHYSICAL then
        if SideEffects.hasSideEffect(battleState, defendingSide, SIDE_EFFECT_TYPES.REFLECT) or
           SideEffects.hasSideEffect(battleState, defendingSide, SIDE_EFFECT_TYPES.AURORA_VEIL) then
            reductionFactor = isDoublesFormat and DAMAGE_REDUCTION.DOUBLES or DAMAGE_REDUCTION.SINGLES
        end
    end
    
    return math.floor(damage * reductionFactor)
end

-- Check if status condition application should be prevented by Safeguard
-- @param battleState: Current battle state
-- @param targetSide: Side of Pokemon receiving status
-- @param statusType: Status condition type being applied
-- @return: Boolean indicating if status should be prevented
function SideEffects.preventStatusCondition(battleState, targetSide, statusType)
    if not battleState or not targetSide or not statusType then
        return false
    end
    
    -- Safeguard prevents all status conditions
    return SideEffects.hasSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.SAFEGUARD)
end

-- Check if stat reduction should be prevented by Mist
-- @param battleState: Current battle state
-- @param targetSide: Side of Pokemon receiving stat change
-- @param statChanges: Table of stat changes being applied
-- @return: Boolean indicating if stat reductions should be prevented
function SideEffects.preventStatReduction(battleState, targetSide, statChanges)
    if not battleState or not targetSide or not statChanges then
        return false
    end
    
    -- Check if Mist is active on target side
    if not SideEffects.hasSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.MIST) then
        return false
    end
    
    -- Check if any stat changes are reductions (negative values)
    for stat, change in pairs(statChanges) do
        if change < 0 then
            return true  -- Prevent any negative stat changes
        end
    end
    
    return false
end

-- Remove screen effects (for Brick Break and Psychic Fangs)
-- @param battleState: Current battle state
-- @param targetSide: Side to remove screens from
-- @param removeAuroraVeil: Whether to also remove Aurora Veil (Psychic Fangs only)
-- @return: Table of removed effects
function SideEffects.removeScreens(battleState, targetSide, removeAuroraVeil)
    if not battleState or not targetSide then
        return {}
    end
    
    local removedEffects = {}
    
    -- Remove Light Screen
    if SideEffects.hasSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.LIGHT_SCREEN) then
        SideEffects.removeSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.LIGHT_SCREEN)
        table.insert(removedEffects, SIDE_EFFECT_TYPES.LIGHT_SCREEN)
    end
    
    -- Remove Reflect
    if SideEffects.hasSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.REFLECT) then
        SideEffects.removeSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.REFLECT)
        table.insert(removedEffects, SIDE_EFFECT_TYPES.REFLECT)
    end
    
    -- Remove Aurora Veil if specified (Psychic Fangs)
    if removeAuroraVeil and SideEffects.hasSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.AURORA_VEIL) then
        SideEffects.removeSideEffect(battleState, targetSide, SIDE_EFFECT_TYPES.AURORA_VEIL)
        table.insert(removedEffects, SIDE_EFFECT_TYPES.AURORA_VEIL)
    end
    
    return removedEffects
end

-- Get all active side effects for a battle side
-- @param battleState: Current battle state
-- @param side: Battle side to check
-- @return: Table of active side effects with their data
function SideEffects.getActiveSideEffects(battleState, side)
    if not battleState or not side then
        return {}
    end
    
    if not battleState.sideEffects or not battleState.sideEffects[side] then
        return {}
    end
    
    local activeEffects = {}
    for effectType, effectData in pairs(battleState.sideEffects[side]) do
        if effectData.duration > 0 then
            activeEffects[effectType] = effectData
        end
    end
    
    return activeEffects
end

-- Check if any defensive screens are active (Light Screen, Reflect, or Aurora Veil)
-- @param battleState: Current battle state
-- @param side: Battle side to check
-- @return: Boolean indicating if any screens are active
function SideEffects.hasAnyScreens(battleState, side)
    return SideEffects.hasSideEffect(battleState, side, SIDE_EFFECT_TYPES.LIGHT_SCREEN) or
           SideEffects.hasSideEffect(battleState, side, SIDE_EFFECT_TYPES.REFLECT) or
           SideEffects.hasSideEffect(battleState, side, SIDE_EFFECT_TYPES.AURORA_VEIL)
end

-- Get side effect names for display
-- @param effectType: Side effect type
-- @return: Human-readable name
function SideEffects.getEffectName(effectType)
    local names = {
        [SIDE_EFFECT_TYPES.LIGHT_SCREEN] = "Light Screen",
        [SIDE_EFFECT_TYPES.REFLECT] = "Reflect",
        [SIDE_EFFECT_TYPES.AURORA_VEIL] = "Aurora Veil",
        [SIDE_EFFECT_TYPES.SAFEGUARD] = "Safeguard", 
        [SIDE_EFFECT_TYPES.MIST] = "Mist"
    }
    
    return names[effectType] or effectType
end

-- Export side effect types for external use
SideEffects.TYPES = SIDE_EFFECT_TYPES


-- ===== END MODULE: game-logic.battle.side-effects =====

        local targetSide = pokemonData.side or "player"
        local statChanges = {[stat] = stages}
        
        if SideEffects.preventStatReduction(battleState, targetSide, statChanges) then
            return false, "Stat reduction prevented by Mist", true  -- Third param indicates blocked by Mist
        end
    end
    
    -- Check if stat is valid (either numeric index or string name)
    local validStats = {"attack", "defense", "spAttack", "spDefense", "speed", "accuracy", "evasion"}
    local isValidStat = false
    if type(stat) == "number" and MoveEffects.StatStages[stat] then
        isValidStat = true
    elseif type(stat) == "string" then
        for _, validStat in ipairs(validStats) do
            if stat == validStat then
                isValidStat = true
                break
            end
        end
    end
    
    if not isValidStat then
        return false, "Invalid stat for stage change: " .. tostring(stat)
    end
    
    -- Get current stat stage (default 0)
    local currentStage = (currentStages and currentStages[stat]) or 0
    
    -- Check ability interactions
    local finalStages = stages
    local abilityModified = false
    
    if pokemonData and pokemonData.ability then
        -- Check for stat reduction prevention first
        if stages < 0 then
            if pokemonData.ability == Enums.AbilityId.CLEAR_BODY then
                return false, "Clear Body prevents stat reduction"
            elseif pokemonData.ability == Enums.AbilityId.WHITE_SMOKE then
                return false, "White Smoke prevents stat reduction"
            elseif pokemonData.ability == Enums.AbilityId.HYPER_CUTTER and stat == Enums.Stat.ATK then
                return false, "Hyper Cutter prevents Attack reduction"
            elseif pokemonData.ability == Enums.AbilityId.KEEN_EYE and stat == Enums.Stat.ACC then
                return false, "Keen Eye prevents accuracy reduction"
            end
        end
        
        -- Apply stat modification abilities
        if pokemonData.ability == Enums.AbilityId.SIMPLE then
            -- Simple doubles stat changes
            finalStages = stages * 2
            abilityModified = true
        elseif pokemonData.ability == Enums.AbilityId.CONTRARY then
            -- Contrary reverses stat changes
            finalStages = -stages
            abilityModified = true
        end
    end
    
    -- Calculate new stage with bounds checking
    local newStage = math.max(-6, math.min(6, currentStage + finalStages))
    local actualChange = newStage - currentStage
    
    -- Check if change actually occurred
    if actualChange == 0 then
        local statName = stat
        if type(stat) == "number" then
            statName = MoveEffects.StatStages[stat] or tostring(stat)
        end
        if currentStage == 6 and finalStages > 0 then
            return false, statName .. " cannot be raised further"
        elseif currentStage == -6 and finalStages < 0 then
            return false, statName .. " cannot be lowered further"
        end
        return false, "No stat change occurred"
    end
    
    -- Get stat name for display
    local statName = stat
    if type(stat) == "number" then
        statName = MoveEffects.StatStages[stat] or tostring(stat)
    end
    local multiplier = MoveEffects.StatStageMultipliers[newStage]
    
    local result = {
        success = true,
        stat = stat,
        stat_name = statName,
        stages_changed = actualChange,
        new_stage = newStage,
        new_multiplier = multiplier,
        ability_modified = abilityModified,
        source = source,
        timestamp = os.time()
    }
    
    local changeText = actualChange > 0 and "raised" or "lowered"
    print(statName .. " " .. changeText .. " by " .. math.abs(actualChange) .. " stage(s) for Pokemon " .. targetId)
    return true, result
end

-- Reset all stat stages to 0
-- @param battleId: Battle instance identifier
-- @param targetId: Target Pokemon identifier
-- @param source: Source of the reset (Haze, etc.)
-- @return: Boolean indicating success and reset details
function MoveEffects.resetStatStages(battleId, targetId, source)
    if not battleId or not targetId then
        return false, "Invalid parameters for stat stage reset"
    end
    
    local result = {
        success = true,
        reset_stats = {},
        source = source,
        timestamp = os.time()
    }
    
    -- Reset all battle stats (excluding HP)
    for stat, statName in pairs(MoveEffects.StatStages) do
        if stat ~= Enums.Stat.HP then
            result.reset_stats[stat] = {
                stat_name = statName,
                new_stage = 0,
                new_multiplier = 1.0
            }
        end
    end
    
    print("All stat stages reset to 0 for Pokemon " .. targetId)
    return true, result
end

-- Copy stat stages from one Pokemon to another
-- @param battleId: Battle instance identifier
-- @param sourceId: Source Pokemon ID
-- @param targetId: Target Pokemon ID
-- @param sourceStages: Source Pokemon's current stat stages
-- @param moveSource: Move causing the copy (Psych Up, etc.)
-- @return: Boolean indicating success and copy details
function MoveEffects.copyStatStages(battleId, sourceId, targetId, sourceStages, moveSource)
    if not battleId or not sourceId or not targetId or not sourceStages then
        return false, "Invalid parameters for stat stage copy"
    end
    
    local result = {
        success = true,
        copied_stats = {},
        source_pokemon = sourceId,
        target_pokemon = targetId,
        move_source = moveSource,
        timestamp = os.time()
    }
    
    -- Copy all stat stages (excluding HP)
    for stat, stage in pairs(sourceStages) do
        if stat ~= Enums.Stat.HP and MoveEffects.StatStages[stat] then
            result.copied_stats[stat] = {
                stat_name = MoveEffects.StatStages[stat],
                new_stage = stage,
                new_multiplier = MoveEffects.StatStageMultipliers[stage]
            }
        end
    end
    
    print("Copied stat stages from Pokemon " .. sourceId .. " to Pokemon " .. targetId)
    return true, result
end

-- Calculate effective stat with stage multipliers
-- @param baseStat: Base stat value
-- @param stage: Current stat stage (-6 to +6)
-- @return: Effective stat value with stage multiplier applied
function MoveEffects.calculateEffectiveStat(baseStat, stage)
    if not baseStat or not stage then
        return baseStat or 0
    end
    
    local multiplier = MoveEffects.StatStageMultipliers[stage] or 1.0
    return math.floor(baseStat * multiplier)
end

-- Get stat stage description for UI/debugging
-- @param stat: Stat ID
-- @param stage: Current stage
-- @return: Human-readable description
function MoveEffects.getStatStageDescription(stat, stage)
    local statName = MoveEffects.StatStages[stat]
    if not statName then
        return "Unknown stat"
    end
    
    if stage == 0 then
        return statName .. " (normal)"
    elseif stage > 0 then
        return statName .. " (+" .. stage .. ")"
    else
        return statName .. " (" .. stage .. ")"
    end
end

-- Apply weather change effect
-- @param battleId: Battle instance identifier
-- @param weatherType: Weather type to set
-- @param duration: Duration in turns (-1 for permanent)
-- @param source: Source of the weather change
-- @return: Boolean indicating success and weather details
function MoveEffects.applyWeatherChange(battleId, weatherType, duration, source)
    -- Input validation
    if not battleId or not weatherType then
        return false, "Invalid parameters for weather change"
    end
    
    -- Integration ready - provides weather effect foundation
    -- Ready for battle-conditions.lua integration
    
    local weatherNames = {
        [MoveEffects.WeatherType.SUNNY] = "Sunny",
        [MoveEffects.WeatherType.RAIN] = "Rain",
        [MoveEffects.WeatherType.SANDSTORM] = "Sandstorm",
        [MoveEffects.WeatherType.HAIL] = "Hail",
        [MoveEffects.WeatherType.SNOW] = "Snow",
        [MoveEffects.WeatherType.FOG] = "Fog",
        [MoveEffects.WeatherType.HEAVY_RAIN] = "Heavy Rain",
        [MoveEffects.WeatherType.HARSH_SUN] = "Harsh Sun",
        [MoveEffects.WeatherType.STRONG_WINDS] = "Strong Winds"
    }
    
    local weatherName = weatherNames[weatherType] or "Unknown"
    
    local result = {
        success = true,
        weather_type = weatherType,
        weather_name = weatherName,
        duration = duration or 5, -- Default 5 turns
        source = source,
        timestamp = os.time()
    }
    
    print("Changed weather to " .. weatherName .. " in battle " .. battleId)
    return true, result
end

-- Apply terrain change effect
-- @param battleId: Battle instance identifier
-- @param terrainType: Terrain type to set
-- @param duration: Duration in turns
-- @param source: Source of the terrain change
-- @return: Boolean indicating success and terrain details
function MoveEffects.applyTerrainChange(battleId, terrainType, duration, source)
    -- Input validation
    if not battleId or not terrainType then
        return false, "Invalid parameters for terrain change"
    end
    
    -- Integration ready - provides terrain effect foundation
    
    local terrainNames = {
        [MoveEffects.TerrainType.ELECTRIC] = "Electric Terrain",
        [MoveEffects.TerrainType.GRASSY] = "Grassy Terrain",
        [MoveEffects.TerrainType.MISTY] = "Misty Terrain",
        [MoveEffects.TerrainType.PSYCHIC] = "Psychic Terrain"
    }
    
    local terrainName = terrainNames[terrainType] or "Unknown"
    
    local result = {
        success = true,
        terrain_type = terrainType,
        terrain_name = terrainName,
        duration = duration or 5, -- Default 5 turns
        source = source,
        timestamp = os.time()
    }
    
    print("Changed terrain to " .. terrainName .. " in battle " .. battleId)
    return true, result
end

-- Apply healing effect to Pokemon
-- @param battleId: Battle instance identifier
-- @param targetId: Target Pokemon identifier
-- @param healingFormula: Healing formula ("1/2", "1/4", "full", fixed amount)
-- @param source: Source of the healing
-- @param pokemonData: Pokemon data including current/max HP
-- @param weatherType: Current weather type for weather-dependent healing
-- @param moveName: Name of the healing move for weather modifications
-- @return: Boolean indicating success and healing details
function MoveEffects.applyHealingEffect(battleId, targetId, healingFormula, source, pokemonData, weatherType, moveName)
    -- Input validation
    if not battleId or not targetId or not healingFormula then
        return false, "Invalid parameters for healing effect"
    end
    
    if not pokemonData or not pokemonData.currentHP or not pokemonData.maxHP then
        return false, "Pokemon data required for healing calculation"
    end
    
    -- Check if Pokemon is already at full HP
    if pokemonData.currentHP >= pokemonData.maxHP then
        return false, "Pokemon is already at full HP"
    end
    
    local maxHP = pokemonData.maxHP
    local currentHP = pokemonData.currentHP
    local healingAmount = 0
    
    -- Calculate base healing amount
    if healingFormula == "full" then
        healingAmount = maxHP - currentHP
    elseif healingFormula == "1/2" then
        healingAmount = math.floor(maxHP / 2)
    elseif healingFormula == "1/4" then
        healingAmount = math.floor(maxHP / 4)
    elseif healingFormula == "1/8" then
        healingAmount = math.floor(maxHP / 8)
    elseif healingFormula == "1/16" then
        healingAmount = math.floor(maxHP / 16)
    elseif healingFormula == "2/3" then
        healingAmount = math.floor(maxHP * 2 / 3)
    elseif healingFormula == "3/4" then
        healingAmount = math.floor(maxHP * 3 / 4)
    elseif type(healingFormula) == "number" then
        healingAmount = healingFormula
    else
        return false, "Invalid healing formula: " .. tostring(healingFormula)
    end
    
    -- Apply weather modifications for specific moves
    if weatherType and moveName then

-- ===== MODULE: data.battle.weather-data =====
-- File: ao-processes/data/battle/weather-data.lua
-- Original require:         local WeatherData = require("data.battle.weather-data")

-- Weather System Data
-- Complete weather type interactions with abilities and move effects
-- Provides exact damage modifiers and ability interactions matching TypeScript implementation

local WeatherData = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Weather type effectiveness chart
-- Maps weather types to move type multipliers
WeatherData.TypeModifiers = {
    [1] = { -- SUNNY
        [Enums.PokemonType.FIRE] = 1.5,      -- Fire moves boosted
        [Enums.PokemonType.WATER] = 0.5      -- Water moves weakened
    },
    [2] = { -- RAIN
        [Enums.PokemonType.WATER] = 1.5,     -- Water moves boosted
        [Enums.PokemonType.FIRE] = 0.5       -- Fire moves weakened
    },
    [3] = { -- SANDSTORM
        -- No direct type modifiers, but provides Rock-type SpDef boost
    },
    [4] = { -- HAIL
        -- No direct type modifiers
    },
    [5] = { -- SNOW
        -- No direct type modifiers, but provides Ice-type Defense boost
    }
}

-- Weather ability interactions
-- Maps weather types to abilities that are boosted or triggered
WeatherData.AbilityInteractions = {
    [1] = { -- SUNNY
        boost = {
            [Enums.AbilityId.CHLOROPHYLL] = {stat = "speed", multiplier = 2.0},
            [Enums.AbilityId.SOLAR_POWER] = {stat = "special_attack", multiplier = 1.5}
        },
        trigger = {
            [Enums.AbilityId.DROUGHT] = true
        }
    },
    [2] = { -- RAIN
        boost = {
            [Enums.AbilityId.SWIFT_SWIM] = {stat = "speed", multiplier = 2.0},
            [Enums.AbilityId.RAIN_DISH] = {healing = "1/16"}
        },
        trigger = {
            [Enums.AbilityId.DRIZZLE] = true
        }
    },
    [3] = { -- SANDSTORM
        boost = {
            [Enums.AbilityId.SAND_VEIL] = {evasion = 1.25}
        },
        immunity = {
            [Enums.AbilityId.SAND_VEIL] = true
        },
        trigger = {
            [Enums.AbilityId.SAND_STREAM] = true
        }
    },
    [4] = { -- HAIL
        immunity = {},
        boost = {},
        trigger = {}
    }
}

-- Weather-specific move accuracy modifiers
WeatherData.AccuracyModifiers = {
    [2] = { -- RAIN
        ["thunder"] = 100,    -- Thunder always hits in rain
        ["hurricane"] = 100   -- Hurricane always hits in rain
    },
    [1] = { -- SUNNY
        ["thunder"] = 50,     -- Thunder accuracy reduced in sun
        ["hurricane"] = 50    -- Hurricane accuracy reduced in sun
    },
    [4] = { -- HAIL
        ["blizzard"] = 100    -- Blizzard always hits in hail
    },
    [6] = { -- FOG
        -- All moves have 60% accuracy in fog (applied globally)
    }
}

-- Weather damage per turn
WeatherData.EndTurnDamage = {
    [3] = { -- SANDSTORM
        damage = "1/16",
        immune_types = {Enums.PokemonType.ROCK, Enums.PokemonType.GROUND, Enums.PokemonType.STEEL}
    },
    [4] = { -- HAIL
        damage = "1/16",
        immune_types = {Enums.PokemonType.ICE}
    }
}

-- Weather healing modifiers for specific moves
WeatherData.HealingModifiers = {
    [1] = { -- SUNNY
        ["synthesis"] = "2/3",      -- Synthesis heals 2/3 HP in sun (up from 1/2)
        ["morning_sun"] = "2/3",    -- Morning Sun heals 2/3 HP in sun
        ["moonlight"] = "2/3"       -- Moonlight heals 2/3 HP in sun
    },
    [2] = { -- RAIN
        ["synthesis"] = "1/4",      -- Synthesis heals 1/4 HP in rain (down from 1/2)
        ["morning_sun"] = "1/4",    -- Morning Sun heals 1/4 HP in rain
        ["moonlight"] = "1/4"       -- Moonlight heals 1/4 HP in rain
    },
    [3] = { -- SANDSTORM
        ["synthesis"] = "1/4",      -- Synthesis heals 1/4 HP in sandstorm
        ["morning_sun"] = "1/4",    -- Morning Sun heals 1/4 HP in sandstorm
        ["moonlight"] = "1/4"       -- Moonlight heals 1/4 HP in sandstorm
    },
    [4] = { -- HAIL
        ["synthesis"] = "1/4",      -- Synthesis heals 1/4 HP in hail
        ["morning_sun"] = "1/4",    -- Morning Sun heals 1/4 HP in hail
        ["moonlight"] = "1/4"       -- Moonlight heals 1/4 HP in hail
    }
}

-- Weather stat modifiers (applied continuously while weather is active)
WeatherData.StatModifiers = {
    [3] = { -- SANDSTORM
        -- Rock-type Pokemon get 50% SpDef boost
        type_modifiers = {
            [Enums.PokemonType.ROCK] = {
                [Enums.Stat.SPDEF] = 1.5
            }
        }
    },
    [5] = { -- SNOW
        -- Ice-type Pokemon get 50% Defense boost
        type_modifiers = {
            [Enums.PokemonType.ICE] = {
                [Enums.Stat.DEF] = 1.5
            }
        }
    }
}

-- Weather duration data
WeatherData.DurationData = {
    default = 5,     -- Standard weather duration
    permanent = -1,  -- Permanent weather (Primoridal weather conditions)
    abilities = {
        [Enums.AbilityId.DROUGHT] = {duration = 5, weather = 1},      -- Sunny
        [Enums.AbilityId.DRIZZLE] = {duration = 5, weather = 2},      -- Rain  
        [Enums.AbilityId.SAND_STREAM] = {duration = 5, weather = 3}   -- Sandstorm
    }
}

-- Get weather type modifier for move power
-- @param weatherType: Current weather type (1-9)
-- @param moveType: Move type ID
-- @return: Power multiplier (1.0 = no change)
function WeatherData.getTypePowerModifier(weatherType, moveType)
    local modifiers = WeatherData.TypeModifiers[weatherType]
    if not modifiers then
        return 1.0
    end
    
    return modifiers[moveType] or 1.0
end

-- Get weather accuracy modifier for specific moves
-- @param weatherType: Current weather type
-- @param moveName: Name of the move (lowercase)
-- @return: Accuracy value or nil for no change
function WeatherData.getAccuracyModifier(weatherType, moveName)
    local modifiers = WeatherData.AccuracyModifiers[weatherType]
    if not modifiers then
        return nil
    end
    
    return modifiers[moveName]
end

-- Get end-turn damage for weather
-- @param weatherType: Current weather type
-- @param pokemonTypes: Array of Pokemon types
-- @param pokemonAbility: Pokemon ability ID
-- @return: Damage amount string or nil
function WeatherData.getEndTurnDamage(weatherType, pokemonTypes, pokemonAbility)
    local damageData = WeatherData.EndTurnDamage[weatherType]
    if not damageData then
        return nil
    end
    
    -- Check type immunity
    if damageData.immune_types then
        for _, immuneType in ipairs(damageData.immune_types) do
            for _, pokemonType in ipairs(pokemonTypes) do
                if pokemonType == immuneType then
                    return nil -- Immune to weather damage
                end
            end
        end
    end
    
    -- Check ability immunity
    local abilityData = WeatherData.AbilityInteractions[weatherType]
    if abilityData and abilityData.immunity and abilityData.immunity[pokemonAbility] then
        return nil -- Ability grants immunity
    end
    
    return damageData.damage
end

-- Get healing modifier for weather-dependent moves
-- @param weatherType: Current weather type
-- @param moveName: Name of the healing move
-- @return: Healing fraction string or nil
function WeatherData.getHealingModifier(weatherType, moveName)
    local modifiers = WeatherData.HealingModifiers[weatherType]
    if not modifiers then
        return nil
    end
    
    return modifiers[moveName]
end

-- Get stat modifier from weather
-- @param weatherType: Current weather type
-- @param pokemonTypes: Array of Pokemon types
-- @param stat: Stat to check
-- @return: Stat multiplier or 1.0 for no change
function WeatherData.getStatModifier(weatherType, pokemonTypes, stat)
    local modifierData = WeatherData.StatModifiers[weatherType]
    if not modifierData or not modifierData.type_modifiers then
        return 1.0
    end
    
    for _, pokemonType in ipairs(pokemonTypes) do
        local typeModifiers = modifierData.type_modifiers[pokemonType]
        if typeModifiers and typeModifiers[stat] then
            return typeModifiers[stat]
        end
    end
    
    return 1.0
end

-- Check if ability is boosted by weather
-- @param weatherType: Current weather type
-- @param abilityId: Ability to check
-- @return: Boost data table or nil
function WeatherData.getAbilityBoost(weatherType, abilityId)
    local abilityData = WeatherData.AbilityInteractions[weatherType]
    if not abilityData or not abilityData.boost then
        return nil
    end
    
    return abilityData.boost[abilityId]
end

-- Check if ability triggers weather
-- @param abilityId: Ability to check
-- @return: Weather type or nil
function WeatherData.getAbilityWeather(abilityId)
    local durationData = WeatherData.DurationData.abilities[abilityId]
    return durationData and durationData.weather or nil
end


-- ===== END MODULE: data.battle.weather-data =====

        local weatherModifier = WeatherData.getHealingModifier(weatherType, moveName)
        if weatherModifier then
            -- Recalculate with weather modifier
            if weatherModifier == "2/3" then
                healingAmount = math.floor(maxHP * 2 / 3)
            elseif weatherModifier == "1/4" then
                healingAmount = math.floor(maxHP / 4)
            elseif weatherModifier == "3/4" then
                healingAmount = math.floor(maxHP * 3 / 4)
            end
        end
    end
    
    -- Ensure minimum 1 HP healing if formula would heal 0
    if healingAmount < 1 and healingFormula ~= "0" then
        healingAmount = 1
    end
    
    -- Cap healing to not exceed max HP
    local actualHealing = math.min(healingAmount, maxHP - currentHP)
    local newHP = currentHP + actualHealing
    
    local weatherModified = false
    if weatherType and moveName then

-- ===== MODULE: data.battle.weather-data =====
-- File: ao-processes/data/battle/weather-data.lua
-- Original require:         local WeatherData = require("data.battle.weather-data")


-- ===== END MODULE: data.battle.weather-data =====

        weatherModified = WeatherData.getHealingModifier(weatherType, moveName) ~= nil
    end
    
    local result = {
        success = true,
        target = targetId,
        formula = healingFormula,
        healing_amount = actualHealing,
        new_hp = newHP,
        max_hp = maxHP,
        weather_modified = weatherModified,
        source = source,
        timestamp = os.time()
    }
    
    print("Healed " .. actualHealing .. " HP to Pokemon " .. targetId .. " (" .. newHP .. "/" .. maxHP .. ")")
    return true, result
end

-- Calculate healing amount without applying it
-- @param healingFormula: Healing formula string
-- @param maxHP: Pokemon's maximum HP
-- @param currentHP: Pokemon's current HP
-- @param weatherType: Current weather type
-- @param moveName: Name of healing move
-- @return: Calculated healing amount
function MoveEffects.calculateHealingAmount(healingFormula, maxHP, currentHP, weatherType, moveName)
    if not healingFormula or not maxHP then
        return 0
    end
    
    local healingAmount = 0
    
    -- Calculate base healing
    if healingFormula == "full" then
        healingAmount = maxHP - (currentHP or 0)
    elseif healingFormula == "1/2" then
        healingAmount = math.floor(maxHP / 2)
    elseif healingFormula == "1/4" then
        healingAmount = math.floor(maxHP / 4)
    elseif healingFormula == "1/8" then
        healingAmount = math.floor(maxHP / 8)
    elseif healingFormula == "1/16" then
        healingAmount = math.floor(maxHP / 16)
    elseif healingFormula == "2/3" then
        healingAmount = math.floor(maxHP * 2 / 3)
    elseif healingFormula == "3/4" then
        healingAmount = math.floor(maxHP * 3 / 4)
    elseif type(healingFormula) == "number" then
        healingAmount = healingFormula
    end
    
    -- Apply weather modifications
    if weatherType and moveName then

-- ===== MODULE: data.battle.weather-data =====
-- File: ao-processes/data/battle/weather-data.lua
-- Original require:         local WeatherData = require("data.battle.weather-data")


-- ===== END MODULE: data.battle.weather-data =====

        local weatherModifier = WeatherData.getHealingModifier(weatherType, moveName)
        if weatherModifier then
            if weatherModifier == "2/3" then
                healingAmount = math.floor(maxHP * 2 / 3)
            elseif weatherModifier == "1/4" then
                healingAmount = math.floor(maxHP / 4)
            elseif weatherModifier == "3/4" then
                healingAmount = math.floor(maxHP * 3 / 4)
            end
        end
    end
    
    return math.max(0, healingAmount)
end

-- Check if healing move will fail
-- @param pokemonData: Pokemon data including HP
-- @param healingFormula: Healing formula
-- @return: Boolean indicating if move will fail, reason if applicable
function MoveEffects.willHealingFail(pokemonData, healingFormula)
    if not pokemonData then
        return true, "No Pokemon data"
    end
    
    -- Check if Pokemon is fainted
    if pokemonData.currentHP <= 0 then
        return true, "Pokemon is fainted"
    end
    
    -- Check if Pokemon is at full HP
    if pokemonData.currentHP >= pokemonData.maxHP then
        return true, "Pokemon is already at full HP"
    end
    
    -- Healing moves with 0 healing always fail
    if healingFormula == "0" or healingFormula == 0 then
        return true, "No healing amount"
    end
    
    return false, nil
end

-- Get healing move description
-- @param healingFormula: Healing formula
-- @param weatherType: Current weather (optional)
-- @param moveName: Move name for weather effects (optional)
-- @return: Human-readable description
function MoveEffects.getHealingDescription(healingFormula, weatherType, moveName)
    local description = ""
    
    if healingFormula == "full" then
        description = "Restores all HP"
    elseif healingFormula == "1/2" then
        description = "Restores 1/2 of max HP"
    elseif healingFormula == "1/4" then
        description = "Restores 1/4 of max HP"
    elseif healingFormula == "1/8" then
        description = "Restores 1/8 of max HP"
    elseif healingFormula == "1/16" then
        description = "Restores 1/16 of max HP"
    elseif healingFormula == "2/3" then
        description = "Restores 2/3 of max HP"
    elseif healingFormula == "3/4" then
        description = "Restores 3/4 of max HP"
    elseif type(healingFormula) == "number" then
        description = "Restores " .. healingFormula .. " HP"
    else
        description = "Unknown healing"
    end
    
    -- Add weather modification note
    if weatherType and moveName then

-- ===== MODULE: data.battle.weather-data =====
-- File: ao-processes/data/battle/weather-data.lua
-- Original require:         local WeatherData = require("data.battle.weather-data")


-- ===== END MODULE: data.battle.weather-data =====

        local weatherModifier = WeatherData.getHealingModifier(weatherType, moveName)
        if weatherModifier then
            description = description .. " (" .. weatherModifier .. " in current weather)"
        end
    end
    
    return description
end

-- Apply recoil damage to Pokemon
-- @param battleId: Battle instance identifier
-- @param attackerId: Pokemon taking recoil damage
-- @param recoilFormula: Recoil formula ("1/4", "1/3", "1/2", "max_hp_1/4", etc.)
-- @param damageDealt: Amount of damage dealt by the move
-- @param source: Source move causing recoil
-- @param pokemonData: Pokemon data for ability and HP checks
-- @return: Boolean indicating success and recoil details
function MoveEffects.applyRecoilDamage(battleId, attackerId, recoilFormula, damageDealt, source, pokemonData)
    -- Input validation
    if not battleId or not attackerId or not recoilFormula then
        return false, "Invalid parameters for recoil damage"
    end
    
    if not pokemonData then
        return false, "Pokemon data required for recoil damage calculation"
    end
    
    -- Check for recoil immunity abilities
    if pokemonData.ability == Enums.AbilityId.ROCK_HEAD then
        return false, "Rock Head prevents recoil damage"
    elseif pokemonData.ability == Enums.AbilityId.MAGIC_GUARD then
        return false, "Magic Guard prevents indirect damage"
    end
    
    -- Calculate recoil amount based on formula
    local recoilAmount = 0
    local baseRecoil = 0
    
    if recoilFormula == "1/4" then
        baseRecoil = math.floor(damageDealt / 4)
    elseif recoilFormula == "1/3" then
        baseRecoil = math.floor(damageDealt / 3)
    elseif recoilFormula == "1/2" then
        baseRecoil = math.floor(damageDealt / 2)
    elseif recoilFormula == "2/3" then
        baseRecoil = math.floor(damageDealt * 2 / 3)
    elseif recoilFormula == "max_hp_1/4" then
        -- Fixed recoil based on user's max HP (Brave Bird, Wood Hammer)
        local maxHP = pokemonData.maxHP or pokemonData.stats[Enums.Stat.HP]
        baseRecoil = math.floor(maxHP / 4)
    elseif recoilFormula == "max_hp_1/3" then
        -- Fixed recoil based on user's max HP (Flare Blitz)
        local maxHP = pokemonData.maxHP or pokemonData.stats[Enums.Stat.HP]
        baseRecoil = math.floor(maxHP / 3)
    elseif recoilFormula == "max_hp_1/2" then
        -- Fixed recoil based on user's max HP (Explosion)
        local maxHP = pokemonData.maxHP or pokemonData.stats[Enums.Stat.HP]
        baseRecoil = math.floor(maxHP / 2)
    elseif type(recoilFormula) == "number" then
        baseRecoil = recoilFormula
    else
        return false, "Invalid recoil formula: " .. tostring(recoilFormula)
    end
    
    recoilAmount = baseRecoil
    
    -- Apply Reckless ability boost for recoil moves
    local abilityModified = false
    if pokemonData.ability == Enums.AbilityId.RECKLESS and not string.find(recoilFormula, "max_hp") then
        -- Reckless boosts recoil move damage by 20%, which affects recoil proportionally
        recoilAmount = math.floor(recoilAmount * 1.2)
        abilityModified = true
    end
    
    -- Ensure minimum 1 recoil damage if formula would deal 0
    if recoilAmount < 1 and baseRecoil > 0 then
        recoilAmount = 1
    end
    
    -- Check if recoil would cause fainting
    local currentHP = pokemonData.currentHP or pokemonData.stats[Enums.Stat.HP]
    local willFaint = recoilAmount >= currentHP
    local actualRecoil = math.min(recoilAmount, currentHP - 1) -- Prevent fainting from recoil
    
    -- Some moves can cause user to faint from recoil (like Explosion)
    if source and (source == "explosion" or source == "self_destruct") then
        actualRecoil = recoilAmount
    end
    
    local result = {
        success = true,
        attacker = attackerId,
        formula = recoilFormula,
        damage_dealt = damageDealt,
        base_recoil = baseRecoil,
        recoil_amount = actualRecoil,
        ability_modified = abilityModified,
        would_faint = willFaint,
        source = source,
        timestamp = os.time()
    }
    
    print("Applied recoil damage (" .. actualRecoil .. ") to Pokemon " .. attackerId .. " from " .. (source or "recoil"))
    return true, result
end

-- Calculate recoil damage without applying it
-- @param recoilFormula: Recoil formula string
-- @param damageDealt: Damage dealt by the move
-- @param pokemonData: Pokemon data for HP and ability checks
-- @return: Calculated recoil damage amount
function MoveEffects.calculateRecoilDamage(recoilFormula, damageDealt, pokemonData)
    if not recoilFormula or not pokemonData then
        return 0
    end

    -- Check for immunity
    if pokemonData.ability == Enums.AbilityId.ROCK_HEAD or
       pokemonData.ability == Enums.AbilityId.MAGIC_GUARD then
        return 0
    end

    local baseRecoil = 0

    if recoilFormula == "1/4" then
        baseRecoil = math.floor(damageDealt / 4)
    elseif recoilFormula == "1/3" then
        baseRecoil = math.floor(damageDealt / 3)
    elseif recoilFormula == "1/2" then
        baseRecoil = math.floor(damageDealt / 2)
    elseif recoilFormula == "2/3" then
        baseRecoil = math.floor(damageDealt * 2 / 3)
    elseif recoilFormula == "max_hp_1/4" then
        local maxHP = pokemonData.maxHP or pokemonData.stats[Enums.Stat.HP]
        baseRecoil = math.floor(maxHP / 4)
    elseif recoilFormula == "max_hp_1/3" then
        local maxHP = pokemonData.maxHP or pokemonData.stats[Enums.Stat.HP]
        baseRecoil = math.floor(maxHP / 3)
    elseif recoilFormula == "max_hp_1/2" then
        local maxHP = pokemonData.maxHP or pokemonData.stats[Enums.Stat.HP]
        baseRecoil = math.floor(maxHP / 2)
    elseif type(recoilFormula) == "number" then
        baseRecoil = recoilFormula
    end

    -- Apply Reckless ability boost
    if pokemonData.ability == Enums.AbilityId.RECKLESS and not string.find(recoilFormula, "max_hp") then
        baseRecoil = math.floor(baseRecoil * 1.2)
    end

    return math.max(0, baseRecoil)
end

-- Check if Pokemon will take recoil damage
-- @param pokemonData: Pokemon data including ability
-- @param recoilFormula: Recoil formula
-- @return: Boolean indicating if recoil will be taken
function MoveEffects.willTakeRecoilDamage(pokemonData, recoilFormula)
    if not pokemonData or not recoilFormula then
        return false
    end

    -- Check immunity abilities
    if pokemonData.ability == Enums.AbilityId.ROCK_HEAD or
       pokemonData.ability == Enums.AbilityId.MAGIC_GUARD then
        return false
    end

    return true
end

-- Get recoil damage description
-- @param recoilFormula: Recoil formula
-- @param pokemonData: Pokemon data for ability checks (optional)
-- @return: Human-readable description
function MoveEffects.getRecoilDescription(recoilFormula, pokemonData)
    if not recoilFormula then
        return "No recoil"
    end

    -- Check immunity
    if pokemonData then
        if pokemonData.ability == Enums.AbilityId.ROCK_HEAD then
            return "No recoil (Rock Head)"
        elseif pokemonData.ability == Enums.AbilityId.MAGIC_GUARD then
            return "No recoil (Magic Guard)"
        end
    end

    local description = ""
    if recoilFormula == "1/4" then
        description = "User takes 1/4 of damage dealt as recoil"
    elseif recoilFormula == "1/3" then
        description = "User takes 1/3 of damage dealt as recoil"
    elseif recoilFormula == "1/2" then
        description = "User takes 1/2 of damage dealt as recoil"
    elseif recoilFormula == "2/3" then
        description = "User takes 2/3 of damage dealt as recoil"
    elseif recoilFormula == "max_hp_1/4" then
        description = "User takes 1/4 of max HP as recoil"
    elseif recoilFormula == "max_hp_1/3" then
        description = "User takes 1/3 of max HP as recoil"
    elseif recoilFormula == "max_hp_1/2" then
        description = "User takes 1/2 of max HP as recoil"
    elseif type(recoilFormula) == "number" then
        description = "User takes " .. recoilFormula .. " recoil damage"
    else
        description = "User takes recoil damage"
    end

    -- Add ability modification note
    if pokemonData and pokemonData.ability == Enums.AbilityId.RECKLESS and not string.find(recoilFormula, "max_hp") then
        description = description .. " (boosted by Reckless)"
    end

    return description
end

-- Process recoil damage timing after move execution
-- @param battleId: Battle instance identifier
-- @param moveResult: Result from move execution including damage dealt
-- @param attackerData: Attacker Pokemon data
-- @param recoilFormula: Recoil formula from move data
-- @return: Boolean indicating if recoil was processed and timing details
function MoveEffects.processRecoilTiming(battleId, moveResult, attackerData, recoilFormula)
    -- Input validation
    if not battleId or not moveResult or not attackerData or not recoilFormula then
        return false, "Invalid parameters for recoil timing"
    end

    -- Only process recoil if move actually dealt damage
    if not moveResult.damage_dealt or moveResult.damage_dealt <= 0 then
        return false, "No damage dealt, no recoil needed"
    end

    -- Check if move hit successfully
    if moveResult.missed or moveResult.failed then
        return false, "Move missed or failed, no recoil"
    end

    -- Check for contact-based recoil prevention (moves that miss due to protection)
    if moveResult.protected then
        return false, "Move was protected, no recoil"
    end

    -- Apply recoil damage after primary move damage
    local recoilSuccess, recoilResult = MoveEffects.applyRecoilDamage(
        battleId,
        attackerData.id,
        recoilFormula,
        moveResult.damage_dealt,
        moveResult.move_name or "recoil_move",
        attackerData
    )

    if not recoilSuccess then
        return false, recoilResult -- Error message from applyRecoilDamage
    end

    -- Check if recoil caused fainting
    local newHP = (attackerData.currentHP or attackerData.stats[Enums.Stat.HP]) - recoilResult.recoil_amount
    local faintedFromRecoil = newHP <= 0

    local result = {
        success = true,
        timing = "after_damage",
        recoil_applied = true,
        recoil_amount = recoilResult.recoil_amount,
        move_damage = moveResult.damage_dealt,
        attacker_fainted = faintedFromRecoil,
        ability_prevented = recoilResult.ability_modified == "prevented",
        timestamp = os.time()
    }

    print("Processed recoil timing: " .. recoilResult.recoil_amount .. " recoil after " .. moveResult.damage_dealt .. " move damage")
    return true, result
end

-- Check if recoil should be processed for a move result
-- @param moveResult: Result from move execution
-- @param moveData: Move data including recoil information
-- @return: Boolean indicating if recoil processing is needed
function MoveEffects.shouldProcessRecoil(moveResult, moveData)
    if not moveResult or not moveData then
        return false
    end

    -- Must have recoil formula
    if not moveData.recoil then
        return false
    end

    -- Move must have dealt damage
    if not moveResult.damage_dealt or moveResult.damage_dealt <= 0 then
        return false
    end

    -- Move must not have missed or failed
    if moveResult.missed or moveResult.failed or moveResult.protected then
        return false
    end

    return true
end

-- Handle multi-hit move mechanics
-- @param battleId: Battle instance identifier
-- @param attackerId: Pokemon using the move
-- @param targetId: Target Pokemon
-- @param moveId: Move being used
-- @param hitType: Type of multi-hit ("2-5", "2", "3", "fixed")
-- @return: Number of hits and hit results
function MoveEffects.processMultiHitMove(battleId, attackerId, targetId, moveId, hitType)
    -- Input validation
    if not battleId or not attackerId or not targetId or not moveId then
        return 0, "Invalid parameters for multi-hit move"
    end
    
    -- Determine number of hits based on type
    local hitCount = 1
    if hitType == "2-5" then
        -- 2-5 hits with distribution: 35%, 35%, 15%, 15% for 2, 3, 4, 5 hits
        local rand = BattleRNG.randomInt(1, 100)
        if rand <= 35 then
            hitCount = 2
        elseif rand <= 70 then
            hitCount = 3
        elseif rand <= 85 then
            hitCount = 4
        else
            hitCount = 5
        end
    elseif hitType == "2" then
        hitCount = 2
    elseif hitType == "3" then
        hitCount = 3
    elseif type(hitType) == "number" then
        hitCount = hitType
    end
    
    -- Integration ready - compatible with damage calculation system
    
    local result = {
        success = true,
        hit_count = hitCount,
        hit_type = hitType,
        attacker = attackerId,
        target = targetId,
        move = moveId,
        timestamp = os.time()
    }
    
    print("Multi-hit move: " .. hitCount .. " hits for move " .. moveId)
    return hitCount, result
end

-- Multi-turn move states
MoveEffects.MultiTurnState = {
    NONE = 0,
    CHARGING = 1,
    EXECUTING = 2,
    SEMI_INVULNERABLE = 3,
    COMPLETED = 4
}

-- Multi-turn move types and data
MoveEffects.MultiTurnMoves = {
    [Enums.MoveId.FLY] = {
        name = "Fly",
        charging_turn = {state = "semi_invulnerable", message = "flew up high!"},
        execution_turn = {power_multiplier = 1.0, vulnerable_to = {"gust", "twister", "thunder", "hurricane"}},
        duration = 2
    },
    [Enums.MoveId.DIG] = {
        name = "Dig",
        charging_turn = {state = "semi_invulnerable", message = "dug underground!"},
        execution_turn = {power_multiplier = 1.0, vulnerable_to = {"earthquake", "magnitude", "fissure"}},
        duration = 2
    },
    [Enums.MoveId.DIVE] = {
        name = "Dive",
        charging_turn = {state = "semi_invulnerable", message = "dove underwater!"},
        execution_turn = {power_multiplier = 1.0, vulnerable_to = {"surf", "whirlpool"}},
        duration = 2
    },
    [Enums.MoveId.BOUNCE] = {
        name = "Bounce",
        charging_turn = {state = "semi_invulnerable", message = "bounced up high!"},
        execution_turn = {power_multiplier = 1.0, vulnerable_to = {"gust", "twister", "thunder", "hurricane"}},
        duration = 2
    },
    [Enums.MoveId.SHADOW_FORCE] = {
        name = "Shadow Force",
        charging_turn = {state = "semi_invulnerable", message = "disappeared!"},
        execution_turn = {power_multiplier = 1.0, ignores_protection = true},
        duration = 2
    },
    [Enums.MoveId.SKY_ATTACK] = {
        name = "Sky Attack",
        charging_turn = {state = "semi_invulnerable", message = "is glowing with power!"},
        execution_turn = {power_multiplier = 1.0, high_critical_hit = true},
        duration = 2
    },
    [Enums.MoveId.RAZOR_WIND] = {
        name = "Razor Wind",
        charging_turn = {state = "normal", message = "whipped up a whirlwind!"},
        execution_turn = {power_multiplier = 1.0, high_critical_hit = true},
        duration = 2
    },
    [Enums.MoveId.SOLAR_BEAM] = {
        name = "Solar Beam",
        charging_turn = {state = "normal", message = "took in sunlight!", weather_skip = "sunny"},
        execution_turn = {power_multiplier = 1.0, weather_modifier = {harsh_sun = 0.5, rain = 0.5, sandstorm = 0.5, hail = 0.5}},
        duration = 2
    },
    [Enums.MoveId.SKULL_BASH] = {
        name = "Skull Bash",
        charging_turn = {state = "normal", message = "lowered its head!", stat_boost = {[Enums.Stat.DEF] = 1}},
        execution_turn = {power_multiplier = 1.0},
        duration = 2
    },
    [Enums.MoveId.FREEZE_SHOCK] = {
        name = "Freeze Shock",
        charging_turn = {state = "normal", message = "became cloaked in a freezing light!"},
        execution_turn = {power_multiplier = 1.0, status_chance = {status = MoveEffects.StatusEffect.PARALYSIS, chance = 30}},
        duration = 2
    }
}

-- Initialize multi-turn move state for Pokemon
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon using the multi-turn move
-- @param moveId: Move being initiated
-- @param pokemonData: Pokemon data for ability checks
-- @param weatherType: Current weather type
-- @return: Boolean indicating success and move state details
function MoveEffects.initializeMultiTurnMove(battleId, pokemonId, moveId, pokemonData, weatherType)
    -- Input validation
    if not battleId or not pokemonId or not moveId then
        return false, "Invalid parameters for multi-turn move initialization"
    end

    local moveData = MoveEffects.MultiTurnMoves[moveId]
    if not moveData then
        return false, "Move is not a multi-turn move: " .. tostring(moveId)
    end

    -- Check for weather-based skipping (Solar Beam in sun)
    local skipCharging = false
    if moveData.charging_turn.weather_skip and weatherType then
        if (moveData.charging_turn.weather_skip == "sunny" and 
            (weatherType == MoveEffects.WeatherType.SUNNY or weatherType == MoveEffects.WeatherType.HARSH_SUN)) then
            skipCharging = true
        end
    end

    -- Check for Power Herb item (skips charging turn)
    if pokemonData and pokemonData.item == Enums.ItemId.POWER_HERB then
        skipCharging = true
    end

    local initialState = skipCharging and MoveEffects.MultiTurnState.EXECUTING or MoveEffects.MultiTurnState.CHARGING
    local turnCount = skipCharging and 2 or 1

    local result = {
        success = true,
        move_id = moveId,
        move_name = moveData.name,
        state = initialState,
        turn_count = turnCount,
        max_turns = moveData.duration,
        skip_charging = skipCharging,
        semi_invulnerable = moveData.charging_turn.state == "semi_invulnerable" and not skipCharging,
        charging_message = moveData.charging_turn.message,
        power_herb_consumed = pokemonData and pokemonData.item == Enums.ItemId.POWER_HERB,
        timestamp = os.time()
    }

    -- Apply charging turn stat boosts if any
    if moveData.charging_turn.stat_boost and not skipCharging then
        result.stat_boosts = moveData.charging_turn.stat_boost
    end

    print("Initialized multi-turn move " .. moveData.name .. " for Pokemon " .. pokemonId .. 
          (skipCharging and " (skipping charging turn)" or " (entering charging phase)"))
    return true, result
end

-- Process multi-turn move progression
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon using the multi-turn move
-- @param currentState: Current multi-turn move state
-- @return: Boolean indicating success and updated state
function MoveEffects.processMultiTurnMove(battleId, pokemonId, currentState)
    -- Input validation
    if not battleId or not pokemonId or not currentState then
        return false, "Invalid parameters for multi-turn move processing"
    end

    local moveData = MoveEffects.MultiTurnMoves[currentState.move_id]
    if not moveData then
        return false, "Unknown multi-turn move: " .. tostring(currentState.move_id)
    end

    local newTurnCount = currentState.turn_count + 1
    local newState = currentState.state

    -- State transition logic
    if currentState.state == MoveEffects.MultiTurnState.CHARGING then
        if newTurnCount >= moveData.duration then
            newState = MoveEffects.MultiTurnState.EXECUTING
        end
    elseif currentState.state == MoveEffects.MultiTurnState.EXECUTING then
        newState = MoveEffects.MultiTurnState.COMPLETED
    end

    local isCompleted = newState == MoveEffects.MultiTurnState.COMPLETED
    local canExecute = newState == MoveEffects.MultiTurnState.EXECUTING

    local result = {
        success = true,
        move_id = currentState.move_id,
        move_name = moveData.name,
        previous_state = currentState.state,
        new_state = newState,
        turn_count = newTurnCount,
        max_turns = moveData.duration,
        can_execute = canExecute,
        is_completed = isCompleted,
        semi_invulnerable = newState == MoveEffects.MultiTurnState.CHARGING and moveData.charging_turn.state == "semi_invulnerable",
        execution_data = canExecute and moveData.execution_turn or nil,
        timestamp = os.time()
    }

    local stateNames = {
        [MoveEffects.MultiTurnState.CHARGING] = "charging",
        [MoveEffects.MultiTurnState.EXECUTING] = "executing", 
        [MoveEffects.MultiTurnState.COMPLETED] = "completed"
    }

    print("Multi-turn move " .. moveData.name .. " progressed from " .. 
          (stateNames[currentState.state] or "unknown") .. " to " .. 
          (stateNames[newState] or "unknown") .. " (turn " .. newTurnCount .. "/" .. moveData.duration .. ")")
    
    return true, result
end

-- Check if Pokemon is vulnerable to a move while in semi-invulnerable state
-- @param multiTurnState: Current multi-turn move state
-- @param incomingMoveId: ID of incoming move
-- @return: Boolean indicating if Pokemon is vulnerable
function MoveEffects.isVulnerableInSemiInvulnerableState(multiTurnState, incomingMoveId)
    if not multiTurnState or not multiTurnState.semi_invulnerable then
        return true -- Not in semi-invulnerable state
    end

    local moveData = MoveEffects.MultiTurnMoves[multiTurnState.move_id]
    if not moveData or not moveData.execution_turn.vulnerable_to then
        return false -- No vulnerabilities defined
    end

    -- Check if incoming move is in vulnerability list
    for _, vulnerableMove in ipairs(moveData.execution_turn.vulnerable_to) do
        if vulnerableMove == incomingMoveId or 
           (type(vulnerableMove) == "string" and Enums.MoveId[string.upper(vulnerableMove)] == incomingMoveId) then
            return true
        end
    end

    return false
end

-- Get multi-turn move execution modifiers
-- @param multiTurnState: Current multi-turn move state
-- @param weatherType: Current weather type (optional)
-- @return: Table of execution modifiers
function MoveEffects.getMultiTurnExecutionModifiers(multiTurnState, weatherType)
    if not multiTurnState or multiTurnState.state ~= MoveEffects.MultiTurnState.EXECUTING then
        return {}
    end

    local moveData = MoveEffects.MultiTurnMoves[multiTurnState.move_id]
    if not moveData then
        return {}
    end

    local modifiers = {
        power_multiplier = moveData.execution_turn.power_multiplier or 1.0,
        ignores_protection = moveData.execution_turn.ignores_protection or false,
        high_critical_hit = moveData.execution_turn.high_critical_hit or false
    }

    -- Apply weather modifiers
    if weatherType and moveData.execution_turn.weather_modifier then
        local weatherNames = {
            [MoveEffects.WeatherType.HARSH_SUN] = "harsh_sun",
            [MoveEffects.WeatherType.RAIN] = "rain",
            [MoveEffects.WeatherType.SANDSTORM] = "sandstorm",
            [MoveEffects.WeatherType.HAIL] = "hail"
        }
        
        local weatherName = weatherNames[weatherType]
        if weatherName and moveData.execution_turn.weather_modifier[weatherName] then
            modifiers.power_multiplier = modifiers.power_multiplier * moveData.execution_turn.weather_modifier[weatherName]
        end
    end

    -- Add status effect if applicable
    if moveData.execution_turn.status_chance then
        modifiers.status_effect = moveData.execution_turn.status_chance
    end

    return modifiers
end

-- Check if multi-turn move can be interrupted
-- @param multiTurnState: Current multi-turn move state
-- @param interruptSource: Source of interruption (flinch, sleep, etc.)
-- @return: Boolean indicating if move can be interrupted
function MoveEffects.canInterruptMultiTurnMove(multiTurnState, interruptSource)
    if not multiTurnState then
        return false
    end

    -- Semi-invulnerable Pokemon cannot be interrupted by most effects
    if multiTurnState.semi_invulnerable then
        -- Only specific conditions can interrupt semi-invulnerable state
        local allowedInterrupts = {"sleep", "freeze", "faint"}
        for _, allowed in ipairs(allowedInterrupts) do
            if interruptSource == allowed then
                return true
            end
        end
        return false
    end

    -- Charging state can be interrupted by various effects
    if multiTurnState.state == MoveEffects.MultiTurnState.CHARGING then
        local disruptiveEffects = {"sleep", "freeze", "paralysis", "flinch", "confusion", "attraction"}
        for _, effect in ipairs(disruptiveEffects) do
            if interruptSource == effect then
                return true
            end
        end
    end

    return false
end

-- Get multi-turn move description
-- @param moveId: Multi-turn move ID
-- @param currentState: Current state (optional)
-- @return: Human-readable description
function MoveEffects.getMultiTurnMoveDescription(moveId, currentState)
    local moveData = MoveEffects.MultiTurnMoves[moveId]
    if not moveData then
        return "Unknown multi-turn move"
    end

    local description = moveData.name .. " (multi-turn)"
    
    if currentState then
        if currentState.state == MoveEffects.MultiTurnState.CHARGING then
            description = description .. " - Charging (" .. currentState.turn_count .. "/" .. moveData.duration .. ")"
        elseif currentState.state == MoveEffects.MultiTurnState.EXECUTING then
            description = description .. " - Executing"
        elseif currentState.state == MoveEffects.MultiTurnState.COMPLETED then
            description = description .. " - Completed"
        end
        
        if currentState.semi_invulnerable then
            description = description .. " (Semi-invulnerable)"
        end
    else
        description = description .. " - " .. moveData.duration .. " turns"
        if moveData.charging_turn.state == "semi_invulnerable" then
            description = description .. " (Semi-invulnerable during charge)"
        end
    end

    return description
end

-- Random Effect Move System

-- Metronome move pool (moves that can be selected)
MoveEffects.MetronomeMovePool = {
    -- Exclude certain moves from Metronome
    excluded_moves = {
        [Enums.MoveId.METRONOME] = true,
        [Enums.MoveId.STRUGGLE] = true,
        [Enums.MoveId.CHATTER] = true,
        [Enums.MoveId.COUNTER] = true,
        [Enums.MoveId.MIRROR_COAT] = true,
        [Enums.MoveId.PROTECT] = true,
        [Enums.MoveId.DETECT] = true,
        [Enums.MoveId.ENDURE] = true,
        [Enums.MoveId.FOLLOW_ME] = true,
        [Enums.MoveId.HELPING_HAND] = true,
        [Enums.MoveId.MIRROR_MOVE] = true,
        [Enums.MoveId.SKETCH] = true,
        [Enums.MoveId.SLEEP_TALK] = true,
        [Enums.MoveId.TRANSFORM] = true
    },
    -- Category restrictions
    excluded_categories = {
        "status_healing", -- Healing moves that could break battle balance
        "field_control", -- Moves that drastically alter battle conditions
        "unique_mechanic" -- Moves with special mechanics that don't translate well
    }
}

-- Sleep Talk move pool (moves Pokemon can use while sleeping)
MoveEffects.SleepTalkMovePool = {
    -- Sleep Talk can only select from moves the Pokemon knows
    require_known_moves = true,
    -- Exclude certain moves from Sleep Talk
    excluded_moves = {
        [Enums.MoveId.SLEEP_TALK] = true,
        [Enums.MoveId.BIDE] = true,
        [Enums.MoveId.FOCUS_PUNCH] = true,
        [Enums.MoveId.UPROAR] = true,
        [Enums.MoveId.ASSIST] = true,
        [Enums.MoveId.METRONOME] = true
    }
}

-- Execute Metronome move selection
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon using Metronome
-- @param pokemonData: Pokemon data for move validation
-- @param battleState: Current battle state for context
-- @return: Boolean indicating success and selected move details
function MoveEffects.executeMetronome(battleId, pokemonId, pokemonData, battleState)
    -- Input validation
    if not battleId or not pokemonId then
        return false, "Invalid parameters for Metronome execution"
    end

    -- Get all valid moves for Metronome (this would normally come from move database)
    local allMoves = {}
    for moveId = 1, 900 do -- Assuming 900 moves total
        if not MoveEffects.MetronomeMovePool.excluded_moves[moveId] then
            table.insert(allMoves, moveId)
        end
    end

    -- Select random move using deterministic RNG
    if #allMoves == 0 then
        return false, "No valid moves available for Metronome"
    end

    local selectedIndex = BattleRNG.randomInt(1, #allMoves)
    local selectedMoveId = allMoves[selectedIndex]

    -- Validate selected move (additional checks)
    local isValid, reason = MoveEffects.validateRandomMoveSelection(selectedMoveId, pokemonData, battleState, "metronome")
    if not isValid then
        -- Try again with different move (limited retries to prevent infinite loops)
        local retryCount = 0
        while not isValid and retryCount < 5 do
            selectedIndex = BattleRNG.randomInt(1, #allMoves)
            selectedMoveId = allMoves[selectedIndex]
            isValid, reason = MoveEffects.validateRandomMoveSelection(selectedMoveId, pokemonData, battleState, "metronome")
            retryCount = retryCount + 1
        end
        
        if not isValid then
            return false, "Could not find valid move for Metronome: " .. tostring(reason)
        end
    end

    local result = {
        success = true,
        source_move = "Metronome",
        selected_move_id = selectedMoveId,
        selection_method = "metronome",
        total_pool_size = #allMoves,
        selected_index = selectedIndex,
        retry_count = retryCount or 0,
        timestamp = os.time()
    }

    print("Metronome selected move " .. selectedMoveId .. " for Pokemon " .. pokemonId)
    return true, result
end

-- Execute Sleep Talk move selection
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon using Sleep Talk
-- @param pokemonData: Pokemon data including known moves
-- @param battleState: Current battle state for context
-- @return: Boolean indicating success and selected move details
function MoveEffects.executeSleepTalk(battleId, pokemonId, pokemonData, battleState)
    -- Input validation
    if not battleId or not pokemonId or not pokemonData then
        return false, "Invalid parameters for Sleep Talk execution"
    end

    -- Verify Pokemon is asleep
    if not pokemonData.statusEffect or pokemonData.statusEffect ~= MoveEffects.StatusEffect.SLEEP then
        return false, "Sleep Talk can only be used while sleeping"
    end

    -- Get Pokemon's known moves (excluding Sleep Talk itself)
    local knownMoves = {}
    if pokemonData.moves then
        for _, moveId in ipairs(pokemonData.moves) do
            if not MoveEffects.SleepTalkMovePool.excluded_moves[moveId] then
                table.insert(knownMoves, moveId)
            end
        end
    end

    if #knownMoves == 0 then
        return false, "No valid moves available for Sleep Talk"
    end

    -- Select random move from known moves using deterministic RNG
    local selectedIndex = BattleRNG.randomInt(1, #knownMoves)
    local selectedMoveId = knownMoves[selectedIndex]

    -- Validate selected move
    local isValid, reason = MoveEffects.validateRandomMoveSelection(selectedMoveId, pokemonData, battleState, "sleep_talk")
    if not isValid then
        -- Try other known moves (limited retries)
        local retryCount = 0
        while not isValid and retryCount < #knownMoves - 1 do
            selectedIndex = (selectedIndex % #knownMoves) + 1
            selectedMoveId = knownMoves[selectedIndex]
            isValid, reason = MoveEffects.validateRandomMoveSelection(selectedMoveId, pokemonData, battleState, "sleep_talk")
            retryCount = retryCount + 1
        end
        
        if not isValid then
            return false, "No valid moves available for Sleep Talk: " .. tostring(reason)
        end
    end

    local result = {
        success = true,
        source_move = "Sleep Talk",
        selected_move_id = selectedMoveId,
        selection_method = "sleep_talk",
        total_pool_size = #knownMoves,
        selected_index = selectedIndex,
        retry_count = retryCount or 0,
        known_moves = knownMoves,
        timestamp = os.time()
    }

    print("Sleep Talk selected move " .. selectedMoveId .. " for Pokemon " .. pokemonId)
    return true, result
end

-- Validate random move selection
-- @param moveId: Selected move ID
-- @param pokemonData: Pokemon data for validation
-- @param battleState: Battle state for context checks
-- @param selectionType: Type of random selection (metronome, sleep_talk)
-- @return: Boolean indicating validity and reason if invalid
function MoveEffects.validateRandomMoveSelection(moveId, pokemonData, battleState, selectionType)
    if not moveId then
        return false, "Invalid move ID"
    end

    -- Move must exist (basic validation)
    -- This would normally check against move database
    if moveId < 1 or moveId > 900 then
        return false, "Move ID out of range"
    end

    -- Specific validation for Sleep Talk
    if selectionType == "sleep_talk" then
        -- Sleep Talk cannot select multi-turn moves in their charging phase
        if MoveEffects.MultiTurnMoves[moveId] then
            return false, "Cannot use multi-turn moves with Sleep Talk"
        end

        -- Sleep Talk cannot select moves requiring conscious choice
        local consciousChoiceMoves = {
            [Enums.MoveId.FOCUS_PUNCH] = true,
            [Enums.MoveId.BIDE] = true
        }
        if consciousChoiceMoves[moveId] then
            return false, "Move requires conscious choice"
        end
    end

    -- Specific validation for Metronome
    if selectionType == "metronome" then
        -- Metronome cannot select certain signature moves
        local signatureMoves = {
            [Enums.MoveId.CHATTER] = true,
            [Enums.MoveId.STRUGGLE] = true
        }
        if signatureMoves[moveId] then
            return false, "Signature move cannot be selected"
        end
    end

    -- PP validation (move must have PP available)
    -- This would normally check Pokemon's current PP for the move

    return true, nil
end

-- Get random move selection description
-- @param selectionResult: Result from random move selection
-- @param moveDatabase: Optional move database for move names
-- @return: Human-readable description
function MoveEffects.getRandomMoveDescription(selectionResult, moveDatabase)
    if not selectionResult then
        return "No random move selected"
    end

    local moveName = "Move " .. selectionResult.selected_move_id
    if moveDatabase and moveDatabase[selectionResult.selected_move_id] then
        moveName = moveDatabase[selectionResult.selected_move_id].name
    end

    local description = selectionResult.source_move .. " selected " .. moveName
    
    if selectionResult.retry_count and selectionResult.retry_count > 0 then
        description = description .. " (after " .. selectionResult.retry_count .. " retries)"
    end

    if selectionResult.total_pool_size then
        description = description .. " from " .. selectionResult.total_pool_size .. " possible moves"
    end

    return description
end

-- Check if move can be randomly selected
-- @param moveId: Move to check
-- @param selectionType: Type of selection (metronome, sleep_talk, etc.)
-- @return: Boolean indicating if move can be selected
function MoveEffects.canMoveBeRandomlySelected(moveId, selectionType)
    if not moveId or not selectionType then
        return false
    end

    -- Check Metronome exclusions
    if selectionType == "metronome" then
        return not MoveEffects.MetronomeMovePool.excluded_moves[moveId]
    end

    -- Check Sleep Talk exclusions
    if selectionType == "sleep_talk" then
        return not MoveEffects.SleepTalkMovePool.excluded_moves[moveId]
    end

    return true
end

-- Execute random effect move with failure conditions
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon using the move
-- @param moveType: Type of random move (metronome, sleep_talk)
-- @param pokemonData: Pokemon data
-- @param battleState: Battle state
-- @return: Boolean indicating success and execution details
function MoveEffects.executeRandomEffectMove(battleId, pokemonId, moveType, pokemonData, battleState)
    -- Input validation
    if not battleId or not pokemonId or not moveType then
        return false, "Invalid parameters for random effect move"
    end

    local result = {}
    local success = false

    if moveType == "metronome" then
        success, result = MoveEffects.executeMetronome(battleId, pokemonId, pokemonData, battleState)
    elseif moveType == "sleep_talk" then
        success, result = MoveEffects.executeSleepTalk(battleId, pokemonId, pokemonData, battleState)
    else
        return false, "Unknown random effect move type: " .. tostring(moveType)
    end

    if not success then
        return false, result -- Error message
    end

    -- Additional post-selection processing
    result.execution_type = "random_effect"
    result.deterministic = true -- Uses seeded RNG for reproducibility
    result.battle_id = battleId
    result.pokemon_id = pokemonId

    print("Random effect move executed: " .. moveType .. " -> " .. (result.selected_move_id or "none"))
    return true, result
end

-- Cure status effect from Pokemon
-- @param battleId: Battle instance identifier
-- @param pokemonId: Pokemon to cure
-- @param statusEffect: Status effect to cure
-- @param cureMethod: Method of cure (for validation)
-- @return: Boolean indicating success and cure details
function MoveEffects.cureStatusEffect(battleId, pokemonId, statusEffect, cureMethod)
    if not battleId or not pokemonId or not statusEffect then
        return false, "Invalid parameters for status cure"
    end
    
    local effectData = MoveEffects.StatusEffectData[statusEffect]
    if not effectData then
        return false, "Unknown status effect: " .. tostring(statusEffect)
    end
    
    -- Validate cure method
    local validCure = false
    if effectData.cure_conditions then
        for _, condition in ipairs(effectData.cure_conditions) do
            if cureMethod == condition then
                validCure = true
                break
            end
        end
    end
    
    if not validCure then
        return false, "Invalid cure method for " .. effectData.name .. ": " .. tostring(cureMethod)
    end
    
    local result = {
        success = true,
        cured_effect = statusEffect,
        effect_name = effectData.name,
        cure_method = cureMethod,
        timestamp = os.time()
    }
    
    print("Cured " .. effectData.name .. " from Pokemon " .. pokemonId .. " via " .. cureMethod)
    return true, result
end

-- Validate move effect parameters
-- @param effect: Effect data to validate
-- @return: Boolean indicating validity and error message if invalid
function MoveEffects.validateEffect(effect)
    if type(effect) ~= "table" then
        return false, "Effect must be a table"
    end
    
    -- Validate status effects
    if effect.status_effect then
        if not MoveEffects.StatusEffectData[effect.status_effect] then
            return false, "Invalid status effect: " .. tostring(effect.status_effect)
        end
        
        if effect.status_chance and (effect.status_chance < 0 or effect.status_chance > 100) then
            return false, "Status chance must be between 0-100: " .. effect.status_chance
        end
    end
    
    -- Validate stat changes
    if effect.stat_changes then
        for stat, change in pairs(effect.stat_changes) do
            if not MoveEffects.StatStages[stat] then
                return false, "Invalid stat for change: " .. tostring(stat)
            end
            
            if change < -6 or change > 6 then
                return false, "Stat change out of range (-6 to +6): " .. change
            end
        end
    end
    
    -- Validate healing
    if effect.healing then
        local validFormulas = {"1/2", "1/4", "1/8", "1/16", "full"}
        if type(effect.healing) == "string" then
            local validFormula = false
            for _, formula in ipairs(validFormulas) do
                if effect.healing == formula then
                    validFormula = true
                    break
                end
            end
            if not validFormula and effect.healing ~= "full" then
                return false, "Invalid healing formula: " .. effect.healing
            end
        elseif type(effect.healing) ~= "number" or effect.healing < 0 then
            return false, "Healing must be positive number or valid formula"
        end
    end
    
    return true, "Valid effect"
end

-- Validate stat stage bounds and ability interactions
-- @param pokemonData: Pokemon data including ability
-- @param stat: Stat to check
-- @param stageChange: Proposed stage change
-- @param currentStage: Current stat stage
-- @return: Boolean indicating if change is valid, adjusted change amount
function MoveEffects.validateStatStageChange(pokemonData, stat, stageChange, currentStage)
    if not pokemonData or not stat or not stageChange then
        return false, 0
    end
    
    -- Check ability restrictions for stat reductions
    if pokemonData.ability and stageChange < 0 then
        if pokemonData.ability == Enums.AbilityId.CLEAR_BODY or 
           pokemonData.ability == Enums.AbilityId.WHITE_SMOKE then
            return false, 0
        elseif pokemonData.ability == Enums.AbilityId.HYPER_CUTTER and stat == Enums.Stat.ATK then
            return false, 0
        elseif pokemonData.ability == Enums.AbilityId.KEEN_EYE and stat == Enums.Stat.ACC then
            return false, 0
        end
    end
    
    -- Apply ability modifications
    local modifiedChange = stageChange
    if pokemonData.ability == Enums.AbilityId.SIMPLE then
        modifiedChange = stageChange * 2
    elseif pokemonData.ability == Enums.AbilityId.CONTRARY then
        modifiedChange = -stageChange
    end
    
    -- Bounds checking
    currentStage = currentStage or 0
    local newStage = math.max(-6, math.min(6, currentStage + modifiedChange))
    local actualChange = newStage - currentStage
    
    return actualChange ~= 0, actualChange
end

-- Get effect description for move
-- @param effect: Effect data table
-- @return: Human-readable description of the effect
function MoveEffects.getEffectDescription(effect)
    if not effect or type(effect) ~= "table" then
        return "No effect"
    end
    
    local descriptions = {}
    
    -- Status effects
    if effect.status_effect then
        local effectData = MoveEffects.StatusEffectData[effect.status_effect]
        if effectData then
            local statusName = effectData.name
            local chance = effect.status_chance or 100
            if chance == 100 then
                table.insert(descriptions, "Inflicts " .. statusName)
            else
                table.insert(descriptions, chance .. "% chance to inflict " .. statusName)
            end
        end
    end
    
    -- Stat changes
    if effect.stat_changes then
        for stat, change in pairs(effect.stat_changes) do
            local statName = MoveEffects.StatStages[stat]
            if statName then
                if change > 0 then
                    table.insert(descriptions, "Raises " .. statName .. " by " .. change .. " stage(s)")
                elseif change < 0 then
                    table.insert(descriptions, "Lowers " .. statName .. " by " .. math.abs(change) .. " stage(s)")
                end
            end
        end
    end
    
    -- Healing
    if effect.healing then
        if effect.healing == "full" then
            table.insert(descriptions, "Restores all HP")
        elseif type(effect.healing) == "string" then
            table.insert(descriptions, "Restores " .. effect.healing .. " of max HP")
        else
            table.insert(descriptions, "Restores " .. effect.healing .. " HP")
        end
    end
    
    -- Recoil
    if effect.recoil then
        table.insert(descriptions, "User takes " .. effect.recoil .. " recoil damage")
    end
    
    -- Multi-hit
    if effect.multi_hit then
        if effect.multi_hit == "2-5" then
            table.insert(descriptions, "Hits 2-5 times")
        else
            table.insert(descriptions, "Hits " .. effect.multi_hit .. " times")
        end
    end
    
    -- Weather
    if effect.weather then
        table.insert(descriptions, "Changes weather")
    end
    
    -- Terrain
    if effect.terrain then
        table.insert(descriptions, "Changes terrain")
    end
    
    return table.concat(descriptions, ", ")
end

-- Execute move with damage calculation integration
-- @param battleState: Current battle state
-- @param attacker: Pokemon using the move
-- @param moveData: Move data from database
-- @param target: Target Pokemon (optional for some moves)
-- @return: Move execution result with damage and effects
function MoveEffects.executeMove(battleState, attacker, moveData, target)
    local result = {
        success = false,
        damage = 0,
        effectiveness = 1.0,
        critical_hit = false,
        missed = false,
        failed = false,
        no_effect = false,
        effects = {},
        status_effects = {},
        messages = {}
    }
    
    -- Input validation
    if not attacker or not moveData then
        result.failed = true
        result.messages = {"Move execution failed: Invalid parameters"}
        return result
    end
    
    -- Load damage calculator for damage moves

-- ===== MODULE: game-logic.battle.damage-calculator =====
-- File: ao-processes/game-logic/battle/damage-calculator.lua
-- Original require:     local DamageCalculator = require("game-logic.battle.damage-calculator")

-- Damage Calculator System
-- Complete damage calculation implementation matching TypeScript behavioral parity
-- Handles base damage, type effectiveness, STAB, critical hits, and all damage modifiers

-- SHARED MODULE REFERENCE: data.constants.type-chart (already included)
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- ===== MODULE: game-logic.battle.move-targeting =====
-- File: ao-processes/game-logic/battle/move-targeting.lua
-- Original require: local MoveTargeting = require("game-logic.battle.move-targeting")

-- Move Targeting System
-- Handles single-target, multi-target, and ally targeting validation for positional mechanics
-- Supports position-dependent moves and doubles-specific targeting rules

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.battle.positional-mechanics =====
-- File: ao-processes/game-logic/battle/positional-mechanics.lua
-- Original require: local PositionalMechanics = require("game-logic.battle.positional-mechanics")


-- ===== END MODULE: game-logic.battle.positional-mechanics =====


local MoveTargeting = {}

-- Targeting types for moves
MoveTargeting.TargetingType = {
    SINGLE_OPPONENT = "single_opponent",
    ALL_OPPONENTS = "all_opponents", 
    SINGLE_ALLY = "single_ally",
    ALL_ALLIES = "all_allies",
    SELF = "self",
    ALL_POKEMON = "all_pokemon",
    SPREAD = "spread", -- Multi-target with damage reduction
    POSITION_DEPENDENT = "position_dependent", -- Doubles-specific moves
    USER_AND_ALLY = "user_and_ally",
    RANDOM_OPPONENT = "random_opponent"
}

-- Target validation results
MoveTargeting.ValidationResult = {
    VALID = "valid",
    INVALID_TARGET = "invalid_target",
    INVALID_FORMAT = "invalid_format",
    NO_VALID_TARGETS = "no_valid_targets",
    ALLY_TARGETING_BLOCKED = "ally_targeting_blocked",
    POSITION_REQUIRED = "position_required"
}

-- Determine move targeting type from move data
-- @param moveData: Move database entry
-- @return: Targeting type and additional targeting info
function MoveTargeting.getMoveTargetingType(moveData)
    if not moveData then
        return MoveTargeting.TargetingType.SINGLE_OPPONENT, {}
    end
    
    -- Check for explicit targeting type in move data
    if moveData.targetingType then
        return moveData.targetingType, moveData.targetingOptions or {}
    end
    
    -- Infer targeting type from move properties
    local targetingInfo = {
        requiresTarget = true,
        allowsAllies = false,
        allowsOpponents = true,
        requiresDoublesFormat = false
    }
    
    -- Status moves targeting self
    if moveData.category == Enums.MoveCategory.STATUS and moveData.target == "self" then
        targetingInfo.requiresTarget = false
        return MoveTargeting.TargetingType.SELF, targetingInfo
    end
    
    -- Spread moves (multi-target with damage reduction) - check before general multi-target
    if moveData.isSpreadMove or moveData.damageReduction then
        targetingInfo.damageReduction = moveData.damageReduction or 0.75 -- 25% reduction typical
        return MoveTargeting.TargetingType.SPREAD, targetingInfo
    end
    
    -- Multi-target moves
    if moveData.target == "all_opponents" or moveData.hitsAllOpponents then
        return MoveTargeting.TargetingType.ALL_OPPONENTS, targetingInfo
    end
    
    if moveData.target == "all_allies" or moveData.hitsAllAllies then
        targetingInfo.allowsAllies = true
        targetingInfo.allowsOpponents = false
        return MoveTargeting.TargetingType.ALL_ALLIES, targetingInfo
    end
    
    if moveData.target == "all_pokemon" or moveData.hitsAllPokemon then
        targetingInfo.allowsAllies = true
        return MoveTargeting.TargetingType.ALL_POKEMON, targetingInfo
    end
    
    
    -- Ally targeting moves
    if moveData.target == "ally" or moveData.canTargetAllies then
        targetingInfo.allowsAllies = true
        targetingInfo.allowsOpponents = false
        targetingInfo.requiresDoublesFormat = true
        return MoveTargeting.TargetingType.SINGLE_ALLY, targetingInfo
    end
    
    -- Position-dependent moves (doubles-specific)
    if moveData.doublesOnly or moveData.requiresDoublesFormat then
        targetingInfo.requiresDoublesFormat = true
        return MoveTargeting.TargetingType.POSITION_DEPENDENT, targetingInfo
    end
    
    -- Default to single opponent targeting
    return MoveTargeting.TargetingType.SINGLE_OPPONENT, targetingInfo
end

-- Validate move targeting for a specific battle situation
-- @param battleState: Current battle state
-- @param attacker: Pokemon using the move
-- @param moveData: Move being used
-- @param targetPokemon: Intended target Pokemon (can be nil for self/all moves)
-- @param targetPosition: Intended target position (for position-dependent moves)
-- @return: Validation result and details
function MoveTargeting.validateMoveTargeting(battleState, attacker, moveData, targetPokemon, targetPosition)
    if not battleState or not attacker or not moveData then
        return MoveTargeting.ValidationResult.INVALID_TARGET, "Missing required parameters"
    end
    
    local targetingType, targetingInfo = MoveTargeting.getMoveTargetingType(moveData)
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    
    -- Check format requirements (but let ally targeting moves handle their own validation)
    if targetingInfo.requiresDoublesFormat and 
       formatInfo.format ~= PositionalMechanics.BattleFormat.DOUBLE and
       targetingType ~= MoveTargeting.TargetingType.SINGLE_ALLY then
        return MoveTargeting.ValidationResult.INVALID_FORMAT, "Move requires double battle format"
    end
    
    -- Validate based on targeting type
    if targetingType == MoveTargeting.TargetingType.SELF then
        -- Self-targeting moves don't need target validation
        return MoveTargeting.ValidationResult.VALID, "Self-targeting move"
    
    elseif targetingType == MoveTargeting.TargetingType.ALL_OPPONENTS or 
           targetingType == MoveTargeting.TargetingType.ALL_ALLIES or 
           targetingType == MoveTargeting.TargetingType.ALL_POKEMON then
        -- Multi-target moves don't need specific target validation
        local availableTargets = MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
        if #availableTargets == 0 then
            return MoveTargeting.ValidationResult.NO_VALID_TARGETS, "No valid targets available"
        end
        return MoveTargeting.ValidationResult.VALID, "Multi-target move with available targets"
    
    elseif targetingType == MoveTargeting.TargetingType.SINGLE_OPPONENT then
        -- Single opponent targeting
        if not targetPokemon then
            return MoveTargeting.ValidationResult.INVALID_TARGET, "Target Pokemon required"
        end
        
        local validOpponents = MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
        for _, target in ipairs(validOpponents) do
            if target.pokemon.id == targetPokemon.id then
                return MoveTargeting.ValidationResult.VALID, "Valid opponent target"
            end
        end
        
        return MoveTargeting.ValidationResult.INVALID_TARGET, "Pokemon is not a valid opponent target"
    
    elseif targetingType == MoveTargeting.TargetingType.SINGLE_ALLY then
        -- Single ally targeting (doubles only)
        -- Debug: print format info for troubleshooting
        -- print("DEBUG: Format detected:", formatInfo.format, "Expected:", PositionalMechanics.BattleFormat.DOUBLE)
        if formatInfo.format ~= PositionalMechanics.BattleFormat.DOUBLE then
            return MoveTargeting.ValidationResult.ALLY_TARGETING_BLOCKED, "Ally targeting only available in double battles"
        end
        
        if not targetPokemon then
            return MoveTargeting.ValidationResult.INVALID_TARGET, "Target ally required"
        end
        
        local validAllies = MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
        for _, target in ipairs(validAllies) do
            if target.pokemon.id == targetPokemon.id then
                return MoveTargeting.ValidationResult.VALID, "Valid ally target"
            end
        end
        
        return MoveTargeting.ValidationResult.INVALID_TARGET, "Pokemon is not a valid ally target"
    
    elseif targetingType == MoveTargeting.TargetingType.POSITION_DEPENDENT then
        -- Position-dependent moves need position validation
        if formatInfo.format ~= PositionalMechanics.BattleFormat.DOUBLE then
            return MoveTargeting.ValidationResult.INVALID_FORMAT, "Position-dependent move requires double battle"
        end
        
        if not targetPosition then
            return MoveTargeting.ValidationResult.POSITION_REQUIRED, "Target position required for position-dependent move"
        end
        
        -- Validate position exists and has a Pokemon
        local opponentSide = attacker.battleData.side == "player" and "enemy" or "player"
        local targetPokemonAtPosition = PositionalMechanics.getPokemonAtPosition(battleState, opponentSide, targetPosition)
        
        if not targetPokemonAtPosition or targetPokemonAtPosition.fainted then
            return MoveTargeting.ValidationResult.NO_VALID_TARGETS, "No Pokemon at target position"
        end
        
        return MoveTargeting.ValidationResult.VALID, "Valid position-dependent target"
    
    elseif targetingType == MoveTargeting.TargetingType.SPREAD then
        -- Spread moves target multiple Pokemon with damage reduction
        local availableTargets = MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
        if #availableTargets == 0 then
            return MoveTargeting.ValidationResult.NO_VALID_TARGETS, "No valid spread targets available"
        end
        return MoveTargeting.ValidationResult.VALID, "Valid spread move targets"
    end
    
    return MoveTargeting.ValidationResult.INVALID_TARGET, "Unknown targeting type"
end

-- Get all available targets for a move
-- @param battleState: Current battle state  
-- @param attacker: Pokemon using the move
-- @param targetingType: Type of targeting
-- @return: Array of available target objects
function MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
    if not battleState or not attacker then
        return {}
    end
    
    local availableTargets = {}
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    local attackerSide = attacker.battleData and attacker.battleData.side or "player"
    local opponentSide = attackerSide == "player" and "enemy" or "player"
    
    if targetingType == MoveTargeting.TargetingType.SELF then
        table.insert(availableTargets, {
            pokemon = attacker,
            position = attacker.battleData and attacker.battleData.position or 1,
            side = attackerSide,
            relationship = "self"
        })
    
    elseif targetingType == MoveTargeting.TargetingType.SINGLE_OPPONENT or 
           targetingType == MoveTargeting.TargetingType.ALL_OPPONENTS or
           targetingType == MoveTargeting.TargetingType.SPREAD then
        -- Get opponent targets
        for position = 1, formatInfo.max_active_per_side do
            local opponent = PositionalMechanics.getPokemonAtPosition(battleState, opponentSide, position)
            if opponent and not opponent.fainted then
                table.insert(availableTargets, {
                    pokemon = opponent,
                    position = position,
                    side = opponentSide,
                    relationship = "opponent"
                })
            end
        end
    
    elseif targetingType == MoveTargeting.TargetingType.SINGLE_ALLY or 
           targetingType == MoveTargeting.TargetingType.ALL_ALLIES then
        -- Get ally targets (excluding self)
        for position = 1, formatInfo.max_active_per_side do
            local ally = PositionalMechanics.getPokemonAtPosition(battleState, attackerSide, position)
            if ally and ally.id ~= attacker.id and not ally.fainted then
                table.insert(availableTargets, {
                    pokemon = ally,
                    position = position,
                    side = attackerSide,
                    relationship = "ally"
                })
            end
        end
    
    elseif targetingType == MoveTargeting.TargetingType.ALL_POKEMON then
        -- Get all Pokemon (allies and opponents)
        -- Add opponents
        for position = 1, formatInfo.max_active_per_side do
            local opponent = PositionalMechanics.getPokemonAtPosition(battleState, opponentSide, position)
            if opponent and not opponent.fainted then
                table.insert(availableTargets, {
                    pokemon = opponent,
                    position = position,
                    side = opponentSide,
                    relationship = "opponent"
                })
            end
        end
        
        -- Add allies (including self)
        for position = 1, formatInfo.max_active_per_side do
            local ally = PositionalMechanics.getPokemonAtPosition(battleState, attackerSide, position)
            if ally and not ally.fainted then
                table.insert(availableTargets, {
                    pokemon = ally,
                    position = position,
                    side = attackerSide,
                    relationship = ally.id == attacker.id and "self" or "ally"
                })
            end
        end
    
    elseif targetingType == MoveTargeting.TargetingType.POSITION_DEPENDENT then
        -- Position-dependent moves target specific positions
        for position = 1, formatInfo.max_active_per_side do
            local opponent = PositionalMechanics.getPokemonAtPosition(battleState, opponentSide, position)
            if opponent and not opponent.fainted then
                table.insert(availableTargets, {
                    pokemon = opponent,
                    position = position,
                    side = opponentSide,
                    relationship = "opponent",
                    position_specific = true
                })
            end
        end
    end
    
    return availableTargets
end

-- Resolve move targets for execution
-- @param battleState: Current battle state
-- @param attacker: Pokemon using the move
-- @param moveData: Move being used
-- @param targetPokemon: Primary target (optional)
-- @param targetPosition: Target position (optional)
-- @return: Array of resolved targets for move execution
function MoveTargeting.resolveTargets(battleState, attacker, moveData, targetPokemon, targetPosition)
    if not battleState or not attacker or not moveData then
        return {}
    end
    
    local targetingType, targetingInfo = MoveTargeting.getMoveTargetingType(moveData)
    local resolvedTargets = {}
    
    -- Validate targeting first
    local validation, message = MoveTargeting.validateMoveTargeting(battleState, attacker, moveData, targetPokemon, targetPosition)
    if validation ~= MoveTargeting.ValidationResult.VALID then
        return {} -- Invalid targeting returns no targets
    end
    
    if targetingType == MoveTargeting.TargetingType.SELF then
        table.insert(resolvedTargets, {
            pokemon = attacker,
            damageMultiplier = 1.0,
            targetType = "self"
        })
    
    elseif targetingType == MoveTargeting.TargetingType.SINGLE_OPPONENT then
        if targetPokemon then
            table.insert(resolvedTargets, {
                pokemon = targetPokemon,
                damageMultiplier = 1.0,
                targetType = "opponent"
            })
        end
    
    elseif targetingType == MoveTargeting.TargetingType.SINGLE_ALLY then
        if targetPokemon then
            table.insert(resolvedTargets, {
                pokemon = targetPokemon,
                damageMultiplier = 1.0,
                targetType = "ally"
            })
        end
    
    elseif targetingType == MoveTargeting.TargetingType.ALL_OPPONENTS or 
           targetingType == MoveTargeting.TargetingType.ALL_ALLIES or 
           targetingType == MoveTargeting.TargetingType.ALL_POKEMON then
        -- Multi-target moves
        local availableTargets = MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
        for _, target in ipairs(availableTargets) do
            table.insert(resolvedTargets, {
                pokemon = target.pokemon,
                damageMultiplier = 1.0,
                targetType = target.relationship
            })
        end
    
    elseif targetingType == MoveTargeting.TargetingType.SPREAD then
        -- Spread moves with damage reduction
        local availableTargets = MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
        local damageReduction = targetingInfo.damageReduction or 0.75
        
        for _, target in ipairs(availableTargets) do
            table.insert(resolvedTargets, {
                pokemon = target.pokemon,
                damageMultiplier = damageReduction, -- Reduced damage for spread moves
                targetType = target.relationship,
                isSpreadTarget = true
            })
        end
    
    elseif targetingType == MoveTargeting.TargetingType.POSITION_DEPENDENT then
        -- Position-dependent targeting
        if targetPosition then
            local opponentSide = attacker.battleData.side == "player" and "enemy" or "player"
            local targetPokemonAtPosition = PositionalMechanics.getPokemonAtPosition(battleState, opponentSide, targetPosition)
            
            if targetPokemonAtPosition then
                table.insert(resolvedTargets, {
                    pokemon = targetPokemonAtPosition,
                    damageMultiplier = 1.0,
                    targetType = "opponent",
                    targetPosition = targetPosition
                })
            end
        end
    end
    
    return resolvedTargets
end

-- Get targeting summary for UI display
-- @param battleState: Current battle state
-- @param attacker: Pokemon using the move
-- @param moveData: Move being used
-- @return: Targeting summary information
function MoveTargeting.getTargetingSummary(battleState, attacker, moveData)
    if not battleState or not attacker or not moveData then
        return {
            targeting_type = "unknown",
            available_targets = 0,
            requires_selection = false
        }
    end
    
    local targetingType, targetingInfo = MoveTargeting.getMoveTargetingType(moveData)
    local availableTargets = MoveTargeting.getAvailableTargets(battleState, attacker, targetingType)
    
    local summary = {
        targeting_type = targetingType,
        available_targets = #availableTargets,
        requires_selection = targetingInfo.requiresTarget and 
                            (targetingType == MoveTargeting.TargetingType.SINGLE_OPPONENT or
                             targetingType == MoveTargeting.TargetingType.SINGLE_ALLY or
                             targetingType == MoveTargeting.TargetingType.POSITION_DEPENDENT),
        format_requirements = targetingInfo.requiresDoublesFormat and "doubles" or "any",
        can_target_allies = targetingInfo.allowsAllies,
        can_target_opponents = targetingInfo.allowsOpponents,
        targets = availableTargets
    }
    
    return summary
end

-- Check if move can target specific Pokemon
-- @param battleState: Current battle state
-- @param attacker: Pokemon using the move
-- @param moveData: Move being used
-- @param targetPokemon: Pokemon to check as target
-- @return: Boolean indicating if targeting is allowed
function MoveTargeting.canTargetPokemon(battleState, attacker, moveData, targetPokemon)
    if not battleState or not attacker or not moveData or not targetPokemon then
        return false
    end
    
    local validation, _ = MoveTargeting.validateMoveTargeting(battleState, attacker, moveData, targetPokemon)
    return validation == MoveTargeting.ValidationResult.VALID
end

-- Get position-specific targeting information for doubles
-- @param battleState: Current battle state
-- @param attacker: Pokemon using the move
-- @return: Position targeting details
function MoveTargeting.getPositionTargetingInfo(battleState, attacker)
    if not battleState or not attacker then
        return {}
    end
    
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    
    if formatInfo.format ~= PositionalMechanics.BattleFormat.DOUBLE then
        return {
            supports_position_targeting = false,
            available_positions = {}
        }
    end
    
    local attackerSide = attacker.battleData and attacker.battleData.side or "player"
    local opponentSide = attackerSide == "player" and "enemy" or "player"
    
    local positionInfo = {
        supports_position_targeting = true,
        available_positions = {},
        ally_positions = {},
        opponent_positions = {}
    }
    
    -- Get opponent position info
    for position = 1, formatInfo.max_active_per_side do
        local opponent = PositionalMechanics.getPokemonAtPosition(battleState, opponentSide, position)
        local positionData = {
            position = position,
            occupied = opponent ~= nil,
            pokemon = opponent,
            fainted = opponent and opponent.fainted or false
        }
        
        table.insert(positionInfo.opponent_positions, positionData)
        if opponent and not opponent.fainted then
            table.insert(positionInfo.available_positions, {
                position = position,
                side = opponentSide,
                pokemon = opponent,
                relationship = "opponent"
            })
        end
    end
    
    -- Get ally position info
    for position = 1, formatInfo.max_active_per_side do
        local ally = PositionalMechanics.getPokemonAtPosition(battleState, attackerSide, position)
        local positionData = {
            position = position,
            occupied = ally ~= nil,
            pokemon = ally,
            fainted = ally and ally.fainted or false,
            is_self = ally and ally.id == attacker.id or false
        }
        
        table.insert(positionInfo.ally_positions, positionData)
        if ally and ally.id ~= attacker.id and not ally.fainted then
            table.insert(positionInfo.available_positions, {
                position = position,
                side = attackerSide,
                pokemon = ally,
                relationship = "ally"
            })
        end
    end
    
    return positionInfo
end


-- ===== END MODULE: game-logic.battle.move-targeting =====


-- Berry system integration

-- ===== MODULE: game-logic.items.berry-activation-manager =====
-- File: ao-processes/game-logic/items/berry-activation-manager.lua
-- Original require: local BerryActivationManager = require("game-logic.items.berry-activation-manager")


-- ===== END MODULE: game-logic.items.berry-activation-manager =====


-- ===== MODULE: game-logic.items.berry-effects-processor =====
-- File: ao-processes/game-logic/items/berry-effects-processor.lua
-- Original require: local BerryEffectsProcessor = require("game-logic.items.berry-effects-processor")


-- ===== END MODULE: game-logic.items.berry-effects-processor =====


local DamageCalculator = {}

-- Damage calculation constants (matching TypeScript implementation)
local DAMAGE_CONSTANTS = {
    BASE_LEVEL_MULTIPLIER = 2,
    LEVEL_DIVISOR = 5,
    LEVEL_ADD = 2,
    FORMULA_DIVISOR = 50,
    FORMULA_ADD = 2,
    STAB_MULTIPLIER = 1.5,
    CRITICAL_MULTIPLIER = 1.5,
    VARIANCE_MIN = 0.85,
    VARIANCE_MAX = 1.0,
    STAT_STAGE_NUMERATORS = {2, 2, 2, 2, 2, 2, 2, 3, 4},  -- -6 to +6 (index 1-13, with 7 = neutral)
    STAT_STAGE_DENOMINATORS = {8, 7, 6, 5, 4, 3, 2, 2, 2},
    -- Spread move damage reduction constants
    SPREAD_DAMAGE_REDUCTION = 0.75, -- Standard 25% reduction for spread moves
    MIN_SPREAD_DAMAGE = 1 -- Minimum damage for spread moves
}

-- Weather damage multipliers
local WEATHER_MULTIPLIERS = {
    RAIN = {
        [Enums.PokemonType.WATER] = 1.5,
        [Enums.PokemonType.FIRE] = 0.5
    },
    SUN = {
        [Enums.PokemonType.FIRE] = 1.5,
        [Enums.PokemonType.WATER] = 0.5
    },
    SANDSTORM = {
        -- No direct damage multipliers, handled elsewhere
    },
    HAIL = {
        -- No direct damage multipliers, handled elsewhere  
    }
}

-- Calculate base damage using exact TypeScript formula
-- Formula: ((2 * Level / 5 + 2) * Power * A / D / 50 + 2)
-- @param level: Pokemon level (1-100)
-- @param power: Move power
-- @param attack: Effective attack stat
-- @param defense: Effective defense stat
-- @return: Base damage (integer)
local function calculateBaseDamage(level, power, attack, defense)
    if not level or not power or not attack or not defense then
        error("Base damage calculation requires level, power, attack, and defense")
    end
    
    if power <= 0 or attack <= 0 or defense <= 0 then
        return 0
    end
    
    -- Exact TypeScript formula implementation using Math.floor equivalents
    -- Formula: ((2 * Level / 5 + 2) * Power * A / D / 50 + 2)
    local levelComponent = math.floor((DAMAGE_CONSTANTS.BASE_LEVEL_MULTIPLIER * level) / DAMAGE_CONSTANTS.LEVEL_DIVISOR) + DAMAGE_CONSTANTS.LEVEL_ADD
    local powerComponent = levelComponent * power
    local attackDefenseRatio = math.floor((powerComponent * attack) / defense)
    local finalComponent = math.floor(attackDefenseRatio / DAMAGE_CONSTANTS.FORMULA_DIVISOR)
    local baseDamage = finalComponent + DAMAGE_CONSTANTS.FORMULA_ADD
    
    return math.max(1, baseDamage)  -- Minimum 1 damage
end

-- Get effective attack or defense stat with stat stage modifications
-- @param baseStat: Base stat value
-- @param statStage: Stat stage modification (-6 to +6)
-- @return: Effective stat after modifications
local function getEffectiveStat(baseStat, statStage)
    if not baseStat then
        error("Effective stat calculation requires base stat")
    end
    
    statStage = statStage or 0
    
    -- Clamp stat stage to valid range
    statStage = math.max(-6, math.min(6, statStage))
    
    -- Convert to array index (0 = index 7, -6 = index 1, +6 = index 13)
    local index = statStage + 7
    
    local numerator = DAMAGE_CONSTANTS.STAT_STAGE_NUMERATORS[index]
    local denominator = DAMAGE_CONSTANTS.STAT_STAGE_DENOMINATORS[index]
    
    return math.floor((baseStat * numerator) / denominator)
end

-- Calculate critical hit damage
-- @param baseDamage: Base damage before critical hit
-- @param criticalHit: Boolean indicating if move is critical hit
-- @return: Damage after critical hit multiplier
local function applyCriticalHit(baseDamage, criticalHit)
    if not criticalHit then
        return baseDamage
    end
    
    return math.floor(baseDamage * DAMAGE_CONSTANTS.CRITICAL_MULTIPLIER)
end

-- Check if move gets STAB (Same Type Attack Bonus)
-- @param moveType: Type of the move being used
-- @param pokemonTypes: Array of Pokemon types or single type
-- @return: Boolean indicating if STAB applies
local function checkSTAB(moveType, pokemonTypes)
    if not moveType or not pokemonTypes then
        return false
    end
    
    -- Convert single type to array
    if type(pokemonTypes) ~= "table" then
        pokemonTypes = {pokemonTypes}
    end
    
    -- Check if move type matches any Pokemon type
    for _, pokemonType in ipairs(pokemonTypes) do
        if pokemonType == moveType then
            return true
        end
    end
    
    return false
end

-- Apply STAB multiplier to damage
-- @param damage: Damage before STAB
-- @param hasSTAB: Boolean indicating if STAB applies
-- @return: Damage after STAB multiplier
local function applySTAB(damage, hasSTAB)
    if not hasSTAB then
        return damage
    end
    
    return math.floor(damage * DAMAGE_CONSTANTS.STAB_MULTIPLIER)
end

-- Apply weather effects to damage
-- @param damage: Damage before weather effects
-- @param moveType: Type of the move
-- @param weather: Current weather condition
-- @return: Damage after weather multiplier
local function applyWeatherEffects(damage, moveType, weather)
    if not weather or not moveType then
        return damage
    end
    
    local weatherMultipliers = WEATHER_MULTIPLIERS[weather]
    if not weatherMultipliers then
        return damage
    end
    
    local multiplier = weatherMultipliers[moveType]
    if not multiplier then
        return damage
    end
    
    return math.floor(damage * multiplier)
end

-- Apply random damage variance (85%-100%)
-- @param damage: Damage before variance
-- @return: Final damage after random variance
local function applyDamageVariance(damage)
    if damage <= 0 then
        return 0
    end
    
    -- Generate random multiplier between 85% and 100%
    local randomMultiplier = BattleRNG.randomFloat() * (DAMAGE_CONSTANTS.VARIANCE_MAX - DAMAGE_CONSTANTS.VARIANCE_MIN) + DAMAGE_CONSTANTS.VARIANCE_MIN
    
    return math.max(1, math.floor(damage * randomMultiplier))
end

-- Determine if move results in critical hit
-- @param criticalHitRatio: Critical hit stage (0-4, higher = more likely)
-- @param pokemon: Pokemon data (for abilities/items that affect crit rate)
-- @return: Boolean indicating critical hit
local function determineCriticalHit(criticalHitRatio, pokemon)
    criticalHitRatio = criticalHitRatio or 0
    
    -- Critical hit thresholds based on ratio (matching TypeScript)
    local criticalThresholds = {16, 8, 2, 1, 1}  -- Indices 1-5 for ratios 0-4
    
    local thresholdIndex = math.min(criticalHitRatio + 1, 5)
    local threshold = criticalThresholds[thresholdIndex]
    
    return BattleRNG.criticalHit(threshold)
end

-- Apply ability effects to damage calculation
-- @param damage: Current damage
-- @param attacker: Attacking Pokemon data
-- @param defender: Defending Pokemon data  
-- @param moveData: Move data
-- @param battleState: Current battle state
-- @return: Damage after ability modifications
local function applyAbilityEffects(damage, attacker, defender, moveData, battleState)
    -- Placeholder for ability effects - will be expanded in ability system integration
    -- Examples: Huge Power (doubles attack), Wonder Guard (immunity), etc.
    return damage
end

-- Apply item effects to damage calculation
-- @param damage: Current damage
-- @param attacker: Attacking Pokemon data
-- @param defender: Defending Pokemon data
-- @param moveData: Move data
-- @param battleState: Current battle state  
-- @return: Damage after item modifications
local function applyItemEffects(damage, attacker, defender, moveData, battleState)
    -- Placeholder for item effects - will be expanded in item system integration
    -- Examples: Choice Band (+50% attack), Life Orb (+30% damage), etc.
    return damage
end

-- Apply side effect damage reduction (Light Screen, Reflect, Aurora Veil)
-- @param damage: Current damage
-- @param moveData: Move data
-- @param attackingSide: Side performing the attack
-- @param defendingSide: Side receiving the attack
-- @param battleState: Current battle state
-- @return: Damage after side effect reductions
local function applySideEffectReductions(damage, moveData, attackingSide, defendingSide, battleState)
    if not damage or damage <= 0 or not moveData or not battleState then
        return damage
    end
    
    -- Only apply to damaging moves
    if moveData.category == Enums.MoveCategory.STATUS then
        return damage
    end
    

-- ===== MODULE: game-logic.battle.side-effects =====
-- File: ao-processes/game-logic/battle/side-effects.lua
-- Original require:     local SideEffects = require("game-logic.battle.side-effects")


-- ===== END MODULE: game-logic.battle.side-effects =====

    
    -- Determine if this is a doubles battle format
    local isDoublesFormat = battleState.battleFormat == "doubles" or 
                           (battleState.playerParty and #battleState.playerParty > 1 and battleState.activePlayerPokemon and #battleState.activePlayerPokemon > 1)
    
    -- Apply side effect damage reduction
    return SideEffects.applyDamageReduction(damage, moveData.category, attackingSide, defendingSide, battleState, isDoublesFormat)
end

-- Main damage calculation function
-- @param params: Table containing all damage calculation parameters
--   - attacker: Pokemon using the move
--   - defender: Pokemon receiving damage
--   - moveData: Data about the move being used
--   - battleState: Current battle conditions
--   - options: Optional parameters (criticalHitForced, etc.)
-- @return: Table with damage result and calculation details
function DamageCalculator.calculateDamage(params)
    if not params or not params.attacker or not params.defender or not params.moveData then
        error("Damage calculation requires attacker, defender, and moveData")
    end
    
    local attacker = params.attacker
    local defender = params.defender
    local moveData = params.moveData
    local battleState = params.battleState or {}
    local options = params.options or {}
    
    -- Check for status moves (no damage)
    if moveData.category == Enums.MoveCategory.STATUS then
        return {
            damage = 0,
            criticalHit = false,
            typeEffectiveness = 1.0,
            details = {
                reason = "Status move deals no damage"
            }
        }
    end
    
    -- Check for zero power moves
    if not moveData.power or moveData.power <= 0 then
        return {
            damage = 0,
            criticalHit = false,
            typeEffectiveness = 1.0,
            details = {
                reason = "Move has no power"
            }
        }
    end
    
    -- Get Pokemon stats with current HP checks
    if not attacker.stats or not defender.stats then
        error("Pokemon must have stats for damage calculation")
    end
    
    -- Determine which stats to use based on move category
    local attackStat = moveData.category == Enums.MoveCategory.PHYSICAL and 
        (attacker.stats.attack or attacker.stats.atk) or 
        (attacker.stats.spAttack or attacker.stats.spatk)
    local defenseStat = moveData.category == Enums.MoveCategory.PHYSICAL and 
        (defender.stats.defense or defender.stats.def) or 
        (defender.stats.spDefense or defender.stats.spdef)
    
    -- Validate stats exist
    if not attackStat then
        error(string.format("Missing attack stat for %s move - attacker stats: %s", 
            moveData.category == Enums.MoveCategory.PHYSICAL and "physical" or "special",
            attacker.stats and "present" or "nil"))
    end
    if not defenseStat then
        error(string.format("Missing defense stat for %s move - defender stats: %s", 
            moveData.category == Enums.MoveCategory.PHYSICAL and "physical" or "special",
            defender.stats and "present" or "nil"))
    end
    
    -- Apply stat stage modifications
    local attackStages = (attacker.battleData and attacker.battleData.statStages) and 
        (moveData.category == Enums.MoveCategory.PHYSICAL and 
         (attacker.battleData.statStages.attack or attacker.battleData.statStages.atk) or 
         (attacker.battleData.statStages.spAttack or attacker.battleData.statStages.spatk)) or 0
    local defenseStages = (defender.battleData and defender.battleData.statStages) and
        (moveData.category == Enums.MoveCategory.PHYSICAL and 
         (defender.battleData.statStages.defense or defender.battleData.statStages.def) or 
         (defender.battleData.statStages.spDefense or defender.battleData.statStages.spdef)) or 0
    
    local effectiveAttack = getEffectiveStat(attackStat, attackStages)
    local effectiveDefense = getEffectiveStat(defenseStat, defenseStages)
    
    -- Calculate base damage
    local baseDamage = calculateBaseDamage(attacker.level, moveData.power, effectiveAttack, effectiveDefense)
    local currentDamage = baseDamage
    
    -- Determine critical hit
    local criticalHit = false
    if options.criticalHitForced == true then
        criticalHit = true
    elseif options.criticalHitForced == false then
        criticalHit = false  -- Explicitly forced to false
    else
        criticalHit = determineCriticalHit(moveData.criticalHitRatio or 0, attacker)
    end
    currentDamage = applyCriticalHit(currentDamage, criticalHit)
    
    -- Apply STAB
    local hasSTAB = checkSTAB(moveData.type, attacker.types)
    currentDamage = applySTAB(currentDamage, hasSTAB)
    
    -- Calculate type effectiveness
    local typeEffectiveness = TypeChart.getAttackTypeEffectiveness(moveData.type, defender.types)
    currentDamage = math.floor(currentDamage * typeEffectiveness)
    
    -- Apply weather effects
    local weather = battleState.weather
    currentDamage = applyWeatherEffects(currentDamage, moveData.type, weather)
    
    -- Apply ability effects
    currentDamage = applyAbilityEffects(currentDamage, attacker, defender, moveData, battleState)
    
    -- Apply item effects  
    currentDamage = applyItemEffects(currentDamage, attacker, defender, moveData, battleState)
    
    -- Apply side effect damage reductions (Light Screen, Reflect, Aurora Veil)
    -- Need to determine attacking and defending sides
    local attackingSide = attacker.side or "player"
    local defendingSide = defender.side or "enemy"
    currentDamage = applySideEffectReductions(currentDamage, moveData, attackingSide, defendingSide, battleState)
    
    -- Apply spread move damage reduction if move has spread properties or explicit multiplier
    if moveData.isSpreadMove and moveData.damageReduction then
        currentDamage = math.floor(currentDamage * moveData.damageReduction)
    elseif options.damageMultiplier then
        currentDamage = math.floor(currentDamage * options.damageMultiplier)
    end
    
    -- Apply random damage variance (final step)
    local finalDamage = applyDamageVariance(currentDamage)
    
    -- Return comprehensive damage calculation result
    return {
        damage = finalDamage,
        criticalHit = criticalHit,
        typeEffectiveness = typeEffectiveness,
        stab = hasSTAB,
        details = {
            baseDamage = baseDamage,
            afterCritical = criticalHit and math.floor(baseDamage * DAMAGE_CONSTANTS.CRITICAL_MULTIPLIER) or baseDamage,
            afterSTAB = hasSTAB and math.floor(currentDamage / typeEffectiveness * DAMAGE_CONSTANTS.STAB_MULTIPLIER) or currentDamage / typeEffectiveness,
            beforeVariance = currentDamage,
            effectiveAttack = effectiveAttack,
            effectiveDefense = effectiveDefense,
            attackStages = attackStages,
            defenseStages = defenseStages,
            weather = weather
        }
    }
end

-- Quick damage calculation for simple cases
-- @param attacker: Attacking Pokemon
-- @param defender: Defending Pokemon
-- @param moveData: Move data
-- @param battleState: Optional battle state
-- @return: Final damage amount (integer)
function DamageCalculator.quickDamage(attacker, defender, moveData, battleState)
    local result = DamageCalculator.calculateDamage({
        attacker = attacker,
        defender = defender,
        moveData = moveData,
        battleState = battleState
    })
    return result.damage
end

-- Calculate damage preview without random variance (for UI display)
-- @param params: Same as calculateDamage
-- @return: Damage range (min, max) without variance applied
function DamageCalculator.previewDamage(params)
    local result = DamageCalculator.calculateDamage(params)
    local beforeVariance = result.details.beforeVariance
    
    local minDamage = math.max(1, math.floor(beforeVariance * DAMAGE_CONSTANTS.VARIANCE_MIN))
    local maxDamage = math.floor(beforeVariance * DAMAGE_CONSTANTS.VARIANCE_MAX)
    
    return {
        minDamage = minDamage,
        maxDamage = maxDamage,
        criticalHit = result.criticalHit,
        typeEffectiveness = result.typeEffectiveness,
        stab = result.stab
    }
end

-- Utility function to check if attack would be super effective
-- @param moveType: Attack type
-- @param defenderTypes: Defender Pokemon types
-- @return: Boolean indicating super effectiveness
function DamageCalculator.isSuperEffective(moveType, defenderTypes)
    return TypeChart.isSuperEffective(moveType, defenderTypes)
end

-- Utility function to check if attack would have no effect
-- @param moveType: Attack type
-- @param defenderTypes: Defender Pokemon types  
-- @return: Boolean indicating no effect
function DamageCalculator.hasNoEffect(moveType, defenderTypes)
    return TypeChart.hasNoEffect(moveType, defenderTypes)
end

-- Get type effectiveness description
-- @param moveType: Attack type
-- @param defenderTypes: Defender Pokemon types
-- @return: String description of effectiveness
function DamageCalculator.getEffectivenessDescription(moveType, defenderTypes)
    return TypeChart.getEffectivenessDescription(moveType, defenderTypes)
end

-- Validate damage calculation parameters
-- @param params: Damage calculation parameters
-- @return: Boolean indicating if parameters are valid
function DamageCalculator.validateParams(params)
    if not params then
        return false, "Parameters are required"
    end
    
    if not params.attacker or not params.defender or not params.moveData then
        return false, "Attacker, defender, and moveData are required"
    end
    
    if not params.attacker.stats or not params.defender.stats then
        return false, "Both Pokemon must have stats"
    end
    
    if not params.attacker.level or params.attacker.level < 1 or params.attacker.level > 100 then
        return false, "Attacker level must be between 1 and 100"
    end
    
    if not params.moveData.type or not Enums.isValidType(params.moveData.type) then
        return false, "Move must have a valid type"
    end
    
    return true
end

-- Apply spread move damage reduction
-- @param damage: Base damage amount
-- @param targetCount: Number of targets being hit
-- @param customReduction: Custom reduction multiplier (optional)
-- @return: Reduced damage for spread moves
function DamageCalculator.applySpreadMoveDamageReduction(damage, targetCount, customReduction)
    if not damage or damage <= 0 then
        return 0
    end
    
    targetCount = targetCount or 1
    
    -- No reduction for single target
    if targetCount <= 1 then
        return damage
    end
    
    -- Use custom reduction or default spread move reduction
    local reductionMultiplier = customReduction or DAMAGE_CONSTANTS.SPREAD_DAMAGE_REDUCTION
    
    -- Apply reduction
    local reducedDamage = math.floor(damage * reductionMultiplier)
    
    -- Ensure minimum damage
    return math.max(DAMAGE_CONSTANTS.MIN_SPREAD_DAMAGE, reducedDamage)
end

-- Calculate damage for multiple targets (spread moves)
-- @param params: Table containing damage calculation parameters
--   - attacker: Pokemon using the move
--   - targets: Array of target Pokemon with their relationship info
--   - moveData: Data about the move being used
--   - battleState: Current battle conditions
--   - options: Optional parameters
-- @return: Array of damage results for each target
function DamageCalculator.calculateSpreadMoveDamage(params)
    if not params or not params.attacker or not params.targets or not params.moveData then
        return {}
    end
    
    local attacker = params.attacker
    local targets = params.targets
    local moveData = params.moveData
    local battleState = params.battleState or {}
    local options = params.options or {}
    
    -- Check if this is actually a spread move
    local targetingType = MoveTargeting.getMoveTargetingType(moveData)
    local isSpreadMove = targetingType == MoveTargeting.TargetingType.SPREAD
    
    local results = {}
    local targetCount = #targets
    
    -- Determine if damage reduction should be applied
    local applyReduction = isSpreadMove or (moveData.isSpreadMove == true) or targetCount > 1
    
    for _, targetInfo in ipairs(targets) do
        local target = targetInfo.pokemon
        
        -- Calculate base damage for this target
        local damageResult = DamageCalculator.calculateDamage({
            attacker = attacker,
            defender = target,
            moveData = moveData,
            battleState = battleState,
            options = options
        })
        
        -- Apply spread move damage reduction if applicable
        if applyReduction and damageResult.damage > 0 then
            local customReduction = targetInfo.damageMultiplier or moveData.damageReduction
            local reducedDamage = DamageCalculator.applySpreadMoveDamageReduction(
                damageResult.damage,
                targetCount,
                customReduction
            )
            
            -- Update damage result with reduction information
            damageResult.originalDamage = damageResult.damage
            damageResult.damage = reducedDamage
            damageResult.spreadReduction = true
            damageResult.reductionRatio = reducedDamage / damageResult.originalDamage
            damageResult.targetCount = targetCount
        end
        
        -- Add target-specific information
        damageResult.targetInfo = {
            pokemon_id = target.id,
            target_name = target.name or "Unknown",
            target_relationship = targetInfo.targetType or "opponent",
            target_position = targetInfo.targetPosition
        }
        
        table.insert(results, damageResult)
    end
    
    return results
end

-- Calculate damage for all targets of a multi-target move
-- @param battleState: Current battle state
-- @param attacker: Pokemon using the move
-- @param moveData: Move data
-- @param options: Optional calculation parameters
-- @return: Complete damage results for all valid targets
function DamageCalculator.calculateMultiTargetDamage(battleState, attacker, moveData, options)
    if not battleState or not attacker or not moveData then
        return {}
    end
    
    -- Resolve all targets for the move
    local resolvedTargets = MoveTargeting.resolveTargets(battleState, attacker, moveData)
    
    if #resolvedTargets == 0 then
        return {}
    end
    
    -- Calculate spread move damage for all targets
    return DamageCalculator.calculateSpreadMoveDamage({
        attacker = attacker,
        targets = resolvedTargets,
        moveData = moveData,
        battleState = battleState,
        options = options
    })
end

-- Preview spread move damage (without variance)
-- @param params: Same parameters as calculateSpreadMoveDamage
-- @return: Array of damage previews for each target
function DamageCalculator.previewSpreadMoveDamage(params)
    if not params or not params.attacker or not params.targets or not params.moveData then
        return {}
    end
    
    local results = {}
    local targetCount = #params.targets
    
    -- Determine if damage reduction should be applied
    local targetingType = MoveTargeting.getMoveTargetingType(params.moveData)
    local isSpreadMove = targetingType == MoveTargeting.TargetingType.SPREAD
    local applyReduction = isSpreadMove or (params.moveData.isSpreadMove == true) or targetCount > 1
    
    for _, targetInfo in ipairs(params.targets) do
        local target = targetInfo.pokemon
        
        -- Get damage preview for this target
        local damagePreview = DamageCalculator.previewDamage({
            attacker = params.attacker,
            defender = target,
            moveData = params.moveData,
            battleState = params.battleState,
            options = params.options
        })
        
        -- Apply spread move reduction to preview
        if applyReduction then
            local customReduction = targetInfo.damageMultiplier or params.moveData.damageReduction
            
            damagePreview.originalMinDamage = damagePreview.minDamage
            damagePreview.originalMaxDamage = damagePreview.maxDamage
            
            damagePreview.minDamage = DamageCalculator.applySpreadMoveDamageReduction(
                damagePreview.minDamage,
                targetCount,
                customReduction
            )
            damagePreview.maxDamage = DamageCalculator.applySpreadMoveDamageReduction(
                damagePreview.maxDamage,
                targetCount,
                customReduction
            )
            
            damagePreview.spreadReduction = true
            damagePreview.targetCount = targetCount
        end
        
        -- Add target information
        damagePreview.targetInfo = {
            pokemon_id = target.id,
            target_name = target.name or "Unknown",
            target_relationship = targetInfo.targetType or "opponent"
        }
        
        table.insert(results, damagePreview)
    end
    
    return results
end

-- Utility function to determine if a move should use spread damage mechanics
-- @param moveData: Move data to check
-- @param targetCount: Number of targets the move will hit
-- @return: Boolean indicating if spread damage should apply
function DamageCalculator.shouldUseSpreadDamage(moveData, targetCount)
    if not moveData then
        return false
    end
    
    -- Explicit spread move flag
    if moveData.isSpreadMove == true then
        return true
    end
    
    -- Check targeting type
    local targetingType = MoveTargeting.getMoveTargetingType(moveData)
    if targetingType == MoveTargeting.TargetingType.SPREAD then
        return true
    end
    
    -- Multi-target moves with multiple actual targets
    if targetCount and targetCount > 1 and 
       (targetingType == MoveTargeting.TargetingType.ALL_OPPONENTS or
        targetingType == MoveTargeting.TargetingType.ALL_POKEMON) then
        return true
    end
    
    return false
end


-- ===== END MODULE: game-logic.battle.damage-calculator =====

    
    -- Check if move affects the user or needs a target
    local actualTarget = target
    if not target and moveData.target ~= Enums.MoveTarget.USER then
        -- For moves that need a target but none provided, use default target logic
        if battleState.activePokemon then
            if attacker == battleState.activePokemon.player then
                actualTarget = battleState.activePokemon.enemy
            else
                actualTarget = battleState.activePokemon.player
            end
        end
    end
    
    -- Check accuracy for moves that can miss (negative accuracy means never misses)
    if moveData.accuracy and moveData.accuracy >= 0 and moveData.accuracy < 100 then
        local accuracyRoll = BattleRNG.randomInt(1, 100)
        if accuracyRoll > moveData.accuracy then
            result.missed = true
            result.success = true  -- Move executed but missed
            result.messages = {"The attack missed!"}
            return result
        end
    end
    
    result.success = true
    
    -- Handle damage calculation for offensive moves
    if moveData.category ~= Enums.MoveCategory.STATUS and moveData.power and moveData.power > 0 and actualTarget then
        local damageParams = {
            attacker = attacker,
            defender = actualTarget,
            moveData = moveData,
            battleState = battleState
        }
        
        local damageResult = DamageCalculator.calculateDamage(damageParams)
        
        result.damage = damageResult.damage
        result.effectiveness = damageResult.typeEffectiveness
        result.critical_hit = damageResult.criticalHit
        result.stab = damageResult.stab
        
        -- Check for no effect
        if result.effectiveness == 0 then
            result.no_effect = true
            result.damage = 0
            result.messages = {"It had no effect!"}
            return result
        end
        
        -- Apply damage to target
        if actualTarget and result.damage > 0 then
            -- Support both currentHP and hp field names for compatibility
            local currentHP = actualTarget.currentHP or actualTarget.hp
            if currentHP then
                local newHP = math.max(0, currentHP - result.damage)
                if actualTarget.currentHP then
                    actualTarget.currentHP = newHP
                else
                    actualTarget.hp = newHP
                end
                
                if newHP <= 0 then
                    actualTarget.fainted = true
                    table.insert(result.effects, {
                        type = "faint",
                        target = actualTarget,
                        pokemon_id = actualTarget.id
                    })
                end
            end
        end
    end
    
    -- Apply status effects from move
    if moveData.status_chance and moveData.status_effect and actualTarget then
        local statusRoll = BattleRNG.randomInt(1, 100)
        if statusRoll <= moveData.status_chance then
            local statusApplied = MoveEffects.applyStatusEffectBattle(
                battleState.battleId,
                actualTarget.id,
                moveData.status_effect,
                "move",
                attacker,
                actualTarget
            )
            
            if statusApplied then
                table.insert(result.status_effects, {
                    target = actualTarget,
                    status = moveData.status_effect,
                    applied = true
                })
            end
        end
    end
    
    -- Apply stat changes from move
    local statChanges = moveData.stat_changes or (moveData.effects and moveData.effects.stat_change)
    if statChanges then
        local statTarget = actualTarget
        -- Check for explicit stat change target or fallback to move target
        local statChangeTarget = (moveData.effects and moveData.effects.stat_change_target) or moveData.stat_change_target
        if moveData.target == Enums.MoveTarget.USER or statChangeTarget == "self" or statChanges.user then
            statTarget = attacker
        end
        
        if statTarget and statTarget.battleData and statTarget.battleData.statStages then
            for stat, change in pairs(statChanges) do
                -- Skip metadata fields like 'user', 'target', etc.
                if stat == "user" or stat == "target" or type(change) ~= "number" then
                    goto continue
                end
                local statChangeResult = MoveEffects.applyStatStageChange(
                    battleState.battleId,
                    statTarget.id,
                    stat,
                    change,
                    "move",
                    statTarget,
                    statTarget.battleData.statStages
                )
                
                if statChangeResult then
                    statTarget.battleData.statStages[stat] = (statTarget.battleData.statStages[stat] or 0) + change
                    
                    -- Also update battleStats array for test compatibility
                    if statTarget.battleStats then
                        local statIndex = nil
                        if stat == "attack" then statIndex = 0
                        elseif stat == "defense" then statIndex = 1
                        elseif stat == "spAttack" then statIndex = 2
                        elseif stat == "spDefense" then statIndex = 3
                        elseif stat == "speed" then statIndex = 4
                        elseif stat == "accuracy" then statIndex = 5
                        elseif stat == "evasion" then statIndex = 6
                        end
                        
                        if statIndex then
                            statTarget.battleStats[statIndex] = (statTarget.battleStats[statIndex] or 0) + change
                        end
                    end
                    
                    table.insert(result.effects, {
                        type = "stat_change",
                        target = statTarget,
                        stat = stat,
                        change = change
                    })
                end
                ::continue::
            end
        end
    end
    
    -- Handle healing moves
    if moveData.healing and moveData.target == Enums.MoveTarget.USER then
        local healingAmount = 0
        if type(moveData.healing) == "string" then
            -- Percentage healing (e.g., "1/2" for half HP)
            local numerator, denominator = moveData.healing:match("(%d+)/(%d+)")
            if numerator and denominator then
                healingAmount = math.floor((attacker.stats.hp * tonumber(numerator)) / tonumber(denominator))
            elseif moveData.healing == "full" then
                local currentHP = attacker.currentHP or attacker.hp
                local maxHP = attacker.stats.hp or attacker.stats.maxHp or attacker.maxHp
                healingAmount = maxHP - currentHP
            end
        elseif type(moveData.healing) == "number" then
            healingAmount = moveData.healing
        end
        
        if healingAmount > 0 then
            -- Support both currentHP and hp field names for compatibility
            local currentHP = attacker.currentHP or attacker.hp
            local maxHP = attacker.stats.hp or attacker.stats.maxHp or attacker.maxHp
            if currentHP and maxHP then
                local oldHP = currentHP
                local newHP = math.min(maxHP, currentHP + healingAmount)
                
                if attacker.currentHP then
                    attacker.currentHP = newHP
                else
                    attacker.hp = newHP
                end
                
                local actualHealing = newHP - oldHP
                
                if actualHealing > 0 then
                    table.insert(result.effects, {
                        type = "healing",
                        target = attacker,
                        amount = actualHealing
                    })
                end
            end
        end
    end
    
    -- Handle multi-hit moves
    if moveData.multi_hit and actualTarget and result.damage > 0 then
        local hitCount = 1
        if moveData.multi_hit == "2-5" then
            hitCount = BattleRNG.multiHitCount(2, 5)
        elseif type(moveData.multi_hit) == "number" then
            hitCount = moveData.multi_hit
        end
        
        if hitCount > 1 then
            local totalDamage = result.damage
            for hit = 2, hitCount do
                if actualTarget.currentHP <= 0 then
                    break  -- Stop if target faints
                end
                
                -- Recalculate damage for each hit (for consistency with variance)
                local hitDamageResult = DamageCalculator.calculateDamage({
                    attacker = attacker,
                    defender = actualTarget,
                    moveData = moveData,
                    battleState = battleState
                })
                
                actualTarget.currentHP = math.max(0, actualTarget.currentHP - hitDamageResult.damage)
                totalDamage = totalDamage + hitDamageResult.damage
                
                if actualTarget.currentHP <= 0 then
                    actualTarget.fainted = true
                    break
                end
            end
            
            result.damage = totalDamage
            result.hit_count = hitCount
        end
    end
    
    -- Handle recoil damage
    if moveData.recoil and result.damage > 0 then
        local recoilAmount = 0
        if type(moveData.recoil) == "string" then
            local numerator, denominator = moveData.recoil:match("(%d+)/(%d+)")
            if numerator and denominator then
                recoilAmount = math.floor((result.damage * tonumber(numerator)) / tonumber(denominator))
            end
        elseif type(moveData.recoil) == "number" then
            recoilAmount = moveData.recoil
        end
        
        if recoilAmount > 0 then
            -- Support both currentHP and hp field names for compatibility
            local currentHP = attacker.currentHP or attacker.hp
            if currentHP then
                local newHP = math.max(0, currentHP - recoilAmount)
                if attacker.currentHP then
                    attacker.currentHP = newHP
                else
                    attacker.hp = newHP
                end
                
                table.insert(result.effects, {
                    type = "recoil",
                    target = attacker,
                    amount = recoilAmount
                })
                
                if newHP <= 0 then
                    attacker.fainted = true
                    table.insert(result.effects, {
                        type = "faint",
                        target = attacker,
                        pokemon_id = attacker.id
                    })
                end
            end
        end
    end
    
    -- Handle weather effects from move
    if moveData.effects and moveData.effects.weather and battleState then
        local weatherType = moveData.effects.weather.type or moveData.effects.weather
        local turns = moveData.effects.weather.turns or 5
        
        if not battleState.weather then
            battleState.weather = {}
        end
        
        battleState.weather.weatherType = weatherType
        battleState.weather.turnsLeft = turns
        
        table.insert(result.effects, {
            type = "weather_change",
            weatherType = weatherType,
            turns = turns
        })
        
        result.weatherChanged = true
    end
    
    -- Handle terrain effects from move  
    if moveData.effects and moveData.effects.terrain and battleState then
        local terrainType = moveData.effects.terrain.type or moveData.effects.terrain
        local turns = moveData.effects.terrain.turns or 5
        
        if not battleState.terrain then
            battleState.terrain = {}
        end
        
        battleState.terrain.terrainType = terrainType
        battleState.terrain.turnsLeft = turns
        
        table.insert(result.effects, {
            type = "terrain_change",
            terrainType = terrainType,
            turns = turns
        })
        
        result.terrainChanged = true
    end
    
    -- Handle field condition effects from move
    if moveData.effects and moveData.effects.field_condition and battleState then
        local fieldConditionType = moveData.effects.field_condition
        
        -- Check if field condition is already active
        local shouldFail, failReason = MoveEffects.shouldFieldConditionMoveFail(battleState, fieldConditionType)
        if shouldFail then
            result.failed = true
            result.messages = {failReason}
            return result
        end
        
        -- Apply field condition effect
        local fieldSuccess, fieldResult = MoveEffects.processFieldConditionMove(battleState, moveData, attacker)
        if fieldSuccess then
            table.insert(result.effects, {
                type = "field_condition",
                field_condition_type = fieldConditionType,
                field_condition_name = fieldResult.field_effect_name,
                duration = fieldResult.duration
            })
            
            table.insert(result.messages, fieldResult.message)
            if fieldResult.description then
                table.insert(result.messages, fieldResult.description)
            end
            
            result.fieldConditionChanged = true
        else
            result.failed = true
            result.messages = {fieldResult}
            return result
        end
    end
    
    -- Handle entry hazard effects from move

-- ===== MODULE: game-logic.battle.entry-hazards =====
-- File: ao-processes/game-logic/battle/entry-hazards.lua
-- Original require:     local EntryHazards = require("game-logic.battle.entry-hazards")

-- Entry Hazards System
-- Comprehensive implementation of entry hazards (Stealth Rock, Spikes, Toxic Spikes, Sticky Web)
-- Handles hazard setting, layer tracking, damage calculations, and immunity checks
-- Provides deterministic hazard processing with behavioral parity to TypeScript reference

local EntryHazards = {}

-- Load dependencies

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Optional dependencies
local TypeChart = nil
local Enums = nil
-- SHARED MODULE REFERENCE: data.constants.type-chart (already included)
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Entry hazard type definitions
EntryHazards.HazardType = {
    STEALTH_ROCK = "STEALTH_ROCK",
    SPIKES = "SPIKES", 
    TOXIC_SPIKES = "TOXIC_SPIKES",
    STICKY_WEB = "STICKY_WEB"
}

-- Hazard configuration with exact TypeScript parity
EntryHazards.HazardConfig = {
    [EntryHazards.HazardType.STEALTH_ROCK] = {
        maxLayers = 1,
        baseDamage = 0.125, -- 1/8 max HP
        useTypeEffectiveness = true,
        affectedByFlying = false,
        affectedByLevitate = false,
        stackable = false
    },
    [EntryHazards.HazardType.SPIKES] = {
        maxLayers = 3,
        damagePerLayer = {0.125, 0.1667, 0.25}, -- 1/8, 1/6, 1/4 max HP
        useTypeEffectiveness = false,
        affectedByFlying = true,
        affectedByLevitate = true,
        stackable = true
    },
    [EntryHazards.HazardType.TOXIC_SPIKES] = {
        maxLayers = 2,
        effects = {"poison", "badly_poison"},
        affectedByFlying = true,
        affectedByLevitate = true,
        absorbedByPoison = true,
        immuneSteel = true,
        stackable = true
    },
    [EntryHazards.HazardType.STICKY_WEB] = {
        maxLayers = 1,
        effect = "speed_drop",
        stages = -1,
        affectedByFlying = true,
        affectedByLevitate = true,
        stackable = false
    }
}

-- Initialize entry hazards system
function EntryHazards.init()
    return true, "Entry hazards system initialized"
end

-- Set entry hazard on specified side
-- @param battleState: Current battle state
-- @param hazardType: Type of hazard to set
-- @param targetSide: Side to place hazard on ("player" or "enemy")
-- @return: Hazard setting result
function EntryHazards.setHazard(battleState, hazardType, targetSide)
    if not battleState or not hazardType or not targetSide then
        return {
            success = false,
            error = "Invalid parameters for hazard setting"
        }
    end
    
    -- Initialize battle conditions if needed
    if not battleState.battleConditions then
        battleState.battleConditions = {}
    end
    
    if not battleState.battleConditions.entryHazards then
        battleState.battleConditions.entryHazards = {
            player = {},
            enemy = {}
        }
    end
    
    local hazardSide = battleState.battleConditions.entryHazards[targetSide]
    if not hazardSide then
        hazardSide = {}
        battleState.battleConditions.entryHazards[targetSide] = hazardSide
    end
    
    local config = EntryHazards.HazardConfig[hazardType]
    if not config then
        return {
            success = false,
            error = "Unknown hazard type: " .. tostring(hazardType)
        }
    end
    
    local result = {
        success = true,
        hazardType = hazardType,
        targetSide = targetSide,
        layersAdded = 0,
        messages = {}
    }
    
    if hazardType == EntryHazards.HazardType.STEALTH_ROCK then
        if not hazardSide.stealthRock then
            hazardSide.stealthRock = true
            result.layersAdded = 1
            table.insert(result.messages, "Pointed stones float in the air around " .. targetSide .. "'s team!")
        else
            table.insert(result.messages, "But it failed!")
        end
        
    elseif hazardType == EntryHazards.HazardType.SPIKES then
        local currentLayers = hazardSide.spikes or 0
        if currentLayers < config.maxLayers then
            hazardSide.spikes = currentLayers + 1
            result.layersAdded = 1
            table.insert(result.messages, "Spikes were scattered all around " .. targetSide .. "'s team!")
        else
            table.insert(result.messages, "But it failed!")
        end
        
    elseif hazardType == EntryHazards.HazardType.TOXIC_SPIKES then
        local currentLayers = hazardSide.toxicSpikes or 0
        if currentLayers < config.maxLayers then
            hazardSide.toxicSpikes = currentLayers + 1
            result.layersAdded = 1
            table.insert(result.messages, "Poison spikes were scattered all around " .. targetSide .. "'s team!")
        else
            table.insert(result.messages, "But it failed!")
        end
        
    elseif hazardType == EntryHazards.HazardType.STICKY_WEB then
        if not hazardSide.stickyWeb then
            hazardSide.stickyWeb = true
            result.layersAdded = 1
            table.insert(result.messages, "A sticky web spreads out on the ground around " .. targetSide .. "'s team!")
        else
            table.insert(result.messages, "But it failed!")
        end
    end
    
    -- Record hazard setting in battle events
    table.insert(battleState.battleEvents, {
        type = "hazard_set",
        hazardType = hazardType,
        targetSide = targetSide,
        layersAdded = result.layersAdded,
        turn = battleState.turn,
        timestamp = os.time()
    })
    
    return result
end

-- Process entry hazard effects for switching Pokemon
-- @param battleState: Current battle state
-- @param pokemon: Pokemon switching in
-- @return: Hazard processing result
function EntryHazards.processHazardEffects(battleState, pokemon)
    if not battleState or not pokemon or not pokemon.battleData then
        return {
            success = false,
            error = "Invalid parameters for hazard processing"
        }
    end
    
    local side = pokemon.battleData.side
    local hazards = battleState.battleConditions and 
                   battleState.battleConditions.entryHazards and
                   battleState.battleConditions.entryHazards[side]
    
    if not hazards then
        return {
            success = true,
            pokemon = pokemon.id,
            effects = {},
            messages = {},
            damageTaken = 0
        }
    end
    
    local result = {
        success = true,
        pokemon = pokemon.id,
        effects = {},
        messages = {},
        damageTaken = 0,
        statusChanges = {},
        statChanges = {},
        hazardsRemoved = {}
    }
    
    -- Process hazards in order: Stealth Rock, Spikes, Toxic Spikes, Sticky Web
    local hazardOrder = {
        EntryHazards.HazardType.STEALTH_ROCK,
        EntryHazards.HazardType.SPIKES,
        EntryHazards.HazardType.TOXIC_SPIKES,
        EntryHazards.HazardType.STICKY_WEB
    }
    
    for _, hazardType in ipairs(hazardOrder) do
        if EntryHazards.hasHazard(hazards, hazardType) then
            local hazardResult = EntryHazards.processIndividualHazard(battleState, pokemon, hazardType, hazards)
            
            if hazardResult then
                table.insert(result.effects, hazardResult)
                
                -- Combine messages
                if hazardResult.messages then
                    for _, message in ipairs(hazardResult.messages) do
                        table.insert(result.messages, message)
                    end
                end
                
                -- Accumulate damage
                result.damageTaken = result.damageTaken + (hazardResult.damage or 0)
                
                -- Handle status changes
                if hazardResult.statusChange then
                    table.insert(result.statusChanges, hazardResult.statusChange)
                end
                
                -- Handle stat changes
                if hazardResult.statChanges then
                    for stat, change in pairs(hazardResult.statChanges) do
                        result.statChanges[stat] = (result.statChanges[stat] or 0) + change
                    end
                end
                
                -- Handle hazard removal (Poison types absorbing Toxic Spikes)
                if hazardResult.hazardRemoved then
                    table.insert(result.hazardsRemoved, hazardResult.hazardRemoved)
                end
                
                -- Stop processing if Pokemon fainted
                if pokemon.currentHP <= 0 then
                    pokemon.fainted = true
                    table.insert(result.messages, pokemon.name .. " fainted!")
                    break
                end
            end
        end
    end
    
    -- Record hazard effects in battle events
    if #result.effects > 0 then
        table.insert(battleState.battleEvents, {
            type = "entry_hazards",
            pokemon = pokemon.id,
            side = side,
            effects = result.effects,
            damage = result.damageTaken,
            turn = battleState.turn,
            timestamp = os.time()
        })
    end
    
    return result
end

-- Process individual hazard effect
-- @param battleState: Current battle state
-- @param pokemon: Pokemon being affected
-- @param hazardType: Type of hazard
-- @param hazards: Hazard data for Pokemon's side
-- @return: Individual hazard processing result
function EntryHazards.processIndividualHazard(battleState, pokemon, hazardType, hazards)
    local config = EntryHazards.HazardConfig[hazardType]
    if not config then
        return nil
    end
    
    local result = {
        hazardType = hazardType,
        pokemon = pokemon.id,
        messages = {},
        damage = 0
    }
    
    -- Check immunity
    local immunity = EntryHazards.checkHazardImmunity(pokemon, hazardType, config)
    if immunity.immune then
        if immunity.messages then
            result.messages = immunity.messages
        end
        return result
    end
    
    if hazardType == EntryHazards.HazardType.STEALTH_ROCK then
        return EntryHazards.processStealthRock(battleState, pokemon, result)
        
    elseif hazardType == EntryHazards.HazardType.SPIKES then
        local layers = hazards.spikes or 0
        return EntryHazards.processSpikes(battleState, pokemon, result, layers)
        
    elseif hazardType == EntryHazards.HazardType.TOXIC_SPIKES then
        local layers = hazards.toxicSpikes or 0
        return EntryHazards.processToxicSpikes(battleState, pokemon, result, layers, hazards)
        
    elseif hazardType == EntryHazards.HazardType.STICKY_WEB then
        return EntryHazards.processStickyWeb(battleState, pokemon, result)
    end
    
    return nil
end

-- Process Stealth Rock damage
-- @param battleState: Current battle state
-- @param pokemon: Pokemon being damaged
-- @param result: Result object to update
-- @return: Updated result
function EntryHazards.processStealthRock(battleState, pokemon, result)
    local baseDamage = pokemon.maxHP * 0.125 -- 1/8 max HP
    local typeEffectiveness = EntryHazards.calculateStealthRockEffectiveness(pokemon)
    
    local finalDamage = math.max(1, math.floor(baseDamage * typeEffectiveness))
    
    pokemon.currentHP = math.max(0, pokemon.currentHP - finalDamage)
    result.damage = finalDamage
    
    table.insert(result.messages, "Pointed stones dug into " .. pokemon.name .. "!")
    
    return result
end

-- Process Spikes damage
-- @param battleState: Current battle state
-- @param pokemon: Pokemon being damaged
-- @param result: Result object to update
-- @param layers: Number of Spikes layers
-- @return: Updated result
function EntryHazards.processSpikes(battleState, pokemon, result, layers)
    local config = EntryHazards.HazardConfig[EntryHazards.HazardType.SPIKES]
    local damagePercent = config.damagePerLayer[layers] or config.damagePerLayer[3]
    
    local damage = math.max(1, math.floor(pokemon.maxHP * damagePercent))
    
    pokemon.currentHP = math.max(0, pokemon.currentHP - damage)
    result.damage = damage
    
    table.insert(result.messages, pokemon.name .. " was hurt by the spikes!")
    
    return result
end

-- Process Toxic Spikes status effect
-- @param battleState: Current battle state
-- @param pokemon: Pokemon being affected
-- @param result: Result object to update
-- @param layers: Number of Toxic Spikes layers
-- @param hazards: Hazard data for removal
-- @return: Updated result
function EntryHazards.processToxicSpikes(battleState, pokemon, result, layers, hazards)
    -- Check if Poison type absorbs Toxic Spikes
    if EntryHazards.isPoisonType(pokemon) then
        -- Remove one layer of Toxic Spikes
        hazards.toxicSpikes = math.max(0, hazards.toxicSpikes - 1)
        result.hazardRemoved = {type = EntryHazards.HazardType.TOXIC_SPIKES, layers = 1}
        table.insert(result.messages, pokemon.name .. " absorbed the Toxic Spikes!")
        return result
    end
    
    -- Apply poison status if not already statused
    if not pokemon.status then
        local poisonType = layers >= 2 and "badly_poison" or "poison"
        pokemon.status = poisonType
        
        -- Set badly poison counter for escalating damage
        if poisonType == "badly_poison" then
            pokemon.statusTurns = 1
        end
        
        result.statusChange = {
            status = poisonType,
            applied = true
        }
        
        local poisonMessage = poisonType == "badly_poison" and "badly poisoned" or "poisoned"
        table.insert(result.messages, pokemon.name .. " was " .. poisonMessage .. "!")
    end
    
    return result
end

-- Process Sticky Web speed reduction
-- @param battleState: Current battle state
-- @param pokemon: Pokemon being affected
-- @param result: Result object to update
-- @return: Updated result
function EntryHazards.processStickyWeb(battleState, pokemon, result)
    if not pokemon.battleData.statStages then
        pokemon.battleData.statStages = {
            atk = 0, def = 0, spa = 0, spd = 0, spe = 0, acc = 0, eva = 0
        }
    end
    
    -- Lower speed by 1 stage (minimum -6)
    local currentSpeed = pokemon.battleData.statStages.spe or 0
    local newSpeed = math.max(-6, currentSpeed - 1)
    pokemon.battleData.statStages.spe = newSpeed
    
    result.statChanges = {spe = -1}
    table.insert(result.messages, pokemon.name .. " was caught in a Sticky Web!")
    
    return result
end

-- Calculate Stealth Rock type effectiveness
-- @param pokemon: Pokemon to calculate effectiveness for
-- @return: Type effectiveness multiplier (0.25x to 4x)
function EntryHazards.calculateStealthRockEffectiveness(pokemon)
    local effectiveness = 1.0
    
    if not TypeChart or not Enums or not pokemon.species then
        return effectiveness
    end
    
    -- Get Pokemon's types
    local primaryType = pokemon.species.type1
    local secondaryType = pokemon.species.type2
    
    -- Calculate effectiveness against Rock-type moves
    if primaryType and TypeChart.getTypeDamageMultiplier then
        local primaryEff = TypeChart.getTypeDamageMultiplier(Enums.PokemonType.ROCK, primaryType)
        effectiveness = effectiveness * primaryEff
    end
    
    if secondaryType and TypeChart.getTypeDamageMultiplier then
        local secondaryEff = TypeChart.getTypeDamageMultiplier(Enums.PokemonType.ROCK, secondaryType)
        effectiveness = effectiveness * secondaryEff
    end
    
    return effectiveness
end

-- Check entry hazard immunity for a Pokemon
-- @param pokemon: Pokemon to check
-- @param hazardType: Type of hazard
-- @param config: Hazard configuration
-- @return: Immunity check result
function EntryHazards.checkHazardImmunity(pokemon, hazardType, config)
    local result = {immune = false, messages = {}}
    
    if not Enums then
        return result
    end
    
    -- Magic Guard ability prevents all entry hazard damage
    if pokemon.ability == Enums.AbilityId.MAGIC_GUARD then
        result.immune = true
        if hazardType ~= EntryHazards.HazardType.STICKY_WEB then
            table.insert(result.messages, pokemon.name .. "'s Magic Guard prevents damage!")
        end
        return result
    end
    
    -- Ground-based hazard immunity (only for hazards affected by Flying/Levitate)
    if config.affectedByFlying and EntryHazards.hasType(pokemon, Enums.PokemonType.FLYING) then
        result.immune = true
        return result
    end
    
    if config.affectedByLevitate and pokemon.ability == Enums.AbilityId.LEVITATE then
        result.immune = true
        return result
    end
    
    -- Air Balloon item immunity (affects same hazards as Levitate)
    if config.affectedByLevitate and pokemon.item == Enums.ItemId.AIR_BALLOON then
        result.immune = true
        table.insert(result.messages, pokemon.name .. " floats in the air with its Air Balloon!")
        return result
    end
    
    -- Toxic Spikes specific immunities
    if hazardType == EntryHazards.HazardType.TOXIC_SPIKES then
        -- Steel type immunity
        if EntryHazards.hasType(pokemon, Enums.PokemonType.STEEL) then
            result.immune = true
            return result
        end
    end
    
    return result
end

-- Remove entry hazards from specified side
-- @param battleState: Current battle state
-- @param side: Side to remove hazards from
-- @param hazardTypes: Array of hazard types to remove (optional, removes all if nil)
-- @return: Removal result
function EntryHazards.removeHazards(battleState, side, hazardTypes)
    if not battleState or not side then
        return {
            success = false,
            error = "Invalid parameters for hazard removal"
        }
    end
    
    local hazards = battleState.battleConditions and 
                   battleState.battleConditions.entryHazards and
                   battleState.battleConditions.entryHazards[side]
    
    if not hazards then
        return {
            success = true,
            removed = {},
            messages = {}
        }
    end
    
    local result = {
        success = true,
        removed = {},
        messages = {}
    }
    
    -- If no specific hazards specified, remove all
    if not hazardTypes then
        hazardTypes = {
            EntryHazards.HazardType.STEALTH_ROCK,
            EntryHazards.HazardType.SPIKES,
            EntryHazards.HazardType.TOXIC_SPIKES,
            EntryHazards.HazardType.STICKY_WEB
        }
    end
    
    for _, hazardType in ipairs(hazardTypes) do
        local removed = false
        
        if hazardType == EntryHazards.HazardType.STEALTH_ROCK and hazards.stealthRock then
            hazards.stealthRock = false
            removed = true
            
        elseif hazardType == EntryHazards.HazardType.SPIKES and (hazards.spikes or 0) > 0 then
            hazards.spikes = 0
            removed = true
            
        elseif hazardType == EntryHazards.HazardType.TOXIC_SPIKES and (hazards.toxicSpikes or 0) > 0 then
            hazards.toxicSpikes = 0
            removed = true
            
        elseif hazardType == EntryHazards.HazardType.STICKY_WEB and hazards.stickyWeb then
            hazards.stickyWeb = false
            removed = true
        end
        
        if removed then
            table.insert(result.removed, hazardType)
        end
    end
    
    -- Generate messages for removed hazards
    if #result.removed > 0 then
        table.insert(result.messages, "Entry hazards were removed from " .. side .. "'s side of the field!")
    end
    
    -- Record hazard removal in battle events
    if #result.removed > 0 then
        table.insert(battleState.battleEvents, {
            type = "hazards_removed",
            side = side,
            removed = result.removed,
            turn = battleState.turn,
            timestamp = os.time()
        })
    end
    
    return result
end

-- Check if a side has a specific hazard
-- @param hazards: Hazard data for a side
-- @param hazardType: Hazard type to check
-- @return: True if hazard exists
function EntryHazards.hasHazard(hazards, hazardType)
    if not hazards then
        return false
    end
    
    if hazardType == EntryHazards.HazardType.STEALTH_ROCK then
        return hazards.stealthRock == true
        
    elseif hazardType == EntryHazards.HazardType.SPIKES then
        return (hazards.spikes or 0) > 0
        
    elseif hazardType == EntryHazards.HazardType.TOXIC_SPIKES then
        return (hazards.toxicSpikes or 0) > 0
        
    elseif hazardType == EntryHazards.HazardType.STICKY_WEB then
        return hazards.stickyWeb == true
    end
    
    return false
end

-- Get hazard layer count
-- @param hazards: Hazard data for a side
-- @param hazardType: Hazard type to check
-- @return: Number of layers (0 if none)
function EntryHazards.getHazardLayers(hazards, hazardType)
    if not hazards then
        return 0
    end
    
    if hazardType == EntryHazards.HazardType.STEALTH_ROCK then
        return hazards.stealthRock and 1 or 0
        
    elseif hazardType == EntryHazards.HazardType.SPIKES then
        return hazards.spikes or 0
        
    elseif hazardType == EntryHazards.HazardType.TOXIC_SPIKES then
        return hazards.toxicSpikes or 0
        
    elseif hazardType == EntryHazards.HazardType.STICKY_WEB then
        return hazards.stickyWeb and 1 or 0
    end
    
    return 0
end

-- Helper functions for type and ability checks

-- Check if Pokemon has specific type
-- @param pokemon: Pokemon to check
-- @param typeId: Type ID to check for
-- @return: True if Pokemon has the type
function EntryHazards.hasType(pokemon, typeId)
    if not pokemon or not pokemon.species or not typeId then
        return false
    end
    
    return pokemon.species.type1 == typeId or pokemon.species.type2 == typeId
end

-- Check if Pokemon is Poison type
-- @param pokemon: Pokemon to check
-- @return: True if Pokemon is Poison type
function EntryHazards.isPoisonType(pokemon)
    if not Enums or not Enums.PokemonType then
        return false
    end
    return EntryHazards.hasType(pokemon, Enums.PokemonType.POISON)
end


-- ===== END MODULE: game-logic.battle.entry-hazards =====

    if moveData.effects and battleState then
        local hazardSet = false
        local hazardMessages = {}
        
        -- Determine target side (opposite side from attacker)
        local targetSide = "enemy"
        if attacker.battleData and attacker.battleData.side then
            targetSide = attacker.battleData.side == "player" and "enemy" or "player"
        end
        
        -- Stealth Rock
        if moveData.effects.stealth_rock then
            local hazardResult = EntryHazards.setHazard(battleState, EntryHazards.HazardType.STEALTH_ROCK, targetSide)
            if hazardResult.success and hazardResult.layersAdded > 0 then
                hazardSet = true
                for _, message in ipairs(hazardResult.messages) do
                    table.insert(hazardMessages, message)
                end
                table.insert(result.effects, {
                    type = "entry_hazard",
                    hazardType = "stealth_rock",
                    targetSide = targetSide,
                    layersAdded = hazardResult.layersAdded
                })
            else
                table.insert(hazardMessages, "But it failed!")
            end
        end
        
        -- Spikes
        if moveData.effects.spikes then
            local hazardResult = EntryHazards.setHazard(battleState, EntryHazards.HazardType.SPIKES, targetSide)
            if hazardResult.success and hazardResult.layersAdded > 0 then
                hazardSet = true
                for _, message in ipairs(hazardResult.messages) do
                    table.insert(hazardMessages, message)
                end
                table.insert(result.effects, {
                    type = "entry_hazard",
                    hazardType = "spikes",
                    targetSide = targetSide,
                    layersAdded = hazardResult.layersAdded
                })
            else
                table.insert(hazardMessages, "But it failed!")
            end
        end
        
        -- Toxic Spikes
        if moveData.effects.toxic_spikes then
            local hazardResult = EntryHazards.setHazard(battleState, EntryHazards.HazardType.TOXIC_SPIKES, targetSide)
            if hazardResult.success and hazardResult.layersAdded > 0 then
                hazardSet = true
                for _, message in ipairs(hazardResult.messages) do
                    table.insert(hazardMessages, message)
                end
                table.insert(result.effects, {
                    type = "entry_hazard",
                    hazardType = "toxic_spikes",
                    targetSide = targetSide,
                    layersAdded = hazardResult.layersAdded
                })
            else
                table.insert(hazardMessages, "But it failed!")
            end
        end
        
        -- Sticky Web
        if moveData.effects.sticky_web then
            local hazardResult = EntryHazards.setHazard(battleState, EntryHazards.HazardType.STICKY_WEB, targetSide)
            if hazardResult.success and hazardResult.layersAdded > 0 then
                hazardSet = true
                for _, message in ipairs(hazardResult.messages) do
                    table.insert(hazardMessages, message)
                end
                table.insert(result.effects, {
                    type = "entry_hazard",
                    hazardType = "sticky_web",
                    targetSide = targetSide,
                    layersAdded = hazardResult.layersAdded
                })
            else
                table.insert(hazardMessages, "But it failed!")
            end
        end
        
        -- Add hazard messages to result
        if hazardSet and #hazardMessages > 0 then
            for _, message in ipairs(hazardMessages) do
                table.insert(result.messages, message)
            end
        end
        
        -- Handle hazard removal effects
        local hazardRemoved = false
        local removalMessages = {}
        
        -- Rapid Spin - removes hazards from user's side
        if moveData.effects.rapid_spin then
            local userSide = "player"
            if attacker.battleData and attacker.battleData.side then
                userSide = attacker.battleData.side
            end
            
            local removalResult = EntryHazards.removeHazards(battleState, userSide)
            if removalResult.success and #removalResult.removed > 0 then
                hazardRemoved = true
                for _, message in ipairs(removalResult.messages) do
                    table.insert(removalMessages, message)
                end
                table.insert(result.effects, {
                    type = "hazard_removal",
                    removalType = "rapid_spin",
                    targetSide = userSide,
                    hazardsRemoved = removalResult.removed
                })
            end
        end
        
        -- Defog - removes hazards from both sides (like in battle-conditions.lua Story 5.4)
        if moveData.effects.defog then
            -- Remove from both sides
            local userSide = "player"
            if attacker.battleData and attacker.battleData.side then
                userSide = attacker.battleData.side
            end
            local opponentSide = userSide == "player" and "enemy" or "player"
            
            local userRemoval = EntryHazards.removeHazards(battleState, userSide)
            local opponentRemoval = EntryHazards.removeHazards(battleState, opponentSide)
            
            local totalRemoved = {}
            if userRemoval.success then
                for _, hazard in ipairs(userRemoval.removed) do
                    table.insert(totalRemoved, hazard)
                end
            end
            if opponentRemoval.success then
                for _, hazard in ipairs(opponentRemoval.removed) do
                    table.insert(totalRemoved, hazard)
                end
            end
            
            if #totalRemoved > 0 then
                hazardRemoved = true
                table.insert(removalMessages, "The wind cleared away entry hazards!")
                table.insert(result.effects, {
                    type = "hazard_removal",
                    removalType = "defog",
                    hazardsRemoved = totalRemoved
                })
            end
        end
        
        -- Add removal messages to result
        if hazardRemoved and #removalMessages > 0 then
            for _, message in ipairs(removalMessages) do
                table.insert(result.messages, message)
            end
        end
    end
    
    return result
end

-- Compatibility function for test suite - alias for executeMove
function MoveEffects.processMovEffects(moveData, attacker, targets, battleState)
    if not moveData or not attacker or not targets then
        return {
            success = false,
            statusEffects = {},
            messages = {"Invalid parameters for processMovEffects"}
        }
    end

    local target = targets[1] -- Use first target
    local result = MoveEffects.executeMove(battleState, attacker, moveData, target)

    -- Convert to expected format for test compatibility
    local compatResult = {
        success = result.success,
        statusEffects = result.status_effects or {},
        effects = result.effects or {},
        weatherChanged = result.weatherChanged or false,
        terrainChanged = result.terrainChanged or false,
        messages = result.messages or {}
    }
    
    -- Extract stat changes for backward compatibility
    compatResult.statChanges = {}
    if result.effects then
        for _, effect in ipairs(result.effects) do
            if effect.type == "stat_change" then
                table.insert(compatResult.statChanges, {
                    stat = effect.stat,
                    stages = effect.change,
                    target = effect.target
                })
            end
        end
    end
    
    return compatResult
end

-- Compatibility function for test suite - calculate multi-hit count
function MoveEffects.calculateMultiHitCount(moveData)
    if not moveData or not moveData.effects or not moveData.effects.multi_hit then
        return 1
    end

    local hitType = moveData.effects.multi_hit
    if type(hitType) == "table" then
        -- Handle {2, 5} format
        local min = hitType[1] or 2
        local max = hitType[2] or 5

        -- Use distribution: 35%, 35%, 15%, 15% for 2, 3, 4, 5 hits
        local rand = BattleRNG.randomInt(1, 100)
        if rand <= 35 then
            return min
        elseif rand <= 70 then
            return min + 1
        elseif rand <= 85 then
            return max - 1
        else
            return max
        end
    elseif type(hitType) == "number" then
        return hitType
    elseif hitType == true then
        -- Default multi-hit is 2-5
        local rand = BattleRNG.randomInt(1, 100)
        if rand <= 35 then
            return 2
        elseif rand <= 70 then
            return 3
        elseif rand <= 85 then
            return 4
        else
            return 5
        end
    end

    return 1
end

-- Field Condition Move Processing Functions
-- Added to complete field condition system integration

-- Check if field condition move should fail
-- @param battleState: Current battle state
-- @param fieldConditionType: Type of field condition to check
-- @return: Boolean indicating if move should fail, reason if applicable
function MoveEffects.shouldFieldConditionMoveFail(battleState, fieldConditionType)
    if not battleState or not fieldConditionType then
        return true, "Invalid parameters for field condition check"
    end
    
    -- Load field conditions module

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")

-- Field Conditions System
-- Implements global field conditions that alter battle mechanics
-- Includes Trick Room, Wonder Room, Magic Room with proper duration tracking and interactions

local FieldConditions = {}

-- Load dependencies

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Field condition types (matching battle-conditions.lua)
FieldConditions.FieldEffectType = {
    NONE = 0,
    TRICK_ROOM = 1,
    WONDER_ROOM = 2,
    MAGIC_ROOM = 3,
    GRAVITY = 4
}

-- Field condition data with effects and interactions
FieldConditions.FieldEffectData = {
    [FieldConditions.FieldEffectType.TRICK_ROOM] = {
        name = "Trick Room",
        default_duration = 5,
        priority_reversal = true,
        affects_speed_order = true,
        global_effect = true,
        description = "Slower Pokemon move first"
    },
    [FieldConditions.FieldEffectType.WONDER_ROOM] = {
        name = "Wonder Room", 
        default_duration = 5,
        stat_swap = {defense = "special_defense", special_defense = "defense"},
        affects_stats = true,
        global_effect = true,
        description = "Defense and Special Defense stats are swapped"
    },
    [FieldConditions.FieldEffectType.MAGIC_ROOM] = {
        name = "Magic Room",
        default_duration = 5,
        suppresses_items = true,
        global_effect = true,
        description = "Held items have no effect"
    },
    [FieldConditions.FieldEffectType.GRAVITY] = {
        name = "Gravity",
        default_duration = 5,
        grounds_pokemon = true,
        move_restrictions = {"fly", "bounce", "sky_drop", "magnet_rise", "telekinesis"},
        global_effect = true,
        description = "All Pokemon are grounded and certain moves fail"
    }
}

-- Set field condition
-- @param battleId: Battle instance identifier
-- @param fieldEffectType: Field effect type to set
-- @param duration: Duration override (nil for default)
-- @param source: Source of field effect change (move, ability, etc.)
-- @param sourcePokemon: Pokemon that triggered the field effect
-- @return: Boolean indicating success and field effect details
function FieldConditions.setFieldEffect(battleId, fieldEffectType, duration, source, sourcePokemon)
    if not battleId or not fieldEffectType then
        return false, "Invalid parameters for field effect change"
    end
    
    local fieldData = FieldConditions.FieldEffectData[fieldEffectType]
    if not fieldData and fieldEffectType ~= FieldConditions.FieldEffectType.NONE then
        return false, "Unknown field effect type: " .. tostring(fieldEffectType)
    end
    
    local actualDuration = duration
    if not actualDuration and fieldData then
        actualDuration = fieldData.default_duration
    end
    
    local result = {
        success = true,
        field_effect_type = fieldEffectType,
        field_effect_name = fieldData and fieldData.name or "None",
        duration = actualDuration or 0,
        source = source,
        source_pokemon = sourcePokemon,
        timestamp = os.time(),
        global_effect = fieldData and fieldData.global_effect or false
    }
    
    -- Add effect-specific data
    if fieldData then
        if fieldData.priority_reversal then
            result.priority_reversal = true
        end
        if fieldData.stat_swap then
            result.stat_swap = fieldData.stat_swap
        end
        if fieldData.suppresses_items then
            result.suppresses_items = true
        end
        if fieldData.grounds_pokemon then
            result.grounds_pokemon = true
        end
        if fieldData.move_restrictions then
            result.move_restrictions = fieldData.move_restrictions
        end
    end
    
    print("Field effect changed to " .. result.field_effect_name .. " for " .. (actualDuration or "unlimited") .. " turns")
    return true, result
end

-- Process Trick Room speed reversal
-- @param battleId: Battle instance identifier
-- @param pokemonActions: List of Pokemon actions with priorities
-- @param fieldConditions: Current field conditions
-- @return: Modified actions with reversed speed priority
function FieldConditions.processTrickRoomPriority(battleId, pokemonActions, fieldConditions)
    if not fieldConditions or not fieldConditions.trick_room or fieldConditions.trick_room <= 0 then
        return pokemonActions
    end
    
    -- Apply Trick Room speed reversal to actions with same move priority
    local modifiedActions = {}
    
    for _, action in ipairs(pokemonActions) do
        local modifiedAction = {}
        for k, v in pairs(action) do
            modifiedAction[k] = v
        end
        
        -- Mark action as affected by Trick Room for priority calculator
        modifiedAction.trick_room_active = true
        modifiedAction.original_speed = action.effectiveSpeed or 0
        
        table.insert(modifiedActions, modifiedAction)
    end
    
    return modifiedActions
end

-- Process Wonder Room stat swapping
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to apply stat swaps
-- @param fieldConditions: Current field conditions
-- @return: Pokemon list with swapped stats
function FieldConditions.processWonderRoomStats(battleId, pokemonList, fieldConditions)
    if not fieldConditions or not fieldConditions.wonder_room or fieldConditions.wonder_room <= 0 then
        return pokemonList
    end
    
    local modifiedPokemonList = {}
    
    for _, pokemon in ipairs(pokemonList) do
        local modifiedPokemon = {}
        for k, v in pairs(pokemon) do
            modifiedPokemon[k] = v
        end
        
        -- Swap Defense and Special Defense stats
        if pokemon.stats then
            local originalDef = pokemon.stats.defense or pokemon.stats.def or 0
            local originalSpDef = pokemon.stats.special_defense or pokemon.stats.spdef or 0
            
            -- Create modified stats table
            modifiedPokemon.stats = {}
            for statKey, statValue in pairs(pokemon.stats) do
                modifiedPokemon.stats[statKey] = statValue
            end
            
            -- Perform the swap
            modifiedPokemon.stats.defense = originalSpDef
            modifiedPokemon.stats.special_defense = originalDef
            modifiedPokemon.stats.def = originalSpDef
            modifiedPokemon.stats.spdef = originalDef
            
            -- Mark as Wonder Room affected
            modifiedPokemon.wonder_room_active = true
        end
        
        table.insert(modifiedPokemonList, modifiedPokemon)
    end
    
    return modifiedPokemonList
end

-- Process Magic Room item suppression
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to suppress items
-- @param fieldConditions: Current field conditions
-- @return: Pokemon list with suppressed items
function FieldConditions.processMagicRoomItems(battleId, pokemonList, fieldConditions)
    if not fieldConditions or not fieldConditions.magic_room or fieldConditions.magic_room <= 0 then
        return pokemonList
    end
    
    local modifiedPokemonList = {}
    
    for _, pokemon in ipairs(pokemonList) do
        local modifiedPokemon = {}
        for k, v in pairs(pokemon) do
            modifiedPokemon[k] = v
        end
        
        -- Suppress held item effects
        if pokemon.heldItem then
            modifiedPokemon.held_item_suppressed = true
            modifiedPokemon.original_held_item = pokemon.heldItem
            modifiedPokemon.magic_room_active = true
            -- Item is still held but effects are suppressed
        end
        
        table.insert(modifiedPokemonList, modifiedPokemon)
    end
    
    return modifiedPokemonList
end

-- Check if field condition affects move usage
-- @param moveId: Move identifier
-- @param moveName: Move name (for restriction checking)
-- @param fieldConditions: Current field conditions
-- @param pokemon: Pokemon using the move
-- @return: Boolean indicating if move is blocked, reason string
function FieldConditions.doesFieldConditionBlockMove(moveId, moveName, fieldConditions, pokemon)
    if not fieldConditions then
        return false, nil
    end
    
    -- Check Gravity restrictions
    if fieldConditions.gravity and fieldConditions.gravity > 0 then
        local fieldData = FieldConditions.FieldEffectData[FieldConditions.FieldEffectType.GRAVITY]
        if fieldData and fieldData.move_restrictions then
            local lowerMoveName = string.lower(moveName or "")
            for _, restrictedMove in ipairs(fieldData.move_restrictions) do
                if lowerMoveName == restrictedMove then
                    return true, "Move blocked by Gravity"
                end
            end
        end
    end
    
    return false, nil
end

-- Update field condition duration
-- @param fieldConditionType: Type of field condition
-- @param currentDuration: Current duration (-1 for permanent)
-- @return: New duration, boolean indicating if condition should end
function FieldConditions.updateFieldConditionDuration(fieldConditionType, currentDuration)
    if currentDuration == -1 then
        return -1, false -- Permanent conditions don't expire
    end
    
    if currentDuration <= 1 then
        return 0, true -- Condition expires
    end
    
    return currentDuration - 1, false
end

-- Process field condition coexistence and interactions
-- @param currentFieldConditions: Currently active field conditions
-- @param newFieldCondition: New field condition to add
-- @return: Updated field conditions with interaction resolution
function FieldConditions.processFieldConditionInteractions(currentFieldConditions, newFieldCondition)
    if not currentFieldConditions then
        currentFieldConditions = {}
    end
    
    local interactions = {
        conflicts = {},
        coexistence = {},
        replacement = {}
    }
    
    -- Field conditions generally coexist unless they directly conflict
    -- Trick Room, Wonder Room, and Magic Room can all be active simultaneously
    
    -- Check for direct conflicts (same field condition type)
    if newFieldCondition and newFieldCondition.field_effect_type then
        local newType = newFieldCondition.field_effect_type
        
        -- Replace existing condition of same type
        if currentFieldConditions[newType] then
            table.insert(interactions.replacement, {
                type = newType,
                previous = currentFieldConditions[newType],
                new = newFieldCondition,
                reason = "Same field condition type replaces previous"
            })
        else
            table.insert(interactions.coexistence, {
                type = newType,
                new = newFieldCondition,
                reason = "Field condition coexists with existing conditions"
            })
        end
        
        -- Update field conditions
        currentFieldConditions[newType] = newFieldCondition
    end
    
    return currentFieldConditions, interactions
end

-- Get field condition move power modifier
-- @param moveType: Type of the move
-- @param moveData: Move data including name and properties
-- @param fieldConditions: Current field conditions
-- @param pokemon: Pokemon using the move
-- @return: Power multiplier (1.0 = no change)
function FieldConditions.getFieldConditionMovePowerModifier(moveType, moveData, fieldConditions, pokemon)
    -- Field conditions don't directly modify move power
    -- They affect priority, stats, and item usage instead
    return 1.0
end

-- Check if Pokemon's held item is suppressed by field conditions
-- @param pokemon: Pokemon to check
-- @param fieldConditions: Current field conditions
-- @return: Boolean indicating if item is suppressed
function FieldConditions.isHeldItemSuppressed(pokemon, fieldConditions)
    if not pokemon or not fieldConditions then
        return false
    end
    
    -- Magic Room suppresses all held item effects
    if fieldConditions.magic_room and fieldConditions.magic_room > 0 then
        return true
    end
    
    return false
end

-- Apply field condition effects to Pokemon stats during battle calculations
-- @param pokemon: Pokemon to modify
-- @param fieldConditions: Current field conditions
-- @param statCalculationType: Type of stat calculation ("damage", "priority", etc.)
-- @return: Modified Pokemon stats
function FieldConditions.applyFieldConditionStatModifications(pokemon, fieldConditions, statCalculationType)
    if not pokemon or not fieldConditions then
        return pokemon
    end
    
    local modifiedPokemon = {}
    for k, v in pairs(pokemon) do
        modifiedPokemon[k] = v
    end
    
    -- Apply Wonder Room stat swapping for damage calculations
    if fieldConditions.wonder_room and fieldConditions.wonder_room > 0 and 
       (statCalculationType == "damage" or statCalculationType == "all") then
        
        if pokemon.stats then
            modifiedPokemon.stats = {}
            for k, v in pairs(pokemon.stats) do
                modifiedPokemon.stats[k] = v
            end
            
            -- Swap Defense and Special Defense
            local originalDef = pokemon.stats.defense or pokemon.stats.def or 0
            local originalSpDef = pokemon.stats.special_defense or pokemon.stats.spdef or 0
            
            modifiedPokemon.stats.defense = originalSpDef
            modifiedPokemon.stats.special_defense = originalDef
            modifiedPokemon.stats.def = originalSpDef
            modifiedPokemon.stats.spdef = originalDef
        end
    end
    
    return modifiedPokemon
end

-- Remove field condition effects
-- @param fieldConditions: Current field conditions
-- @param conditionTypeToRemove: Specific condition type to remove (nil for all)
-- @param removalSource: Source of removal (move, ability, etc.)
-- @return: Updated field conditions and removal results
function FieldConditions.removeFieldConditions(fieldConditions, conditionTypeToRemove, removalSource)
    if not fieldConditions then
        return {}, {removed = {}, failed = {}}
    end
    
    local results = {
        removed = {},
        failed = {},
        remaining = {}
    }
    
    local updatedConditions = {}
    
    -- Remove specific condition type or all conditions
    for conditionType, conditionData in pairs(fieldConditions) do
        local shouldRemove = false
        
        if conditionTypeToRemove then
            -- Remove specific condition type
            if conditionType == conditionTypeToRemove then
                shouldRemove = true
            end
        else
            -- Remove all removable conditions
            shouldRemove = true
        end
        
        if shouldRemove then
            table.insert(results.removed, {
                type = conditionType,
                name = conditionData.field_effect_name or "Unknown",
                duration_remaining = conditionData.duration or 0,
                removal_source = removalSource
            })
        else
            updatedConditions[conditionType] = conditionData
            table.insert(results.remaining, {
                type = conditionType,
                name = conditionData.field_effect_name or "Unknown"
            })
        end
    end
    
    return updatedConditions, results
end

-- Get active field condition summary
-- @param fieldConditions: Current field conditions
-- @return: Summary of active field conditions
function FieldConditions.getActiveFieldConditionSummary(fieldConditions)
    if not fieldConditions then
        return {
            active_count = 0,
            conditions = {},
            global_effects = {}
        }
    end
    
    local summary = {
        active_count = 0,
        conditions = {},
        global_effects = {
            priority_reversal = false,
            stat_swapping = false,
            item_suppression = false,
            grounding_effect = false
        }
    }
    
    for conditionType, conditionData in pairs(fieldConditions) do
        if conditionData.duration and conditionData.duration > 0 then
            summary.active_count = summary.active_count + 1
            
            table.insert(summary.conditions, {
                type = conditionType,
                name = conditionData.field_effect_name,
                duration = conditionData.duration,
                source = conditionData.source
            })
            
            -- Track global effects
            if conditionData.priority_reversal then
                summary.global_effects.priority_reversal = true
            end
            if conditionData.stat_swap then
                summary.global_effects.stat_swapping = true
            end
            if conditionData.suppresses_items then
                summary.global_effects.item_suppression = true
            end
            if conditionData.grounds_pokemon then
                summary.global_effects.grounding_effect = true
            end
        end
    end
    
    return summary
end

-- Process field condition notifications for battle messages
-- @param fieldConditionChanges: List of field condition changes
-- @param timing: When notifications should be shown
-- @return: Formatted notifications
function FieldConditions.generateFieldConditionNotifications(fieldConditionChanges, timing)
    local notifications = {
        timing = timing or "immediate",
        messages = {},
        condition_count = 0
    }
    
    if not fieldConditionChanges or #fieldConditionChanges == 0 then
        return notifications
    end
    
    for _, change in ipairs(fieldConditionChanges) do
        local message = ""
        
        if change.type == "activation" then
            local effectData = FieldConditions.FieldEffectData[change.field_effect_type]
            if effectData then
                message = effectData.name .. " was activated! " .. effectData.description
            else
                message = "A field condition was activated!"
            end
        elseif change.type == "expiration" then
            message = (change.field_effect_name or "Field condition") .. " wore off!"
        elseif change.type == "removal" then
            message = (change.field_effect_name or "Field condition") .. " was removed!"
        elseif change.type == "replacement" then
            message = (change.field_effect_name or "Field condition") .. " replaced the previous condition!"
        end
        
        if message ~= "" then
            table.insert(notifications.messages, {
                text = message,
                type = change.type,
                field_effect_type = change.field_effect_type,
                priority = "high"
            })
            notifications.condition_count = notifications.condition_count + 1
        end
    end
    
    return notifications
end

-- Check field condition ability interactions
-- @param pokemon: Pokemon with ability
-- @param fieldConditions: Current field conditions
-- @param abilityId: Ability identifier
-- @return: Interaction results
function FieldConditions.checkAbilityFieldConditionInteractions(pokemon, fieldConditions, abilityId)
    local interactions = {
        blocked_conditions = {},
        enhanced_conditions = {},
        ability_effects = {}
    }
    
    if not pokemon or not abilityId or not fieldConditions then
        return interactions
    end
    
    -- Some abilities may interact with field conditions
    -- For now, most field conditions are not blocked by abilities
    -- Future expansion could include abilities that interact with specific field conditions
    
    return interactions
end


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    -- Check if field condition is already active
    if battleState.fieldConditions and battleState.fieldConditions[fieldConditionType] then
        local conditionData = battleState.fieldConditions[fieldConditionType]
        if conditionData.duration and conditionData.duration > 0 then
            local fieldData = FieldConditions.FieldEffectData[fieldConditionType]
            local conditionName = fieldData and fieldData.name or "Field condition"
            return true, conditionName .. " is already active!"
        end
    end
    
    return false, nil
end

-- Process field condition move effect
-- @param battleState: Current battle state
-- @param moveData: Move data including field condition type
-- @param attacker: Pokemon using the move
-- @return: Boolean indicating success and field condition result
function MoveEffects.processFieldConditionMove(battleState, moveData, attacker)
    if not battleState or not moveData or not attacker then
        return false, "Invalid parameters for field condition move"
    end
    
    local fieldConditionType = moveData.effects and moveData.effects.field_condition
    if not fieldConditionType then
        return false, "No field condition type specified in move"
    end
    
    -- Load field conditions module

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    -- Set the field condition
    local success, result = FieldConditions.setFieldEffect(
        battleState.battleId,
        fieldConditionType,
        5, -- Default duration
        "move",
        attacker.id or attacker.name
    )
    
    if not success then
        return false, result -- Error message
    end
    
    -- Initialize field conditions table if needed
    if not battleState.fieldConditions then
        battleState.fieldConditions = {}
    end
    
    -- Store field condition in battle state
    battleState.fieldConditions[fieldConditionType] = result
    
    -- Set compatibility fields for existing systems
    if fieldConditionType == FieldConditions.FieldEffectType.TRICK_ROOM then
        battleState.trickRoom = result.duration
    elseif fieldConditionType == FieldConditions.FieldEffectType.WONDER_ROOM then
        battleState.wonderRoom = result.duration
    elseif fieldConditionType == FieldConditions.FieldEffectType.MAGIC_ROOM then
        battleState.magicRoom = result.duration
    end
    
    -- Prepare result for move execution
    result.message = result.field_effect_name .. " was activated!"
    result.description = FieldConditions.FieldEffectData[fieldConditionType] and 
                        FieldConditions.FieldEffectData[fieldConditionType].description
    
    return true, result
end

-- Process Trick Room effect for move integration
-- @param battleState: Current battle state
-- @param pokemon: Pokemon using Trick Room
-- @return: Boolean indicating success and effect result
function MoveEffects.processTrickRoomEffect(battleState, pokemon)

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    local trickRoomMoveData = {
        effects = {
            field_condition = FieldConditions.FieldEffectType.TRICK_ROOM
        }
    }
    
    return MoveEffects.processFieldConditionMove(battleState, trickRoomMoveData, pokemon)
end

-- Process Wonder Room effect for move integration
-- @param battleState: Current battle state
-- @param pokemon: Pokemon using Wonder Room
-- @return: Boolean indicating success and effect result
function MoveEffects.processWonderRoomEffect(battleState, pokemon)

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    local wonderRoomMoveData = {
        effects = {
            field_condition = FieldConditions.FieldEffectType.WONDER_ROOM
        }
    }
    
    return MoveEffects.processFieldConditionMove(battleState, wonderRoomMoveData, pokemon)
end

-- Process Magic Room effect for move integration  
-- @param battleState: Current battle state
-- @param pokemon: Pokemon using Magic Room
-- @return: Boolean indicating success and effect result
function MoveEffects.processMagicRoomEffect(battleState, pokemon)

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    local magicRoomMoveData = {
        effects = {
            field_condition = FieldConditions.FieldEffectType.MAGIC_ROOM
        }
    }
    
    return MoveEffects.processFieldConditionMove(battleState, magicRoomMoveData, pokemon)
end

-- Process side effect moves (Light Screen, Reflect, Aurora Veil, Safeguard, Mist)
-- @param battleState: Current battle state
-- @param moveData: Move data containing side effect information
-- @param pokemon: Pokemon using the move
-- @return: Boolean indicating success and effect result
function MoveEffects.processSideEffectMove(battleState, moveData, pokemon)

-- ===== MODULE: game-logic.battle.side-effects =====
-- File: ao-processes/game-logic/battle/side-effects.lua
-- Original require:     local SideEffects = require("game-logic.battle.side-effects")


-- ===== END MODULE: game-logic.battle.side-effects =====

    
    if not battleState or not moveData or not pokemon then
        return false, "Missing required parameters for side effect move"
    end
    
    -- Determine which side the Pokemon belongs to
    local side = pokemon.side or "player"  -- Default to player if not specified
    
    local success = false
    local effectName = ""
    
    -- Process Light Screen
    if moveData.effects and moveData.effects.light_screen then
        success = SideEffects.setLightScreen(battleState, side)
        effectName = "Light Screen"
    end
    
    -- Process Reflect
    if moveData.effects and moveData.effects.reflect then
        success = SideEffects.setReflect(battleState, side)
        effectName = "Reflect"
    end
    
    -- Process Aurora Veil (requires hail/snow weather)
    if moveData.effects and moveData.effects.aurora_veil then
        local success_result, message = SideEffects.setAuroraVeil(battleState, side)
        success = success_result
        effectName = "Aurora Veil"
        if not success and message then
            return false, message
        end
    end
    
    -- Process Safeguard
    if moveData.effects and moveData.effects.safeguard then
        success = SideEffects.setSafeguard(battleState, side)
        effectName = "Safeguard"
    end
    
    -- Process Mist
    if moveData.effects and moveData.effects.mist then
        success = SideEffects.setMist(battleState, side)
        effectName = "Mist"
    end
    
    if success then
        return true, string.format("%s activated for %s's team!", effectName, side)
    else
        return false, string.format("Failed to activate %s", effectName)
    end
end

-- Process screen-breaking moves (Brick Break, Psychic Fangs)
-- @param battleState: Current battle state
-- @param moveData: Move data containing screen removal information
-- @param pokemon: Pokemon using the move
-- @param targetSide: Side to remove screens from
-- @return: Boolean indicating success and removed effects
function MoveEffects.processScreenBreakingMove(battleState, moveData, pokemon, targetSide)

-- ===== MODULE: game-logic.battle.side-effects =====
-- File: ao-processes/game-logic/battle/side-effects.lua
-- Original require:     local SideEffects = require("game-logic.battle.side-effects")


-- ===== END MODULE: game-logic.battle.side-effects =====

    
    if not battleState or not moveData or not pokemon or not targetSide then
        return false, "Missing required parameters for screen breaking move"
    end
    
    -- Check if move breaks screens
    if not moveData.effects or not moveData.effects.remove_screens then
        return false, "Move does not break screens"
    end
    
    -- Determine if move removes Aurora Veil (Psychic Fangs only)
    local removeAuroraVeil = (moveData.id == 1414)  -- Psychic Fangs ID
    
    local removedEffects = SideEffects.removeScreens(battleState, targetSide, removeAuroraVeil)
    
    if #removedEffects > 0 then
        local effectNames = {}
        for _, effectType in ipairs(removedEffects) do
            table.insert(effectNames, SideEffects.getEffectName(effectType))
        end
        
        return true, string.format("Removed %s from %s's team!", table.concat(effectNames, ", "), targetSide)
    else
        return false, "No screens to remove"
    end
end

-- Check if move has side effect components
-- @param moveData: Move data to check
-- @return: Boolean indicating if move has side effects
function MoveEffects.hasSideEffects(moveData)
    if not moveData or not moveData.effects then
        return false
    end
    
    return moveData.effects.light_screen or 
           moveData.effects.reflect or 
           moveData.effects.aurora_veil or 
           moveData.effects.safeguard or 
           moveData.effects.mist or
           moveData.effects.remove_screens
end

-- Position Swapping Move Effects
-- Handles Ally Switch and other position-changing moves

-- Execute Ally Switch move effect
-- @param battleState: Current battle state
-- @param user: Pokemon using Ally Switch
-- @param moveData: Move data for Ally Switch
-- @return: Result of position swap
function MoveEffects.executeAllySwitch(battleState, user, moveData)
    if not battleState or not user then
        return {
            success = false,
            message = "Missing required parameters",
            effect_applied = false
        }
    end
    
    -- Check if this is a double battle format
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    if formatInfo.format ~= PositionalMechanics.BattleFormat.DOUBLE then
        return {
            success = false,
            message = "Ally Switch can only be used in double battles",
            effect_applied = false
        }
    end
    
    -- Find ally to switch with
    local adjacentAllies = PositionalMechanics.getAdjacentAllies(battleState, user)
    if #adjacentAllies == 0 then
        return {
            success = false,
            message = "No ally available to switch positions with",
            effect_applied = false
        }
    end
    
    -- Get the ally (should only be one in doubles)
    local ally = adjacentAllies[1]
    
    -- Perform position swap
    local swapSuccess, swapMessage = PositionalMechanics.swapPokemonPositions(battleState, user, ally)
    
    if swapSuccess then
        return {
            success = true,
            message = string.format("%s switched positions with %s!", 
                user.name or "User Pokemon", ally.name or "Ally Pokemon"),
            effect_applied = true,
            swap_details = {
                user_id = user.id,
                ally_id = ally.id,
                user_new_position = user.battleData.position,
                ally_new_position = ally.battleData.position
            }
        }
    else
        return {
            success = false,
            message = "Position swap failed: " .. swapMessage,
            effect_applied = false
        }
    end
end

-- Check if move is a position-swapping move
-- @param moveData: Move data to check
-- @return: Boolean indicating if move swaps positions
function MoveEffects.isPositionSwappingMove(moveData)
    if not moveData then
        return false
    end
    
    -- Check by move ID (Ally Switch is move ID 502 in most Pokemon games)
    if moveData.id == 502 or moveData.name == "Ally Switch" then
        return true
    end
    
    -- Check by move effect flag
    if moveData.effects and moveData.effects.ally_switch then
        return true
    end
    
    -- Check by move category or special flags
    if moveData.isPositionSwapMove or moveData.swapsPositions then
        return true
    end
    
    return false
end

-- Apply position-dependent move effects
-- @param battleState: Current battle state
-- @param user: Pokemon using the move
-- @param targets: Array of target Pokemon
-- @param moveData: Move data
-- @return: Result of position-dependent effect
function MoveEffects.applyPositionDependentEffects(battleState, user, targets, moveData)
    if not battleState or not user or not moveData then
        return {
            success = false,
            message = "Missing required parameters",
            effects_applied = {}
        }
    end
    
    local results = {
        success = true,
        message = "Position-dependent effects processed",
        effects_applied = {}
    }
    
    -- Handle Ally Switch
    if MoveEffects.isPositionSwappingMove(moveData) then
        local allySwapResult = MoveEffects.executeAllySwitch(battleState, user, moveData)
        table.insert(results.effects_applied, {
            effect_type = "position_swap",
            result = allySwapResult
        })
        
        if not allySwapResult.success then
            results.success = false
            results.message = allySwapResult.message
        end
    end
    
    -- Handle other position-dependent moves
    if moveData.effects then
        -- Position-based targeting effects
        if moveData.effects.position_targeting then
            local targetingResult = MoveEffects.processPositionTargeting(battleState, user, targets, moveData)
            table.insert(results.effects_applied, {
                effect_type = "position_targeting",
                result = targetingResult
            })
        end
        
        -- Position-based power modifications
        if moveData.effects.position_power_modifier then
            local powerResult = MoveEffects.processPositionPowerModifier(battleState, user, targets, moveData)
            table.insert(results.effects_applied, {
                effect_type = "position_power",
                result = powerResult
            })
        end
    end
    
    return results
end

-- Process position-based targeting for moves
-- @param battleState: Current battle state
-- @param user: Pokemon using the move
-- @param targets: Array of target Pokemon
-- @param moveData: Move data
-- @return: Targeting processing result
function MoveEffects.processPositionTargeting(battleState, user, targets, moveData)
    -- This handles special position-based targeting mechanics
    -- For moves that target specific positions rather than specific Pokemon
    
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    
    if formatInfo.format ~= PositionalMechanics.BattleFormat.DOUBLE then
        return {
            success = false,
            message = "Position-based targeting requires double battle format"
        }
    end
    
    -- Process targeting based on position rules
    local processedTargets = {}
    
    for _, target in ipairs(targets) do
        local targetPosition = target.battleData and target.battleData.position
        
        if targetPosition then
            table.insert(processedTargets, {
                pokemon_id = target.id,
                position = targetPosition,
                targeting_valid = true
            })
        end
    end
    
    return {
        success = true,
        message = "Position targeting processed successfully",
        processed_targets = processedTargets
    }
end

-- Process position-based power modifiers
-- @param battleState: Current battle state
-- @param user: Pokemon using the move
-- @param targets: Array of target Pokemon
-- @param moveData: Move data
-- @return: Power modifier processing result
function MoveEffects.processPositionPowerModifier(battleState, user, targets, moveData)
    -- Handle moves that have different power based on position
    -- For example, some moves hit harder when targeting certain positions
    
    local modifiers = {}
    
    for _, target in ipairs(targets) do
        local targetPosition = target.battleData and target.battleData.position
        local userPosition = user.battleData and user.battleData.position
        
        local powerModifier = 1.0
        
        -- Apply position-based power modifications
        if moveData.effects.position_power_modifier then
            local modifierData = moveData.effects.position_power_modifier
            
            if modifierData.same_side_bonus and userPosition == targetPosition then
                powerModifier = powerModifier * (modifierData.same_side_bonus or 1.2)
            end
            
            if modifierData.opposite_side_bonus and userPosition ~= targetPosition then
                powerModifier = powerModifier * (modifierData.opposite_side_bonus or 1.2)
            end
        end
        
        table.insert(modifiers, {
            target_id = target.id,
            position = targetPosition,
            power_modifier = powerModifier
        })
    end
    
    return {
        success = true,
        message = "Position power modifiers calculated",
        modifiers = modifiers
    }
end

-- Get position swap priority
-- Position-swapping moves typically have high priority in doubles battles
-- @param moveData: Move data
-- @return: Priority value for position swapping moves
function MoveEffects.getPositionSwapPriority(moveData)
    if MoveEffects.isPositionSwappingMove(moveData) then
        -- Ally Switch typically has +2 priority
        return moveData.priority or 2
    end
    
    return moveData.priority or 0
end

-- Validate position swap move usage
-- @param battleState: Current battle state
-- @param user: Pokemon attempting to use the move
-- @param moveData: Position swapping move data
-- @return: Validation result
function MoveEffects.validatePositionSwapUsage(battleState, user, moveData)
    if not battleState or not user or not moveData then
        return {
            valid = false,
            reason = "Missing required parameters"
        }
    end
    
    -- Must be in double battle format
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    if formatInfo.format ~= PositionalMechanics.BattleFormat.DOUBLE then
        return {
            valid = false,
            reason = "Position swapping moves require double battle format"
        }
    end
    
    -- Must have an ally to swap with
    local adjacentAllies = PositionalMechanics.getAdjacentAllies(battleState, user)
    if #adjacentAllies == 0 then
        return {
            valid = false,
            reason = "No ally available to swap positions with"
        }
    end
    
    -- Ally must not be fainted
    local ally = adjacentAllies[1]
    if ally.fainted then
        return {
            valid = false,
            reason = "Cannot swap positions with fainted ally"
        }
    end
    
    return {
        valid = true,
        reason = "Position swap is valid",
        ally = ally
    }
end


-- ===== END MODULE: game-logic.battle.move-effects =====

        
        if pokemon.status == StatusEffect.PARALYSIS then
            effectiveSpeed = math.floor(effectiveSpeed * SPEED_TIERS.PARALYSIS_MODIFIER)
        end
    end
    
    -- Apply weather and field condition modifiers
    if battleConditions then
        -- Tailwind effect
        if battleConditions.tailwind then
            -- Check if Pokemon's side has tailwind active
            local pokemonSide = pokemon.side or 0
            if battleConditions.tailwind[pokemonSide] and battleConditions.tailwind[pokemonSide] > 0 then
                effectiveSpeed = math.floor(effectiveSpeed * SPEED_TIERS.TAILWIND_MULTIPLIER)
            end
        end
        
        -- Trick Room reversal (handled in turn order calculation)
        -- Other field effects can be added here
    end
    
    -- Apply ability modifiers for speed-affecting abilities
    if pokemon.ability then
        -- Weather-based speed abilities
        if battleConditions and battleConditions.weather then
            if pokemon.ability == Enums.AbilityId.CHLOROPHYLL and 
               (battleConditions.weather == 1 or battleConditions.weather == 8) then -- SUNNY or HARSH_SUN
                effectiveSpeed = math.floor(effectiveSpeed * 2.0)
            elseif pokemon.ability == Enums.AbilityId.SWIFT_SWIM and 
                   (battleConditions.weather == 2 or battleConditions.weather == 7) then -- RAIN or HEAVY_RAIN
                effectiveSpeed = math.floor(effectiveSpeed * 2.0)
            elseif pokemon.ability == Enums.AbilityId.SAND_RUSH and 
                   battleConditions.weather == 3 then -- SANDSTORM
                effectiveSpeed = math.floor(effectiveSpeed * 2.0)
            elseif pokemon.ability == Enums.AbilityId.SLUSH_RUSH and 
                   (battleConditions.weather == 4 or battleConditions.weather == 5) then -- HAIL or SNOW
                effectiveSpeed = math.floor(effectiveSpeed * 2.0)
            end
        end
        
        -- Other speed-affecting abilities
        if pokemon.ability == Enums.AbilityId.SPEED_BOOST then
            -- Speed Boost increases speed each turn (implemented in ability system)
            -- The stat stage increase is already applied via battleStats
        elseif pokemon.ability == Enums.AbilityId.QUICK_FEET and pokemon.status then
            -- Quick Feet increases speed when statused (but not paralyzed effect)
            effectiveSpeed = math.floor(effectiveSpeed * 1.5)
        elseif pokemon.ability == Enums.AbilityId.UNBURDEN and pokemon.itemConsumed then
            -- Unburden doubles speed when item is consumed
            effectiveSpeed = math.floor(effectiveSpeed * 2.0)
        end
    end
    
    -- Apply item modifiers for speed-affecting items
    if pokemon.heldItem then
        -- Choice Scarf boosts speed by 50%
        if pokemon.heldItem == Enums.ItemId.CHOICE_SCARF then
            effectiveSpeed = math.floor(effectiveSpeed * 1.5)
        -- Iron Ball halves speed and grounds Pokemon
        elseif pokemon.heldItem == Enums.ItemId.IRON_BALL then
            effectiveSpeed = math.floor(effectiveSpeed * 0.5)
        -- Quick Powder doubles speed for Ditto
        elseif pokemon.heldItem == Enums.ItemId.QUICK_POWDER and 
               pokemon.species == Enums.SpeciesId.DITTO then
            effectiveSpeed = math.floor(effectiveSpeed * 2.0)
        -- Power items reduce speed
        elseif pokemon.heldItem == Enums.ItemId.POWER_WEIGHT or
               pokemon.heldItem == Enums.ItemId.POWER_BRACER or
               pokemon.heldItem == Enums.ItemId.POWER_BELT or
               pokemon.heldItem == Enums.ItemId.POWER_LENS or
               pokemon.heldItem == Enums.ItemId.POWER_BAND or
               pokemon.heldItem == Enums.ItemId.POWER_ANKLET then
            effectiveSpeed = math.max(1, effectiveSpeed - 50) -- Reduce speed by 50 (minimum 1)
        end
    end
    
    return effectiveSpeed
end

-- Create turn action object for priority queue
-- @param actionType: Type of action (move, switch, etc.)
-- @param pokemon: Pokemon performing the action
-- @param moveId: Move ID if action is a move
-- @param target: Target of the action
-- @param additionalData: Any additional action data
-- @return: Turn action object with priority information
function PriorityCalculator.createTurnAction(actionType, pokemon, moveId, target, additionalData)
    if not actionType or not pokemon then
        return nil
    end
    
    local action = {
        type = actionType,
        pokemon = pokemon,
        pokemonId = pokemon.id,
        moveId = moveId or 0,
        target = target,
        data = additionalData or {},
        timestamp = os.time()
    }
    
    -- Calculate priority based on action type
    if actionType == "move" then
        action.priority = PriorityCalculator.getMovePriority(moveId)
        action.category = PRIORITY_CATEGORIES.MOVE_PRIORITY
    elseif actionType == "switch" then
        action.priority = PRIORITY_CATEGORIES.SWITCH_PRIORITY
        action.category = PRIORITY_CATEGORIES.SWITCH_PRIORITY
    elseif actionType == "mega_evolution" then
        action.priority = PRIORITY_CATEGORIES.MEGA_EVOLUTION
        action.category = PRIORITY_CATEGORIES.MEGA_EVOLUTION
    elseif actionType == "ability" then
        action.priority = PRIORITY_CATEGORIES.ABILITY_PRIORITY
        action.category = PRIORITY_CATEGORIES.ABILITY_PRIORITY
    elseif actionType == "item" then
        action.priority = PRIORITY_CATEGORIES.ITEM_PRIORITY
        action.category = PRIORITY_CATEGORIES.ITEM_PRIORITY
    else
        action.priority = PRIORITY_CATEGORIES.DEFAULT_PRIORITY
        action.category = PRIORITY_CATEGORIES.DEFAULT_PRIORITY
    end
    
    return action
end

-- Calculate turn order for a list of actions
-- @param actions: Table of turn actions from all Pokemon
-- @param battleConditions: Current battle state and conditions
-- @return: Sorted table of actions in execution order
function PriorityCalculator.calculateTurnOrder(actions, battleConditions)
    if not actions or #actions == 0 then
        return {}
    end
    
    -- Add effective speed to each action
    for _, action in ipairs(actions) do
        if action.pokemon then
            action.effectiveSpeed = PriorityCalculator.calculateEffectiveSpeed(action.pokemon, battleConditions)
        else
            action.effectiveSpeed = 0
        end
    end
    
    -- Sort actions by priority system
    table.sort(actions, function(a, b)
        return PriorityCalculator.compareActions(a, b, battleConditions)
    end)
    
    return actions
end

-- Compare two actions for turn order priority
-- @param actionA: First action to compare
-- @param actionB: Second action to compare  
-- @param battleConditions: Battle conditions for tie-breaking
-- @return: Boolean indicating if actionA should go before actionB
function PriorityCalculator.compareActions(actionA, actionB, battleConditions)
    if not actionA or not actionB then
        return false
    end
    
    -- 1. Higher priority categories go first (switch > move, etc.)
    if actionA.category ~= actionB.category then
        return actionA.category > actionB.category
    end
    
    -- 2. Higher move priority goes first
    if actionA.priority ~= actionB.priority then
        return actionA.priority > actionB.priority
    end
    
    -- 3. Speed comparison (with Trick Room consideration)
    local speedA = actionA.effectiveSpeed or 0
    local speedB = actionB.effectiveSpeed or 0
    
    -- Check for Trick Room
    local trickRoom = false
    if battleConditions and battleConditions.trickRoom and battleConditions.trickRoom > 0 then
        trickRoom = true
    elseif battleConditions and battleConditions.fieldConditions then
        -- Check field conditions for Trick Room

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:         local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

        for conditionType, conditionData in pairs(battleConditions.fieldConditions) do
            if conditionType == FieldConditions.FieldEffectType.TRICK_ROOM and 
               conditionData.duration and conditionData.duration > 0 then
                trickRoom = true
                break
            end
        end
    end
    
    if speedA ~= speedB then
        if trickRoom then
            return speedA < speedB -- Trick Room reverses speed order
        else
            return speedA > speedB -- Normal speed order
        end
    end
    
    -- 4. Speed tie resolution using deterministic randomization
    -- In real battles this would use battle seed, here we use Pokemon ID for consistency
    local pokemonIdA = actionA.pokemonId or 0
    local pokemonIdB = actionB.pokemonId or 0
    
    -- Use deterministic tie-breaking based on Pokemon IDs
    -- This ensures consistent results in tests while maintaining randomness feel
    if pokemonIdA ~= pokemonIdB then
        return pokemonIdA < pokemonIdB
    end
    
    -- 5. Final fallback for identical actions
    return false
end

-- Process priority-based turn order for a battle turn
-- @param battleId: Battle identifier
-- @param playerCommands: Commands from all players
-- @param battleState: Current battle state
-- @return: Ordered list of actions to execute and success status
function PriorityCalculator.processBattleTurn(battleId, playerCommands, battleState)
    if not battleId or not playerCommands then
        return {}, false, "Invalid battle parameters"
    end
    
    local turnActions = {}
    
    -- Convert player commands to turn actions
    for playerId, commands in pairs(playerCommands) do
        if commands and type(commands) == "table" then
            for _, command in ipairs(commands) do
                if command.type and command.pokemon then
                    local action = PriorityCalculator.createTurnAction(
                        command.type,
                        command.pokemon,
                        command.moveId,
                        command.target,
                        command.data
                    )
                    
                    if action then
                        table.insert(turnActions, action)
                    end
                end
            end
        end
    end
    
    -- Calculate turn order
    local orderedActions = PriorityCalculator.calculateTurnOrder(turnActions, battleState)
    
    return orderedActions, true, "Turn order calculated successfully"
end

-- Validate priority calculation results
-- @param actions: List of actions to validate
-- @return: Boolean indicating validity and error message if invalid
function PriorityCalculator.validateTurnOrder(actions)
    if not actions or type(actions) ~= "table" then
        return false, "Actions must be a table"
    end
    
    -- Check that actions are properly sorted
    for i = 1, #actions - 1 do
        local current = actions[i]
        local next = actions[i + 1]
        
        if not current or not next then
            return false, "Invalid action at position " .. i
        end
        
        -- Verify priority order is correct
        if current.priority and next.priority then
            if current.priority < next.priority then
                return false, "Priority order violation at position " .. i
            end
        end
        
        -- Verify required fields are present
        if not current.pokemon or not current.type then
            return false, "Missing required fields in action at position " .. i
        end
    end
    
    return true, "Turn order validation passed"
end

-- Get detailed priority information for debugging
-- @param action: Action to analyze
-- @param battleConditions: Current battle conditions
-- @return: Detailed priority breakdown
function PriorityCalculator.getPriorityBreakdown(action, battleConditions)
    if not action then
        return {}
    end
    
    local breakdown = {
        action_type = action.type,
        base_priority = action.priority or 0,
        category_priority = action.category or 0,
        effective_speed = action.effectiveSpeed or 0,
        pokemon_id = action.pokemonId,
        move_id = action.moveId or 0
    }
    
    -- Add battle condition effects
    if battleConditions then
        breakdown.trick_room = battleConditions.trickRoom and battleConditions.trickRoom > 0
        breakdown.tailwind = battleConditions.tailwind and true or false
    end
    
    -- Add Pokemon-specific modifiers
    if action.pokemon then
        breakdown.status_effect = action.pokemon.status
        breakdown.base_speed = action.pokemon.stats and action.pokemon.stats.speed or 0
        breakdown.speed_stage = action.pokemon.battleStats and action.pokemon.battleStats.speed or 0
    end
    
    return breakdown
end

-- Apply field condition effects to action priority
-- @param action: Action to modify
-- @param battleConditions: Current battle conditions including field conditions
-- @return: Modified action with field condition effects applied
function PriorityCalculator.applyFieldConditionEffects(action, battleConditions)
    if not action or not battleConditions or not battleConditions.fieldConditions then
        return action
    end
    

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    local modifiedAction = {}
    
    -- Copy action properties
    for k, v in pairs(action) do
        modifiedAction[k] = v
    end
    
    -- Apply Trick Room effects if active
    for conditionType, conditionData in pairs(battleConditions.fieldConditions) do
        if conditionType == FieldConditions.FieldEffectType.TRICK_ROOM and 
           conditionData.duration and conditionData.duration > 0 then
            
            -- Mark action as affected by Trick Room
            modifiedAction.trick_room_active = true
            modifiedAction.field_condition_priority = true
            
            -- Store original speed for debugging
            if not modifiedAction.original_speed then
                modifiedAction.original_speed = modifiedAction.effectiveSpeed or 0
            end
            
            break
        end
    end
    
    return modifiedAction
end

-- Check if field conditions affect priority calculation
-- @param battleConditions: Current battle conditions
-- @return: Boolean indicating if field conditions affect priority, list of active effects
function PriorityCalculator.checkFieldConditionPriorityEffects(battleConditions)
    if not battleConditions or not battleConditions.fieldConditions then
        return false, {}
    end
    
    local affectsPriority = false
    local activeEffects = {}
    

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    for conditionType, conditionData in pairs(battleConditions.fieldConditions) do
        if conditionData.duration and conditionData.duration > 0 then
            if conditionType == FieldConditions.FieldEffectType.TRICK_ROOM then
                affectsPriority = true
                table.insert(activeEffects, {
                    type = "trick_room",
                    effect = "speed_reversal",
                    duration = conditionData.duration
                })
            end
        end
    end
    
    return affectsPriority, activeEffects
end


-- ===== END MODULE: game-logic.battle.priority-calculator =====


-- ===== MODULE: game-logic.battle.battle-conditions =====
-- File: ao-processes/game-logic/battle/battle-conditions.lua
-- Original require: local BattleConditions = require("game-logic.battle.battle-conditions")

-- Battle Conditions System
-- Comprehensive weather, terrain, and field effect management
-- Handles duration tracking, ability interactions, and move modifications

local BattleConditions = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- ===== MODULE: game-logic.battle.positional-mechanics =====
-- File: ao-processes/game-logic/battle/positional-mechanics.lua
-- Original require: local PositionalMechanics = require("game-logic.battle.positional-mechanics")


-- ===== END MODULE: game-logic.battle.positional-mechanics =====


-- Weather types and data (matching TypeScript implementation)
BattleConditions.WeatherType = {
    NONE = 0,
    SUNNY = 1,
    RAIN = 2,
    SANDSTORM = 3,
    HAIL = 4,
    SNOW = 5,
    FOG = 6,
    HEAVY_RAIN = 7,
    HARSH_SUN = 8,
    STRONG_WINDS = 9
}

-- Weather data with effects and interactions
BattleConditions.WeatherData = {
    [BattleConditions.WeatherType.SUNNY] = {
        name = "Sunny",
        default_duration = 5,
        fire_boost = 1.5,
        water_nerf = 0.5,
        abilities = {Enums.AbilityId.DROUGHT, Enums.AbilityId.SOLAR_POWER},
        healing_moves = {["synthesis"] = "3/4", ["morning_sun"] = "3/4", ["moonlight"] = "3/4"}
    },
    [BattleConditions.WeatherType.RAIN] = {
        name = "Rain",
        default_duration = 5,
        water_boost = 1.5,
        fire_nerf = 0.5,
        abilities = {Enums.AbilityId.DRIZZLE, Enums.AbilityId.SWIFT_SWIM, Enums.AbilityId.RAIN_DISH},
        accuracy_moves = {["thunder"] = 100, ["hurricane"] = 100}
    },
    [BattleConditions.WeatherType.SANDSTORM] = {
        name = "Sandstorm",
        default_duration = 5,
        damage_per_turn = "1/16",
        immune_types = {Enums.PokemonType.ROCK, Enums.PokemonType.GROUND, Enums.PokemonType.STEEL},
        abilities = {Enums.AbilityId.SAND_STREAM, Enums.AbilityId.SAND_VEIL},
        spdef_boost_types = {Enums.PokemonType.ROCK}
    },
    [BattleConditions.WeatherType.HAIL] = {
        name = "Hail",
        default_duration = 5,
        damage_per_turn = "1/16",
        immune_types = {Enums.PokemonType.ICE},
        abilities = {Enums.AbilityId.SNOW_WARNING},
        accuracy_moves = {["blizzard"] = 100}
    },
    [BattleConditions.WeatherType.SNOW] = {
        name = "Snow",
        default_duration = 5,
        immune_types = {Enums.PokemonType.ICE},
        abilities = {Enums.AbilityId.SNOW_WARNING},
        def_boost_types = {Enums.PokemonType.ICE}
    },
    [BattleConditions.WeatherType.FOG] = {
        name = "Fog",
        default_duration = 5,
        accuracy_reduction = 0.6
    },
    [BattleConditions.WeatherType.HEAVY_RAIN] = {
        name = "Heavy Rain",
        default_duration = -1, -- Permanent until overridden
        water_boost = 1.5,
        fire_immunity = true,
        abilities = {Enums.AbilityId.DRIZZLE}
    },
    [BattleConditions.WeatherType.HARSH_SUN] = {
        name = "Harsh Sun",
        default_duration = -1, -- Permanent until overridden
        fire_boost = 1.5,
        water_immunity = true,
        abilities = {Enums.AbilityId.DROUGHT}
    },
    [BattleConditions.WeatherType.STRONG_WINDS] = {
        name = "Strong Winds",
        default_duration = -1, -- Permanent until overridden
        flying_resistance = true,
        abilities = {}
    }
}

-- Terrain types and data
BattleConditions.TerrainType = {
    NONE = 0,
    ELECTRIC = 1,
    GRASSY = 2,
    MISTY = 3,
    PSYCHIC = 4
}

-- Terrain data with effects and interactions
BattleConditions.TerrainData = {
    [BattleConditions.TerrainType.ELECTRIC] = {
        name = "Electric Terrain",
        default_duration = 5,
        power_boost = {[Enums.PokemonType.ELECTRIC] = 1.5},
        status_prevention = {"sleep"},
        grounded_only = true
    },
    [BattleConditions.TerrainType.GRASSY] = {
        name = "Grassy Terrain",
        default_duration = 5,
        power_boost = {[Enums.PokemonType.GRASS] = 1.5},
        healing_per_turn = "1/16",
        move_power_reduction = {["earthquake"] = 0.5, ["magnitude"] = 0.5, ["bulldoze"] = 0.5},
        grounded_only = true
    },
    [BattleConditions.TerrainType.MISTY] = {
        name = "Misty Terrain",
        default_duration = 5,
        power_boost = {[Enums.PokemonType.FAIRY] = 1.5},
        status_prevention = {"all"},
        dragon_move_immunity = true,
        grounded_only = true
    },
    [BattleConditions.TerrainType.PSYCHIC] = {
        name = "Psychic Terrain",
        default_duration = 5,
        power_boost = {[Enums.PokemonType.PSYCHIC] = 1.5},
        priority_move_immunity = true,
        grounded_only = true
    }
}

-- Field effects (global battle conditions)
BattleConditions.FieldEffectType = {
    NONE = 0,
    TRICK_ROOM = 1,
    WONDER_ROOM = 2,
    MAGIC_ROOM = 3,
    GRAVITY = 4
}

-- Field condition data integration with environmental system
BattleConditions.FieldConditionData = {
    [BattleConditions.FieldEffectType.TRICK_ROOM] = {
        name = "Trick Room",
        default_duration = 5,
        priority_reversal = true,
        interacts_with_weather = false,
        interacts_with_terrain = false,
        global_effect = true
    },
    [BattleConditions.FieldEffectType.WONDER_ROOM] = {
        name = "Wonder Room",
        default_duration = 5,
        stat_swap = true,
        interacts_with_weather = false,
        interacts_with_terrain = false,
        global_effect = true
    },
    [BattleConditions.FieldEffectType.MAGIC_ROOM] = {
        name = "Magic Room",
        default_duration = 5,
        suppresses_items = true,
        interacts_with_weather = false,
        interacts_with_terrain = false,
        global_effect = true
    },
    [BattleConditions.FieldEffectType.GRAVITY] = {
        name = "Gravity",
        default_duration = 5,
        grounds_pokemon = true,
        interacts_with_weather = false,
        interacts_with_terrain = true, -- Affects terrain interaction for flying types
        global_effect = true
    }
}

-- Set weather condition
-- @param battleId: Battle instance identifier
-- @param weatherType: Weather type to set
-- @param duration: Duration override (nil for default)
-- @param source: Source of weather change (move, ability, etc.)
-- @param sourceAbility: Source ability if triggered by ability
-- @return: Boolean indicating success and weather details
function BattleConditions.setWeather(battleId, weatherType, duration, source, sourceAbility)
    if not battleId or not weatherType then
        return false, "Invalid parameters for weather change"
    end
    
    local weatherData = BattleConditions.WeatherData[weatherType]
    if not weatherData and weatherType ~= BattleConditions.WeatherType.NONE then
        return false, "Unknown weather type: " .. tostring(weatherType)
    end
    
    local actualDuration = duration
    if not actualDuration and weatherData then
        actualDuration = weatherData.default_duration
        -- Add random variation for some weather types
        if actualDuration > 0 then
            local variance = BattleRNG.randomInt(-1, 1)
            actualDuration = math.max(1, actualDuration + variance)
        end
    end
    
    local result = {
        success = true,
        weather_type = weatherType,
        weather_name = weatherData and weatherData.name or "None",
        duration = actualDuration or 0,
        source = source,
        source_ability = sourceAbility,
        timestamp = os.time()
    }
    
    print("Weather changed to " .. result.weather_name .. " for " .. (actualDuration or "unlimited") .. " turns")
    return true, result
end

-- Set terrain condition
-- @param battleId: Battle instance identifier
-- @param terrainType: Terrain type to set
-- @param duration: Duration override (nil for default)
-- @param source: Source of terrain change
-- @return: Boolean indicating success and terrain details
function BattleConditions.setTerrain(battleId, terrainType, duration, source)
    if not battleId or not terrainType then
        return false, "Invalid parameters for terrain change"
    end
    
    local terrainData = BattleConditions.TerrainData[terrainType]
    if not terrainData and terrainType ~= BattleConditions.TerrainType.NONE then
        return false, "Unknown terrain type: " .. tostring(terrainType)
    end
    
    local actualDuration = duration
    if not actualDuration and terrainData then
        actualDuration = terrainData.default_duration
    end
    
    local result = {
        success = true,
        terrain_type = terrainType,
        terrain_name = terrainData and terrainData.name or "None",
        duration = actualDuration or 0,
        source = source,
        timestamp = os.time()
    }
    
    print("Terrain changed to " .. result.terrain_name .. " for " .. (actualDuration or "unlimited") .. " turns")
    return true, result
end

-- Process weather effects at end of turn
-- @param battleId: Battle instance identifier
-- @param weatherType: Current weather type
-- @param pokemonList: List of Pokemon to process
-- @return: Weather damage results and updated weather data
function BattleConditions.processWeatherDamage(battleId, weatherType, pokemonList)
    local weatherData = BattleConditions.WeatherData[weatherType]
    if not weatherData or not weatherData.damage_per_turn then
        return {}, nil
    end
    
    local damageResults = {}
    
    for _, pokemon in ipairs(pokemonList) do
        local takeDamage = true
        
        -- Check type immunity
        if weatherData.immune_types then
            for _, immuneType in ipairs(weatherData.immune_types) do
                if pokemon.types[1] == immuneType or pokemon.types[2] == immuneType then
                    takeDamage = false
                    break
                end
            end
        end
        
        -- Check ability protection
        if pokemon.ability then
            for _, protectiveAbility in ipairs(weatherData.abilities or {}) do
                if pokemon.ability == protectiveAbility then
                    takeDamage = false
                    break
                end
            end
        end
        
        if takeDamage then
            local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP]
            local damage = 0
            
            if weatherData.damage_per_turn == "1/16" then
                damage = math.max(1, math.floor(maxHP / 16))
            elseif weatherData.damage_per_turn == "1/8" then
                damage = math.max(1, math.floor(maxHP / 8))
            end
            
            table.insert(damageResults, {
                pokemon_id = pokemon.id,
                damage = damage,
                weather = weatherData.name
            })
        end
    end
    
    return damageResults, nil
end

-- Process terrain healing effects
-- @param battleId: Battle instance identifier
-- @param terrainType: Current terrain type
-- @param pokemonList: List of Pokemon to process
-- @return: Terrain healing results
function BattleConditions.processTerrainHealing(battleId, terrainType, pokemonList)
    local terrainData = BattleConditions.TerrainData[terrainType]
    if not terrainData or not terrainData.healing_per_turn then
        return {}
    end
    
    local healingResults = {}
    
    for _, pokemon in ipairs(pokemonList) do
        -- Check if Pokemon is grounded (affected by terrain)
        if terrainData.grounded_only and not BattleConditions.isPokemonGrounded(pokemon) then
            goto continue
        end
        
        local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP]
        local healing = 0
        
        if terrainData.healing_per_turn == "1/16" then
            healing = math.max(1, math.floor(maxHP / 16))
        end
        
        -- Only heal if not at full HP
        if pokemon.currentHP < maxHP then
            table.insert(healingResults, {
                pokemon_id = pokemon.id,
                healing = healing,
                terrain = terrainData.name
            })
        end
        
        ::continue::
    end
    
    return healingResults
end

-- Check if Pokemon is grounded (affected by terrain)
-- @param pokemon: Pokemon data
-- @return: Boolean indicating if Pokemon is grounded
function BattleConditions.isPokemonGrounded(pokemon)
    -- Flying type Pokemon are not grounded
    if pokemon.types[1] == Enums.PokemonType.FLYING or pokemon.types[2] == Enums.PokemonType.FLYING then
        return false
    end
    
    -- Levitate ability makes Pokemon not grounded
    if pokemon.ability == Enums.AbilityId.LEVITATE then
        return false
    end
    
    -- TODO: Add checks for Air Balloon, Magnet Rise, Telekinesis, etc.
    
    return true
end

-- Get weather move power modifier
-- @param moveType: Type of the move
-- @param weatherType: Current weather type
-- @return: Power multiplier (1.0 = no change)
function BattleConditions.getWeatherMovePowerModifier(moveType, weatherType)
    local weatherData = BattleConditions.WeatherData[weatherType]
    if not weatherData then
        return 1.0
    end
    
    if moveType == Enums.PokemonType.FIRE and weatherData.fire_boost then
        return weatherData.fire_boost
    elseif moveType == Enums.PokemonType.FIRE and weatherData.fire_nerf then
        return weatherData.fire_nerf
    elseif moveType == Enums.PokemonType.WATER and weatherData.water_boost then
        return weatherData.water_boost
    elseif moveType == Enums.PokemonType.WATER and weatherData.water_nerf then
        return weatherData.water_nerf
    end
    
    return 1.0
end

-- Get terrain move power modifier
-- @param moveType: Type of the move
-- @param terrainType: Current terrain type
-- @param pokemonGrounded: Whether the attacking Pokemon is grounded
-- @return: Power multiplier (1.0 = no change)
function BattleConditions.getTerrainMovePowerModifier(moveType, terrainType, pokemonGrounded)
    local terrainData = BattleConditions.TerrainData[terrainType]
    if not terrainData or not pokemonGrounded then
        return 1.0
    end
    
    if terrainData.power_boost and terrainData.power_boost[moveType] then
        return terrainData.power_boost[moveType]
    end
    
    return 1.0
end

-- Check if weather blocks a move type
-- @param moveType: Type of move being used
-- @param weatherType: Current weather type
-- @return: Boolean indicating if move is blocked
function BattleConditions.doesWeatherBlockMove(moveType, weatherType)
    local weatherData = BattleConditions.WeatherData[weatherType]
    if not weatherData then
        return false
    end
    
    if moveType == Enums.PokemonType.FIRE and weatherData.fire_immunity then
        return true
    elseif moveType == Enums.PokemonType.WATER and weatherData.water_immunity then
        return true
    end
    
    return false
end

-- Check if terrain blocks a move
-- @param moveData: Move data including type and priority
-- @param terrainType: Current terrain type
-- @param targetGrounded: Whether the target is grounded
-- @return: Boolean indicating if move is blocked
function BattleConditions.doesTerrainBlockMove(moveData, terrainType, targetGrounded)
    local terrainData = BattleConditions.TerrainData[terrainType]
    if not terrainData or not targetGrounded then
        return false
    end
    
    -- Misty Terrain blocks Dragon-type moves
    if terrainData.dragon_move_immunity and moveData.type == Enums.PokemonType.DRAGON then
        return true
    end
    
    -- Psychic Terrain blocks priority moves
    if terrainData.priority_move_immunity and moveData.priority and moveData.priority > 0 then
        return true
    end
    
    return false
end

-- Update weather/terrain duration
-- @param conditionType: "weather" or "terrain"
-- @param currentDuration: Current duration (-1 for permanent)
-- @return: New duration, boolean indicating if condition should end
function BattleConditions.updateDuration(conditionType, currentDuration)
    if currentDuration == -1 then
        return -1, false -- Permanent conditions don't expire
    end
    
    if currentDuration <= 1 then
        return 0, true -- Condition expires
    end
    
    return currentDuration - 1, false
end

-- Get weather healing modifier
-- @param healingMove: Name of the healing move
-- @param weatherType: Current weather type
-- @return: Healing fraction string or nil
function BattleConditions.getWeatherHealingModifier(healingMove, weatherType)
    local weatherData = BattleConditions.WeatherData[weatherType]
    if not weatherData or not weatherData.healing_moves then
        return nil
    end
    
    return weatherData.healing_moves[healingMove]
end

-- Check if terrain prevents status condition
-- @param statusEffect: Status effect to check
-- @param terrainType: Current terrain type
-- @param pokemonGrounded: Whether Pokemon is grounded
-- @return: Boolean indicating if status is prevented
function BattleConditions.doesTerrainPreventStatus(statusEffect, terrainType, pokemonGrounded)
    local terrainData = BattleConditions.TerrainData[terrainType]
    if not terrainData or not pokemonGrounded or not terrainData.status_prevention then
        return false
    end
    
    -- Check if terrain prevents all status conditions
    for _, preventedStatus in ipairs(terrainData.status_prevention) do
        if preventedStatus == "all" then
            return true
        elseif preventedStatus == "sleep" and statusEffect == "sleep" then
            return true
        end
    end
    
    return false
end

-- Process combined terrain and weather effects at end of turn
-- @param battleId: Battle instance identifier
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @param pokemonList: List of Pokemon to process
-- @return: Combined effects results
function BattleConditions.processCombinedEnvironmentalEffects(battleId, weatherType, terrainType, pokemonList)
    local results = {
        weather_damage = {},
        terrain_healing = {},
        combined_effects = {}
    }
    
    -- Process weather damage first
    local weatherDamage = BattleConditions.processWeatherDamage(battleId, weatherType, pokemonList)
    results.weather_damage = weatherDamage
    
    -- Process terrain healing second
    local terrainHealing = BattleConditions.processTerrainHealing(battleId, terrainType, pokemonList)
    results.terrain_healing = terrainHealing
    
    -- Check for conflicts and precedence
    for _, pokemon in ipairs(pokemonList) do
        local pokemonId = pokemon.id
        local weatherEffect = nil
        local terrainEffect = nil
        
        -- Find weather effect for this Pokemon
        for _, effect in ipairs(weatherDamage) do
            if effect.pokemon_id == pokemonId then
                weatherEffect = effect
                break
            end
        end
        
        -- Find terrain effect for this Pokemon
        for _, effect in ipairs(terrainHealing) do
            if effect.pokemon_id == pokemonId then
                terrainEffect = effect
                break
            end
        end
        
        -- Handle combined effects (terrain healing vs weather damage)
        if weatherEffect and terrainEffect then
            local netEffect = terrainEffect.healing - weatherEffect.damage
            table.insert(results.combined_effects, {
                pokemon_id = pokemonId,
                weather_damage = weatherEffect.damage,
                terrain_healing = terrainEffect.healing,
                net_effect = netEffect,
                effect_type = netEffect > 0 and "heal" or "damage",
                final_amount = math.abs(netEffect)
            })
        end
    end
    
    return results
end

-- Check terrain-weather interaction conflicts
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @return: Interaction information
function BattleConditions.getTerrainWeatherInteractions(weatherType, terrainType)
    local interactions = {
        conflicts = {},
        synergies = {},
        precedence_rules = {}
    }
    
    -- Terrain and weather can coexist, but some effects may interact
    if weatherType ~= BattleConditions.WeatherType.NONE and terrainType ~= BattleConditions.TerrainType.NONE then
        -- Grassy Terrain healing vs weather damage
        if terrainType == BattleConditions.TerrainType.GRASSY then
            if weatherType == BattleConditions.WeatherType.SANDSTORM or weatherType == BattleConditions.WeatherType.HAIL then
                table.insert(interactions.conflicts, {
                    type = "healing_vs_damage",
                    description = "Grassy Terrain healing competes with weather damage",
                    resolution = "Both effects apply, net result calculated"
                })
            end
        end
        
        -- Electric Terrain with weather interactions (no direct conflicts)
        if terrainType == BattleConditions.TerrainType.ELECTRIC then
            table.insert(interactions.synergies, {
                type = "electric_weather_neutral",
                description = "Electric Terrain and weather effects are independent"
            })
        end
    end
    
    return interactions
end

-- Get combined environmental move power modifier
-- @param moveType: Type of the move
-- @param moveData: Move data including name and properties
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @param attackerGrounded: Whether attacker is grounded
-- @return: Combined power multiplier
function BattleConditions.getCombinedEnvironmentalMovePowerModifier(moveType, moveData, weatherType, terrainType, attackerGrounded)
    local weatherModifier = BattleConditions.getWeatherMovePowerModifier(moveType, weatherType)
    local terrainModifier = BattleConditions.getTerrainMovePowerModifier(moveType, terrainType, attackerGrounded)
    
    -- Weather and terrain modifiers multiply (they don't stack additively)
    local combinedModifier = weatherModifier * terrainModifier
    
    -- Special case: Grassy Terrain reduces power of ground-based moves
    local terrainData = BattleConditions.TerrainData[terrainType]
    if terrainData and terrainData.move_power_reduction and moveData.name then
        local moveName = string.lower(moveData.name)
        if terrainData.move_power_reduction[moveName] then
            combinedModifier = combinedModifier * terrainData.move_power_reduction[moveName]
        end
    end
    
    return combinedModifier
end

-- Check if environmental conditions block a move
-- @param moveData: Move data including type and properties
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @param targetGrounded: Whether target is grounded
-- @return: Boolean indicating if move is blocked, reason string
function BattleConditions.doEnvironmentalConditionsBlockMove(moveData, weatherType, terrainType, targetGrounded)
    -- Check weather blocks first
    if BattleConditions.doesWeatherBlockMove(moveData.type, weatherType) then
        local weatherData = BattleConditions.WeatherData[weatherType]
        return true, "Move blocked by " .. (weatherData and weatherData.name or "weather")
    end
    
    -- Check terrain blocks second
    if BattleConditions.doesTerrainBlockMove(moveData, terrainType, targetGrounded) then
        local terrainData = BattleConditions.TerrainData[terrainType]
        return true, "Move blocked by " .. (terrainData and terrainData.name or "terrain")
    end
    
    return false, nil
end

-- Get environmental condition priority for field effect removal
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @return: Priority information for moves like Defog
function BattleConditions.getEnvironmentalRemovalPriority(weatherType, terrainType)
    local priorities = {}
    
    -- Weather removal priority (some weather is harder to remove)
    if weatherType ~= BattleConditions.WeatherType.NONE then
        local weatherData = BattleConditions.WeatherData[weatherType]
        local priority = (weatherData and weatherData.default_duration == -1) and "high" or "normal"
        table.insert(priorities, {
            condition = "weather",
            type = weatherType,
            priority = priority,
            name = weatherData and weatherData.name or "Unknown Weather"
        })
    end
    
    -- Terrain removal priority
    if terrainType ~= BattleConditions.TerrainType.NONE then
        local terrainData = BattleConditions.TerrainData[terrainType]
        table.insert(priorities, {
            condition = "terrain",
            type = terrainType,
            priority = "normal",
            name = terrainData and terrainData.name or "Unknown Terrain"
        })
    end
    
    return priorities
end

-- Environmental Effect Precedence System
-- Complex interactions between weather, terrain, status effects, and abilities
-- Implements proper game-accurate precedence rules for environmental effects

-- Environmental effect processing order constants
BattleConditions.EffectPrecedence = {
    ABILITY_SUPPRESSION = 1,
    WEATHER_EFFECTS = 2,
    TERRAIN_EFFECTS = 3,
    STATUS_EFFECTS = 4,
    ENVIRONMENTAL_DAMAGE = 5,
    ENVIRONMENTAL_HEALING = 6
}

-- Environmental interaction types
BattleConditions.InteractionType = {
    SUPPRESSION = "suppression",
    STACKING = "stacking", 
    REPLACEMENT = "replacement",
    PRECEDENCE = "precedence"
}

-- Process all environmental effects with proper precedence
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of all active Pokemon
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @param activeAbilities: List of active abilities that may suppress effects
-- @return: Processed environmental effects with proper precedence resolution
function BattleConditions.processEnvironmentalEffectPrecedence(battleId, pokemonList, weatherType, terrainType, activeAbilities)
    local results = {
        suppressed_effects = {},
        active_effects = {},
        interaction_log = {},
        final_effects = {}
    }
    
    -- Step 1: Check ability suppression (highest precedence)
    local weatherSuppressed, suppressingAbility = BattleConditions.checkAbilityWeatherSuppression(pokemonList, weatherType)
    
    if weatherSuppressed then
        table.insert(results.suppressed_effects, {
            effect_type = "weather",
            weather_type = weatherType,
            suppressed_by = suppressingAbility,
            precedence_level = BattleConditions.EffectPrecedence.ABILITY_SUPPRESSION
        })
        weatherType = BattleConditions.WeatherType.NONE -- Suppress weather for processing
    end
    
    -- Step 2: Process weather effects (if not suppressed)
    if weatherType ~= BattleConditions.WeatherType.NONE then
        local weatherEffects = BattleConditions.processWeatherEffectsWithPrecedence(battleId, pokemonList, weatherType)
        for _, effect in ipairs(weatherEffects) do
            effect.precedence_level = BattleConditions.EffectPrecedence.WEATHER_EFFECTS
            table.insert(results.active_effects, effect)
        end
    end
    
    -- Step 3: Process terrain effects (terrain takes precedence over weather for grounded Pokemon)
    if terrainType ~= BattleConditions.TerrainType.NONE then
        local terrainEffects = BattleConditions.processTerrainEffectsWithPrecedence(battleId, pokemonList, terrainType, weatherType)
        for _, effect in ipairs(terrainEffects) do
            effect.precedence_level = BattleConditions.EffectPrecedence.TERRAIN_EFFECTS
            table.insert(results.active_effects, effect)
        end
    end
    
    -- Step 4: Resolve conflicts and apply precedence rules
    local finalEffects = BattleConditions.resolveEnvironmentalPrecedence(results.active_effects, pokemonList)
    results.final_effects = finalEffects
    
    -- Step 5: Log interactions for debugging and notifications
    results.interaction_log = BattleConditions.generateInteractionLog(results.suppressed_effects, results.active_effects, finalEffects)
    
    return results
end

-- Check if any abilities suppress weather effects
-- @param pokemonList: List of active Pokemon
-- @param weatherType: Current weather type
-- @return: Boolean if suppressed, suppressing ability name
function BattleConditions.checkAbilityWeatherSuppression(pokemonList, weatherType)

-- ===== MODULE: game-logic.battle.weather-abilities =====
-- File: ao-processes/game-logic/battle/weather-abilities.lua
-- Original require:     local WeatherAbilities = require("game-logic.battle.weather-abilities")

-- Weather-Ability Interactions
-- Handles weather-related ability activations and stat modifications
-- Implements Solar Power, Rain Dish, Ice Body, Sand Rush, Swift Swim, Chlorophyll

local WeatherAbilities = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Weather-related ability definitions with activation conditions and effects
WeatherAbilities.WeatherAbilityData = {
    [Enums.AbilityId.SOLAR_POWER] = {
        name = "Solar Power",
        weather_conditions = {Enums.WeatherType.SUNNY},
        effects = {
            stat_boost = {stat = Enums.Stat.SPATK, multiplier = 1.5},
            end_turn_damage = {fraction = "1/8", damage_type = "ability"}
        },
        activation_timing = {"stat_calculation", "end_of_turn"}
    },
    [Enums.AbilityId.RAIN_DISH] = {
        name = "Rain Dish",
        weather_conditions = {Enums.WeatherType.RAIN},
        effects = {
            end_turn_healing = {fraction = "1/16", healing_type = "ability"}
        },
        activation_timing = {"end_of_turn"}
    },
    [Enums.AbilityId.ICE_BODY] = {
        name = "Ice Body",
        weather_conditions = {Enums.WeatherType.HAIL},
        effects = {
            end_turn_healing = {fraction = "1/16", healing_type = "ability"},
            weather_immunity = true
        },
        activation_timing = {"end_of_turn", "weather_damage_check"}
    },
    [Enums.AbilityId.SAND_RUSH] = {
        name = "Sand Rush",
        weather_conditions = {Enums.WeatherType.SANDSTORM},
        effects = {
            stat_boost = {stat = Enums.Stat.SPEED, multiplier = 2.0},
            weather_immunity = true
        },
        activation_timing = {"stat_calculation", "weather_damage_check"}
    },
    [Enums.AbilityId.SWIFT_SWIM] = {
        name = "Swift Swim",
        weather_conditions = {Enums.WeatherType.RAIN},
        effects = {
            stat_boost = {stat = Enums.Stat.SPEED, multiplier = 2.0}
        },
        activation_timing = {"stat_calculation"}
    },
    [Enums.AbilityId.CHLOROPHYLL] = {
        name = "Chlorophyll",
        weather_conditions = {Enums.WeatherType.SUNNY},
        effects = {
            stat_boost = {stat = Enums.Stat.SPEED, multiplier = 2.0}
        },
        activation_timing = {"stat_calculation"}
    },
    [Enums.AbilityId.SAND_VEIL] = {
        name = "Sand Veil",
        weather_conditions = {Enums.WeatherType.SANDSTORM},
        effects = {
            evasion_boost = {multiplier = 1.2},
            weather_immunity = true
        },
        activation_timing = {"accuracy_calculation", "weather_damage_check"}
    },
    [Enums.AbilityId.SNOW_CLOAK] = {
        name = "Snow Cloak",
        weather_conditions = {Enums.WeatherType.HAIL},
        effects = {
            evasion_boost = {multiplier = 1.2},
            weather_immunity = true
        },
        activation_timing = {"accuracy_calculation", "weather_damage_check"}
    },
    [Enums.AbilityId.OVERCOAT] = {
        name = "Overcoat",
        weather_conditions = {Enums.WeatherType.SANDSTORM, Enums.WeatherType.HAIL},
        effects = {
            weather_immunity = true
        },
        activation_timing = {"weather_damage_check"}
    },
    [Enums.AbilityId.CLOUD_NINE] = {
        name = "Cloud Nine",
        weather_conditions = "all", -- Suppresses all weather
        effects = {
            weather_suppression = true,
            suppression_scope = "all_pokemon"
        },
        activation_timing = {"weather_check", "field_entry"}
    },
    [Enums.AbilityId.AIR_LOCK] = {
        name = "Air Lock",
        weather_conditions = "all", -- Suppresses all weather  
        effects = {
            weather_suppression = true,
            suppression_scope = "all_pokemon"
        },
        activation_timing = {"weather_check", "field_entry"}
    },
    [Enums.AbilityId.DRY_SKIN] = {
        name = "Dry Skin",
        weather_conditions = {Enums.WeatherType.RAIN, Enums.WeatherType.SUNNY},
        effects = {
            end_turn_healing = {fraction = "1/8", weather = Enums.WeatherType.RAIN},
            end_turn_damage = {fraction = "1/8", weather = Enums.WeatherType.SUNNY}
        },
        activation_timing = {"end_of_turn"}
    }
}

-- Check if Pokemon has weather-related ability for current conditions
-- @param pokemon: Pokemon data with ability
-- @param weatherType: Current weather type
-- @param checkTiming: Specific timing to check ("stat_calculation", "end_of_turn", etc.)
-- @return: Boolean indicating if ability should activate, ability data
function WeatherAbilities.shouldAbilityActivate(pokemon, weatherType, checkTiming)
    if not pokemon or not pokemon.ability or not weatherType then
        return false, nil
    end
    
    local abilityData = WeatherAbilities.WeatherAbilityData[pokemon.ability]
    if not abilityData then
        return false, nil
    end
    
    -- Check if timing matches
    if checkTiming and abilityData.activation_timing then
        local timingMatches = false
        for _, timing in ipairs(abilityData.activation_timing) do
            if timing == checkTiming then
                timingMatches = true
                break
            end
        end
        if not timingMatches then
            return false, nil
        end
    end
    
    -- Check weather conditions
    if abilityData.weather_conditions == "all" then
        return true, abilityData
    end
    
    if type(abilityData.weather_conditions) == "table" then
        for _, condition in ipairs(abilityData.weather_conditions) do
            if weatherType == condition then
                return true, abilityData
            end
        end
    end
    
    return false, nil
end

-- Process weather-related ability stat modifications
-- @param pokemon: Pokemon data with ability and stats
-- @param weatherType: Current weather type
-- @return: Table of stat modifications {stat = multiplier}
function WeatherAbilities.getWeatherStatModifications(pokemon, weatherType)
    local shouldActivate, abilityData = WeatherAbilities.shouldAbilityActivate(pokemon, weatherType, "stat_calculation")
    
    if not shouldActivate or not abilityData or not abilityData.effects then
        return {}
    end
    
    local modifications = {}
    
    -- Stat boost modifications
    if abilityData.effects.stat_boost then
        local boost = abilityData.effects.stat_boost
        modifications[boost.stat] = boost.multiplier
    end
    
    return modifications
end

-- Process end-of-turn weather ability effects (healing, damage)
-- @param pokemonList: List of active Pokemon
-- @param weatherType: Current weather type
-- @return: List of ability activation results
function WeatherAbilities.processEndOfTurnAbilityEffects(pokemonList, weatherType)
    local results = {}
    
    for _, pokemon in ipairs(pokemonList) do
        local shouldActivate, abilityData = WeatherAbilities.shouldAbilityActivate(pokemon, weatherType, "end_of_turn")
        
        if shouldActivate and abilityData and abilityData.effects then
            local effects = abilityData.effects
            
            -- Process healing effects
            if effects.end_turn_healing then
                local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP] or 100
                local healingAmount = 0
                
                -- Check if healing is conditional on specific weather
                local shouldHeal = true
                if effects.end_turn_healing.weather then
                    shouldHeal = (weatherType == effects.end_turn_healing.weather)
                end
                
                if shouldHeal then
                    if effects.end_turn_healing.fraction == "1/16" then
                        healingAmount = math.max(1, math.floor(maxHP / 16))
                    elseif effects.end_turn_healing.fraction == "1/8" then
                        healingAmount = math.max(1, math.floor(maxHP / 8))
                    end
                    
                    if healingAmount > 0 and pokemon.currentHP < maxHP then
                        table.insert(results, {
                            pokemon_id = pokemon.id or "unknown",
                            pokemon_name = pokemon.name or "Unknown Pokemon",
                            ability_name = abilityData.name,
                            effect_type = "healing",
                            healing = healingAmount,
                            source = "weather_ability",
                            weather = effects.end_turn_healing.weather
                        })
                    end
                end
            end
            
            -- Process damage effects (Solar Power, Dry Skin in sun)
            if effects.end_turn_damage then
                local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP] or 100
                local damageAmount = 0
                
                -- Check if damage is conditional on specific weather
                local shouldDamage = true
                if effects.end_turn_damage.weather then
                    shouldDamage = (weatherType == effects.end_turn_damage.weather)
                end
                
                if shouldDamage then
                    if effects.end_turn_damage.fraction == "1/8" then
                        damageAmount = math.max(1, math.floor(maxHP / 8))
                    elseif effects.end_turn_damage.fraction == "1/16" then
                        damageAmount = math.max(1, math.floor(maxHP / 16))
                    end
                    
                    if damageAmount > 0 then
                        table.insert(results, {
                            pokemon_id = pokemon.id or "unknown",
                            pokemon_name = pokemon.name or "Unknown Pokemon",
                            ability_name = abilityData.name,
                            effect_type = "damage",
                            damage = damageAmount,
                            source = "weather_ability",
                            weather = effects.end_turn_damage.weather
                        })
                    end
                end
            end
        end
    end
    
    return results
end

-- Check if Pokemon is immune to weather damage due to ability
-- @param pokemon: Pokemon data with ability
-- @param weatherType: Current weather type causing damage
-- @return: Boolean indicating immunity, ability name if immune
function WeatherAbilities.isImmuneToWeatherDamage(pokemon, weatherType)
    if not pokemon or not pokemon.ability or not weatherType then
        return false, nil
    end
    
    local shouldActivate, abilityData = WeatherAbilities.shouldAbilityActivate(pokemon, weatherType, "weather_damage_check")
    
    if shouldActivate and abilityData and abilityData.effects and abilityData.effects.weather_immunity then
        return true, abilityData.name
    end
    
    return false, nil
end

-- Check if weather effects are suppressed due to abilities (Cloud Nine, Air Lock)
-- @param pokemonList: List of active Pokemon to check for suppression abilities
-- @param weatherType: Current weather type
-- @return: Boolean indicating if weather is suppressed, suppressing ability name, suppressing Pokemon
function WeatherAbilities.isWeatherSuppressed(pokemonList, weatherType)
    for _, pokemon in ipairs(pokemonList) do
        local shouldActivate, abilityData = WeatherAbilities.shouldAbilityActivate(pokemon, weatherType, "weather_check")
        
        if shouldActivate and abilityData and abilityData.effects and abilityData.effects.weather_suppression then
            return true, abilityData.name, pokemon
        end
    end
    
    return false, nil, nil
end

-- Enhanced weather suppression system with state tracking
-- @param pokemonList: List of active Pokemon
-- @param weatherType: Current weather type
-- @param battleState: Battle state for tracking suppression
-- @return: Suppression details with state management
function WeatherAbilities.processWeatherSuppression(pokemonList, weatherType, battleState)
    local suppressed, suppressingAbility, suppressingPokemon = WeatherAbilities.isWeatherSuppressed(pokemonList, weatherType)
    
    local result = {
        suppressed = suppressed,
        suppressing_ability = suppressingAbility,
        suppressing_pokemon = suppressingPokemon and suppressingPokemon.id or nil,
        previous_suppression = battleState and battleState.weather_suppression or nil,
        suppression_changed = false
    }
    
    -- Check if suppression state changed
    if battleState then
        local previousSuppressed = battleState.weather_suppression and battleState.weather_suppression.active or false
        result.suppression_changed = (suppressed ~= previousSuppressed)
        
        -- Update battle state
        battleState.weather_suppression = {
            active = suppressed,
            ability = suppressingAbility,
            pokemon_id = suppressingPokemon and suppressingPokemon.id or nil,
            previous_weather = not suppressed and weatherType or nil
        }
    end
    
    return result
end

-- Restore weather when suppression ends (Pokemon switches out)
-- @param battleState: Battle state with suppression tracking
-- @param switchedPokemonId: ID of Pokemon that switched out
-- @return: Weather restoration information
function WeatherAbilities.checkWeatherRestorationOnSwitch(battleState, switchedPokemonId)
    if not battleState or not battleState.weather_suppression then
        return nil
    end
    
    local suppression = battleState.weather_suppression
    
    -- If the suppressing Pokemon switched out, restore weather
    if suppression.active and suppression.pokemon_id == switchedPokemonId then
        return {
            should_restore = true,
            restored_weather = suppression.previous_weather or BattleConditions.WeatherType.NONE,
            reason = "Suppressing Pokemon switched out"
        }
    end
    
    return nil
end

-- Get accuracy/evasion modifications from weather abilities
-- @param attacker: Attacking Pokemon data
-- @param defender: Defending Pokemon data
-- @param weatherType: Current weather type
-- @return: Accuracy multiplier for attacker, evasion multiplier for defender
function WeatherAbilities.getWeatherAccuracyModifications(attacker, defender, weatherType)
    local attackerAccuracy = 1.0
    local defenderEvasion = 1.0
    
    -- Check attacker weather abilities (none currently affect accuracy directly)
    
    -- Check defender weather abilities for evasion boosts
    if defender then
        local shouldActivate, abilityData = WeatherAbilities.shouldAbilityActivate(defender, weatherType, "accuracy_calculation")
        
        if shouldActivate and abilityData and abilityData.effects and abilityData.effects.evasion_boost then
            defenderEvasion = abilityData.effects.evasion_boost.multiplier
        end
    end
    
    return attackerAccuracy, defenderEvasion
end

-- Activate weather-setting abilities at battle start or switch-in
-- @param pokemon: Pokemon data with potential weather ability
-- @param battleId: Battle instance identifier
-- @return: Weather change result or nil if no weather ability
function WeatherAbilities.activateWeatherSettingAbility(pokemon, battleId)
    if not pokemon or not pokemon.ability or not battleId then
        return nil
    end
    
    local weatherSettingAbilities = {
        [Enums.AbilityId.DROUGHT] = {
            weather = Enums.WeatherType.SUNNY,
            duration = 5,
            name = "Drought"
        },
        [Enums.AbilityId.DRIZZLE] = {
            weather = Enums.WeatherType.RAIN,
            duration = 5,
            name = "Drizzle"
        },
        [Enums.AbilityId.SAND_STREAM] = {
            weather = Enums.WeatherType.SANDSTORM,
            duration = 5,
            name = "Sand Stream"
        },
        [Enums.AbilityId.SNOW_WARNING] = {
            weather = Enums.WeatherType.HAIL,
            duration = 5,
            name = "Snow Warning"
        }
    }
    
    local abilityData = weatherSettingAbilities[pokemon.ability]
    if abilityData then
        return {
            weather_type = abilityData.weather,
            duration = abilityData.duration,
            source = "ability",
            source_ability = pokemon.ability,
            ability_name = abilityData.name,
            pokemon_name = pokemon.name or "Unknown Pokemon"
        }
    end
    
    return nil
end

-- Calculate final stat value with weather ability modifications
-- @param pokemon: Pokemon data with base stats and ability
-- @param statType: Type of stat being calculated
-- @param baseValue: Base stat value before modifications
-- @param weatherType: Current weather type
-- @return: Modified stat value
function WeatherAbilities.calculateWeatherModifiedStat(pokemon, statType, baseValue, weatherType)
    if not pokemon or not statType or not baseValue then
        return baseValue
    end
    
    local modifications = WeatherAbilities.getWeatherStatModifications(pokemon, weatherType)
    local modifier = modifications[statType] or 1.0
    
    return math.floor(baseValue * modifier)
end

-- Get all active weather abilities for Pokemon list
-- @param pokemonList: List of Pokemon to check
-- @param weatherType: Current weather type
-- @return: List of active ability descriptions
function WeatherAbilities.getActiveWeatherAbilities(pokemonList, weatherType)
    local activeAbilities = {}
    
    for _, pokemon in ipairs(pokemonList) do
        if pokemon.ability then
            local shouldActivate, abilityData = WeatherAbilities.shouldAbilityActivate(pokemon, weatherType, nil)
            
            if shouldActivate and abilityData then
                table.insert(activeAbilities, {
                    pokemon_id = pokemon.id or "unknown",
                    pokemon_name = pokemon.name or "Unknown Pokemon",
                    ability_id = pokemon.ability,
                    ability_name = abilityData.name,
                    effects = abilityData.effects
                })
            end
        end
    end
    
    return activeAbilities
end


-- ===== END MODULE: game-logic.battle.weather-abilities =====

    return WeatherAbilities.isWeatherSuppressed(pokemonList, weatherType)
end

-- Process weather effects with precedence tracking
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to process
-- @param weatherType: Current weather type
-- @return: Weather effects with precedence information
function BattleConditions.processWeatherEffectsWithPrecedence(battleId, pokemonList, weatherType)
    local effects = {}
    
    -- Process weather damage
    local weatherDamage = BattleConditions.processWeatherDamage(battleId, weatherType, pokemonList)
    for _, damage in ipairs(weatherDamage) do
        table.insert(effects, {
            effect_type = "weather_damage",
            pokemon_id = damage.pokemon_id,
            damage = damage.damage,
            weather = damage.weather,
            timing = "end_of_turn",
            priority = 3 -- Weather damage has medium priority
        })
    end
    
    -- Process weather-related ability effects

-- ===== MODULE: game-logic.battle.weather-abilities =====
-- File: ao-processes/game-logic/battle/weather-abilities.lua
-- Original require:     local WeatherAbilities = require("game-logic.battle.weather-abilities")


-- ===== END MODULE: game-logic.battle.weather-abilities =====

    local abilityEffects = WeatherAbilities.processEndOfTurnAbilityEffects(pokemonList, weatherType)
    for _, effect in ipairs(abilityEffects) do
        table.insert(effects, {
            effect_type = "weather_ability",
            pokemon_id = effect.pokemon_id,
            ability_name = effect.ability_name,
            healing = effect.healing,
            damage = effect.damage,
            source = effect.source,
            timing = "end_of_turn",
            priority = 2 -- Ability effects have higher priority than weather damage
        })
    end
    
    return effects
end

-- Process terrain effects with precedence tracking
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to process
-- @param terrainType: Current terrain type
-- @param weatherType: Current weather type (for interaction checks)
-- @return: Terrain effects with precedence information
function BattleConditions.processTerrainEffectsWithPrecedence(battleId, pokemonList, terrainType, weatherType)
    local effects = {}
    
    -- Process terrain healing
    local terrainHealing = BattleConditions.processTerrainHealing(battleId, terrainType, pokemonList)
    for _, healing in ipairs(terrainHealing) do
        table.insert(effects, {
            effect_type = "terrain_healing",
            pokemon_id = healing.pokemon_id,
            healing = healing.healing,
            terrain = healing.terrain,
            timing = "end_of_turn",
            priority = 1, -- Terrain healing has highest priority
            grounded_only = true
        })
    end
    
    return effects
end

-- Resolve environmental effect precedence conflicts
-- @param activeEffects: List of all active environmental effects
-- @param pokemonList: List of Pokemon for context
-- @return: Final effects after precedence resolution
function BattleConditions.resolveEnvironmentalPrecedence(activeEffects, pokemonList)
    local finalEffects = {}
    local pokemonEffectMap = {} -- Group effects by Pokemon
    
    -- Group effects by Pokemon ID
    for _, effect in ipairs(activeEffects) do
        local pokemonId = effect.pokemon_id
        if not pokemonEffectMap[pokemonId] then
            pokemonEffectMap[pokemonId] = {}
        end
        table.insert(pokemonEffectMap[pokemonId], effect)
    end
    
    -- Resolve conflicts for each Pokemon
    for pokemonId, effects in pairs(pokemonEffectMap) do
        local resolvedEffect = BattleConditions.resolvePokemonEffectConflicts(effects, pokemonId, pokemonList)
        if resolvedEffect then
            table.insert(finalEffects, resolvedEffect)
        end
    end
    
    return finalEffects
end

-- Resolve effect conflicts for a single Pokemon
-- @param effects: List of effects affecting this Pokemon
-- @param pokemonId: Pokemon ID for context
-- @param pokemonList: Full Pokemon list for lookups
-- @return: Final resolved effect or nil
function BattleConditions.resolvePokemonEffectConflicts(effects, pokemonId, pokemonList)
    if #effects == 0 then
        return nil
    end
    
    if #effects == 1 then
        return effects[1]
    end
    
    -- Sort by priority (higher priority = lower number)
    table.sort(effects, function(a, b) return (a.priority or 999) < (b.priority or 999) end)
    
    -- Check if Pokemon is grounded for terrain effects
    local pokemon = BattleConditions.findPokemonById(pokemonId, pokemonList)
    local isGrounded = pokemon and BattleConditions.isPokemonGrounded(pokemon)
    
    local totalHealing = 0
    local totalDamage = 0
    local sources = {}
    
    -- Process effects in priority order
    for _, effect in ipairs(effects) do
        -- Terrain effects only apply to grounded Pokemon
        if effect.grounded_only and not isGrounded then
            goto continue
        end
        
        if effect.healing then
            totalHealing = totalHealing + effect.healing
            table.insert(sources, effect.effect_type .. ":" .. (effect.ability_name or effect.terrain or effect.weather or "unknown"))
        end
        
        if effect.damage then
            totalDamage = totalDamage + effect.damage
            table.insert(sources, effect.effect_type .. ":" .. (effect.ability_name or effect.terrain or effect.weather or "unknown"))
        end
        
        ::continue::
    end
    
    -- Calculate net effect
    local netAmount = totalHealing - totalDamage
    
    if netAmount == 0 then
        return nil -- No net effect
    end
    
    return {
        effect_type = netAmount > 0 and "net_healing" or "net_damage",
        pokemon_id = pokemonId,
        healing = netAmount > 0 and netAmount or 0,
        damage = netAmount < 0 and math.abs(netAmount) or 0,
        net_amount = netAmount,
        sources = sources,
        timing = "end_of_turn",
        resolved_conflicts = #effects > 1
    }
end

-- Find Pokemon by ID in pokemon list
-- @param pokemonId: Pokemon ID to find
-- @param pokemonList: List of Pokemon to search
-- @return: Pokemon data or nil
function BattleConditions.findPokemonById(pokemonId, pokemonList)
    for _, pokemon in ipairs(pokemonList) do
        if pokemon.id == pokemonId then
            return pokemon
        end
    end
    return nil
end

-- Generate interaction log for debugging and notifications
-- @param suppressedEffects: List of suppressed effects
-- @param activeEffects: List of active effects
-- @param finalEffects: List of final resolved effects
-- @return: Detailed interaction log
function BattleConditions.generateInteractionLog(suppressedEffects, activeEffects, finalEffects)
    local log = {
        timestamp = os.time(),
        suppression_count = #suppressedEffects,
        active_count = #activeEffects,
        final_count = #finalEffects,
        interactions = {}
    }
    
    -- Log suppressions
    for _, suppressed in ipairs(suppressedEffects) do
        table.insert(log.interactions, {
            type = "suppression",
            description = suppressed.effect_type .. " suppressed by " .. suppressed.suppressed_by,
            precedence_level = suppressed.precedence_level
        })
    end
    
    -- Log conflicts resolved
    for _, final in ipairs(finalEffects) do
        if final.resolved_conflicts then
            table.insert(log.interactions, {
                type = "conflict_resolution",
                description = "Multiple effects resolved for Pokemon " .. final.pokemon_id,
                sources = final.sources,
                net_effect = final.net_amount
            })
        end
    end
    
    return log
end

-- Check environmental effect stacking compatibility
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @return: Stacking information and compatibility
function BattleConditions.checkEnvironmentalEffectStacking(weatherType, terrainType)
    local stacking = {
        compatible = true,
        conflicts = {},
        synergies = {},
        precedence_notes = {}
    }
    
    -- Weather and terrain generally stack, but with specific rules
    if weatherType ~= BattleConditions.WeatherType.NONE and terrainType ~= BattleConditions.TerrainType.NONE then
        stacking.compatible = true
        table.insert(stacking.precedence_notes, "Terrain effects take precedence over weather for grounded Pokemon")
        
        -- Check for specific interactions
        if terrainType == BattleConditions.TerrainType.GRASSY then
            if weatherType == BattleConditions.WeatherType.SANDSTORM or weatherType == BattleConditions.WeatherType.HAIL then
                table.insert(stacking.conflicts, {
                    description = "Grassy Terrain healing vs weather damage",
                    resolution = "Both effects apply, net healing/damage calculated"
                })
            end
        end
    end
    
    return stacking
end

-- Move-Environment Interaction System
-- Complex interactions between moves and environmental conditions
-- Implements Hurricane, Solar Beam, Thunder, and other environment-dependent moves

-- Weather-dependent move modifications
BattleConditions.WeatherMoveData = {
    ["hurricane"] = {
        weather_effects = {
            [BattleConditions.WeatherType.RAIN] = {
                accuracy_override = 100, -- Never misses in rain
                description = "Hurricane never misses in rain"
            },
            [BattleConditions.WeatherType.HARSH_SUN] = {
                accuracy_modifier = 0.5, -- 50% accuracy in harsh sun
                description = "Hurricane has reduced accuracy in harsh sun"
            }
        },
        base_accuracy = 70
    },
    ["thunder"] = {
        weather_effects = {
            [BattleConditions.WeatherType.RAIN] = {
                accuracy_override = 100, -- Never misses in rain
                description = "Thunder never misses in rain"
            },
            [BattleConditions.WeatherType.SUNNY] = {
                accuracy_modifier = 0.5, -- 50% accuracy in sun
                description = "Thunder has reduced accuracy in sun"
            },
            [BattleConditions.WeatherType.HARSH_SUN] = {
                accuracy_modifier = 0.5,
                description = "Thunder has reduced accuracy in harsh sun"
            }
        },
        base_accuracy = 70
    },
    ["solar_beam"] = {
        weather_effects = {
            [BattleConditions.WeatherType.SUNNY] = {
                charge_skip = true, -- Instant charging in sun
                description = "Solar Beam charges instantly in sun"
            },
            [BattleConditions.WeatherType.HARSH_SUN] = {
                charge_skip = true,
                power_boost = 1.0, -- No power reduction
                description = "Solar Beam charges instantly with full power in harsh sun"
            },
            [BattleConditions.WeatherType.RAIN] = {
                power_modifier = 0.5, -- Half power in rain
                description = "Solar Beam has reduced power in rain"
            },
            [BattleConditions.WeatherType.SANDSTORM] = {
                power_modifier = 0.5,
                description = "Solar Beam has reduced power in sandstorm"
            },
            [BattleConditions.WeatherType.HAIL] = {
                power_modifier = 0.5,
                description = "Solar Beam has reduced power in hail"
            }
        },
        base_power = 120,
        requires_charging = true
    },
    ["blizzard"] = {
        weather_effects = {
            [BattleConditions.WeatherType.HAIL] = {
                accuracy_override = 100, -- Never misses in hail
                description = "Blizzard never misses in hail"
            }
        },
        base_accuracy = 70
    },
    ["moonlight"] = {
        weather_effects = {
            [BattleConditions.WeatherType.SUNNY] = {
                healing_fraction = "2/3", -- 2/3 HP in sun
                description = "Moonlight restores more HP in sun"
            },
            [BattleConditions.WeatherType.RAIN] = {
                healing_fraction = "1/4", -- 1/4 HP in rain
                description = "Moonlight restores less HP in rain"
            },
            [BattleConditions.WeatherType.SANDSTORM] = {
                healing_fraction = "1/4",
                description = "Moonlight restores less HP in sandstorm"
            },
            [BattleConditions.WeatherType.HAIL] = {
                healing_fraction = "1/4",
                description = "Moonlight restores less HP in hail"
            }
        },
        base_healing = "1/2" -- Normal conditions
    },
    ["synthesis"] = {
        weather_effects = {
            [BattleConditions.WeatherType.SUNNY] = {
                healing_fraction = "2/3",
                description = "Synthesis restores more HP in sun"
            },
            [BattleConditions.WeatherType.RAIN] = {
                healing_fraction = "1/4",
                description = "Synthesis restores less HP in rain"
            },
            [BattleConditions.WeatherType.SANDSTORM] = {
                healing_fraction = "1/4",
                description = "Synthesis restores less HP in sandstorm"
            },
            [BattleConditions.WeatherType.HAIL] = {
                healing_fraction = "1/4",
                description = "Synthesis restores less HP in hail"
            }
        },
        base_healing = "1/2"
    },
    ["morning_sun"] = {
        weather_effects = {
            [BattleConditions.WeatherType.SUNNY] = {
                healing_fraction = "2/3",
                description = "Morning Sun restores more HP in sun"
            },
            [BattleConditions.WeatherType.RAIN] = {
                healing_fraction = "1/4",
                description = "Morning Sun restores less HP in rain"
            },
            [BattleConditions.WeatherType.SANDSTORM] = {
                healing_fraction = "1/4",
                description = "Morning Sun restores less HP in sandstorm"
            },
            [BattleConditions.WeatherType.HAIL] = {
                healing_fraction = "1/4",
                description = "Morning Sun restores less HP in hail"
            }
        },
        base_healing = "1/2"
    }
}

-- Get weather-dependent move accuracy modification
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @param baseAccuracy: Base accuracy of the move
-- @return: Modified accuracy, whether it's an override
function BattleConditions.getWeatherMoveAccuracyModifier(moveName, weatherType, baseAccuracy)
    local moveData = BattleConditions.WeatherMoveData[string.lower(moveName)]
    if not moveData or not moveData.weather_effects then
        return baseAccuracy, false
    end
    
    local weatherEffect = moveData.weather_effects[weatherType]
    if not weatherEffect then
        return baseAccuracy, false
    end
    
    if weatherEffect.accuracy_override then
        return weatherEffect.accuracy_override, true
    elseif weatherEffect.accuracy_modifier then
        return math.floor(baseAccuracy * weatherEffect.accuracy_modifier), false
    end
    
    return baseAccuracy, false
end

-- Get weather-dependent move power modification
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @param basePower: Base power of the move
-- @return: Modified power, description of effect
function BattleConditions.getWeatherMovePowerModifier(moveName, weatherType, basePower)
    local moveData = BattleConditions.WeatherMoveData[string.lower(moveName)]
    if not moveData or not moveData.weather_effects then
        return basePower, nil
    end
    
    local weatherEffect = moveData.weather_effects[weatherType]
    if not weatherEffect then
        return basePower, nil
    end
    
    if weatherEffect.power_modifier then
        local modifiedPower = math.floor(basePower * weatherEffect.power_modifier)
        return modifiedPower, weatherEffect.description
    elseif weatherEffect.power_boost then
        return basePower, weatherEffect.description -- No modification, just description
    end
    
    return basePower, weatherEffect.description
end

-- Check if move requires charging and can skip charge phase
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @return: Should skip charge phase, description
function BattleConditions.canSkipChargePhase(moveName, weatherType)
    local moveData = BattleConditions.WeatherMoveData[string.lower(moveName)]
    if not moveData or not moveData.requires_charging or not moveData.weather_effects then
        return false, nil
    end
    
    local weatherEffect = moveData.weather_effects[weatherType]
    if weatherEffect and weatherEffect.charge_skip then
        return true, weatherEffect.description
    end
    
    return false, nil
end

-- Get weather-dependent healing amount for moves
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @param maxHP: Pokemon's maximum HP
-- @return: Healing amount, description
function BattleConditions.getWeatherMoveHealingAmount(moveName, weatherType, maxHP)
    local moveData = BattleConditions.WeatherMoveData[string.lower(moveName)]
    if not moveData then
        return 0, nil
    end
    
    local healingFraction = moveData.base_healing
    local description = "Standard healing"
    
    -- Check for weather-specific healing
    if moveData.weather_effects and moveData.weather_effects[weatherType] then
        local weatherEffect = moveData.weather_effects[weatherType]
        if weatherEffect.healing_fraction then
            healingFraction = weatherEffect.healing_fraction
            description = weatherEffect.description
        end
    end
    
    -- Convert fraction to actual healing amount
    local healingAmount = 0
    if healingFraction == "1/2" then
        healingAmount = math.floor(maxHP / 2)
    elseif healingFraction == "2/3" then
        healingAmount = math.floor(maxHP * 2 / 3)
    elseif healingFraction == "1/4" then
        healingAmount = math.floor(maxHP / 4)
    elseif healingFraction == "3/4" then
        healingAmount = math.floor(maxHP * 3 / 4)
    end
    
    return math.max(1, healingAmount), description
end

-- Check terrain effects on move power and blocking
-- @param moveName: Name of the move (lowercase)
-- @param moveData: Complete move data including type and priority
-- @param terrainType: Current terrain type
-- @param attackerGrounded: Whether attacker is grounded
-- @param targetGrounded: Whether target is grounded
-- @return: Power modifier, blocked status, description
function BattleConditions.getTerrainMoveInteraction(moveName, moveData, terrainType, attackerGrounded, targetGrounded)
    local powerModifier = 1.0
    local blocked = false
    local description = nil
    
    local terrainData = BattleConditions.TerrainData[terrainType]
    if not terrainData then
        return powerModifier, blocked, description
    end
    
    -- Check power boost for grounded attackers
    if attackerGrounded and terrainData.power_boost and moveData.type then
        local boost = terrainData.power_boost[moveData.type]
        if boost then
            powerModifier = boost
            description = terrainData.name .. " boosts " .. moveData.type .. " move power"
        end
    end
    
    -- Check move blocking effects
    if targetGrounded then
        -- Dragon move immunity in Misty Terrain
        if terrainData.dragon_move_immunity and moveData.type == Enums.PokemonType.DRAGON then
            blocked = true
            description = terrainData.name .. " blocks Dragon-type moves"
        end
        
        -- Priority move blocking in Psychic Terrain
        if terrainData.priority_move_immunity and moveData.priority and moveData.priority > 0 then
            blocked = true
            description = terrainData.name .. " blocks priority moves"
        end
    end
    
    -- Check move power reduction (Grassy Terrain reducing ground moves)
    if terrainData.move_power_reduction and moveName then
        local reduction = terrainData.move_power_reduction[string.lower(moveName)]
        if reduction then
            powerModifier = powerModifier * reduction
            description = (description and (description .. ", ") or "") .. terrainData.name .. " reduces " .. moveName .. " power"
        end
    end
    
    return powerModifier, blocked, description
end

-- Process complete move-environment interaction
-- @param moveName: Name of the move
-- @param moveData: Complete move data
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @param attackerGrounded: Whether attacker is grounded
-- @param targetGrounded: Whether target is grounded
-- @param attackerMaxHP: Attacker's max HP (for healing moves)
-- @return: Complete interaction results
function BattleConditions.processMovePveEnvironmentInteraction(moveName, moveData, weatherType, terrainType, attackerGrounded, targetGrounded, attackerMaxHP)
    local results = {
        accuracy_modified = false,
        power_modified = false,
        blocked = false,
        healing_modified = false,
        charge_skipped = false,
        effects = {}
    }
    
    local lowerMoveName = string.lower(moveName)
    
    -- Weather-based accuracy modifications
    local modifiedAccuracy, isOverride = BattleConditions.getWeatherMoveAccuracyModifier(lowerMoveName, weatherType, moveData.accuracy or 100)
    if modifiedAccuracy ~= (moveData.accuracy or 100) then
        results.accuracy_modified = true
        results.final_accuracy = modifiedAccuracy
        results.accuracy_override = isOverride
        table.insert(results.effects, {
            type = "accuracy_change",
            source = "weather",
            value = modifiedAccuracy,
            is_override = isOverride
        })
    end
    
    -- Weather-based power modifications
    local modifiedPower, powerDescription = BattleConditions.getWeatherMovePowerModifier(lowerMoveName, weatherType, moveData.power or 0)
    if modifiedPower ~= (moveData.power or 0) then
        results.power_modified = true
        results.final_power = modifiedPower
        table.insert(results.effects, {
            type = "power_change",
            source = "weather",
            value = modifiedPower,
            description = powerDescription
        })
    end
    
    -- Terrain-based interactions
    local terrainPowerModifier, terrainBlocked, terrainDescription = BattleConditions.getTerrainMoveInteraction(lowerMoveName, moveData, terrainType, attackerGrounded, targetGrounded)
    
    if terrainBlocked then
        results.blocked = true
        table.insert(results.effects, {
            type = "move_blocked",
            source = "terrain",
            description = terrainDescription
        })
    elseif terrainPowerModifier ~= 1.0 then
        results.power_modified = true
        local currentPower = results.final_power or moveData.power or 0
        results.final_power = math.floor(currentPower * terrainPowerModifier)
        table.insert(results.effects, {
            type = "power_change",
            source = "terrain",
            modifier = terrainPowerModifier,
            description = terrainDescription
        })
    end
    
    -- Charge phase skipping
    local canSkipCharge, chargeDescription = BattleConditions.canSkipChargePhase(lowerMoveName, weatherType)
    if canSkipCharge then
        results.charge_skipped = true
        table.insert(results.effects, {
            type = "charge_skipped",
            source = "weather",
            description = chargeDescription
        })
    end
    
    -- Healing move modifications
    if attackerMaxHP and attackerMaxHP > 0 then
        local healingAmount, healingDescription = BattleConditions.getWeatherMoveHealingAmount(lowerMoveName, weatherType, attackerMaxHP)
        if healingAmount > 0 then
            results.healing_modified = true
            results.healing_amount = healingAmount
            table.insert(results.effects, {
                type = "healing_change",
                source = "weather",
                amount = healingAmount,
                description = healingDescription
            })
        end
    end
    
    return results
end

-- Environmental Healing System
-- Comprehensive environmental healing with ability interactions and precedence

-- Process all environmental healing effects with proper precedence
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to process
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @return: Complete healing results with precedence resolution
function BattleConditions.processEnvironmentalHealing(battleId, pokemonList, weatherType, terrainType)
    local healingResults = {
        total_healers = 0,
        healing_effects = {},
        ability_healing = {},
        terrain_healing = {},
        precedence_resolved = {}
    }
    
    -- Process ability-based healing (Rain Dish, Ice Body, Dry Skin)

-- ===== MODULE: game-logic.battle.weather-abilities =====
-- File: ao-processes/game-logic/battle/weather-abilities.lua
-- Original require:     local WeatherAbilities = require("game-logic.battle.weather-abilities")


-- ===== END MODULE: game-logic.battle.weather-abilities =====

    local abilityHealing = WeatherAbilities.processEndOfTurnAbilityEffects(pokemonList, weatherType)
    
    for _, healing in ipairs(abilityHealing) do
        if healing.effect_type == "healing" then
            table.insert(healingResults.ability_healing, healing)
            table.insert(healingResults.healing_effects, {
                pokemon_id = healing.pokemon_id,
                source = "ability",
                ability_name = healing.ability_name,
                healing = healing.healing,
                priority = 1 -- Ability healing has highest priority
            })
        end
    end
    
    -- Process terrain-based healing (Grassy Terrain)
    local terrainHealing = BattleConditions.processTerrainHealing(battleId, terrainType, pokemonList)
    for _, healing in ipairs(terrainHealing) do
        table.insert(healingResults.terrain_healing, healing)
        table.insert(healingResults.healing_effects, {
            pokemon_id = healing.pokemon_id,
            source = "terrain",
            terrain_name = healing.terrain,
            healing = healing.healing,
            priority = 2 -- Terrain healing has second priority
        })
    end
    
    -- Resolve healing precedence and stacking
    local finalHealing = BattleConditions.resolveHealingPrecedence(healingResults.healing_effects, pokemonList)
    healingResults.precedence_resolved = finalHealing
    healingResults.total_healers = #finalHealing
    
    return healingResults
end

-- Resolve healing precedence for Pokemon with multiple healing sources
-- @param healingEffects: List of all healing effects
-- @param pokemonList: List of Pokemon for context
-- @return: Final healing amounts after precedence resolution
function BattleConditions.resolveHealingPrecedence(healingEffects, pokemonList)
    local pokemonHealingMap = {}
    local finalHealing = {}
    
    -- Group healing effects by Pokemon
    for _, effect in ipairs(healingEffects) do
        local pokemonId = effect.pokemon_id
        if not pokemonHealingMap[pokemonId] then
            pokemonHealingMap[pokemonId] = {}
        end
        table.insert(pokemonHealingMap[pokemonId], effect)
    end
    
    -- Resolve healing for each Pokemon
    for pokemonId, effects in pairs(pokemonHealingMap) do
        local pokemon = BattleConditions.findPokemonById(pokemonId, pokemonList)
        if pokemon then
            local totalHealing = 0
            local sources = {}
            
            -- Sort by priority (lower number = higher priority)
            table.sort(effects, function(a, b) return a.priority < b.priority end)
            
            for _, effect in ipairs(effects) do
                -- Check if Pokemon is grounded for terrain effects
                if effect.source == "terrain" and not BattleConditions.isPokemonGrounded(pokemon) then
                    goto continue
                end
                
                totalHealing = totalHealing + effect.healing
                table.insert(sources, effect.source .. ":" .. (effect.ability_name or effect.terrain_name or "unknown"))
                
                ::continue::
            end
            
            if totalHealing > 0 then
                -- Cap healing at missing HP
                local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP] or 100
                local currentHP = pokemon.currentHP or maxHP
                local actualHealing = math.min(totalHealing, maxHP - currentHP)
                
                if actualHealing > 0 then
                    table.insert(finalHealing, {
                        pokemon_id = pokemonId,
                        pokemon_name = pokemon.name or "Unknown Pokemon",
                        total_healing = actualHealing,
                        raw_healing = totalHealing,
                        sources = sources,
                        multiple_sources = #effects > 1
                    })
                end
            end
        end
    end
    
    return finalHealing
end

-- Environmental Damage Precedence System
-- Proper ordering and calculation of environmental damage effects

-- Process all environmental damage effects with proper precedence
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to process
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @return: Complete damage results with precedence resolution
function BattleConditions.processEnvironmentalDamage(battleId, pokemonList, weatherType, terrainType)
    local damageResults = {
        total_damaged = 0,
        damage_effects = {},
        weather_damage = {},
        ability_damage = {},
        precedence_resolved = {}
    }
    
    -- Process weather damage (sandstorm, hail)
    local weatherDamage = BattleConditions.processWeatherDamage(battleId, weatherType, pokemonList)
    for _, damage in ipairs(weatherDamage) do
        table.insert(damageResults.weather_damage, damage)
        table.insert(damageResults.damage_effects, {
            pokemon_id = damage.pokemon_id,
            source = "weather",
            weather_name = damage.weather,
            damage = damage.damage,
            priority = 3 -- Weather damage has lower priority
        })
    end
    
    -- Process ability-based damage (Solar Power, Dry Skin in sun)

-- ===== MODULE: game-logic.battle.weather-abilities =====
-- File: ao-processes/game-logic/battle/weather-abilities.lua
-- Original require:     local WeatherAbilities = require("game-logic.battle.weather-abilities")


-- ===== END MODULE: game-logic.battle.weather-abilities =====

    local abilityEffects = WeatherAbilities.processEndOfTurnAbilityEffects(pokemonList, weatherType)
    
    for _, effect in ipairs(abilityEffects) do
        if effect.effect_type == "damage" then
            table.insert(damageResults.ability_damage, effect)
            table.insert(damageResults.damage_effects, {
                pokemon_id = effect.pokemon_id,
                source = "ability",
                ability_name = effect.ability_name,
                damage = effect.damage,
                priority = 2 -- Ability damage has higher priority than weather
            })
        end
    end
    
    -- Resolve damage precedence
    local finalDamage = BattleConditions.resolveDamagePrecedence(damageResults.damage_effects, pokemonList)
    damageResults.precedence_resolved = finalDamage
    damageResults.total_damaged = #finalDamage
    
    return damageResults
end

-- Resolve damage precedence for Pokemon with multiple damage sources
-- @param damageEffects: List of all damage effects
-- @param pokemonList: List of Pokemon for context
-- @return: Final damage amounts after precedence resolution
function BattleConditions.resolveDamagePrecedence(damageEffects, pokemonList)
    local pokemonDamageMap = {}
    local finalDamage = {}
    
    -- Group damage effects by Pokemon
    for _, effect in ipairs(damageEffects) do
        local pokemonId = effect.pokemon_id
        if not pokemonDamageMap[pokemonId] then
            pokemonDamageMap[pokemonId] = {}
        end
        table.insert(pokemonDamageMap[pokemonId], effect)
    end
    
    -- Resolve damage for each Pokemon
    for pokemonId, effects in pairs(pokemonDamageMap) do
        local pokemon = BattleConditions.findPokemonById(pokemonId, pokemonList)
        if pokemon then
            local totalDamage = 0
            local sources = {}
            
            -- Sort by priority (lower number = higher priority)
            table.sort(effects, function(a, b) return a.priority < b.priority end)
            
            for _, effect in ipairs(effects) do
                totalDamage = totalDamage + effect.damage
                table.insert(sources, effect.source .. ":" .. (effect.ability_name or effect.weather_name or "unknown"))
            end
            
            if totalDamage > 0 then
                -- Cap damage at current HP - 1 (can't faint from environmental damage)
                local currentHP = pokemon.currentHP or pokemon.maxHP or 100
                local actualDamage = math.min(totalDamage, math.max(1, currentHP - 1))
                
                table.insert(finalDamage, {
                    pokemon_id = pokemonId,
                    pokemon_name = pokemon.name or "Unknown Pokemon",
                    total_damage = actualDamage,
                    raw_damage = totalDamage,
                    sources = sources,
                    multiple_sources = #effects > 1
                })
            end
        end
    end
    
    return finalDamage
end

-- Process complete environmental healing and damage with proper timing
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to process
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @return: Complete results with proper precedence timing
function BattleConditions.processCompleteEnvironmentalEffects(battleId, pokemonList, weatherType, terrainType)
    local results = {
        timing_order = {},
        healing_results = {},
        damage_results = {},
        net_effects = {},
        summary = {
            total_healed = 0,
            total_damaged = 0,
            net_healers = 0,
            net_damaged = 0
        }
    }
    
    -- Step 1: Process healing first (higher priority)
    local healingResults = BattleConditions.processEnvironmentalHealing(battleId, pokemonList, weatherType, terrainType)
    results.healing_results = healingResults
    table.insert(results.timing_order, {phase = "healing", count = healingResults.total_healers})
    
    -- Step 2: Process damage second (lower priority)
    local damageResults = BattleConditions.processEnvironmentalDamage(battleId, pokemonList, weatherType, terrainType)
    results.damage_results = damageResults
    table.insert(results.timing_order, {phase = "damage", count = damageResults.total_damaged})
    
    -- Step 3: Calculate net effects per Pokemon
    local pokemonNetEffects = {}
    
    -- Add healing effects
    for _, healing in ipairs(healingResults.precedence_resolved) do
        local pokemonId = healing.pokemon_id
        if not pokemonNetEffects[pokemonId] then
            pokemonNetEffects[pokemonId] = {pokemon_id = pokemonId, pokemon_name = healing.pokemon_name, net_hp_change = 0, effects = {}}
        end
        pokemonNetEffects[pokemonId].net_hp_change = pokemonNetEffects[pokemonId].net_hp_change + healing.total_healing
        table.insert(pokemonNetEffects[pokemonId].effects, {type = "healing", amount = healing.total_healing, sources = healing.sources})
    end
    
    -- Subtract damage effects
    for _, damage in ipairs(damageResults.precedence_resolved) do
        local pokemonId = damage.pokemon_id
        if not pokemonNetEffects[pokemonId] then
            pokemonNetEffects[pokemonId] = {pokemon_id = pokemonId, pokemon_name = damage.pokemon_name, net_hp_change = 0, effects = {}}
        end
        pokemonNetEffects[pokemonId].net_hp_change = pokemonNetEffects[pokemonId].net_hp_change - damage.total_damage
        table.insert(pokemonNetEffects[pokemonId].effects, {type = "damage", amount = damage.total_damage, sources = damage.sources})
    end
    
    -- Convert to array and calculate summary
    for pokemonId, netEffect in pairs(pokemonNetEffects) do
        table.insert(results.net_effects, netEffect)
        
        if netEffect.net_hp_change > 0 then
            results.summary.net_healers = results.summary.net_healers + 1
            results.summary.total_healed = results.summary.total_healed + netEffect.net_hp_change
        elseif netEffect.net_hp_change < 0 then
            results.summary.net_damaged = results.summary.net_damaged + 1
            results.summary.total_damaged = results.summary.total_damaged + math.abs(netEffect.net_hp_change)
        end
    end
    
    return results
end

-- Field Effect Removal System
-- Implementation of Defog and other field effect removal moves

-- Field effect removal move data
BattleConditions.FieldRemovalMoves = {
    ["defog"] = {
        name = "Defog",
        removes = {
            weather = {"all"}, -- Removes all weather except permanent weather
            terrain = {"all"}, -- Removes all terrain
            entry_hazards = {"all"}, -- Would remove entry hazards (future implementation)
            field_conditions = {} -- Does not remove field conditions
        },
        resistance = {
            -- Permanent weather (generated by Primal abilities) has higher resistance
            weather_resistance = {"HARSH_SUN", "HEAVY_RAIN", "STRONG_WINDS"}
        },
        success_rate = 100 -- Defog always succeeds
    },
    ["psychic_terrain"] = {
        name = "Psychic Terrain",
        removes = {
            weather = {}, -- Does not remove weather
            terrain = {"all"}, -- Replaces terrain
            entry_hazards = {},
            field_conditions = {} -- Does not remove field conditions
        },
        success_rate = 100
    },
    ["trick_room"] = {
        name = "Trick Room",
        removes = {
            weather = {},
            terrain = {},
            entry_hazards = {},
            field_conditions = {"TRICK_ROOM"} -- Removes existing Trick Room or creates new one
        },
        success_rate = 100,
        toggle_effect = true -- Can remove or set depending on current state
    },
    ["wonder_room"] = {
        name = "Wonder Room",
        removes = {
            weather = {},
            terrain = {},
            entry_hazards = {},
            field_conditions = {"WONDER_ROOM"} -- Removes existing Wonder Room or creates new one
        },
        success_rate = 100,
        toggle_effect = true
    },
    ["magic_room"] = {
        name = "Magic Room",
        removes = {
            weather = {},
            terrain = {},
            entry_hazards = {},
            field_conditions = {"MAGIC_ROOM"} -- Removes existing Magic Room or creates new one
        },
        success_rate = 100,
        toggle_effect = true
    },
    ["rapid_spin"] = {
        name = "Rapid Spin",
        removes = {
            weather = {}, -- Does not remove weather
            terrain = {}, -- Does not remove terrain
            entry_hazards = {"user_side"}, -- Only removes hazards on user's side
            field_effects = {}
        },
        success_rate = 100
    },
    ["haze"] = {
        name = "Haze",
        removes = {
            weather = {}, -- Does not remove weather/terrain
            terrain = {},
            entry_hazards = {},
            field_effects = {"stat_changes"} -- Removes all stat changes
        },
        success_rate = 100
    }
}

-- Process field effect removal move
-- @param moveName: Name of the removal move
-- @param currentWeather: Current weather type and data
-- @param currentTerrain: Current terrain type and data
-- @param moveUser: Pokemon using the move
-- @param battleState: Current battle state
-- @return: Removal results and updated field conditions
function BattleConditions.processFieldEffectRemoval(moveName, currentWeather, currentTerrain, moveUser, battleState)
    local moveData = BattleConditions.FieldRemovalMoves[string.lower(moveName)]
    if not moveData then
        return {
            success = false,
            reason = "Move does not remove field effects",
            removed_effects = {}
        }
    end
    
    local results = {
        success = true,
        move_name = moveData.name,
        removed_effects = {},
        failed_removals = {},
        new_weather = currentWeather,
        new_terrain = currentTerrain,
        removal_messages = {}
    }
    
    -- Process weather removal
    if moveData.removes.weather and #moveData.removes.weather > 0 then
        local weatherRemoval = BattleConditions.processWeatherRemoval(moveData, currentWeather, moveUser)
        if weatherRemoval.removed then
            results.new_weather = {
                type = BattleConditions.WeatherType.NONE,
                duration = 0,
                source = "none"
            }
            table.insert(results.removed_effects, {
                type = "weather",
                previous = currentWeather,
                reason = "Removed by " .. moveData.name
            })
            table.insert(results.removal_messages, weatherRemoval.message)
        else
            table.insert(results.failed_removals, {
                type = "weather",
                reason = weatherRemoval.reason
            })
        end
    end
    
    -- Process terrain removal
    if moveData.removes.terrain and #moveData.removes.terrain > 0 then
        local terrainRemoval = BattleConditions.processTerrainRemoval(moveData, currentTerrain, moveUser)
        if terrainRemoval.removed then
            results.new_terrain = {
                type = BattleConditions.TerrainType.NONE,
                duration = 0,
                source = "none"
            }
            table.insert(results.removed_effects, {
                type = "terrain",
                previous = currentTerrain,
                reason = "Removed by " .. moveData.name
            })
            table.insert(results.removal_messages, terrainRemoval.message)
        else
            table.insert(results.failed_removals, {
                type = "terrain",
                reason = terrainRemoval.reason
            })
        end
    end
    
    -- Process field condition removal
    if moveData.removes.field_conditions and #moveData.removes.field_conditions > 0 then
        local fieldConditionRemoval = BattleConditions.processFieldConditionRemoval(moveData, battleState.fieldConditions, moveUser)
        if fieldConditionRemoval.removed or fieldConditionRemoval.toggled then
            results.new_field_conditions = fieldConditionRemoval.new_field_conditions
            for _, removed in ipairs(fieldConditionRemoval.removed_conditions or {}) do
                table.insert(results.removed_effects, {
                    type = "field_condition",
                    previous = removed,
                    reason = "Removed by " .. moveData.name
                })
                table.insert(results.removal_messages, fieldConditionRemoval.message or (removed.name .. " was removed!"))
            end
        else
            if fieldConditionRemoval.created then
                results.new_field_conditions = fieldConditionRemoval.new_field_conditions
                table.insert(results.removal_messages, fieldConditionRemoval.message or (moveData.name .. " was activated!"))
            end
        end
    end
    
    -- Process other field effects (future expansion)
    if moveData.removes.field_effects and #moveData.removes.field_effects > 0 then
        for _, effectType in ipairs(moveData.removes.field_effects) do
            if effectType == "stat_changes" then
                table.insert(results.removed_effects, {
                    type = "stat_changes",
                    reason = "All stat changes removed by " .. moveData.name
                })
                table.insert(results.removal_messages, "All stat changes were removed!")
            end
        end
    end
    
    return results
end

-- Process weather removal with resistance checks
-- @param moveData: Move data for the removal move
-- @param currentWeather: Current weather state
-- @param moveUser: Pokemon using the removal move
-- @return: Weather removal result
function BattleConditions.processWeatherRemoval(moveData, currentWeather, moveUser)
    if not currentWeather or currentWeather.type == BattleConditions.WeatherType.NONE then
        return {
            removed = false,
            reason = "No weather to remove",
            message = "There is no weather to clear!"
        }
    end
    
    -- Check if weather type has resistance
    if moveData.resistance and moveData.resistance.weather_resistance then
        local weatherName = BattleConditions.WeatherTypeName[currentWeather.type] or "UNKNOWN"
        for _, resistantWeather in ipairs(moveData.resistance.weather_resistance) do
            if weatherName == resistantWeather then
                return {
                    removed = false,
                    reason = "Weather is too strong to be removed",
                    message = "The " .. (BattleConditions.WeatherData[currentWeather.type] and BattleConditions.WeatherData[currentWeather.type].name or "weather") .. " is too strong to be blown away!"
                }
            end
        end
    end
    
    -- Check if it's ability-generated weather with remaining duration
    if currentWeather.source == "ability" and currentWeather.duration > 1 then
        -- Reduce duration instead of removing completely
        return {
            removed = false,
            duration_reduced = true,
            new_duration = math.max(1, currentWeather.duration - 2),
            reason = "Ability-generated weather partially resisted",
            message = "The weather weakened but persists!"
        }
    end
    
    -- Weather can be removed
    local weatherData = BattleConditions.WeatherData[currentWeather.type]
    local weatherName = weatherData and weatherData.name or "weather"
    
    return {
        removed = true,
        message = "The " .. weatherName .. " was blown away!"
    }
end

-- Process terrain removal with resistance checks
-- @param moveData: Move data for the removal move
-- @param currentTerrain: Current terrain state
-- @param moveUser: Pokemon using the removal move
-- @return: Terrain removal result
function BattleConditions.processTerrainRemoval(moveData, currentTerrain, moveUser)
    if not currentTerrain or currentTerrain.type == BattleConditions.TerrainType.NONE then
        return {
            removed = false,
            reason = "No terrain to remove",
            message = "There is no terrain to clear!"
        }
    end
    
    -- Check if it's ability-generated terrain with remaining duration
    if currentTerrain.source == "ability" and currentTerrain.duration > 1 then
        return {
            removed = false,
            duration_reduced = true,
            new_duration = math.max(1, currentTerrain.duration - 1),
            reason = "Ability-generated terrain partially resisted",
            message = "The terrain weakened but persists!"
        }
    end
    
    -- Terrain can be removed
    local terrainData = BattleConditions.TerrainData[currentTerrain.type]
    local terrainName = terrainData and terrainData.name or "terrain"
    
    return {
        removed = true,
        message = "The " .. terrainName .. " disappeared!"
    }
end

-- Process field condition removal with toggle support
-- @param moveData: Move data for the removal move
-- @param currentFieldConditions: Current field conditions
-- @param moveUser: Pokemon using the removal move
-- @return: Field condition removal result
function BattleConditions.processFieldConditionRemoval(moveData, currentFieldConditions, moveUser)
    if not moveData.removes.field_conditions or #moveData.removes.field_conditions == 0 then
        return {
            removed = false,
            toggled = false,
            created = false,
            reason = "Move does not affect field conditions",
            message = "No field conditions to affect!"
        }
    end
    
    local results = {
        removed = false,
        toggled = false,
        created = false,
        removed_conditions = {},
        new_field_conditions = currentFieldConditions or {},
        messages = {}
    }
    

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    -- Handle each field condition type
    for _, conditionTypeName in ipairs(moveData.removes.field_conditions) do
        local conditionType = BattleConditions.FieldEffectType[conditionTypeName]
        if not conditionType then
            goto continue
        end
        
        -- Check if this is a toggle move (field condition moves that can remove themselves)
        if moveData.toggle_effect then
            -- Check if condition is already active
            if currentFieldConditions and currentFieldConditions[conditionType] and 
               currentFieldConditions[conditionType].duration and 
               currentFieldConditions[conditionType].duration > 0 then
                
                -- Remove existing condition
                table.insert(results.removed_conditions, currentFieldConditions[conditionType])
                results.new_field_conditions[conditionType] = nil
                results.removed = true
                results.toggled = true
                
                local conditionData = BattleConditions.FieldConditionData[conditionType]
                local conditionName = conditionData and conditionData.name or "Field Condition"
                table.insert(results.messages, conditionName .. " wore off!")
                
            else
                -- Create new condition
                local success, conditionResult = FieldConditions.setFieldEffect(
                    "battle", conditionType, nil, "move", moveUser
                )
                
                if success then
                    results.new_field_conditions[conditionType] = {
                        type = conditionType,
                        duration = conditionResult.duration,
                        source = "move",
                        source_pokemon = moveUser,
                        field_effect_name = conditionResult.field_effect_name,
                        timestamp = conditionResult.timestamp
                    }
                    
                    -- Copy effect data
                    if conditionResult.priority_reversal then
                        results.new_field_conditions[conditionType].effects = {priority_reversal = true}
                    elseif conditionResult.stat_swap then
                        results.new_field_conditions[conditionType].effects = {stat_swap = conditionResult.stat_swap}
                    elseif conditionResult.suppresses_items then
                        results.new_field_conditions[conditionType].effects = {suppresses_items = true}
                    end
                    
                    results.created = true
                    results.toggled = true
                    table.insert(results.messages, conditionResult.field_effect_name .. " was activated!")
                end
            end
        else
            -- Non-toggle removal (like Defog)
            if currentFieldConditions and currentFieldConditions[conditionType] and 
               currentFieldConditions[conditionType].duration and 
               currentFieldConditions[conditionType].duration > 0 then
                
                table.insert(results.removed_conditions, currentFieldConditions[conditionType])
                results.new_field_conditions[conditionType] = nil
                results.removed = true
                
                local conditionData = BattleConditions.FieldConditionData[conditionType]
                local conditionName = conditionData and conditionData.name or "Field Condition"
                table.insert(results.messages, conditionName .. " was blown away!")
            end
        end
        
        ::continue::
    end
    
    -- Set final message
    if #results.messages > 0 then
        results.message = table.concat(results.messages, " ")
    elseif results.removed then
        results.message = "Field conditions were cleared!"
    elseif results.created then
        results.message = "Field condition was activated!"
    else
        results.message = "No field conditions were affected!"
    end
    
    return results
end

-- Check if field effects can be removed by move
-- @param moveName: Name of the move to check
-- @param fieldConditions: Current field conditions to check
-- @return: Information about what can be removed
function BattleConditions.checkRemovalPotential(moveName, fieldConditions)
    local moveData = BattleConditions.FieldRemovalMoves[string.lower(moveName)]
    if not moveData then
        return {
            can_remove = false,
            reason = "Move does not remove field effects",
            removable_effects = {}
        }
    end
    
    local removableEffects = {}
    
    -- Check weather removal potential
    if moveData.removes.weather and #moveData.removes.weather > 0 and fieldConditions.weather then
        if fieldConditions.weather.type ~= BattleConditions.WeatherType.NONE then
            local canRemove = true
            local reason = "Can remove weather"
            
            -- Check resistance
            if moveData.resistance and moveData.resistance.weather_resistance then
                local weatherName = BattleConditions.WeatherTypeName[fieldConditions.weather.type] or "UNKNOWN"
                for _, resistantWeather in ipairs(moveData.resistance.weather_resistance) do
                    if weatherName == resistantWeather then
                        canRemove = false
                        reason = "Weather has resistance"
                        break
                    end
                end
            end
            
            table.insert(removableEffects, {
                type = "weather",
                can_remove = canRemove,
                reason = reason,
                current_weather = fieldConditions.weather
            })
        end
    end
    
    -- Check terrain removal potential
    if moveData.removes.terrain and #moveData.removes.terrain > 0 and fieldConditions.terrain then
        if fieldConditions.terrain.type ~= BattleConditions.TerrainType.NONE then
            table.insert(removableEffects, {
                type = "terrain",
                can_remove = true,
                reason = "Can remove terrain",
                current_terrain = fieldConditions.terrain
            })
        end
    end
    
    return {
        can_remove = #removableEffects > 0,
        move_name = moveData.name,
        removable_effects = removableEffects
    }
end

-- Get list of all available field removal moves
-- @return: List of field removal moves and their capabilities
function BattleConditions.getFieldRemovalMoves()
    local moves = {}
    
    for moveName, moveData in pairs(BattleConditions.FieldRemovalMoves) do
        table.insert(moves, {
            name = moveName,
            display_name = moveData.name,
            removes_weather = #(moveData.removes.weather or {}) > 0,
            removes_terrain = #(moveData.removes.terrain or {}) > 0,
            removes_hazards = #(moveData.removes.entry_hazards or {}) > 0,
            removes_field_effects = #(moveData.removes.field_effects or {}) > 0,
            success_rate = moveData.success_rate
        })
    end
    
    return moves
end

-- Environmental Effect Notification System
-- Comprehensive messaging system for environmental effects with proper timing

-- Notification types and priorities
BattleConditions.NotificationType = {
    WEATHER_CHANGE = "weather_change",
    TERRAIN_CHANGE = "terrain_change",
    ABILITY_ACTIVATION = "ability_activation",
    ENVIRONMENTAL_DAMAGE = "environmental_damage",
    ENVIRONMENTAL_HEALING = "environmental_healing",
    MOVE_INTERACTION = "move_interaction",
    EFFECT_SUPPRESSION = "effect_suppression",
    FIELD_REMOVAL = "field_removal"
}

BattleConditions.NotificationPriority = {
    IMMEDIATE = 1,
    HIGH = 2,
    MEDIUM = 3,
    LOW = 4
}

-- Generate comprehensive environmental effect notifications
-- @param environmentalResults: Results from environmental processing
-- @param battleTurn: Current battle turn
-- @param timing: When notifications should be shown ("start_turn", "end_turn", etc.)
-- @return: Formatted notifications ready for display
function BattleConditions.generateEnvironmentalNotifications(environmentalResults, battleTurn, timing)
    local notifications = {
        turn = battleTurn,
        timing = timing,
        messages = {},
        priority_groups = {
            immediate = {},
            high = {},
            medium = {},
            low = {}
        }
    }
    
    -- Process weather change notifications
    if environmentalResults.weather_changes then
        for _, change in ipairs(environmentalResults.weather_changes) do
            local notification = BattleConditions.createWeatherChangeNotification(change)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Process terrain change notifications
    if environmentalResults.terrain_changes then
        for _, change in ipairs(environmentalResults.terrain_changes) do
            local notification = BattleConditions.createTerrainChangeNotification(change)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Process ability activation notifications
    if environmentalResults.ability_activations then
        for _, activation in ipairs(environmentalResults.ability_activations) do
            local notification = BattleConditions.createAbilityActivationNotification(activation)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Process environmental healing notifications
    if environmentalResults.healing_results and environmentalResults.healing_results.precedence_resolved then
        for _, healing in ipairs(environmentalResults.healing_results.precedence_resolved) do
            local notification = BattleConditions.createHealingNotification(healing)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Process environmental damage notifications
    if environmentalResults.damage_results and environmentalResults.damage_results.precedence_resolved then
        for _, damage in ipairs(environmentalResults.damage_results.precedence_resolved) do
            local notification = BattleConditions.createDamageNotification(damage)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Process move interaction notifications
    if environmentalResults.move_interactions then
        for _, interaction in ipairs(environmentalResults.move_interactions) do
            local notification = BattleConditions.createMoveInteractionNotification(interaction)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Process suppression notifications
    if environmentalResults.suppression_changes then
        for _, suppression in ipairs(environmentalResults.suppression_changes) do
            local notification = BattleConditions.createSuppressionNotification(suppression)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Process field removal notifications
    if environmentalResults.field_removals then
        for _, removal in ipairs(environmentalResults.field_removals) do
            local notification = BattleConditions.createFieldRemovalNotification(removal)
            BattleConditions.addNotificationToPriorityGroup(notifications, notification)
        end
    end
    
    -- Compile final message list in priority order
    local finalMessages = {}
    
    -- Add messages by priority
    for _, msg in ipairs(notifications.priority_groups.immediate) do
        table.insert(finalMessages, msg)
    end
    for _, msg in ipairs(notifications.priority_groups.high) do
        table.insert(finalMessages, msg)
    end
    for _, msg in ipairs(notifications.priority_groups.medium) do
        table.insert(finalMessages, msg)
    end
    for _, msg in ipairs(notifications.priority_groups.low) do
        table.insert(finalMessages, msg)
    end
    
    notifications.messages = finalMessages
    
    return notifications
end

-- Create weather change notification
-- @param weatherChange: Weather change data
-- @return: Formatted notification
function BattleConditions.createWeatherChangeNotification(weatherChange)
    local weatherData = BattleConditions.WeatherData[weatherChange.new_weather]
    local weatherName = weatherData and weatherData.name or "Unknown Weather"
    
    local message = ""
    if weatherChange.new_weather == BattleConditions.WeatherType.NONE then
        message = "The weather cleared up!"
    else
        if weatherChange.source == "ability" then
            message = weatherChange.pokemon_name .. "'s " .. (weatherChange.ability_name or "ability") .. " made it " .. string.lower(weatherName) .. "!"
        elseif weatherChange.source == "move" then
            message = weatherChange.pokemon_name .. " used " .. (weatherChange.move_name or "a move") .. "! It became " .. string.lower(weatherName) .. "!"
        else
            message = "It became " .. string.lower(weatherName) .. "!"
        end
    end
    
    return {
        type = BattleConditions.NotificationType.WEATHER_CHANGE,
        priority = BattleConditions.NotificationPriority.HIGH,
        message = message,
        weather_type = weatherChange.new_weather,
        source = weatherChange.source
    }
end

-- Create terrain change notification
-- @param terrainChange: Terrain change data
-- @return: Formatted notification
function BattleConditions.createTerrainChangeNotification(terrainChange)
    local terrainData = BattleConditions.TerrainData[terrainChange.new_terrain]
    local terrainName = terrainData and terrainData.name or "Unknown Terrain"
    
    local message = ""
    if terrainChange.new_terrain == BattleConditions.TerrainType.NONE then
        message = "The terrain returned to normal!"
    else
        if terrainChange.source == "ability" then
            message = terrainChange.pokemon_name .. "'s " .. (terrainChange.ability_name or "ability") .. " created " .. terrainName .. "!"
        elseif terrainChange.source == "move" then
            message = terrainChange.pokemon_name .. " used " .. (terrainChange.move_name or "a move") .. "! The battlefield became " .. terrainName .. "!"
        else
            message = "The battlefield became " .. terrainName .. "!"
        end
    end
    
    return {
        type = BattleConditions.NotificationType.TERRAIN_CHANGE,
        priority = BattleConditions.NotificationPriority.HIGH,
        message = message,
        terrain_type = terrainChange.new_terrain,
        source = terrainChange.source
    }
end

-- Create ability activation notification
-- @param activation: Ability activation data
-- @return: Formatted notification
function BattleConditions.createAbilityActivationNotification(activation)
    local message = activation.pokemon_name .. "'s " .. activation.ability_name .. " activated!"
    
    if activation.effect_description then
        message = message .. " " .. activation.effect_description
    end
    
    return {
        type = BattleConditions.NotificationType.ABILITY_ACTIVATION,
        priority = BattleConditions.NotificationPriority.MEDIUM,
        message = message,
        ability_name = activation.ability_name,
        pokemon_name = activation.pokemon_name
    }
end

-- Create environmental healing notification
-- @param healing: Healing effect data
-- @return: Formatted notification
function BattleConditions.createHealingNotification(healing)
    local message = healing.pokemon_name .. " restored " .. healing.total_healing .. " HP"
    
    if healing.multiple_sources then
        message = message .. " from multiple environmental effects!"
    else
        local sourceDesc = table.concat(healing.sources, ", ")
        message = message .. " from " .. sourceDesc .. "!"
    end
    
    return {
        type = BattleConditions.NotificationType.ENVIRONMENTAL_HEALING,
        priority = BattleConditions.NotificationPriority.MEDIUM,
        message = message,
        healing_amount = healing.total_healing,
        pokemon_name = healing.pokemon_name
    }
end

-- Create environmental damage notification
-- @param damage: Damage effect data
-- @return: Formatted notification
function BattleConditions.createDamageNotification(damage)
    local message = damage.pokemon_name .. " took " .. damage.total_damage .. " damage"
    
    if damage.multiple_sources then
        message = message .. " from multiple environmental effects!"
    else
        local sourceDesc = table.concat(damage.sources, ", ")
        message = message .. " from " .. sourceDesc .. "!"
    end
    
    return {
        type = BattleConditions.NotificationType.ENVIRONMENTAL_DAMAGE,
        priority = BattleConditions.NotificationPriority.MEDIUM,
        message = message,
        damage_amount = damage.total_damage,
        pokemon_name = damage.pokemon_name
    }
end

-- Create move interaction notification
-- @param interaction: Move interaction data
-- @return: Formatted notification
function BattleConditions.createMoveInteractionNotification(interaction)
    local message = ""
    
    if interaction.blocked then
        message = interaction.move_name .. " was blocked by environmental conditions!"
    elseif interaction.power_modified then
        if interaction.final_power > interaction.original_power then
            message = interaction.move_name .. "'s power was boosted by environmental conditions!"
        else
            message = interaction.move_name .. "'s power was reduced by environmental conditions!"
        end
    elseif interaction.accuracy_modified then
        if interaction.accuracy_override then
            message = interaction.move_name .. " can't miss due to environmental conditions!"
        else
            message = interaction.move_name .. "'s accuracy was affected by environmental conditions!"
        end
    end
    
    return {
        type = BattleConditions.NotificationType.MOVE_INTERACTION,
        priority = BattleConditions.NotificationPriority.HIGH,
        message = message,
        move_name = interaction.move_name,
        interaction_type = interaction.interaction_type
    }
end

-- Create suppression notification
-- @param suppression: Effect suppression data
-- @return: Formatted notification
function BattleConditions.createSuppressionNotification(suppression)
    local message = ""
    
    if suppression.suppression_started then
        message = suppression.pokemon_name .. "'s " .. suppression.ability_name .. " suppressed the effects of weather!"
    elseif suppression.suppression_ended then
        message = "The weather effects returned as " .. suppression.pokemon_name .. " left the battle!"
    end
    
    return {
        type = BattleConditions.NotificationType.EFFECT_SUPPRESSION,
        priority = BattleConditions.NotificationPriority.HIGH,
        message = message,
        ability_name = suppression.ability_name,
        pokemon_name = suppression.pokemon_name
    }
end

-- Create field removal notification
-- @param removal: Field removal data
-- @return: Formatted notification
function BattleConditions.createFieldRemovalNotification(removal)
    local messages = {}
    
    for _, effect in ipairs(removal.removed_effects) do
        if effect.type == "weather" then
            table.insert(messages, "The weather cleared up!")
        elseif effect.type == "terrain" then
            table.insert(messages, "The terrain returned to normal!")
        end
    end
    
    local combinedMessage = table.concat(messages, " ")
    if combinedMessage == "" then
        combinedMessage = removal.move_name .. " was used!"
    end
    
    return {
        type = BattleConditions.NotificationType.FIELD_REMOVAL,
        priority = BattleConditions.NotificationPriority.HIGH,
        message = combinedMessage,
        move_name = removal.move_name,
        removed_count = #removal.removed_effects
    }
end

-- Add notification to appropriate priority group
-- @param notifications: Notification collection
-- @param notification: Individual notification to add
function BattleConditions.addNotificationToPriorityGroup(notifications, notification)
    if notification.priority == BattleConditions.NotificationPriority.IMMEDIATE then
        table.insert(notifications.priority_groups.immediate, notification)
    elseif notification.priority == BattleConditions.NotificationPriority.HIGH then
        table.insert(notifications.priority_groups.high, notification)
    elseif notification.priority == BattleConditions.NotificationPriority.MEDIUM then
        table.insert(notifications.priority_groups.medium, notification)
    else
        table.insert(notifications.priority_groups.low, notification)
    end
end

-- Format notifications for battle message system
-- @param notifications: Generated notifications
-- @param messageFormat: Format type ("simple", "detailed", "json")
-- @return: Formatted message data
function BattleConditions.formatNotificationsForBattle(notifications, messageFormat)
    messageFormat = messageFormat or "simple"
    
    if messageFormat == "simple" then
        local messages = {}
        for _, notification in ipairs(notifications.messages) do
            table.insert(messages, notification.message)
        end
        return messages
    elseif messageFormat == "detailed" then
        return {
            turn = notifications.turn,
            timing = notifications.timing,
            message_count = #notifications.messages,
            messages = notifications.messages
        }
    elseif messageFormat == "json" then
        -- Would return JSON-formatted string in actual implementation
        return notifications
    end
    
    return notifications.messages
end

-- Field Condition Integration Functions
-- Integrates field conditions with existing environmental systems

-- Set field condition with environmental interaction checks
-- @param battleId: Battle instance identifier
-- @param fieldConditionType: Type of field condition to set
-- @param duration: Duration of the field condition
-- @param source: Source of the field condition
-- @return: Success status and field condition details
function BattleConditions.setFieldCondition(battleId, fieldConditionType, duration, source)
    if not battleId or not fieldConditionType then
        return false, "Invalid parameters for field condition"
    end
    

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    return FieldConditions.setFieldEffect(battleId, fieldConditionType, duration, source)
end

-- Process combined environmental and field condition effects
-- @param battleId: Battle instance identifier
-- @param pokemonList: List of Pokemon to process
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @param fieldConditions: Current field conditions
-- @return: Complete environmental effects with field condition interactions
function BattleConditions.processCompleteEnvironmentalAndFieldEffects(battleId, pokemonList, weatherType, terrainType, fieldConditions)
    local results = {
        environmental_effects = {},
        field_condition_effects = {},
        combined_interactions = {},
        final_effects = {}
    }
    
    -- Step 1: Process standard environmental effects
    local environmentalResults = BattleConditions.processCompleteEnvironmentalEffects(
        battleId, pokemonList, weatherType, terrainType
    )
    results.environmental_effects = environmentalResults
    
    -- Step 2: Process field condition effects
    if fieldConditions then

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:         local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

        
        -- Process priority effects (Trick Room)
        local priorityEffects = {}
        for conditionType, conditionData in pairs(fieldConditions) do
            if conditionType == BattleConditions.FieldEffectType.TRICK_ROOM and 
               conditionData.duration and conditionData.duration > 0 then
                table.insert(priorityEffects, {
                    type = "priority_reversal",
                    condition = "Trick Room",
                    duration = conditionData.duration
                })
            end
        end
        
        -- Process stat modification effects (Wonder Room)
        local statModificationEffects = {}
        for conditionType, conditionData in pairs(fieldConditions) do
            if conditionType == BattleConditions.FieldEffectType.WONDER_ROOM and 
               conditionData.duration and conditionData.duration > 0 then
                for _, pokemon in ipairs(pokemonList) do
                    table.insert(statModificationEffects, {
                        type = "stat_swap",
                        condition = "Wonder Room",
                        pokemon_id = pokemon.id,
                        swap = "defense_special_defense",
                        duration = conditionData.duration
                    })
                end
            end
        end
        
        -- Process item suppression effects (Magic Room)
        local itemSuppressionEffects = {}
        for conditionType, conditionData in pairs(fieldConditions) do
            if conditionType == BattleConditions.FieldEffectType.MAGIC_ROOM and 
               conditionData.duration and conditionData.duration > 0 then
                for _, pokemon in ipairs(pokemonList) do
                    if pokemon.heldItem then
                        table.insert(itemSuppressionEffects, {
                            type = "item_suppression",
                            condition = "Magic Room",
                            pokemon_id = pokemon.id,
                            suppressed_item = pokemon.heldItem,
                            duration = conditionData.duration
                        })
                    end
                end
            end
        end
        
        results.field_condition_effects = {
            priority_effects = priorityEffects,
            stat_modification_effects = statModificationEffects,
            item_suppression_effects = itemSuppressionEffects
        }
    end
    
    -- Step 3: Check for interactions between field conditions and environmental effects
    local interactions = BattleConditions.checkFieldConditionEnvironmentalInteractions(
        weatherType, terrainType, fieldConditions
    )
    results.combined_interactions = interactions
    
    -- Step 4: Combine all effects with proper precedence
    results.final_effects = BattleConditions.combineAllBattleEffects(
        environmentalResults.final_effects or {},
        results.field_condition_effects,
        interactions
    )
    
    return results
end

-- Check interactions between field conditions and environmental effects
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @param fieldConditions: Current field conditions
-- @return: Interaction information
function BattleConditions.checkFieldConditionEnvironmentalInteractions(weatherType, terrainType, fieldConditions)
    local interactions = {
        weather_interactions = {},
        terrain_interactions = {},
        field_interactions = {},
        precedence_rules = {}
    }
    
    if not fieldConditions then
        return interactions
    end
    
    -- Check Gravity interactions with terrain
    for conditionType, conditionData in pairs(fieldConditions) do
        if conditionType == BattleConditions.FieldEffectType.GRAVITY and 
           conditionData.duration and conditionData.duration > 0 then
            
            -- Gravity makes all Pokemon grounded, affecting terrain interactions
            if terrainType ~= BattleConditions.TerrainType.NONE then
                table.insert(interactions.terrain_interactions, {
                    field_condition = "Gravity",
                    terrain_type = terrainType,
                    interaction = "grounds_all_pokemon",
                    effect = "All Pokemon are affected by terrain regardless of type/ability"
                })
            end
        end
    end
    
    -- Field conditions generally don't conflict with weather/terrain
    -- They operate on different mechanics (priority, stats, items vs damage/healing)
    table.insert(interactions.precedence_rules, {
        rule = "field_conditions_independent",
        description = "Field conditions operate independently from weather and terrain"
    })
    
    return interactions
end

-- Combine all battle effects with proper precedence
-- @param environmentalEffects: Environmental effects (weather/terrain)
-- @param fieldConditionEffects: Field condition effects
-- @param interactions: Interaction data
-- @return: Combined effects list
function BattleConditions.combineAllBattleEffects(environmentalEffects, fieldConditionEffects, interactions)
    local combinedEffects = {}
    
    -- Add environmental effects (healing, damage)
    for _, effect in ipairs(environmentalEffects) do
        table.insert(combinedEffects, {
            type = "environmental",
            category = effect.effect_type or "unknown",
            pokemon_id = effect.pokemon_id,
            amount = effect.healing or effect.damage or 0,
            source = effect.sources and table.concat(effect.sources, ", ") or "environmental",
            priority = 2 -- Environmental effects have medium priority
        })
    end
    
    -- Add field condition effects (these are applied during different phases)
    if fieldConditionEffects then
        -- Priority effects don't appear in final effects (they affect turn order calculation)
        
        -- Stat modifications are applied during damage calculation
        if fieldConditionEffects.stat_modification_effects then
            for _, effect in ipairs(fieldConditionEffects.stat_modification_effects) do
                table.insert(combinedEffects, {
                    type = "field_condition",
                    category = "stat_modification",
                    pokemon_id = effect.pokemon_id,
                    modification = effect.swap,
                    source = effect.condition,
                    priority = 1 -- Highest priority (applied first)
                })
            end
        end
        
        -- Item suppression effects
        if fieldConditionEffects.item_suppression_effects then
            for _, effect in ipairs(fieldConditionEffects.item_suppression_effects) do
                table.insert(combinedEffects, {
                    type = "field_condition",
                    category = "item_suppression",
                    pokemon_id = effect.pokemon_id,
                    suppressed_item = effect.suppressed_item,
                    source = effect.condition,
                    priority = 1 -- High priority
                })
            end
        end
    end
    
    -- Sort by priority (lower number = higher priority)
    table.sort(combinedEffects, function(a, b) 
        return (a.priority or 999) < (b.priority or 999) 
    end)
    
    return combinedEffects
end

-- Update field condition durations
-- @param fieldConditions: Current field conditions
-- @return: Updated field conditions and expired conditions
function BattleConditions.updateFieldConditionDurations(fieldConditions)
    if not fieldConditions then
        return {}, {}
    end
    
    local updatedConditions = {}
    local expiredConditions = {}
    

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require:     local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====

    
    for conditionType, conditionData in pairs(fieldConditions) do
        if conditionData.duration then
            local newDuration, shouldExpire = FieldConditions.updateFieldConditionDuration(
                conditionType, conditionData.duration
            )
            
            if shouldExpire then
                table.insert(expiredConditions, {
                    type = conditionType,
                    name = conditionData.field_effect_name or "Unknown Field Condition",
                    expired_duration = conditionData.duration
                })
            else
                -- Update duration
                local updatedCondition = {}
                for k, v in pairs(conditionData) do
                    updatedCondition[k] = v
                end
                updatedCondition.duration = newDuration
                updatedConditions[conditionType] = updatedCondition
            end
        else
            -- Permanent condition
            updatedConditions[conditionType] = conditionData
        end
    end
    
    return updatedConditions, expiredConditions
end

-- Check field condition coexistence rules
-- @param currentFieldConditions: Currently active field conditions
-- @param newFieldCondition: New field condition being added
-- @return: Coexistence result and any conflicts
function BattleConditions.checkFieldConditionCoexistence(currentFieldConditions, newFieldCondition)
    local result = {
        can_coexist = true,
        conflicts = {},
        replacements = {},
        allowed = true
    }
    
    if not currentFieldConditions or not newFieldCondition then
        return result
    end
    
    local newType = newFieldCondition.field_effect_type
    
    -- Check for same type replacement
    if currentFieldConditions[newType] then
        table.insert(result.replacements, {
            type = newType,
            old_condition = currentFieldConditions[newType],
            new_condition = newFieldCondition,
            reason = "Same field condition type replaces existing"
        })
    end
    
    -- Field conditions can generally coexist
    -- Trick Room, Wonder Room, and Magic Room all operate on different mechanics
    result.can_coexist = true
    result.allowed = true
    
    return result
end

-- Process side effect duration countdown (integrates with environmental system)
-- @param battleState: Current battle state
-- @return: Table of expired side effects by side
function BattleConditions.processSideEffectTurnEnd(battleState)

-- ===== MODULE: game-logic.battle.side-effects =====
-- File: ao-processes/game-logic/battle/side-effects.lua
-- Original require:     local SideEffects = require("game-logic.battle.side-effects")


-- ===== END MODULE: game-logic.battle.side-effects =====

    return SideEffects.processTurnEnd(battleState)
end

-- Initialize side effects for battle
-- @param battleState: Current battle state
-- @return: Success boolean
function BattleConditions.initializeSideEffects(battleState)

-- ===== MODULE: game-logic.battle.side-effects =====
-- File: ao-processes/game-logic/battle/side-effects.lua
-- Original require:     local SideEffects = require("game-logic.battle.side-effects")


-- ===== END MODULE: game-logic.battle.side-effects =====

    
    -- Initialize for both sides
    SideEffects.initializeSideEffects(battleState, "player")
    SideEffects.initializeSideEffects(battleState, "enemy")
    
    return true
end

-- Positional Tag Effects System
-- Handle position-specific effects that track duration and application per battlefield position

-- Positional tag types
BattleConditions.PositionalTagType = {
    SUBSTITUTE_POSITION = "substitute_position", -- Position-specific substitutes
    POSITION_BARRIER = "position_barrier", -- Position-specific barriers
    POSITION_CURSE = "position_curse", -- Position-specific curses
    POSITION_TRAP = "position_trap", -- Position-specific traps
    CUSTOM_POSITION_EFFECT = "custom_position_effect" -- Custom positional effects
}

-- Initialize positional tag effects for battle
-- @param battleState: Current battle state
-- @return: Success boolean
function BattleConditions.initializePositionalTags(battleState)
    if not battleState then
        return false
    end
    
    -- Initialize positional tag tracking
    if not battleState.positionalTags then
        battleState.positionalTags = {
            player = {},
            enemy = {}
        }
    end
    
    -- Initialize position-specific storage based on battle format
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    
    for side = 1, 2 do
        local sideName = side == 1 and "player" or "enemy"
        
        for position = 1, formatInfo.max_active_per_side do
            if not battleState.positionalTags[sideName][position] then
                battleState.positionalTags[sideName][position] = {}
            end
        end
    end
    
    return true
end

-- Apply positional tag effect to specific position
-- @param battleState: Current battle state
-- @param side: "player" or "enemy"
-- @param position: Position index (1 for left/single, 2 for right)
-- @param tagType: Type of positional tag
-- @param duration: Effect duration in turns
-- @param effectData: Additional effect data
-- @return: Success boolean and result message
function BattleConditions.applyPositionalTag(battleState, side, position, tagType, duration, effectData)
    if not battleState or not battleState.positionalTags then
        return false, "Positional tags not initialized"
    end
    
    if side ~= "player" and side ~= "enemy" then
        return false, "Invalid side specified"
    end
    
    -- Validate position for battle format
    local formatInfo = PositionalMechanics.getBattleFormatInfo(battleState)
    if position < 1 or position > formatInfo.max_active_per_side then
        return false, "Invalid position for current battle format"
    end
    
    -- Ensure position storage exists
    if not battleState.positionalTags[side][position] then
        battleState.positionalTags[side][position] = {}
    end
    
    -- Apply the positional tag
    local tagData = {
        tag_type = tagType,
        duration = duration or 0,
        turns_remaining = duration or 0,
        effect_data = effectData or {},
        applied_turn = battleState.turn or 0,
        is_active = true
    }
    
    battleState.positionalTags[side][position][tagType] = tagData
    
    return true, string.format("Positional tag %s applied to %s position %d", tagType, side, position)
end

-- Remove positional tag effect from position
-- @param battleState: Current battle state
-- @param side: "player" or "enemy"
-- @param position: Position index
-- @param tagType: Type of tag to remove
-- @return: Success boolean and result message
function BattleConditions.removePositionalTag(battleState, side, position, tagType)
    if not battleState or not battleState.positionalTags then
        return false, "Positional tags not initialized"
    end
    
    if not battleState.positionalTags[side] or not battleState.positionalTags[side][position] then
        return false, "Position not found"
    end
    
    local positionTags = battleState.positionalTags[side][position]
    if positionTags[tagType] then
        positionTags[tagType] = nil
        return true, string.format("Positional tag %s removed from %s position %d", tagType, side, position)
    end
    
    return false, "Tag not found at position"
end

-- Get positional tag effects for specific position
-- @param battleState: Current battle state
-- @param side: "player" or "enemy"
-- @param position: Position index
-- @return: Table of active positional tags
function BattleConditions.getPositionalTags(battleState, side, position)
    if not battleState or not battleState.positionalTags then
        return {}
    end
    
    if not battleState.positionalTags[side] or not battleState.positionalTags[side][position] then
        return {}
    end
    
    local activeTags = {}
    for tagType, tagData in pairs(battleState.positionalTags[side][position]) do
        if tagData.is_active and tagData.turns_remaining > 0 then
            activeTags[tagType] = tagData
        end
    end
    
    return activeTags
end

-- Check if specific positional tag is active at position
-- @param battleState: Current battle state
-- @param side: "player" or "enemy"
-- @param position: Position index
-- @param tagType: Type of tag to check
-- @return: Boolean indicating if tag is active
function BattleConditions.hasPositionalTag(battleState, side, position, tagType)
    local tags = BattleConditions.getPositionalTags(battleState, side, position)
    return tags[tagType] ~= nil
end

-- Update positional tag duration and remove expired tags
-- @param battleState: Current battle state
-- @return: Table of expired tags by side and position
function BattleConditions.updatePositionalTagDurations(battleState)
    if not battleState or not battleState.positionalTags then
        return {}
    end
    
    local expiredTags = {
        player = {},
        enemy = {}
    }
    
    for sideName, sideData in pairs(battleState.positionalTags) do
        expiredTags[sideName] = {}
        
        for position, positionTags in pairs(sideData) do
            expiredTags[sideName][position] = {}
            
            for tagType, tagData in pairs(positionTags) do
                if tagData.is_active then
                    -- Decrease duration
                    tagData.turns_remaining = tagData.turns_remaining - 1
                    
                    -- Check if tag expired
                    if tagData.turns_remaining <= 0 then
                        tagData.is_active = false
                        table.insert(expiredTags[sideName][position], {
                            tag_type = tagType,
                            expired_on_turn = battleState.turn or 0,
                            final_effect_data = tagData.effect_data
                        })
                    end
                end
            end
        end
    end
    
    return expiredTags
end

-- Process end-of-turn positional tag effects
-- @param battleState: Current battle state
-- @return: Results of positional tag processing
function BattleConditions.processPositionalTagTurnEnd(battleState)
    if not battleState or not battleState.positionalTags then
        return {
            tags_processed = 0,
            effects_applied = {},
            tags_expired = {}
        }
    end
    
    local results = {
        tags_processed = 0,
        effects_applied = {},
        tags_expired = {}
    }
    
    -- Update durations and collect expired tags
    local expiredTags = BattleConditions.updatePositionalTagDurations(battleState)
    results.tags_expired = expiredTags
    
    -- Process active positional tag effects
    for sideName, sideData in pairs(battleState.positionalTags) do
        for position, positionTags in pairs(sideData) do
            for tagType, tagData in pairs(positionTags) do
                if tagData.is_active then
                    results.tags_processed = results.tags_processed + 1
                    
                    -- Process tag-specific effects
                    local effectResult = BattleConditions.processPositionalTagEffect(
                        battleState, sideName, position, tagType, tagData
                    )
                    
                    if effectResult.effect_applied then
                        table.insert(results.effects_applied, {
                            side = sideName,
                            position = position,
                            tag_type = tagType,
                            effect_result = effectResult
                        })
                    end
                end
            end
        end
    end
    
    return results
end

-- Process individual positional tag effect
-- @param battleState: Current battle state
-- @param side: Side of the position
-- @param position: Position index
-- @param tagType: Type of tag
-- @param tagData: Tag data
-- @return: Effect processing result
function BattleConditions.processPositionalTagEffect(battleState, side, position, tagType, tagData)
    local result = {
        effect_applied = false,
        effect_message = "",
        damage_dealt = 0,
        healing_applied = 0,
        status_changes = {}
    }
    
    -- Get Pokemon at position
    local pokemon = PositionalMechanics.getPokemonAtPosition(battleState, side, position)
    if not pokemon or pokemon.fainted then
        return result
    end
    
    -- Process based on tag type
    if tagType == BattleConditions.PositionalTagType.SUBSTITUTE_POSITION then
        -- Process substitute at specific position
        result = BattleConditions.processPositionalSubstitute(battleState, pokemon, tagData)
        
    elseif tagType == BattleConditions.PositionalTagType.POSITION_BARRIER then
        -- Process position-specific barrier
        result = BattleConditions.processPositionalBarrier(battleState, pokemon, tagData)
        
    elseif tagType == BattleConditions.PositionalTagType.POSITION_CURSE then
        -- Process position-specific curse damage
        result = BattleConditions.processPositionalCurse(battleState, pokemon, tagData)
        
    elseif tagType == BattleConditions.PositionalTagType.POSITION_TRAP then
        -- Process position-specific trap effects
        result = BattleConditions.processPositionalTrap(battleState, pokemon, tagData)
        
    elseif tagType == BattleConditions.PositionalTagType.CUSTOM_POSITION_EFFECT then
        -- Process custom positional effects
        result = BattleConditions.processCustomPositionalEffect(battleState, pokemon, tagData)
    end
    
    return result
end

-- Process position-specific substitute effects
-- @param battleState: Battle state
-- @param pokemon: Pokemon at position
-- @param tagData: Substitute tag data
-- @return: Processing result
function BattleConditions.processPositionalSubstitute(battleState, pokemon, tagData)
    -- Substitute persists until broken or Pokemon switches
    return {
        effect_applied = true,
        effect_message = string.format("%s's substitute is active", pokemon.name or "Pokemon"),
        damage_dealt = 0,
        healing_applied = 0,
        status_changes = {}
    }
end

-- Process position-specific barrier effects
-- @param battleState: Battle state
-- @param pokemon: Pokemon at position
-- @param tagData: Barrier tag data
-- @return: Processing result
function BattleConditions.processPositionalBarrier(battleState, pokemon, tagData)
    -- Barrier reduces incoming damage for Pokemon at this position
    return {
        effect_applied = true,
        effect_message = string.format("%s is protected by a positional barrier", pokemon.name or "Pokemon"),
        damage_dealt = 0,
        healing_applied = 0,
        status_changes = {},
        damage_reduction = tagData.effect_data.damage_reduction or 0.5
    }
end

-- Process position-specific curse effects
-- @param battleState: Battle state
-- @param pokemon: Pokemon at position
-- @param tagData: Curse tag data
-- @return: Processing result
function BattleConditions.processPositionalCurse(battleState, pokemon, tagData)
    -- Curse deals damage each turn to Pokemon at this position
    local curseDamage = math.floor((pokemon.maxHP or pokemon.stats.hp or 100) / 4) -- 25% max HP
    local actualDamage = math.min(curseDamage, pokemon.currentHP)
    
    pokemon.currentHP = math.max(0, pokemon.currentHP - actualDamage)
    
    return {
        effect_applied = true,
        effect_message = string.format("%s is hurt by the positional curse!", pokemon.name or "Pokemon"),
        damage_dealt = actualDamage,
        healing_applied = 0,
        status_changes = {}
    }
end

-- Process position-specific trap effects
-- @param battleState: Battle state
-- @param pokemon: Pokemon at position
-- @param tagData: Trap tag data
-- @return: Processing result
function BattleConditions.processPositionalTrap(battleState, pokemon, tagData)
    -- Trap triggers when Pokemon tries to move or use certain moves
    return {
        effect_applied = true,
        effect_message = string.format("%s is trapped in position!", pokemon.name or "Pokemon"),
        damage_dealt = 0,
        healing_applied = 0,
        status_changes = {},
        movement_blocked = true
    }
end

-- Process custom positional effects
-- @param battleState: Battle state
-- @param pokemon: Pokemon at position
-- @param tagData: Custom effect tag data
-- @return: Processing result
function BattleConditions.processCustomPositionalEffect(battleState, pokemon, tagData)
    -- Process custom effects based on effect_data
    local effectData = tagData.effect_data or {}
    
    local result = {
        effect_applied = false,
        effect_message = "",
        damage_dealt = 0,
        healing_applied = 0,
        status_changes = {}
    }
    
    -- Apply custom damage
    if effectData.damage_per_turn then
        local damage = effectData.damage_per_turn
        local actualDamage = math.min(damage, pokemon.currentHP)
        pokemon.currentHP = math.max(0, pokemon.currentHP - actualDamage)
        result.damage_dealt = actualDamage
        result.effect_applied = true
    end
    
    -- Apply custom healing
    if effectData.healing_per_turn then
        local maxHP = pokemon.maxHP or pokemon.stats.hp or 100
        local healing = math.min(effectData.healing_per_turn, maxHP - pokemon.currentHP)
        pokemon.currentHP = pokemon.currentHP + healing
        result.healing_applied = healing
        result.effect_applied = true
    end
    
    -- Apply custom message
    if effectData.message then
        result.effect_message = string.format(effectData.message, pokemon.name or "Pokemon")
        result.effect_applied = true
    end
    
    return result
end

-- Get all active positional tags for battle summary
-- @param battleState: Current battle state
-- @return: Summary of all active positional tags
function BattleConditions.getPositionalTagsSummary(battleState)
    if not battleState or not battleState.positionalTags then
        return {
            total_active_tags = 0,
            tags_by_side = {}
        }
    end
    
    local summary = {
        total_active_tags = 0,
        tags_by_side = {}
    }
    
    for sideName, sideData in pairs(battleState.positionalTags) do
        summary.tags_by_side[sideName] = {}
        
        for position, positionTags in pairs(sideData) do
            local activeTags = BattleConditions.getPositionalTags(battleState, sideName, position)
            if next(activeTags) then -- Has active tags
                summary.tags_by_side[sideName][position] = {}
                for tagType, tagData in pairs(activeTags) do
                    summary.total_active_tags = summary.total_active_tags + 1
                    table.insert(summary.tags_by_side[sideName][position], {
                        tag_type = tagType,
                        turns_remaining = tagData.turns_remaining,
                        effect_description = BattleConditions.getPositionalTagDescription(tagType)
                    })
                end
            end
        end
    end
    
    return summary
end

-- Get description for positional tag type
-- @param tagType: Type of positional tag
-- @return: Human-readable description
function BattleConditions.getPositionalTagDescription(tagType)
    local descriptions = {
        [BattleConditions.PositionalTagType.SUBSTITUTE_POSITION] = "Position-specific substitute protecting from damage",
        [BattleConditions.PositionalTagType.POSITION_BARRIER] = "Barrier reducing damage to this position",
        [BattleConditions.PositionalTagType.POSITION_CURSE] = "Curse dealing damage each turn at this position",
        [BattleConditions.PositionalTagType.POSITION_TRAP] = "Trap preventing movement from this position",
        [BattleConditions.PositionalTagType.CUSTOM_POSITION_EFFECT] = "Custom positional effect"
    }
    
    return descriptions[tagType] or "Unknown positional effect"
end


-- ===== END MODULE: game-logic.battle.battle-conditions =====


-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Berry system integration

-- ===== MODULE: game-logic.items.berry-activation-manager =====
-- File: ao-processes/game-logic/items/berry-activation-manager.lua
-- Original require: local BerryActivationManager = require("game-logic.items.berry-activation-manager")


-- ===== END MODULE: game-logic.items.berry-activation-manager =====


-- ===== MODULE: game-logic.items.berry-effects-processor =====
-- File: ao-processes/game-logic/items/berry-effects-processor.lua
-- Original require: local BerryEffectsProcessor = require("game-logic.items.berry-effects-processor")


-- ===== END MODULE: game-logic.items.berry-effects-processor =====


-- Status effects system dependencies

-- ===== MODULE: game-logic.pokemon.status-effects =====
-- File: ao-processes/game-logic/pokemon/status-effects.lua
-- Original require: local StatusEffects = require("game-logic.pokemon.status-effects")

-- Pokemon Status Effects System
-- Implements all status conditions with proper mechanics and damage calculations
-- Integrates with battle system for deterministic status processing
-- Handles sleep, poison, paralysis, burn, and freeze effects

local StatusEffects = {}

-- Load dependencies

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Status effect type enumeration
StatusEffects.StatusType = {
    NONE = nil,
    SLEEP = "sleep",
    POISON = "poison",
    BADLY_POISONED = "badly_poisoned",
    PARALYSIS = "paralysis",
    BURN = "burn",
    FREEZE = "freeze"
}

-- Status effect turn durations (for sleep)
StatusEffects.SleepDuration = {
    MIN = 1,
    MAX = 3
}

-- Status effect damage calculations
StatusEffects.DamageCalculation = {
    POISON_FRACTION = 8,     -- 1/8 max HP
    BURN_FRACTION = 16,      -- 1/16 max HP
    ATTACK_REDUCTION = 0.5   -- 50% attack reduction from burn
}

-- Status effect chance calculations
StatusEffects.ChanceCalculation = {
    PARALYSIS_FAILURE = 25,  -- 25% chance of move failure
    FREEZE_THAW = 20,        -- 20% base thaw chance
    SLEEP_WAKE = 33,         -- 33% chance to wake up each turn
    SPEED_REDUCTION = 0.5    -- 50% speed reduction from paralysis
}

-- Initialize status effects system
function StatusEffects.init()
    -- Status effects system is stateless, no initialization needed
    return true
end

-- Apply status effect to Pokemon
-- @param pokemon: Pokemon to apply status to
-- @param statusType: Type of status effect
-- @param duration: Optional duration for status effects that use it
-- @param battleState: Current battle state for RNG access
-- @return: Application result with success and messages
function StatusEffects.applyStatusEffect(pokemon, statusType, duration, battleState)
    if not pokemon then
        return {success = false, error = "Invalid Pokemon"}
    end
    
    -- Check for Safeguard protection
    if battleState then

-- ===== MODULE: game-logic.battle.side-effects =====
-- File: ao-processes/game-logic/battle/side-effects.lua
-- Original require:         local SideEffects = require("game-logic.battle.side-effects")


-- ===== END MODULE: game-logic.battle.side-effects =====

        local targetSide = pokemon.side or "player"
        
        if SideEffects.preventStatusCondition(battleState, targetSide, statusType) then
            return {
                success = false,
                error = "Status condition prevented by Safeguard",
                blocked = true,
                safeguard_blocked = true
            }
        end
    end
    
    -- Check if Pokemon already has a status effect
    if pokemon.statusEffect then
        return {
            success = false, 
            error = "Pokemon already has status: " .. pokemon.statusEffect,
            blocked = true
        }
    end
    
    local result = {
        success = true,
        statusApplied = statusType,
        messages = {},
        effects = {}
    }
    
    -- Apply the status effect
    pokemon.statusEffect = statusType
    
    -- Handle status-specific initialization
    if statusType == StatusEffects.StatusType.SLEEP then
        -- Initialize sleep duration using deterministic RNG
        local sleepTurns = duration or BattleRNG.randomInt(StatusEffects.SleepDuration.MIN, StatusEffects.SleepDuration.MAX)
        pokemon.statusTurns = sleepTurns
        table.insert(result.messages, pokemon.name .. " fell asleep!")
        
    elseif statusType == StatusEffects.StatusType.POISON then
        table.insert(result.messages, pokemon.name .. " was poisoned!")
        
    elseif statusType == StatusEffects.StatusType.BADLY_POISONED then
        pokemon.statusEffect = StatusEffects.StatusType.BADLY_POISONED
        pokemon.statusTurns = 1 -- Start at turn 1 for escalating damage
        table.insert(result.messages, pokemon.name .. " was badly poisoned!")
        
    elseif statusType == StatusEffects.StatusType.PARALYSIS then
        table.insert(result.messages, pokemon.name .. " is paralyzed! It may be unable to move!")
        -- Apply speed reduction immediately
        table.insert(result.effects, {
            type = "stat_modification",
            stat = "speed",
            multiplier = StatusEffects.ChanceCalculation.SPEED_REDUCTION
        })
        
    elseif statusType == StatusEffects.StatusType.BURN then
        table.insert(result.messages, pokemon.name .. " was burned!")
        -- Apply attack reduction immediately
        table.insert(result.effects, {
            type = "stat_modification",
            stat = "attack",
            multiplier = StatusEffects.DamageCalculation.ATTACK_REDUCTION
        })
        
    elseif statusType == StatusEffects.StatusType.FREEZE then
        table.insert(result.messages, pokemon.name .. " was frozen solid!")
        
    end
    
    return result
end

-- Process end-of-turn status effects for a Pokemon
-- @param pokemon: Pokemon to process status effects for
-- @param battleState: Current battle state for RNG access
-- @return: Status processing result with damage, healing, and messages
function StatusEffects.processEndOfTurnEffects(pokemon, battleState)
    if not pokemon or not pokemon.statusEffect then
        return {effects = {}, messages = {}}
    end
    
    local result = {
        effects = {},
        messages = {},
        statusChanged = false,
        damageDeal = 0
    }
    
    local statusType = pokemon.statusEffect
    
    -- Process status-specific end-of-turn effects
    if statusType == StatusEffects.StatusType.BURN then
        local damage = StatusEffects.calculateBurnDamage(pokemon)
        pokemon.currentHP = math.max(0, pokemon.currentHP - damage)
        result.damageDealt = damage
        
        table.insert(result.effects, {
            type = "damage",
            amount = damage,
            source = "burn"
        })
        table.insert(result.messages, pokemon.name .. " was hurt by its burn!")
        
    elseif statusType == StatusEffects.StatusType.POISON then
        local damage = StatusEffects.calculatePoisonDamage(pokemon)
        pokemon.currentHP = math.max(0, pokemon.currentHP - damage)
        result.damageDealt = damage
        
        table.insert(result.effects, {
            type = "damage",
            amount = damage,
            source = "poison"
        })
        table.insert(result.messages, pokemon.name .. " was hurt by poison!")
        
    elseif statusType == StatusEffects.StatusType.BADLY_POISONED then
        local damage = StatusEffects.calculateBadlyPoisonedDamage(pokemon)
        pokemon.currentHP = math.max(0, pokemon.currentHP - damage)
        result.damageDealt = damage
        
        -- Increment badly poisoned counter
        pokemon.statusTurns = (pokemon.statusTurns or 1) + 1
        
        table.insert(result.effects, {
            type = "damage", 
            amount = damage,
            source = "badly_poisoned"
        })
        table.insert(result.messages, pokemon.name .. " was hurt by poison!")
        
    elseif statusType == StatusEffects.StatusType.SLEEP then
        -- Process sleep duration
        if pokemon.statusTurns then
            pokemon.statusTurns = pokemon.statusTurns - 1
            if pokemon.statusTurns <= 0 then
                pokemon.statusEffect = nil
                pokemon.statusTurns = nil
                result.statusChanged = true
                table.insert(result.messages, pokemon.name .. " woke up!")
            else
                table.insert(result.messages, pokemon.name .. " is fast asleep.")
            end
        end
    end
    
    return result
end

-- Check if Pokemon can use a move (status effect prevention)
-- @param pokemon: Pokemon attempting to use move
-- @param moveData: Data about the move being used
-- @param battleState: Current battle state for RNG access
-- @return: Move prevention result with success, messages, and status updates
function StatusEffects.checkMovePreventionEffects(pokemon, moveData, battleState)
    if not pokemon or not pokemon.statusEffect then
        return {canMove = true, messages = {}}
    end
    
    local result = {
        canMove = true,
        messages = {},
        statusChanged = false
    }
    
    local statusType = pokemon.statusEffect
    
    -- Check sleep prevention
    if statusType == StatusEffects.StatusType.SLEEP then
        -- Check for early wake-up
        local wakeChance = BattleRNG.randomInt(1, 100)
        if wakeChance <= StatusEffects.ChanceCalculation.SLEEP_WAKE then
            pokemon.statusEffect = nil
            pokemon.statusTurns = nil
            result.statusChanged = true
            table.insert(result.messages, pokemon.name .. " woke up!")
            result.canMove = true
        else
            result.canMove = false
            table.insert(result.messages, pokemon.name .. " is fast asleep!")
        end
        
    elseif statusType == StatusEffects.StatusType.FREEZE then
        -- Check for thaw chance (higher for fire-type moves)
        local thawChance = StatusEffects.ChanceCalculation.FREEZE_THAW
        if moveData and moveData.type == Enums.Type.FIRE then
            thawChance = 100 -- Fire moves always thaw
        end
        
        local thawRoll = BattleRNG.randomInt(1, 100)
        if thawRoll <= thawChance then
            pokemon.statusEffect = nil
            pokemon.statusTurns = nil
            result.statusChanged = true
            table.insert(result.messages, pokemon.name .. " thawed out!")
            result.canMove = true
        else
            result.canMove = false
            table.insert(result.messages, pokemon.name .. " is frozen solid!")
        end
        
    elseif statusType == StatusEffects.StatusType.PARALYSIS then
        -- Check for paralysis move failure
        local paralysisRoll = BattleRNG.randomInt(1, 100)
        if paralysisRoll <= StatusEffects.ChanceCalculation.PARALYSIS_FAILURE then
            result.canMove = false
            table.insert(result.messages, pokemon.name .. " is paralyzed! It can't move!")
        else
            result.canMove = true
        end
    end
    
    return result
end

-- Calculate burn damage
-- @param pokemon: Pokemon taking burn damage
-- @return: Damage amount
function StatusEffects.calculateBurnDamage(pokemon)
    local maxHP = pokemon.maxHP or (pokemon.stats and pokemon.stats.hp) or 100
    return math.max(1, math.floor(maxHP / StatusEffects.DamageCalculation.BURN_FRACTION))
end

-- Calculate poison damage
-- @param pokemon: Pokemon taking poison damage
-- @return: Damage amount
function StatusEffects.calculatePoisonDamage(pokemon)
    local maxHP = pokemon.maxHP or (pokemon.stats and pokemon.stats.hp) or 100
    return math.max(1, math.floor(maxHP / StatusEffects.DamageCalculation.POISON_FRACTION))
end

-- Calculate badly poisoned damage (escalating each turn)
-- @param pokemon: Pokemon taking badly poisoned damage
-- @return: Damage amount
function StatusEffects.calculateBadlyPoisonedDamage(pokemon)
    local maxHP = pokemon.maxHP or (pokemon.stats and pokemon.stats.hp) or 100
    local poisonCounter = pokemon.statusTurns or 1
    local baseDamage = math.floor(maxHP / StatusEffects.DamageCalculation.POISON_FRACTION)
    return math.max(1, baseDamage * poisonCounter)
end

-- Get stat modification from status effects
-- @param pokemon: Pokemon to check for stat modifications
-- @param statName: Name of stat to check
-- @return: Stat multiplier (1.0 = no change)
function StatusEffects.getStatModification(pokemon, statName)
    if not pokemon or not pokemon.statusEffect then
        return 1.0
    end
    
    local statusType = pokemon.statusEffect
    
    -- Apply burn attack reduction
    if statusType == StatusEffects.StatusType.BURN and statName == "attack" then
        return StatusEffects.DamageCalculation.ATTACK_REDUCTION
    end
    
    -- Apply paralysis speed reduction
    if statusType == StatusEffects.StatusType.PARALYSIS and statName == "speed" then
        return StatusEffects.ChanceCalculation.SPEED_REDUCTION
    end
    
    return 1.0
end

-- Clear status effect from Pokemon
-- @param pokemon: Pokemon to clear status from
-- @param message: Optional custom clear message
-- @return: Clear result with messages
function StatusEffects.clearStatusEffect(pokemon, message)
    if not pokemon or not pokemon.statusEffect then
        return {success = false, messages = {}}
    end
    
    local previousStatus = pokemon.statusEffect
    pokemon.statusEffect = nil
    pokemon.statusTurns = nil
    
    local result = {
        success = true,
        previousStatus = previousStatus,
        messages = {}
    }
    
    if message then
        table.insert(result.messages, message)
    else
        table.insert(result.messages, pokemon.name .. "'s status condition was cured!")
    end
    
    return result
end

-- Check if Pokemon has a specific status effect
-- @param pokemon: Pokemon to check
-- @param statusType: Status type to check for
-- @return: Boolean indicating if Pokemon has the status
function StatusEffects.hasStatusEffect(pokemon, statusType)
    if not pokemon then
        return false
    end
    
    return pokemon.statusEffect == statusType
end

-- Get comprehensive status effect information
-- @param pokemon: Pokemon to get status info for
-- @return: Status information object
function StatusEffects.getStatusEffectInfo(pokemon)
    if not pokemon or not pokemon.statusEffect then
        return {hasStatus = false}
    end
    
    local info = {
        hasStatus = true,
        statusType = pokemon.statusEffect,
        turnsRemaining = pokemon.statusTurns,
        statModifications = {}
    }
    
    -- Add stat modifications
    local statMods = {
        attack = StatusEffects.getStatModification(pokemon, "attack"),
        speed = StatusEffects.getStatModification(pokemon, "speed")
    }
    
    for stat, multiplier in pairs(statMods) do
        if multiplier ~= 1.0 then
            info.statModifications[stat] = multiplier
        end
    end
    
    return info
end


-- ===== END MODULE: game-logic.pokemon.status-effects =====


-- ===== MODULE: game-logic.pokemon.status-interactions =====
-- File: ao-processes/game-logic/pokemon/status-interactions.lua
-- Original require: local StatusInteractions = require("game-logic.pokemon.status-interactions")

-- Pokemon Status Condition Interactions
-- Handles status condition conflicts, replacements, and exclusion rules
-- Manages status condition stacking and priority handling
-- Integrates with Pokemon state management system

local StatusInteractions = {}

-- Load dependencies

-- ===== MODULE: game-logic.pokemon.status-effects =====
-- File: ao-processes/game-logic/pokemon/status-effects.lua
-- Original require: local StatusEffects = require("game-logic.pokemon.status-effects")


-- ===== END MODULE: game-logic.pokemon.status-effects =====


-- Status interaction rules
StatusInteractions.InteractionRules = {
    -- Status conditions that cannot coexist
    MUTUALLY_EXCLUSIVE = {
        [StatusEffects.StatusType.SLEEP] = {
            StatusEffects.StatusType.POISON,
            StatusEffects.StatusType.BADLY_POISONED,
            StatusEffects.StatusType.PARALYSIS,
            StatusEffects.StatusType.BURN,
            StatusEffects.StatusType.FREEZE
        },
        [StatusEffects.StatusType.FREEZE] = {
            StatusEffects.StatusType.SLEEP,
            StatusEffects.StatusType.POISON,
            StatusEffects.StatusType.BADLY_POISONED,
            StatusEffects.StatusType.PARALYSIS,
            StatusEffects.StatusType.BURN
        },
        [StatusEffects.StatusType.PARALYSIS] = {
            StatusEffects.StatusType.SLEEP,
            StatusEffects.StatusType.FREEZE
        },
        [StatusEffects.StatusType.BURN] = {
            StatusEffects.StatusType.SLEEP,
            StatusEffects.StatusType.FREEZE
        },
        [StatusEffects.StatusType.POISON] = {
            StatusEffects.StatusType.SLEEP,
            StatusEffects.StatusType.FREEZE,
            StatusEffects.StatusType.BADLY_POISONED
        },
        [StatusEffects.StatusType.BADLY_POISONED] = {
            StatusEffects.StatusType.SLEEP,
            StatusEffects.StatusType.FREEZE,
            StatusEffects.StatusType.POISON
        }
    },
    
    -- Status replacement priority (higher priority replaces lower priority)
    REPLACEMENT_PRIORITY = {
        [StatusEffects.StatusType.BADLY_POISONED] = 5,
        [StatusEffects.StatusType.BURN] = 4,
        [StatusEffects.StatusType.POISON] = 3,
        [StatusEffects.StatusType.PARALYSIS] = 2,
        [StatusEffects.StatusType.SLEEP] = 1,
        [StatusEffects.StatusType.FREEZE] = 1
    },
    
    -- Status conditions that can upgrade to others
    STATUS_UPGRADES = {
        [StatusEffects.StatusType.POISON] = StatusEffects.StatusType.BADLY_POISONED
    }
}

-- Initialize status interactions system
function StatusInteractions.init()
    -- Status interactions system is stateless, no initialization needed
    return true
end

-- Validate status effect application considering interactions
-- @param pokemon: Pokemon to apply status to
-- @param newStatus: Status effect to apply
-- @param forceReplace: Whether to force replacement of existing status
-- @return: Validation result with allowed status and messages
function StatusInteractions.validateStatusApplication(pokemon, newStatus, forceReplace)
    if not pokemon then
        return {valid = false, error = "Invalid Pokemon"}
    end
    
    if not newStatus then
        return {valid = false, error = "No status effect specified"}
    end
    
    local result = {
        valid = false,
        allowedStatus = newStatus,
        messages = {},
        replacementOccurred = false,
        previousStatus = pokemon.statusEffect
    }
    
    -- If Pokemon has no status, allow application
    if not pokemon.statusEffect then
        result.valid = true
        result.allowedStatus = newStatus
        return result
    end
    
    local currentStatus = pokemon.statusEffect
    
    -- Check if attempting to apply the same status
    if currentStatus == newStatus then
        result.valid = false
        result.error = "Pokemon already has this status effect"
        table.insert(result.messages, pokemon.name .. " already has " .. newStatus .. "!")
        return result
    end
    
    -- Check for force replacement
    if forceReplace then
        result.valid = true
        result.allowedStatus = newStatus
        result.replacementOccurred = true
        table.insert(result.messages, pokemon.name .. "'s " .. currentStatus .. " was replaced with " .. newStatus .. "!")
        return result
    end
    
    -- Check status upgrade possibility
    if StatusInteractions.canUpgradeStatus(currentStatus, newStatus) then
        result.valid = true
        result.allowedStatus = newStatus
        result.replacementOccurred = true
        table.insert(result.messages, pokemon.name .. "'s " .. currentStatus .. " became " .. newStatus .. "!")
        return result
    end
    
    -- Check mutual exclusivity
    if StatusInteractions.areStatusesMutuallyExclusive(currentStatus, newStatus) then
        -- Check replacement priority
        local priorityResult = StatusInteractions.checkReplacementPriority(currentStatus, newStatus)
        
        if priorityResult.canReplace then
            result.valid = true
            result.allowedStatus = newStatus
            result.replacementOccurred = true
            table.insert(result.messages, priorityResult.message)
        else
            result.valid = false
            result.error = "Status effect blocked by existing condition"
            table.insert(result.messages, priorityResult.message)
        end
        
        return result
    end
    
    -- Default case - allow stacking of compatible effects
    result.valid = true
    result.allowedStatus = newStatus
    return result
end

-- Check if two status effects are mutually exclusive
-- @param status1: First status effect
-- @param status2: Second status effect
-- @return: Boolean indicating mutual exclusivity
function StatusInteractions.areStatusesMutuallyExclusive(status1, status2)
    if not status1 or not status2 then
        return false
    end
    
    local exclusiveList = StatusInteractions.InteractionRules.MUTUALLY_EXCLUSIVE[status1]
    if not exclusiveList then
        return false
    end
    
    for _, excludedStatus in ipairs(exclusiveList) do
        if excludedStatus == status2 then
            return true
        end
    end
    
    return false
end

-- Check replacement priority between two status effects
-- @param currentStatus: Currently applied status
-- @param newStatus: New status being applied
-- @return: Priority check result with replacement decision and message
function StatusInteractions.checkReplacementPriority(currentStatus, newStatus)
    local currentPriority = StatusInteractions.InteractionRules.REPLACEMENT_PRIORITY[currentStatus] or 0
    local newPriority = StatusInteractions.InteractionRules.REPLACEMENT_PRIORITY[newStatus] or 0
    
    local result = {
        canReplace = false,
        currentPriority = currentPriority,
        newPriority = newPriority,
        message = ""
    }
    
    if newPriority > currentPriority then
        result.canReplace = true
        result.message = "The more severe status effect took hold!"
    elseif newPriority == currentPriority then
        result.canReplace = false
        result.message = "The status effects conflicted and cancelled out!"
    else
        result.canReplace = false
        result.message = "The existing status effect prevented the new one!"
    end
    
    return result
end

-- Check if a status can be upgraded to another
-- @param currentStatus: Current status effect
-- @param newStatus: Potential upgrade status
-- @return: Boolean indicating if upgrade is possible
function StatusInteractions.canUpgradeStatus(currentStatus, newStatus)
    if not currentStatus or not newStatus then
        return false
    end
    
    local upgradeTarget = StatusInteractions.InteractionRules.STATUS_UPGRADES[currentStatus]
    return upgradeTarget == newStatus
end

-- Process status condition replacement
-- @param pokemon: Pokemon undergoing status replacement
-- @param newStatus: New status to apply
-- @param previousStatus: Status being replaced
-- @return: Replacement result with effects and messages
function StatusInteractions.processStatusReplacement(pokemon, newStatus, previousStatus)
    if not pokemon then
        return {success = false, error = "Invalid Pokemon"}
    end
    
    local result = {
        success = true,
        previousStatus = previousStatus,
        newStatus = newStatus,
        effects = {},
        messages = {}
    }
    
    -- Clear previous status effects
    if previousStatus then
        -- Remove stat modifications from previous status
        if previousStatus == StatusEffects.StatusType.BURN then
            table.insert(result.effects, {
                type = "stat_restoration",
                stat = "attack",
                message = pokemon.name .. "'s Attack returned to normal!"
            })
        elseif previousStatus == StatusEffects.StatusType.PARALYSIS then
            table.insert(result.effects, {
                type = "stat_restoration", 
                stat = "speed",
                message = pokemon.name .. "'s Speed returned to normal!"
            })
        end
    end
    
    -- Apply new status effects
    local statusApplication = StatusEffects.applyStatusEffect(pokemon, newStatus, nil, nil)
    if statusApplication.success then
        for _, effect in ipairs(statusApplication.effects) do
            table.insert(result.effects, effect)
        end
        for _, message in ipairs(statusApplication.messages) do
            table.insert(result.messages, message)
        end
    else
        result.success = false
        result.error = statusApplication.error
    end
    
    return result
end

-- Resolve status condition conflict
-- @param pokemon: Pokemon with conflicting status conditions
-- @param existingStatus: Current status effect
-- @param newStatus: New status being applied
-- @param context: Additional context (move, ability, item causing new status)
-- @return: Conflict resolution result
function StatusInteractions.resolveStatusConflict(pokemon, existingStatus, newStatus, context)
    if not pokemon or not existingStatus or not newStatus then
        return {resolved = false, error = "Invalid conflict parameters"}
    end
    
    local result = {
        resolved = false,
        finalStatus = existingStatus,
        actions = {},
        messages = {}
    }
    
    -- Check if conflict can be resolved through upgrade
    if StatusInteractions.canUpgradeStatus(existingStatus, newStatus) then
        result.resolved = true
        result.finalStatus = newStatus
        table.insert(result.actions, {
            type = "status_upgrade",
            from = existingStatus,
            to = newStatus
        })
        table.insert(result.messages, pokemon.name .. "'s condition worsened!")
        return result
    end
    
    -- Check priority-based replacement
    local priorityCheck = StatusInteractions.checkReplacementPriority(existingStatus, newStatus)
    if priorityCheck.canReplace then
        result.resolved = true
        result.finalStatus = newStatus
        table.insert(result.actions, {
            type = "status_replacement",
            from = existingStatus,
            to = newStatus,
            reason = "priority"
        })
        table.insert(result.messages, priorityCheck.message)
        return result
    end
    
    -- Handle special cases based on context
    if context then
        if context.type == "move" and context.forceReplace then
            result.resolved = true
            result.finalStatus = newStatus
            table.insert(result.actions, {
                type = "forced_replacement",
                from = existingStatus,
                to = newStatus,
                source = context.source
            })
            table.insert(result.messages, "The powerful effect overrode the existing status!")
            return result
        end
        
        if context.type == "ability" and context.preventAll then
            result.resolved = true
            result.finalStatus = nil
            table.insert(result.actions, {
                type = "status_prevention",
                prevented = newStatus,
                source = context.source
            })
            table.insert(result.messages, pokemon.name .. "'s ability prevented the status condition!")
            return result
        end
    end
    
    -- Default: existing status blocks new one
    result.resolved = false
    result.finalStatus = existingStatus
    table.insert(result.messages, "The new status effect had no effect!")
    
    return result
end

-- Get all compatible status effects for a Pokemon
-- @param pokemon: Pokemon to check
-- @param potentialStatuses: List of potential status effects
-- @return: List of compatible status effects
function StatusInteractions.getCompatibleStatuses(pokemon, potentialStatuses)
    if not pokemon or not potentialStatuses then
        return {}
    end
    
    local compatible = {}
    local currentStatus = pokemon.statusEffect
    
    for _, status in ipairs(potentialStatuses) do
        if not currentStatus then
            -- No current status, all are compatible
            table.insert(compatible, status)
        else
            -- Check compatibility with current status
            if not StatusInteractions.areStatusesMutuallyExclusive(currentStatus, status) then
                table.insert(compatible, status)
            elseif StatusInteractions.canUpgradeStatus(currentStatus, status) then
                table.insert(compatible, status)
            else
                -- Check if new status has higher priority
                local priorityCheck = StatusInteractions.checkReplacementPriority(currentStatus, status)
                if priorityCheck.canReplace then
                    table.insert(compatible, status)
                end
            end
        end
    end
    
    return compatible
end

-- Validate multiple status applications (for moves that apply multiple effects)
-- @param pokemon: Pokemon to apply statuses to
-- @param statusList: List of status effects to apply
-- @return: Validation result for all statuses
function StatusInteractions.validateMultipleStatusApplications(pokemon, statusList)
    if not pokemon or not statusList or #statusList == 0 then
        return {valid = false, error = "Invalid parameters"}
    end
    
    local result = {
        valid = true,
        applicableStatuses = {},
        blockedStatuses = {},
        messages = {}
    }
    
    local simulatedPokemon = {
        statusEffect = pokemon.statusEffect,
        statusTurns = pokemon.statusTurns,
        name = pokemon.name
    }
    
    for _, status in ipairs(statusList) do
        local validation = StatusInteractions.validateStatusApplication(simulatedPokemon, status, false)
        
        if validation.valid then
            table.insert(result.applicableStatuses, {
                status = status,
                replacementOccurred = validation.replacementOccurred
            })
            -- Update simulated Pokemon for next validation
            simulatedPokemon.statusEffect = validation.allowedStatus
            
            for _, message in ipairs(validation.messages) do
                table.insert(result.messages, message)
            end
        else
            table.insert(result.blockedStatuses, {
                status = status,
                reason = validation.error
            })
        end
    end
    
    if #result.applicableStatuses == 0 then
        result.valid = false
        result.error = "No status effects can be applied"
    end
    
    return result
end


-- ===== END MODULE: game-logic.pokemon.status-interactions =====


-- ===== MODULE: game-logic.pokemon.status-healing =====
-- File: ao-processes/game-logic/pokemon/status-healing.lua
-- Original require: local StatusHealing = require("game-logic.pokemon.status-healing")

-- Pokemon Status Healing and Curing System
-- Implements move-based, item-based, and ability-based status healing
-- Integrates with battle handler message processing and inventory systems
-- Handles targeted healing, group healing, and prevention effects

local StatusHealing = {}

-- Load dependencies

-- ===== MODULE: game-logic.pokemon.status-effects =====
-- File: ao-processes/game-logic/pokemon/status-effects.lua
-- Original require: local StatusEffects = require("game-logic.pokemon.status-effects")


-- ===== END MODULE: game-logic.pokemon.status-effects =====


-- ===== MODULE: game-logic.pokemon.status-interactions =====
-- File: ao-processes/game-logic/pokemon/status-interactions.lua
-- Original require: local StatusInteractions = require("game-logic.pokemon.status-interactions")


-- ===== END MODULE: game-logic.pokemon.status-interactions =====


-- Healing method enumeration
StatusHealing.HealingMethod = {
    MOVE = "move",
    ITEM = "item", 
    ABILITY = "ability",
    NATURAL = "natural",
    SWITCH = "switch"
}

-- Healing scope enumeration
StatusHealing.HealingScope = {
    SELF = "self",
    TARGET = "target",
    ALLY = "ally",
    TEAM = "team",
    ALL = "all"
}

-- Status healing move configurations
StatusHealing.HealingMoves = {
    -- Moves that heal all status conditions
    HEAL_BELL = {
        moveId = 215,
        scope = StatusHealing.HealingScope.TEAM,
        healsAll = true,
        message = "A bell chimed and status conditions were healed!"
    },
    AROMATHERAPY = {
        moveId = 312,
        scope = StatusHealing.HealingScope.TEAM,
        healsAll = true,
        message = "The soothing scent healed all status conditions!"
    },
    REFRESH = {
        moveId = 287,
        scope = StatusHealing.HealingScope.SELF,
        healsAll = true,
        message = "{pokemon} healed its status condition!"
    },
    
    -- Moves that heal specific status conditions
    WAKE_UP_SLAP = {
        moveId = 358,
        scope = StatusHealing.HealingScope.TARGET,
        healsSpecific = {StatusEffects.StatusType.SLEEP},
        message = "{pokemon} was slapped awake!"
    },
    SMELLING_SALTS = {
        moveId = 265,
        scope = StatusHealing.HealingScope.TARGET,
        healsSpecific = {StatusEffects.StatusType.PARALYSIS},
        message = "{pokemon} was cured of paralysis!"
    },
    FLAME_WHEEL = {
        moveId = 172,
        scope = StatusHealing.HealingScope.SELF,
        healsSpecific = {StatusEffects.StatusType.FREEZE},
        message = "{pokemon} thawed itself out!"
    }
}

-- Status healing item configurations
StatusHealing.HealingItems = {
    -- Items that heal all status conditions
    FULL_HEAL = {
        itemId = 17,
        scope = StatusHealing.HealingScope.TARGET,
        healsAll = true,
        consumable = true,
        message = "{pokemon} was cured with a Full Heal!"
    },
    PECHA_BERRY = {
        itemId = 151,
        scope = StatusHealing.HealingScope.SELF,
        healsSpecific = {StatusEffects.StatusType.POISON, StatusEffects.StatusType.BADLY_POISONED},
        consumable = true,
        autoUse = true,
        message = "{pokemon}'s Pecha Berry cured its poison!"
    },
    CHESTO_BERRY = {
        itemId = 149,
        scope = StatusHealing.HealingScope.SELF,
        healsSpecific = {StatusEffects.StatusType.SLEEP},
        consumable = true,
        autoUse = true,
        message = "{pokemon}'s Chesto Berry woke it up!"
    },
    RAWST_BERRY = {
        itemId = 152,
        scope = StatusHealing.HealingScope.SELF,
        healsSpecific = {StatusEffects.StatusType.BURN},
        consumable = true,
        autoUse = true,
        message = "{pokemon}'s Rawst Berry healed its burn!"
    },
    ASPEAR_BERRY = {
        itemId = 153,
        scope = StatusHealing.HealingScope.SELF,
        healsSpecific = {StatusEffects.StatusType.FREEZE},
        consumable = true,
        autoUse = true,
        message = "{pokemon}'s Aspear Berry defrosted it!"
    },
    CHERI_BERRY = {
        itemId = 150,
        scope = StatusHealing.HealingScope.SELF,
        healsSpecific = {StatusEffects.StatusType.PARALYSIS},
        consumable = true,
        autoUse = true,
        message = "{pokemon}'s Cheri Berry cured its paralysis!"
    },
    LUM_BERRY = {
        itemId = 157,
        scope = StatusHealing.HealingScope.SELF,
        healsAll = true,
        consumable = true,
        autoUse = true,
        message = "{pokemon}'s Lum Berry cured its status condition!"
    }
}

-- Status healing ability configurations
StatusHealing.HealingAbilities = {
    NATURAL_CURE = {
        abilityId = 30,
        scope = StatusHealing.HealingScope.SELF,
        trigger = "switch_out",
        healsAll = true,
        message = "{pokemon}'s Natural Cure healed its status condition!"
    },
    IMMUNITY = {
        abilityId = 17,
        scope = StatusHealing.HealingScope.SELF,
        trigger = "status_attempt",
        preventsSpecific = {StatusEffects.StatusType.POISON, StatusEffects.StatusType.BADLY_POISONED},
        message = "{pokemon}'s Immunity prevents poison!"
    },
    LIMBER = {
        abilityId = 7,
        scope = StatusHealing.HealingScope.SELF,
        trigger = "status_attempt",
        preventsSpecific = {StatusEffects.StatusType.PARALYSIS},
        message = "{pokemon}'s Limber prevents paralysis!"
    },
    INSOMNIA = {
        abilityId = 15,
        scope = StatusHealing.HealingScope.SELF,
        trigger = "status_attempt",
        preventsSpecific = {StatusEffects.StatusType.SLEEP},
        message = "{pokemon}'s Insomnia prevents sleep!"
    },
    WATER_VEIL = {
        abilityId = 41,
        scope = StatusHealing.HealingScope.SELF,
        trigger = "status_attempt",
        preventsSpecific = {StatusEffects.StatusType.BURN},
        message = "{pokemon}'s Water Veil prevents burns!"
    },
    MAGMA_ARMOR = {
        abilityId = 40,
        scope = StatusHealing.HealingScope.SELF,
        trigger = "status_attempt",
        preventsSpecific = {StatusEffects.StatusType.FREEZE},
        message = "{pokemon}'s Magma Armor prevents freezing!"
    }
}

-- Initialize status healing system
function StatusHealing.init()
    -- Status healing system is stateless, no initialization needed
    return true
end

-- Execute move-based status healing
-- @param battleState: Current battle state
-- @param pokemon: Pokemon using the healing move
-- @param moveId: ID of the healing move
-- @param targetPokemon: Target Pokemon (for targeted healing)
-- @return: Healing result with effects and messages
function StatusHealing.executeMoveBased(battleState, pokemon, moveId, targetPokemon)
    if not pokemon or not moveId then
        return {success = false, error = "Invalid move healing parameters"}
    end
    
    -- Find healing move configuration
    local healingMove = nil
    for moveName, config in pairs(StatusHealing.HealingMoves) do
        if config.moveId == moveId then
            healingMove = config
            break
        end
    end
    
    if not healingMove then
        return {success = false, error = "Move is not a healing move"}
    end
    
    local result = {
        success = true,
        method = StatusHealing.HealingMethod.MOVE,
        scope = healingMove.scope,
        healedPokemon = {},
        messages = {}
    }
    
    -- Determine target Pokemon based on scope
    local targets = StatusHealing.getTargetsForScope(battleState, pokemon, healingMove.scope, targetPokemon)
    
    -- Apply healing to each target
    for _, target in ipairs(targets) do
        local healingResult = StatusHealing.applyHealing(target, healingMove, pokemon)
        if healingResult.healed then
            table.insert(result.healedPokemon, {
                pokemon = target,
                previousStatus = healingResult.previousStatus,
                method = "move"
            })
            
            -- Generate healing message
            local message = healingMove.message
            message = string.gsub(message, "{pokemon}", target.name)
            table.insert(result.messages, message)
        end
    end
    
    return result
end

-- Execute item-based status healing
-- @param battleState: Current battle state
-- @param pokemon: Pokemon using the item (trainer's Pokemon)
-- @param itemId: ID of the healing item
-- @param targetPokemon: Target Pokemon
-- @param inventory: Player's inventory for item consumption
-- @return: Healing result with inventory updates
function StatusHealing.executeItemBased(battleState, pokemon, itemId, targetPokemon, inventory)
    if not pokemon or not itemId then
        return {success = false, error = "Invalid item healing parameters"}
    end
    
    -- Find healing item configuration
    local healingItem = nil
    for itemName, config in pairs(StatusHealing.HealingItems) do
        if config.itemId == itemId then
            healingItem = config
            break
        end
    end
    
    if not healingItem then
        return {success = false, error = "Item is not a healing item"}
    end
    
    -- Check inventory availability
    if healingItem.consumable and inventory then
        if not inventory[itemId] or inventory[itemId] <= 0 then
            return {success = false, error = "Item not available in inventory"}
        end
    end
    
    local result = {
        success = true,
        method = StatusHealing.HealingMethod.ITEM,
        scope = healingItem.scope,
        healedPokemon = {},
        messages = {},
        inventoryUpdates = {}
    }
    
    -- Determine target Pokemon
    local target = targetPokemon or pokemon
    
    -- Apply healing
    local healingResult = StatusHealing.applyHealing(target, healingItem, pokemon)
    if healingResult.healed then
        table.insert(result.healedPokemon, {
            pokemon = target,
            previousStatus = healingResult.previousStatus,
            method = "item"
        })
        
        -- Generate healing message
        local message = healingItem.message
        message = string.gsub(message, "{pokemon}", target.name)
        table.insert(result.messages, message)
    end
    
    -- Update inventory if item is consumable
    if healingItem.consumable and inventory then
        inventory[itemId] = inventory[itemId] - 1
        table.insert(result.inventoryUpdates, {
            itemId = itemId,
            change = -1,
            remaining = inventory[itemId]
        })
    end
    
    return result
end

-- Execute ability-based status healing or prevention
-- @param battleState: Current battle state
-- @param pokemon: Pokemon with the healing ability
-- @param abilityId: ID of the healing ability
-- @param trigger: Trigger context (switch_out, status_attempt, etc.)
-- @param statusBeingApplied: Status effect being applied (for prevention)
-- @return: Healing/prevention result
function StatusHealing.executeAbilityBased(battleState, pokemon, abilityId, trigger, statusBeingApplied)
    if not pokemon or not abilityId or not trigger then
        return {success = false, error = "Invalid ability healing parameters"}
    end
    
    -- Find healing ability configuration
    local healingAbility = nil
    for abilityName, config in pairs(StatusHealing.HealingAbilities) do
        if config.abilityId == abilityId and config.trigger == trigger then
            healingAbility = config
            break
        end
    end
    
    if not healingAbility then
        return {success = false, error = "Ability does not provide healing for this trigger"}
    end
    
    local result = {
        success = true,
        method = StatusHealing.HealingMethod.ABILITY,
        trigger = trigger,
        healedPokemon = {},
        preventedStatuses = {},
        messages = {}
    }
    
    -- Handle prevention abilities
    if trigger == "status_attempt" and healingAbility.preventsSpecific then
        if not statusBeingApplied then
            return {success = false, error = "No status being applied to prevent"}
        end
        
        for _, preventedStatus in ipairs(healingAbility.preventsSpecific) do
            if preventedStatus == statusBeingApplied then
                table.insert(result.preventedStatuses, {
                    pokemon = pokemon,
                    preventedStatus = statusBeingApplied,
                    ability = abilityId
                })
                
                -- Generate prevention message
                local message = healingAbility.message
                message = string.gsub(message, "{pokemon}", pokemon.name)
                table.insert(result.messages, message)
                
                result.statusPrevented = true
                return result
            end
        end
    end
    
    -- Handle healing abilities
    if trigger == "switch_out" or trigger == "end_of_turn" then
        local healingResult = StatusHealing.applyHealing(pokemon, healingAbility, pokemon)
        if healingResult.healed then
            table.insert(result.healedPokemon, {
                pokemon = pokemon,
                previousStatus = healingResult.previousStatus,
                method = "ability"
            })
            
            -- Generate healing message
            local message = healingAbility.message
            message = string.gsub(message, "{pokemon}", pokemon.name)
            table.insert(result.messages, message)
        end
    end
    
    return result
end

-- Execute automatic berry healing (when status is applied)
-- @param pokemon: Pokemon with held berry
-- @param statusApplied: Status effect that was just applied
-- @return: Auto-healing result
function StatusHealing.executeAutoBerryHealing(pokemon, statusApplied)
    if not pokemon or not pokemon.heldItem then
        return {success = false, autoHealed = false}
    end
    
    -- Find matching auto-healing berry
    local healingBerry = nil
    for berryName, config in pairs(StatusHealing.HealingItems) do
        if config.itemId == pokemon.heldItem and config.autoUse then
            -- Check if berry heals this specific status
            if config.healsAll then
                healingBerry = config
                break
            elseif config.healsSpecific then
                for _, healedStatus in ipairs(config.healsSpecific) do
                    if healedStatus == statusApplied then
                        healingBerry = config
                        break
                    end
                end
                if healingBerry then break end
            end
        end
    end
    
    if not healingBerry then
        return {success = false, autoHealed = false}
    end
    
    local result = {
        success = true,
        autoHealed = true,
        method = StatusHealing.HealingMethod.ITEM,
        healedPokemon = {},
        messages = {}
    }
    
    -- Apply healing
    local healingResult = StatusHealing.applyHealing(pokemon, healingBerry, pokemon)
    if healingResult.healed then
        table.insert(result.healedPokemon, {
            pokemon = pokemon,
            previousStatus = healingResult.previousStatus,
            method = "auto_berry"
        })
        
        -- Generate healing message
        local message = healingBerry.message
        message = string.gsub(message, "{pokemon}", pokemon.name)
        table.insert(result.messages, message)
        
        -- Remove consumed berry
        pokemon.heldItem = nil
        result.berryConsumed = healingBerry.itemId
    end
    
    return result
end

-- Apply healing to a Pokemon
-- @param pokemon: Pokemon to heal
-- @param healingConfig: Healing method configuration
-- @param source: Pokemon or entity providing the healing
-- @return: Healing application result
function StatusHealing.applyHealing(pokemon, healingConfig, source)
    if not pokemon or not pokemon.statusEffect then
        return {healed = false, reason = "No status to heal"}
    end
    
    local result = {
        healed = false,
        previousStatus = pokemon.statusEffect,
        method = healingConfig
    }
    
    -- Check if the healing method can cure the current status
    local canHeal = false
    
    if healingConfig.healsAll then
        canHeal = true
    elseif healingConfig.healsSpecific then
        for _, healableStatus in ipairs(healingConfig.healsSpecific) do
            if healableStatus == pokemon.statusEffect then
                canHeal = true
                break
            end
        end
    end
    
    if canHeal then
        -- Clear the status effect
        local clearResult = StatusEffects.clearStatusEffect(pokemon, nil)
        if clearResult.success then
            result.healed = true
            result.clearResult = clearResult
        end
    else
        result.reason = "Healing method doesn't cure this status"
    end
    
    return result
end

-- Get target Pokemon for healing scope
-- @param battleState: Current battle state
-- @param sourcePokemon: Pokemon providing healing
-- @param scope: Healing scope
-- @param explicitTarget: Explicitly specified target
-- @return: List of target Pokemon
function StatusHealing.getTargetsForScope(battleState, sourcePokemon, scope, explicitTarget)
    local targets = {}
    
    if scope == StatusHealing.HealingScope.SELF then
        table.insert(targets, sourcePokemon)
        
    elseif scope == StatusHealing.HealingScope.TARGET then
        if explicitTarget then
            table.insert(targets, explicitTarget)
        else
            table.insert(targets, sourcePokemon) -- Default to self if no target
        end
        
    elseif scope == StatusHealing.HealingScope.TEAM then
        -- Find source Pokemon's team
        local isPlayerPokemon = false
        for _, pokemon in ipairs(battleState.playerParty) do
            if pokemon.id == sourcePokemon.id then
                isPlayerPokemon = true
                break
            end
        end
        
        -- Add all team members
        local teamParty = isPlayerPokemon and battleState.playerParty or battleState.enemyParty
        for _, pokemon in ipairs(teamParty) do
            if pokemon.currentHP > 0 then -- Only heal conscious Pokemon
                table.insert(targets, pokemon)
            end
        end
        
    elseif scope == StatusHealing.HealingScope.ALL then
        -- Add all Pokemon in battle
        for _, pokemon in ipairs(battleState.playerParty) do
            if pokemon.currentHP > 0 then
                table.insert(targets, pokemon)
            end
        end
        for _, pokemon in ipairs(battleState.enemyParty) do
            if pokemon.currentHP > 0 then
                table.insert(targets, pokemon)
            end
        end
    end
    
    return targets
end

-- Check if a Pokemon has any healing items available
-- @param pokemon: Pokemon to check
-- @param inventory: Available inventory
-- @return: List of available healing items
function StatusHealing.getAvailableHealingItems(pokemon, inventory)
    local availableItems = {}
    
    if not inventory then
        return availableItems
    end
    
    for itemName, config in pairs(StatusHealing.HealingItems) do
        if inventory[config.itemId] and inventory[config.itemId] > 0 then
            -- Check if item can heal current status
            local canHeal = false
            if pokemon.statusEffect then
                if config.healsAll then
                    canHeal = true
                elseif config.healsSpecific then
                    for _, healableStatus in ipairs(config.healsSpecific) do
                        if healableStatus == pokemon.statusEffect then
                            canHeal = true
                            break
                        end
                    end
                end
            end
            
            if canHeal then
                table.insert(availableItems, {
                    itemId = config.itemId,
                    name = itemName,
                    available = inventory[config.itemId],
                    config = config
                })
            end
        end
    end
    
    return availableItems
end

-- Get comprehensive healing summary for a Pokemon
-- @param pokemon: Pokemon to get healing info for
-- @param battleState: Current battle state
-- @param inventory: Available inventory
-- @return: Healing options summary
function StatusHealing.getHealingOptions(pokemon, battleState, inventory)
    if not pokemon then
        return {hasOptions = false}
    end
    
    local options = {
        hasOptions = false,
        currentStatus = pokemon.statusEffect,
        healingMoves = {},
        healingItems = {},
        healingAbilities = {},
        autoHealing = {}
    }
    
    if not pokemon.statusEffect then
        return options
    end
    
    -- Check for healing moves
    if pokemon.moves then
        for moveId, moveData in pairs(pokemon.moves) do
            for moveName, config in pairs(StatusHealing.HealingMoves) do
                if config.moveId == moveId then
                    -- Check if move can heal current status
                    local canHeal = config.healsAll
                    if not canHeal and config.healsSpecific then
                        for _, healableStatus in ipairs(config.healsSpecific) do
                            if healableStatus == pokemon.statusEffect then
                                canHeal = true
                                break
                            end
                        end
                    end
                    
                    if canHeal then
                        table.insert(options.healingMoves, {
                            moveId = moveId,
                            name = moveName,
                            scope = config.scope,
                            pp = moveData.pp
                        })
                        options.hasOptions = true
                    end
                end
            end
        end
    end
    
    -- Check for healing items
    local availableItems = StatusHealing.getAvailableHealingItems(pokemon, inventory)
    for _, item in ipairs(availableItems) do
        table.insert(options.healingItems, item)
        options.hasOptions = true
    end
    
    -- Check for healing abilities
    if pokemon.ability then
        for abilityName, config in pairs(StatusHealing.HealingAbilities) do
            if config.abilityId == pokemon.ability then
                table.insert(options.healingAbilities, {
                    abilityId = pokemon.ability,
                    name = abilityName,
                    trigger = config.trigger
                })
                options.hasOptions = true
            end
        end
    end
    
    -- Check for auto-healing items
    if pokemon.heldItem then
        for itemName, config in pairs(StatusHealing.HealingItems) do
            if config.itemId == pokemon.heldItem and config.autoUse then
                -- Check if item can heal current status
                local canAutoHeal = config.healsAll
                if not canAutoHeal and config.healsSpecific then
                    for _, healableStatus in ipairs(config.healsSpecific) do
                        if healableStatus == pokemon.statusEffect then
                            canAutoHeal = true
                            break
                        end
                    end
                end
                
                if canAutoHeal then
                    table.insert(options.autoHealing, {
                        itemId = pokemon.heldItem,
                        name = itemName
                    })
                end
            end
        end
    end
    
    return options
end


-- ===== END MODULE: game-logic.pokemon.status-healing =====


-- ===== MODULE: game-logic.pokemon.status-immunities =====
-- File: ao-processes/game-logic/pokemon/status-immunities.lua
-- Original require: local StatusImmunities = require("game-logic.pokemon.status-immunities")

-- Pokemon Status Immunities System
-- Implements type-based and ability-based status immunities
-- Validates status prevention and immunity checking
-- Integrates with species database and Pokemon creation system

local StatusImmunities = {}

-- Load dependencies

-- ===== MODULE: game-logic.pokemon.status-effects =====
-- File: ao-processes/game-logic/pokemon/status-effects.lua
-- Original require: local StatusEffects = require("game-logic.pokemon.status-effects")


-- ===== END MODULE: game-logic.pokemon.status-effects =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Type-based status immunities
StatusImmunities.TypeImmunities = {
    [Enums.Type.ELECTRIC] = {
        StatusEffects.StatusType.PARALYSIS
    },
    [Enums.Type.FIRE] = {
        StatusEffects.StatusType.BURN,
        StatusEffects.StatusType.FREEZE
    },
    [Enums.Type.ICE] = {
        StatusEffects.StatusType.FREEZE
    },
    [Enums.Type.POISON] = {
        StatusEffects.StatusType.POISON,
        StatusEffects.StatusType.BADLY_POISONED
    },
    [Enums.Type.STEEL] = {
        StatusEffects.StatusType.POISON,
        StatusEffects.StatusType.BADLY_POISONED
    }
}

-- Ability-based status immunities
StatusImmunities.AbilityImmunities = {
    -- Complete status immunity abilities
    [7] = { -- LIMBER
        immuneTo = {StatusEffects.StatusType.PARALYSIS},
        name = "Limber",
        message = "{pokemon}'s Limber prevents paralysis!"
    },
    [15] = { -- INSOMNIA
        immuneTo = {StatusEffects.StatusType.SLEEP},
        name = "Insomnia", 
        message = "{pokemon}'s Insomnia prevents sleep!"
    },
    [17] = { -- IMMUNITY
        immuneTo = {StatusEffects.StatusType.POISON, StatusEffects.StatusType.BADLY_POISONED},
        name = "Immunity",
        message = "{pokemon}'s Immunity prevents poison!"
    },
    [40] = { -- MAGMA_ARMOR
        immuneTo = {StatusEffects.StatusType.FREEZE},
        name = "Magma Armor",
        message = "{pokemon}'s Magma Armor prevents freezing!"
    },
    [41] = { -- WATER_VEIL
        immuneTo = {StatusEffects.StatusType.BURN},
        name = "Water Veil",
        message = "{pokemon}'s Water Veil prevents burns!"
    },
    [72] = { -- VITAL_SPIRIT
        immuneTo = {StatusEffects.StatusType.SLEEP},
        name = "Vital Spirit",
        message = "{pokemon}'s Vital Spirit prevents sleep!"
    },
    [119] = { -- LEAF_GUARD (only in harsh sunlight)
        immuneTo = "all_non_volatile", -- Special handling required
        name = "Leaf Guard",
        condition = "harsh_sunlight",
        message = "{pokemon}'s Leaf Guard prevents status conditions!"
    },
    [43] = { -- OWN_TEMPO
        immuneTo = "confusion", -- Note: confusion is not a major status, but included for completeness
        name = "Own Tempo",
        message = "{pokemon}'s Own Tempo prevents confusion!"
    },
    [93] = { -- OBLIVIOUS
        immuneTo = "infatuation", -- Note: infatuation handling would be separate
        name = "Oblivious",
        message = "{pokemon}'s Oblivious prevents infatuation!"
    }
}

-- Conditional immunity requirements
StatusImmunities.ConditionalImmunities = {
    LEAF_GUARD = {
        abilityId = 119,
        condition = function(battleState)
            return battleState.battleConditions.weather == Enums.Weather.HARSH_SUNLIGHT
        end,
        immuneTo = {
            StatusEffects.StatusType.SLEEP,
            StatusEffects.StatusType.POISON,
            StatusEffects.StatusType.BADLY_POISONED,
            StatusEffects.StatusType.PARALYSIS,
            StatusEffects.StatusType.BURN,
            StatusEffects.StatusType.FREEZE
        }
    }
}

-- Initialize status immunities system
function StatusImmunities.init()
    -- Status immunities system is stateless, no initialization needed
    return true
end

-- Check if a Pokemon is immune to a specific status effect
-- @param pokemon: Pokemon to check immunity for
-- @param statusType: Status effect type to check
-- @param battleState: Current battle state (for conditional immunities)
-- @return: Immunity check result with reason and messages
function StatusImmunities.checkStatusImmunity(pokemon, statusType, battleState)
    if not pokemon or not statusType then
        return {immune = false, error = "Invalid immunity check parameters"}
    end
    
    local result = {
        immune = false,
        immunityType = nil,
        immunitySource = nil,
        message = nil,
        bypassable = false
    }
    
    -- Check type-based immunities
    local typeImmunity = StatusImmunities.checkTypeImmunity(pokemon, statusType)
    if typeImmunity.immune then
        result.immune = true
        result.immunityType = "type"
        result.immunitySource = typeImmunity.pokemonType
        result.message = StatusImmunities.generateTypeImmunityMessage(pokemon, statusType, typeImmunity.pokemonType)
        return result
    end
    
    -- Check ability-based immunities
    local abilityImmunity = StatusImmunities.checkAbilityImmunity(pokemon, statusType, battleState)
    if abilityImmunity.immune then
        result.immune = true
        result.immunityType = "ability"
        result.immunitySource = abilityImmunity.ability
        result.message = abilityImmunity.message
        result.bypassable = abilityImmunity.bypassable or false
        return result
    end
    
    -- Check conditional immunities
    local conditionalImmunity = StatusImmunities.checkConditionalImmunity(pokemon, statusType, battleState)
    if conditionalImmunity.immune then
        result.immune = true
        result.immunityType = "conditional"
        result.immunitySource = conditionalImmunity.source
        result.message = conditionalImmunity.message
        result.condition = conditionalImmunity.condition
        return result
    end
    
    return result
end

-- Check type-based status immunity
-- @param pokemon: Pokemon to check
-- @param statusType: Status effect type
-- @return: Type immunity result
function StatusImmunities.checkTypeImmunity(pokemon, statusType)
    if not pokemon.types or #pokemon.types == 0 then
        return {immune = false}
    end
    
    -- Check each of the Pokemon's types
    for _, pokemonType in ipairs(pokemon.types) do
        local typeImmunities = StatusImmunities.TypeImmunities[pokemonType]
        if typeImmunities then
            for _, immuneStatus in ipairs(typeImmunities) do
                if immuneStatus == statusType then
                    return {
                        immune = true,
                        pokemonType = pokemonType,
                        immuneStatus = statusType
                    }
                end
            end
        end
    end
    
    return {immune = false}
end

-- Check ability-based status immunity
-- @param pokemon: Pokemon to check
-- @param statusType: Status effect type
-- @param battleState: Current battle state
-- @return: Ability immunity result
function StatusImmunities.checkAbilityImmunity(pokemon, statusType, battleState)
    if not pokemon.ability then
        return {immune = false}
    end
    
    local abilityImmunity = StatusImmunities.AbilityImmunities[pokemon.ability]
    if not abilityImmunity then
        return {immune = false}
    end
    
    -- Handle special case for abilities that prevent all non-volatile status
    if abilityImmunity.immuneTo == "all_non_volatile" then
        -- Check if condition is met (e.g., Leaf Guard in sunlight)
        if abilityImmunity.condition and battleState then
            if abilityImmunity.condition == "harsh_sunlight" then
                if battleState.battleConditions.weather == Enums.Weather.HARSH_SUNLIGHT then
                    local message = abilityImmunity.message
                    message = string.gsub(message, "{pokemon}", pokemon.name)
                    return {
                        immune = true,
                        ability = pokemon.ability,
                        message = message
                    }
                end
            end
        end
        return {immune = false}
    end
    
    -- Check specific status immunities
    if abilityImmunity.immuneTo then
        for _, immuneStatus in ipairs(abilityImmunity.immuneTo) do
            if immuneStatus == statusType then
                local message = abilityImmunity.message
                message = string.gsub(message, "{pokemon}", pokemon.name)
                return {
                    immune = true,
                    ability = pokemon.ability,
                    abilityName = abilityImmunity.name,
                    message = message
                }
            end
        end
    end
    
    return {immune = false}
end

-- Check conditional status immunity (weather, terrain, etc.)
-- @param pokemon: Pokemon to check
-- @param statusType: Status effect type
-- @param battleState: Current battle state
-- @return: Conditional immunity result
function StatusImmunities.checkConditionalImmunity(pokemon, statusType, battleState)
    if not battleState then
        return {immune = false}
    end
    
    -- Check Leaf Guard specifically (most common conditional immunity)
    for conditionName, condition in pairs(StatusImmunities.ConditionalImmunities) do
        if pokemon.ability == condition.abilityId then
            if condition.condition(battleState) then
                -- Check if this status is covered by the conditional immunity
                for _, immuneStatus in ipairs(condition.immuneTo) do
                    if immuneStatus == statusType then
                        return {
                            immune = true,
                            source = conditionName,
                            condition = "weather_condition",
                            message = pokemon.name .. "'s " .. conditionName .. " prevents status conditions!"
                        }
                    end
                end
            end
        end
    end
    
    -- Check terrain-based immunities
    if battleState.battleConditions.terrain then
        local terrainImmunity = StatusImmunities.checkTerrainImmunity(pokemon, statusType, battleState.battleConditions.terrain)
        if terrainImmunity.immune then
            return terrainImmunity
        end
    end
    
    return {immune = false}
end

-- Check terrain-based status immunity
-- @param pokemon: Pokemon to check
-- @param statusType: Status effect type
-- @param terrain: Current terrain type
-- @return: Terrain immunity result
function StatusImmunities.checkTerrainImmunity(pokemon, statusType, terrain)
    -- Electric Terrain prevents sleep for grounded Pokemon
    if terrain == Enums.Terrain.ELECTRIC_TERRAIN and statusType == StatusEffects.StatusType.SLEEP then
        -- Check if Pokemon is grounded (not Flying type, no Levitate, etc.)
        local isGrounded = StatusImmunities.isPokemonGrounded(pokemon)
        if isGrounded then
            return {
                immune = true,
                source = "Electric Terrain",
                condition = "terrain",
                message = "Electric Terrain prevents " .. pokemon.name .. " from falling asleep!"
            }
        end
    end
    
    -- Misty Terrain prevents all major status conditions for grounded Pokemon
    if terrain == Enums.Terrain.MISTY_TERRAIN then
        local isGrounded = StatusImmunities.isPokemonGrounded(pokemon)
        if isGrounded then
            return {
                immune = true,
                source = "Misty Terrain",
                condition = "terrain",
                message = "Misty Terrain prevents " .. pokemon.name .. " from getting a status condition!"
            }
        end
    end
    
    return {immune = false}
end

-- Check if Pokemon is grounded (affected by terrain)
-- @param pokemon: Pokemon to check
-- @return: Boolean indicating if Pokemon is grounded
function StatusImmunities.isPokemonGrounded(pokemon)
    if not pokemon or not pokemon.types then
        return true -- Default assumption
    end
    
    -- Flying-type Pokemon are not grounded
    for _, pokemonType in ipairs(pokemon.types) do
        if pokemonType == Enums.Type.FLYING then
            return false
        end
    end
    
    -- Pokemon with Levitate ability are not grounded
    if pokemon.ability == 26 then -- LEVITATE
        return false
    end
    
    -- Pokemon with Air Balloon are not grounded (item check would go here)
    if pokemon.heldItem == 541 then -- AIR_BALLOON
        return false
    end
    
    return true
end

-- Generate type immunity message
-- @param pokemon: Pokemon with immunity
-- @param statusType: Status being prevented
-- @param pokemonType: Type providing immunity
-- @return: Immunity message
function StatusImmunities.generateTypeImmunityMessage(pokemon, statusType, pokemonType)
    local typeNames = {
        [Enums.Type.ELECTRIC] = "Electric",
        [Enums.Type.FIRE] = "Fire",
        [Enums.Type.ICE] = "Ice",
        [Enums.Type.POISON] = "Poison", 
        [Enums.Type.STEEL] = "Steel"
    }
    
    local statusNames = {
        [StatusEffects.StatusType.PARALYSIS] = "paralysis",
        [StatusEffects.StatusType.BURN] = "burns",
        [StatusEffects.StatusType.FREEZE] = "freezing",
        [StatusEffects.StatusType.POISON] = "poison",
        [StatusEffects.StatusType.BADLY_POISONED] = "poison",
        [StatusEffects.StatusType.SLEEP] = "sleep"
    }
    
    local typeName = typeNames[pokemonType] or "Unknown"
    local statusName = statusNames[statusType] or "status condition"
    
    return pokemon.name .. "'s " .. typeName .. " type prevents " .. statusName .. "!"
end

-- Validate status immunity bypass (for certain moves/abilities)
-- @param pokemon: Pokemon with immunity
-- @param statusType: Status being applied
-- @param bypassMethod: Method attempting to bypass immunity
-- @param battleState: Current battle state
-- @return: Bypass validation result
function StatusImmunities.checkImmunityBypass(pokemon, statusType, bypassMethod, battleState)
    if not pokemon or not statusType or not bypassMethod then
        return {canBypass = false}
    end
    
    local result = {
        canBypass = false,
        bypassType = bypassMethod.type,
        bypassSource = bypassMethod.source,
        message = nil
    }
    
    -- Check for Mold Breaker ability (bypasses target's abilities)
    if bypassMethod.type == "ability" and bypassMethod.source == 104 then -- MOLD_BREAKER
        -- Can bypass ability-based immunities but not type-based
        local immunityCheck = StatusImmunities.checkStatusImmunity(pokemon, statusType, battleState)
        if immunityCheck.immune and immunityCheck.immunityType == "ability" then
            result.canBypass = true
            result.message = "Mold Breaker bypasses " .. pokemon.name .. "'s ability!"
        end
    end
    
    -- Check for moves that bypass certain immunities
    if bypassMethod.type == "move" then
        -- Corrosive moves can poison Steel types
        if bypassMethod.corrosive and (statusType == StatusEffects.StatusType.POISON or statusType == StatusEffects.StatusType.BADLY_POISONED) then
            local typeImmunity = StatusImmunities.checkTypeImmunity(pokemon, statusType)
            if typeImmunity.immune and typeImmunity.pokemonType == Enums.Type.STEEL then
                result.canBypass = true
                result.message = "The corrosive effect bypassed " .. pokemon.name .. "'s Steel typing!"
            end
        end
        
        -- Moves that ignore type immunities (like Soak changing type)
        if bypassMethod.ignoreType then
            local immunityCheck = StatusImmunities.checkStatusImmunity(pokemon, statusType, battleState)
            if immunityCheck.immune and immunityCheck.immunityType == "type" then
                result.canBypass = true
                result.message = "The move bypassed type immunity!"
            end
        end
    end
    
    return result
end

-- Get comprehensive immunity information for a Pokemon
-- @param pokemon: Pokemon to check
-- @param battleState: Current battle state
-- @return: Complete immunity information
function StatusImmunities.getPokemonImmunityInfo(pokemon, battleState)
    if not pokemon then
        return {hasImmunities = false}
    end
    
    local info = {
        hasImmunities = false,
        typeImmunities = {},
        abilityImmunities = {},
        conditionalImmunities = {},
        activeImmunities = {}
    }
    
    -- Check type-based immunities
    if pokemon.types then
        for _, pokemonType in ipairs(pokemon.types) do
            local typeImmunities = StatusImmunities.TypeImmunities[pokemonType]
            if typeImmunities then
                info.hasImmunities = true
                for _, immuneStatus in ipairs(typeImmunities) do
                    table.insert(info.typeImmunities, {
                        type = pokemonType,
                        immuneTo = immuneStatus
                    })
                    table.insert(info.activeImmunities, immuneStatus)
                end
            end
        end
    end
    
    -- Check ability-based immunities
    if pokemon.ability then
        local abilityImmunity = StatusImmunities.AbilityImmunities[pokemon.ability]
        if abilityImmunity then
            info.hasImmunities = true
            table.insert(info.abilityImmunities, {
                ability = pokemon.ability,
                name = abilityImmunity.name,
                immuneTo = abilityImmunity.immuneTo
            })
            
            if type(abilityImmunity.immuneTo) == "table" then
                for _, immuneStatus in ipairs(abilityImmunity.immuneTo) do
                    table.insert(info.activeImmunities, immuneStatus)
                end
            end
        end
    end
    
    -- Check conditional immunities
    if battleState then
        for conditionName, condition in pairs(StatusImmunities.ConditionalImmunities) do
            if pokemon.ability == condition.abilityId and condition.condition(battleState) then
                info.hasImmunities = true
                table.insert(info.conditionalImmunities, {
                    condition = conditionName,
                    ability = pokemon.ability,
                    immuneTo = condition.immuneTo
                })
                
                for _, immuneStatus in ipairs(condition.immuneTo) do
                    table.insert(info.activeImmunities, immuneStatus)
                end
            end
        end
        
        -- Check terrain immunities
        if battleState.battleConditions.terrain then
            local terrain = battleState.battleConditions.terrain
            local isGrounded = StatusImmunities.isPokemonGrounded(pokemon)
            
            if isGrounded then
                if terrain == Enums.Terrain.ELECTRIC_TERRAIN then
                    info.hasImmunities = true
                    table.insert(info.activeImmunities, StatusEffects.StatusType.SLEEP)
                elseif terrain == Enums.Terrain.MISTY_TERRAIN then
                    info.hasImmunities = true
                    table.insert(info.activeImmunities, StatusEffects.StatusType.SLEEP)
                    table.insert(info.activeImmunities, StatusEffects.StatusType.POISON)
                    table.insert(info.activeImmunities, StatusEffects.StatusType.BADLY_POISONED)
                    table.insert(info.activeImmunities, StatusEffects.StatusType.PARALYSIS)
                    table.insert(info.activeImmunities, StatusEffects.StatusType.BURN)
                    table.insert(info.activeImmunities, StatusEffects.StatusType.FREEZE)
                end
            end
        end
    end
    
    -- Remove duplicates from activeImmunities
    local seen = {}
    local uniqueImmunities = {}
    for _, immunity in ipairs(info.activeImmunities) do
        if not seen[immunity] then
            seen[immunity] = true
            table.insert(uniqueImmunities, immunity)
        end
    end
    info.activeImmunities = uniqueImmunities
    
    return info
end

-- Validate status application considering all immunities
-- @param pokemon: Pokemon to apply status to
-- @param statusType: Status effect type
-- @param battleState: Current battle state
-- @param bypassMethod: Optional bypass method
-- @return: Complete validation result
function StatusImmunities.validateStatusApplication(pokemon, statusType, battleState, bypassMethod)
    if not pokemon or not statusType then
        return {valid = false, error = "Invalid parameters"}
    end
    
    local result = {
        valid = true,
        blocked = false,
        immunityType = nil,
        immunitySource = nil,
        bypassUsed = false,
        message = nil
    }
    
    -- Check for immunity
    local immunityCheck = StatusImmunities.checkStatusImmunity(pokemon, statusType, battleState)
    if immunityCheck.immune then
        result.blocked = true
        result.immunityType = immunityCheck.immunityType
        result.immunitySource = immunityCheck.immunitySource
        result.message = immunityCheck.message
        
        -- Check for bypass if available
        if bypassMethod and immunityCheck.bypassable ~= false then
            local bypassCheck = StatusImmunities.checkImmunityBypass(pokemon, statusType, bypassMethod, battleState)
            if bypassCheck.canBypass then
                result.blocked = false
                result.bypassUsed = true
                result.message = bypassCheck.message
            else
                result.valid = false
            end
        else
            result.valid = false
        end
    end
    
    return result
end


-- ===== END MODULE: game-logic.pokemon.status-immunities =====


-- Weather system dependencies

-- ===== MODULE: game-logic.battle.weather-effects =====
-- File: ao-processes/game-logic/battle/weather-effects.lua
-- Original require: local WeatherEffects = require("game-logic.battle.weather-effects")

-- Weather Effects System
-- Core weather mechanics and interactions for Pokemon battles
-- Implements Sun, Rain, Sandstorm, and Hail with proper battle effects

local WeatherEffects = {}

-- Load dependencies

-- ===== MODULE: game-logic.battle.battle-conditions =====
-- File: ao-processes/game-logic/battle/battle-conditions.lua
-- Original require: local BattleConditions = require("game-logic.battle.battle-conditions")


-- ===== END MODULE: game-logic.battle.battle-conditions =====


-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Weather type constants (re-export from BattleConditions for convenience)
WeatherEffects.WeatherType = BattleConditions.WeatherType

-- Initialize weather for a battle
-- @param battleId: Battle instance identifier  
-- @param initialWeather: Initial weather type (default NONE)
-- @param duration: Duration override (nil for default)
-- @param source: Source of weather initialization
-- @return: Success boolean and weather state
function WeatherEffects.initializeWeather(battleId, initialWeather, duration, source)
    if not battleId then
        return false, "Battle ID required"
    end
    
    local weatherType = initialWeather or BattleConditions.WeatherType.NONE
    return BattleConditions.setWeather(battleId, weatherType, duration, source or "battle_init")
end

-- Process all weather effects for end of turn
-- @param battleId: Battle instance identifier
-- @param battleState: Current battle state with Pokemon and weather data
-- @return: Weather effects results including damage, healing, and ability triggers
function WeatherEffects.processEndOfTurnWeatherEffects(battleId, battleState)
    if not battleId or not battleState or not battleState.weather then
        return {damage_results = {}, healing_results = {}, ability_triggers = {}}
    end
    
    local results = {
        damage_results = {},
        healing_results = {},
        ability_triggers = {},
        weather_updated = false
    }
    
    local currentWeather = battleState.weather.type
    local weatherData = BattleConditions.WeatherData[currentWeather]
    
    if not weatherData then
        return results
    end
    
    -- Collect all active Pokemon
    local allPokemon = {}
    if battleState.playerParty then
        for _, pokemon in ipairs(battleState.playerParty) do
            if pokemon and pokemon.currentHP > 0 then
                table.insert(allPokemon, pokemon)
            end
        end
    end
    if battleState.enemyParty then
        for _, pokemon in ipairs(battleState.enemyParty) do
            if pokemon and pokemon.currentHP > 0 then
                table.insert(allPokemon, pokemon)
            end
        end
    end
    
    -- Process weather damage (Sandstorm, Hail)
    if weatherData.damage_per_turn then
        local damageResults = WeatherEffects.processWeatherDamage(currentWeather, allPokemon)
        for _, dmgResult in ipairs(damageResults) do
            table.insert(results.damage_results, dmgResult)
        end
    end
    
    -- Process weather-based healing (Rain Dish, Ice Body)
    local healingResults = WeatherEffects.processWeatherHealing(currentWeather, allPokemon)
    for _, healResult in ipairs(healingResults) do
        table.insert(results.healing_results, healResult)
    end
    
    -- Process weather-based ability triggers (Solar Power)
    local abilityResults = WeatherEffects.processWeatherAbilityTriggers(currentWeather, allPokemon)
    for _, abilityResult in ipairs(abilityResults) do
        table.insert(results.ability_triggers, abilityResult)
    end
    
    return results
end

-- Process weather damage for Sandstorm and Hail
-- @param weatherType: Current weather type
-- @param pokemonList: List of active Pokemon
-- @return: List of damage results
function WeatherEffects.processWeatherDamage(weatherType, pokemonList)
    local weatherData = BattleConditions.WeatherData[weatherType]
    if not weatherData or not weatherData.damage_per_turn then
        return {}
    end
    
    local damageResults = {}
    
    for _, pokemon in ipairs(pokemonList) do
        local takeDamage = true
        
        -- Check type immunity
        if weatherData.immune_types then
            for _, immuneType in ipairs(weatherData.immune_types) do
                if pokemon.types and (pokemon.types[1] == immuneType or pokemon.types[2] == immuneType) then
                    takeDamage = false
                    break
                end
            end
        end
        
        -- Check ability protection
        if takeDamage and pokemon.ability then
            local protectiveAbilities = {
                [Enums.AbilityId.SAND_VEIL] = {WeatherEffects.WeatherType.SANDSTORM},
                [Enums.AbilityId.SAND_RUSH] = {WeatherEffects.WeatherType.SANDSTORM},
                [Enums.AbilityId.ICE_BODY] = {WeatherEffects.WeatherType.HAIL},
                [Enums.AbilityId.OVERCOAT] = {WeatherEffects.WeatherType.SANDSTORM, WeatherEffects.WeatherType.HAIL},
                [Enums.AbilityId.SAFETY_GOGGLES] = {WeatherEffects.WeatherType.SANDSTORM, WeatherEffects.WeatherType.HAIL}
            }
            
            if protectiveAbilities[pokemon.ability] then
                for _, protectedWeather in ipairs(protectiveAbilities[pokemon.ability]) do
                    if weatherType == protectedWeather then
                        takeDamage = false
                        break
                    end
                end
            end
        end
        
        if takeDamage then
            local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP] or 100
            local damage = math.max(1, math.floor(maxHP / 16)) -- 1/16 max HP damage
            
            table.insert(damageResults, {
                pokemon_id = pokemon.id or "unknown",
                pokemon_name = pokemon.name or "Unknown Pokemon",
                damage = damage,
                weather = weatherData.name,
                damage_type = "weather"
            })
        end
    end
    
    return damageResults
end

-- Process weather-based healing (Rain Dish, Ice Body)
-- @param weatherType: Current weather type
-- @param pokemonList: List of active Pokemon
-- @return: List of healing results
function WeatherEffects.processWeatherHealing(weatherType, pokemonList)
    local healingResults = {}
    
    -- Rain Dish healing in rain
    if weatherType == WeatherEffects.WeatherType.RAIN then
        for _, pokemon in ipairs(pokemonList) do
            if pokemon.ability == Enums.AbilityId.RAIN_DISH and pokemon.currentHP < pokemon.maxHP then
                local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP] or 100
                local healing = math.max(1, math.floor(maxHP / 16)) -- 1/16 max HP healing
                
                table.insert(healingResults, {
                    pokemon_id = pokemon.id or "unknown",
                    pokemon_name = pokemon.name or "Unknown Pokemon",
                    healing = healing,
                    ability = "Rain Dish",
                    weather = "Rain"
                })
            end
        end
    end
    
    -- Ice Body healing in hail
    if weatherType == WeatherEffects.WeatherType.HAIL then
        for _, pokemon in ipairs(pokemonList) do
            if pokemon.ability == Enums.AbilityId.ICE_BODY and pokemon.currentHP < pokemon.maxHP then
                local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP] or 100
                local healing = math.max(1, math.floor(maxHP / 16)) -- 1/16 max HP healing
                
                table.insert(healingResults, {
                    pokemon_id = pokemon.id or "unknown",
                    pokemon_name = pokemon.name or "Unknown Pokemon",
                    healing = healing,
                    ability = "Ice Body",
                    weather = "Hail"
                })
            end
        end
    end
    
    return healingResults
end

-- Process weather-based ability triggers (Solar Power, etc.)
-- @param weatherType: Current weather type
-- @param pokemonList: List of active Pokemon
-- @return: List of ability trigger results
function WeatherEffects.processWeatherAbilityTriggers(weatherType, pokemonList)
    local abilityResults = {}
    
    -- Solar Power in sun (Special Attack boost but HP loss)
    if weatherType == WeatherEffects.WeatherType.SUNNY then
        for _, pokemon in ipairs(pokemonList) do
            if pokemon.ability == Enums.AbilityId.SOLAR_POWER then
                local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP] or 100
                local damage = math.max(1, math.floor(maxHP / 8)) -- 1/8 max HP damage
                
                table.insert(abilityResults, {
                    pokemon_id = pokemon.id or "unknown",
                    pokemon_name = pokemon.name or "Unknown Pokemon",
                    ability = "Solar Power",
                    weather = "Sun",
                    effect_type = "damage",
                    damage = damage,
                    stat_boost = {stat = "spatk", modifier = 1.5}
                })
            end
        end
    end
    
    return abilityResults
end

-- Calculate weather-modified move power
-- @param moveType: Type of the move
-- @param movePower: Base power of the move
-- @param weatherType: Current weather type
-- @return: Modified move power
function WeatherEffects.getWeatherModifiedPower(moveType, movePower, weatherType)
    if not moveType or not movePower or movePower <= 0 then
        return movePower
    end
    
    local modifier = BattleConditions.getWeatherMovePowerModifier(moveType, weatherType)
    return math.floor(movePower * modifier)
end

-- Check if move accuracy is modified by weather
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @return: Modified accuracy (percentage) or nil if no change
function WeatherEffects.getWeatherModifiedAccuracy(moveName, weatherType)
    local weatherData = BattleConditions.WeatherData[weatherType]
    if not weatherData or not weatherData.accuracy_moves then
        return nil
    end
    
    return weatherData.accuracy_moves[moveName]
end

-- Check if weather blocks a move completely
-- @param moveType: Type of move being used
-- @param weatherType: Current weather type
-- @return: Boolean indicating if move is blocked, reason string
function WeatherEffects.doesWeatherBlockMove(moveType, weatherType)
    local blocked = BattleConditions.doesWeatherBlockMove(moveType, weatherType)
    
    if blocked then
        local weatherData = BattleConditions.WeatherData[weatherType]
        local weatherName = weatherData and weatherData.name or "Unknown Weather"
        local reason = "Move blocked by " .. weatherName
        return true, reason
    end
    
    return false, nil
end

-- Update weather duration and check for expiration
-- @param currentWeather: Current weather state
-- @return: Updated weather state, boolean indicating if weather expired
function WeatherEffects.updateWeatherDuration(currentWeather)
    if not currentWeather or not currentWeather.duration then
        return currentWeather, false
    end
    
    local newDuration, expired = BattleConditions.updateDuration("weather", currentWeather.duration)
    
    local updatedWeather = {
        type = expired and BattleConditions.WeatherType.NONE or currentWeather.type,
        duration = expired and 0 or newDuration,
        source = expired and "expired" or currentWeather.source
    }
    
    return updatedWeather, expired
end

-- Get stat modifier for weather-affected abilities
-- @param pokemon: Pokemon data with ability
-- @param statType: Type of stat being modified
-- @param weatherType: Current weather type
-- @return: Stat modifier (1.0 = no change, 1.5 = 50% boost, etc.)
function WeatherEffects.getWeatherStatModifier(pokemon, statType, weatherType)
    if not pokemon or not pokemon.ability or not statType then
        return 1.0
    end
    
    local ability = pokemon.ability
    
    -- Speed boost abilities
    if statType == Enums.Stat.SPEED then
        if weatherType == WeatherEffects.WeatherType.RAIN and ability == Enums.AbilityId.SWIFT_SWIM then
            return 2.0 -- Double speed in rain
        elseif weatherType == WeatherEffects.WeatherType.SUNNY and ability == Enums.AbilityId.CHLOROPHYLL then
            return 2.0 -- Double speed in sun
        elseif weatherType == WeatherEffects.WeatherType.SANDSTORM and ability == Enums.AbilityId.SAND_RUSH then
            return 2.0 -- Double speed in sandstorm
        end
    end
    
    -- Special Attack boost (Solar Power handled in ability triggers)
    if statType == Enums.Stat.SPATK then
        if weatherType == WeatherEffects.WeatherType.SUNNY and ability == Enums.AbilityId.SOLAR_POWER then
            return 1.5 -- 50% special attack boost in sun
        end
    end
    
    -- Special Defense boost for Rock types in Sandstorm
    if statType == Enums.Stat.SPDEF then
        if weatherType == WeatherEffects.WeatherType.SANDSTORM and 
           pokemon.types and (pokemon.types[1] == Enums.PokemonType.ROCK or pokemon.types[2] == Enums.PokemonType.ROCK) then
            return 1.5 -- 50% special defense boost for Rock types
        end
    end
    
    return 1.0
end

-- Weather-dependent move data and interactions
WeatherEffects.WeatherMoveData = {
    -- Thunder - 100% accuracy in rain, normal accuracy otherwise
    thunder = {
        normal_accuracy = 70,
        weather_modifications = {
            [WeatherEffects.WeatherType.RAIN] = {accuracy = 100},
            [WeatherEffects.WeatherType.SUNNY] = {accuracy = 50} -- Reduced in harsh sun in some games
        }
    },
    -- Hurricane - 100% accuracy in rain, reduced in sandstorm
    hurricane = {
        normal_accuracy = 70,
        weather_modifications = {
            [WeatherEffects.WeatherType.RAIN] = {accuracy = 100},
            [WeatherEffects.WeatherType.SANDSTORM] = {accuracy = 50}
        }
    },
    -- Blizzard - 100% accuracy in hail
    blizzard = {
        normal_accuracy = 70,
        weather_modifications = {
            [WeatherEffects.WeatherType.HAIL] = {accuracy = 100}
        }
    },
    -- Solar Beam - skips charging turn in sun, half power in other weather
    solar_beam = {
        normal_power = 120,
        normal_charging = true,
        weather_modifications = {
            [WeatherEffects.WeatherType.SUNNY] = {charging = false, power = 120},
            [WeatherEffects.WeatherType.RAIN] = {charging = true, power = 60},
            [WeatherEffects.WeatherType.SANDSTORM] = {charging = true, power = 60},
            [WeatherEffects.WeatherType.HAIL] = {charging = true, power = 60}
        }
    },
    -- Weather Ball - changes type and doubles power based on weather
    weather_ball = {
        normal_power = 50,
        normal_type = Enums.PokemonType.NORMAL,
        weather_modifications = {
            [WeatherEffects.WeatherType.SUNNY] = {power = 100, type = Enums.PokemonType.FIRE},
            [WeatherEffects.WeatherType.RAIN] = {power = 100, type = Enums.PokemonType.WATER},
            [WeatherEffects.WeatherType.SANDSTORM] = {power = 100, type = Enums.PokemonType.ROCK},
            [WeatherEffects.WeatherType.HAIL] = {power = 100, type = Enums.PokemonType.ICE}
        }
    },
    -- Synthesis, Morning Sun, Moonlight - heal more in sun, less in other weather
    synthesis = {
        normal_healing = "1/2",
        weather_modifications = {
            [WeatherEffects.WeatherType.SUNNY] = {healing = "2/3"},
            [WeatherEffects.WeatherType.RAIN] = {healing = "1/4"},
            [WeatherEffects.WeatherType.SANDSTORM] = {healing = "1/4"},
            [WeatherEffects.WeatherType.HAIL] = {healing = "1/4"}
        }
    },
    morning_sun = {
        normal_healing = "1/2",
        weather_modifications = {
            [WeatherEffects.WeatherType.SUNNY] = {healing = "2/3"},
            [WeatherEffects.WeatherType.RAIN] = {healing = "1/4"},
            [WeatherEffects.WeatherType.SANDSTORM] = {healing = "1/4"},
            [WeatherEffects.WeatherType.HAIL] = {healing = "1/4"}
        }
    },
    moonlight = {
        normal_healing = "1/2",
        weather_modifications = {
            [WeatherEffects.WeatherType.SUNNY] = {healing = "2/3"},
            [WeatherEffects.WeatherType.RAIN] = {healing = "1/4"},
            [WeatherEffects.WeatherType.SANDSTORM] = {healing = "1/4"},
            [WeatherEffects.WeatherType.HAIL] = {healing = "1/4"}
        }
    }
}

-- Get weather-modified move accuracy
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @param baseAccuracy: Base accuracy of the move
-- @return: Modified accuracy or nil if no change
function WeatherEffects.getWeatherModifiedMoveAccuracy(moveName, weatherType, baseAccuracy)
    local moveData = WeatherEffects.WeatherMoveData[moveName:lower()]
    if not moveData or not moveData.weather_modifications then
        return baseAccuracy
    end
    
    local modification = moveData.weather_modifications[weatherType]
    if modification and modification.accuracy then
        return modification.accuracy
    end
    
    return baseAccuracy
end

-- Get weather-modified move power
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @param basePower: Base power of the move
-- @return: Modified power and type (if changed)
function WeatherEffects.getWeatherModifiedMovePower(moveName, weatherType, basePower, baseType)
    local moveData = WeatherEffects.WeatherMoveData[moveName:lower()]
    if not moveData or not moveData.weather_modifications then
        return basePower, baseType
    end
    
    local modification = moveData.weather_modifications[weatherType]
    if modification then
        local newPower = modification.power or basePower
        local newType = modification.type or baseType
        return newPower, newType
    end
    
    return basePower, baseType
end

-- Check if move requires charging turn and if weather modifies this
-- @param moveName: Name of the move (lowercase)
-- @param weatherType: Current weather type
-- @return: Boolean indicating if charging turn required
function WeatherEffects.doesMoveRequireCharging(moveName, weatherType)
    local moveData = WeatherEffects.WeatherMoveData[moveName:lower()]
    if not moveData then
        return false
    end
    
    -- Check weather modification first
    if moveData.weather_modifications and moveData.weather_modifications[weatherType] then
        local modification = moveData.weather_modifications[weatherType]
        if modification.charging ~= nil then
            return modification.charging
        end
    end
    
    -- Return normal charging behavior
    return moveData.normal_charging or false
end

-- Get weather-modified healing amount for healing moves
-- @param moveName: Name of the healing move (lowercase)
-- @param weatherType: Current weather type
-- @param maxHP: Maximum HP of the Pokemon
-- @return: Healing amount in HP
function WeatherEffects.getWeatherModifiedHealing(moveName, weatherType, maxHP)
    local moveData = WeatherEffects.WeatherMoveData[moveName:lower()]
    if not moveData then
        return 0
    end
    
    local healingFraction = moveData.normal_healing
    
    -- Check for weather modification
    if moveData.weather_modifications and moveData.weather_modifications[weatherType] then
        local modification = moveData.weather_modifications[weatherType]
        if modification.healing then
            healingFraction = modification.healing
        end
    end
    
    -- Convert healing fraction to actual HP amount
    if healingFraction == "1/2" then
        return math.floor(maxHP / 2)
    elseif healingFraction == "2/3" then
        return math.floor(maxHP * 2 / 3)
    elseif healingFraction == "1/4" then
        return math.floor(maxHP / 4)
    elseif healingFraction == "1/8" then
        return math.floor(maxHP / 8)
    elseif healingFraction == "1/16" then
        return math.floor(maxHP / 16)
    end
    
    return 0
end

-- Process move-specific weather interactions during move execution
-- @param moveData: Move data including name, power, accuracy, type
-- @param weatherType: Current weather type
-- @return: Modified move data with weather adjustments
function WeatherEffects.processWeatherMoveInteractions(moveData, weatherType)
    if not moveData or not weatherType then
        return moveData
    end
    
    local modifiedMove = {}
    for k, v in pairs(moveData) do
        modifiedMove[k] = v
    end
    
    local moveName = moveData.name and moveData.name:lower() or ""
    
    -- Apply accuracy modifications
    if moveData.accuracy and moveData.accuracy > 0 then
        local newAccuracy = WeatherEffects.getWeatherModifiedMoveAccuracy(moveName, weatherType, moveData.accuracy)
        if newAccuracy ~= moveData.accuracy then
            modifiedMove.accuracy = newAccuracy
            modifiedMove.weather_accuracy_modified = true
        end
    end
    
    -- Apply power and type modifications
    if moveData.power and moveData.power > 0 then
        local newPower, newType = WeatherEffects.getWeatherModifiedMovePower(moveName, weatherType, moveData.power, moveData.type)
        if newPower ~= moveData.power then
            modifiedMove.power = newPower
            modifiedMove.weather_power_modified = true
        end
        if newType ~= moveData.type then
            modifiedMove.type = newType
            modifiedMove.weather_type_modified = true
        end
    end
    
    -- Apply charging modifications
    local requiresCharging = WeatherEffects.doesMoveRequireCharging(moveName, weatherType)
    if moveData.charging ~= requiresCharging then
        modifiedMove.charging = requiresCharging
        modifiedMove.weather_charging_modified = true
    end
    
    return modifiedMove
end

-- Complex Weather-Field Effect Interaction System

-- Weather suppression abilities that neutralize all weather effects
WeatherEffects.WeatherSuppressionAbilities = {
    [Enums.AbilityId.CLOUD_NINE] = "Cloud Nine",
    [Enums.AbilityId.AIR_LOCK] = "Air Lock"
}

-- Weather overriding move data
WeatherEffects.WeatherMovesToSuppress = {
    defog = true,     -- Clears weather and field effects
    haze = false      -- Does not affect weather directly
}

-- Check if weather effects are currently suppressed
-- @param pokemonList: List of all active Pokemon in battle
-- @return: Boolean indicating suppression, suppressing ability name, Pokemon name
function WeatherEffects.isWeatherEffectsSuppressed(pokemonList)
    for _, pokemon in ipairs(pokemonList) do
        if pokemon and pokemon.ability and WeatherEffects.WeatherSuppressionAbilities[pokemon.ability] then
            local abilityName = WeatherEffects.WeatherSuppressionAbilities[pokemon.ability]
            return true, abilityName, pokemon.name or "Unknown Pokemon"
        end
    end
    return false, nil, nil
end

-- Process weather-terrain interaction conflicts
-- @param weatherType: Current weather type
-- @param terrainType: Current terrain type
-- @return: Adjusted weather and terrain, conflict resolution details
function WeatherEffects.resolveWeatherTerrainConflicts(weatherType, terrainType)
    -- Most weather-terrain combinations coexist, but some have special interactions
    local conflicts = {}
    
    -- Grassy Terrain interaction with weather damage
    if terrainType == BattleConditions.TerrainType.GRASSY and 
       (weatherType == WeatherEffects.WeatherType.SANDSTORM or weatherType == WeatherEffects.WeatherType.HAIL) then
        table.insert(conflicts, {
            type = "terrain_healing_vs_weather_damage",
            description = "Grassy Terrain healing counteracts weather damage for grounded Pokemon"
        })
    end
    
    -- Electric Terrain prevents sleep, which may interact with weather-related moves
    if terrainType == BattleConditions.TerrainType.ELECTRIC then
        table.insert(conflicts, {
            type = "electric_terrain_sleep_prevention",
            description = "Electric Terrain prevents sleep status that may be caused by weather-related moves"
        })
    end
    
    -- Misty Terrain prevents status conditions, protecting from weather-related status
    if terrainType == BattleConditions.TerrainType.MISTY then
        table.insert(conflicts, {
            type = "misty_terrain_status_protection",
            description = "Misty Terrain prevents status conditions that may be caused by weather effects"
        })
    end
    
    return weatherType, terrainType, conflicts
end

-- Process weather removal/replacement mechanics
-- @param currentWeather: Current weather state
-- @param newWeather: New weather being applied
-- @param source: Source of weather change
-- @return: Final weather state, replacement details
function WeatherEffects.processWeatherReplacement(currentWeather, newWeather, source)
    local replacement = {
        previous_weather = currentWeather.type,
        new_weather = newWeather.type,
        source = source,
        replaced = false
    }
    
    -- Check if new weather actually replaces current weather
    if currentWeather.type ~= BattleConditions.WeatherType.NONE and newWeather.type ~= currentWeather.type then
        replacement.replaced = true
        replacement.message = string.format("The %s was replaced by %s!", 
            BattleConditions.WeatherData[currentWeather.type].name,
            BattleConditions.WeatherData[newWeather.type].name)
    elseif newWeather.type == BattleConditions.WeatherType.NONE then
        replacement.replaced = true
        replacement.message = "The weather cleared up!"
    end
    
    return newWeather, replacement
end

-- Process weather effect removal through moves or items
-- @param battleId: Battle instance identifier
-- @param currentWeather: Current weather state
-- @param removalSource: Source of removal (move name, item name, etc.)
-- @return: Updated weather state, removal success
function WeatherEffects.removeWeatherEffects(battleId, currentWeather, removalSource)
    if not currentWeather or currentWeather.type == BattleConditions.WeatherType.NONE then
        return currentWeather, false
    end
    
    -- Moves that can clear weather
    local weatherClearingMoves = {
        defog = true,
        -- Add other weather-clearing moves as needed
    }
    
    if weatherClearingMoves[removalSource:lower()] then
        local clearedWeather = {
            type = BattleConditions.WeatherType.NONE,
            duration = 0,
            source = removalSource,
            cleared_by = removalSource
        }
        
        return clearedWeather, true
    end
    
    return currentWeather, false
end

-- Calculate effective weather for battle calculations (accounting for suppression)
-- @param weatherType: Actual weather type in battle state
-- @param pokemonList: All active Pokemon (to check for suppression abilities)
-- @return: Effective weather type for calculations, suppression status
function WeatherEffects.getEffectiveWeather(weatherType, pokemonList)
    local suppressed, suppressorAbility, suppressorPokemon = WeatherEffects.isWeatherEffectsSuppressed(pokemonList)
    
    if suppressed then
        return BattleConditions.WeatherType.NONE, {
            suppressed = true,
            suppressor_ability = suppressorAbility,
            suppressor_pokemon = suppressorPokemon,
            actual_weather = weatherType
        }
    end
    
    return weatherType, {suppressed = false}
end

-- Process complex weather-status effect interactions
-- @param weatherType: Current weather type
-- @param statusEffect: Status effect being applied or maintained
-- @param pokemon: Pokemon data with types and ability
-- @return: Modified status effect, interaction details
function WeatherEffects.processWeatherStatusInteractions(weatherType, statusEffect, pokemon)
    local interactions = {}
    
    -- Ice-type Pokemon can't be frozen (status), but hail affects all except Ice types
    if statusEffect == "freeze" and weatherType == WeatherEffects.WeatherType.HAIL then
        if pokemon.types and (pokemon.types[1] == Enums.PokemonType.ICE or pokemon.types[2] == Enums.PokemonType.ICE) then
            table.insert(interactions, {
                type = "ice_type_freeze_immunity",
                description = "Ice-type Pokemon cannot be frozen"
            })
            statusEffect = nil
        end
    end
    
    -- Sunny weather may interact with burn status (in some game mechanics)
    if statusEffect == "burn" and weatherType == WeatherEffects.WeatherType.SUNNY then
        table.insert(interactions, {
            type = "sunny_weather_burn_interaction",
            description = "Burn damage may be affected by sunny weather in some mechanics"
        })
    end
    
    return statusEffect, interactions
end

-- Get comprehensive weather effect summary for battle state
-- @param weatherType: Current weather type
-- @param pokemonList: All active Pokemon
-- @return: Complete weather effects summary
function WeatherEffects.getWeatherEffectsSummary(weatherType, pokemonList)
    local effectiveWeather, suppressionStatus = WeatherEffects.getEffectiveWeather(weatherType, pokemonList)
    local weatherData = BattleConditions.WeatherData[effectiveWeather]
    
    local summary = {
        actual_weather = weatherType,
        effective_weather = effectiveWeather,
        weather_name = weatherData and weatherData.name or "None",
        suppression = suppressionStatus,
        active_effects = {},
        affected_pokemon = {},
        move_modifications = {}
    }
    
    if not suppressionStatus.suppressed and weatherData then
        -- List active effects
        if weatherData.fire_boost then
            table.insert(summary.active_effects, "Fire-type moves boosted by 50%")
        end
        if weatherData.water_boost then
            table.insert(summary.active_effects, "Water-type moves boosted by 50%")
        end
        if weatherData.damage_per_turn then
            table.insert(summary.active_effects, "Weather damage: " .. weatherData.damage_per_turn .. " max HP per turn")
        end
        
        -- Identify affected Pokemon
        for _, pokemon in ipairs(pokemonList) do
            local effects = {}
            
            -- Check weather ability interactions

-- ===== MODULE: game-logic.battle.weather-abilities =====
-- File: ao-processes/game-logic/battle/weather-abilities.lua
-- Original require:             local weatherAbilities = require("game-logic.battle.weather-abilities")


-- ===== END MODULE: game-logic.battle.weather-abilities =====

            local shouldActivate, abilityData = weatherAbilities.shouldAbilityActivate(pokemon, effectiveWeather)
            if shouldActivate then
                table.insert(effects, "Ability: " .. abilityData.name)
            end
            
            -- Check weather damage immunity/vulnerability
            if weatherData.damage_per_turn then
                local immune = false
                if weatherData.immune_types then
                    for _, immuneType in ipairs(weatherData.immune_types) do
                        if pokemon.types and (pokemon.types[1] == immuneType or pokemon.types[2] == immuneType) then
                            immune = true
                            break
                        end
                    end
                end
                
                if immune then
                    table.insert(effects, "Immune to weather damage")
                else
                    table.insert(effects, "Takes weather damage")
                end
            end
            
            if #effects > 0 then
                summary.affected_pokemon[pokemon.id or "unknown"] = {
                    name = pokemon.name or "Unknown Pokemon",
                    effects = effects
                }
            end
        end
    end
    
    return summary
end

-- Get list of all weather-dependent moves
-- @return: Table of move names that have weather interactions
function WeatherEffects.getWeatherDependentMoves()
    local moves = {}
    for moveName, _ in pairs(WeatherEffects.WeatherMoveData) do
        table.insert(moves, moveName)
    end
    return moves
end

-- Set weather with proper validation and duration handling
-- @param battleId: Battle instance identifier
-- @param weatherType: Weather type to set
-- @param duration: Duration override (nil for default)
-- @param source: Source of weather change (move name, ability name, etc.)
-- @param sourceAbility: Source ability ID if triggered by ability
-- @return: Success boolean and weather result data
function WeatherEffects.setWeather(battleId, weatherType, duration, source, sourceAbility)
    local success, result = BattleConditions.setWeather(battleId, weatherType, duration, source, sourceAbility)
    
    if success and result then
        -- Add weather-specific initialization
        if weatherType == WeatherEffects.WeatherType.SUNNY then
            result.effects = {"fire_boost", "water_nerf", "healing_boost", "solar_beam_instant"}
        elseif weatherType == WeatherEffects.WeatherType.RAIN then
            result.effects = {"water_boost", "fire_nerf", "thunder_accuracy", "hurricane_accuracy"}
        elseif weatherType == WeatherEffects.WeatherType.SANDSTORM then
            result.effects = {"rock_spdef_boost", "damage_non_rock_ground_steel", "hurricane_accuracy_reduced"}
        elseif weatherType == WeatherEffects.WeatherType.HAIL then
            result.effects = {"blizzard_accuracy", "damage_non_ice"}
        end
    end
    
    return success, result
end


-- ===== END MODULE: game-logic.battle.weather-effects =====


-- ===== MODULE: game-logic.battle.weather-abilities =====
-- File: ao-processes/game-logic/battle/weather-abilities.lua
-- Original require: local WeatherAbilities = require("game-logic.battle.weather-abilities")


-- ===== END MODULE: game-logic.battle.weather-abilities =====


-- Terrain system dependencies

-- ===== MODULE: game-logic.battle.terrain-effects =====
-- File: ao-processes/game-logic/battle/terrain-effects.lua
-- Original require: local TerrainEffects = require("game-logic.battle.terrain-effects")

-- Terrain Effects System
-- Core terrain mechanics and interactions for battle field effects
-- Implements Electric, Grassy, Misty, and Psychic terrain with proper grounding rules

local TerrainEffects = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Terrain types (matching battle-conditions.lua)
TerrainEffects.TerrainType = {
    NONE = 0,
    ELECTRIC = 1,
    GRASSY = 2,
    MISTY = 3,
    PSYCHIC = 4
}

-- Terrain configuration data
TerrainEffects.TerrainData = {
    [TerrainEffects.TerrainType.ELECTRIC] = {
        name = "Electric Terrain",
        default_duration = 5,
        type_boost = Enums.PokemonType.ELECTRIC,
        power_multiplier = 1.3, -- 30% boost
        status_prevention = {"sleep"},
        grounded_only = true,
        description = "Electric-type moves are boosted and Pokemon cannot fall asleep"
    },
    [TerrainEffects.TerrainType.GRASSY] = {
        name = "Grassy Terrain",
        default_duration = 5,
        type_boost = Enums.PokemonType.GRASS,
        power_multiplier = 1.3, -- 30% boost
        healing_per_turn = "1/16", -- 1/16 HP healing per turn
        move_power_reduction = {
            -- Moves that are weakened in Grassy Terrain
            earthquake = 0.5,
            magnitude = 0.5,
            bulldoze = 0.5
        },
        grounded_only = true,
        description = "Grass-type moves are boosted and grounded Pokemon heal each turn"
    },
    [TerrainEffects.TerrainType.MISTY] = {
        name = "Misty Terrain",
        default_duration = 5,
        power_multiplier = 1.0, -- No type boost (original implementation had Fairy boost but that's not standard)
        status_prevention = {"all"}, -- All status conditions prevented
        dragon_move_reduction = 0.5, -- Dragon moves do 50% damage
        grounded_only = true,
        description = "Status conditions are prevented and Dragon-type moves are weakened"
    },
    [TerrainEffects.TerrainType.PSYCHIC] = {
        name = "Psychic Terrain",
        default_duration = 5,
        type_boost = Enums.PokemonType.PSYCHIC,
        power_multiplier = 1.3, -- 30% boost
        priority_move_immunity = true,
        grounded_only = true,
        description = "Psychic-type moves are boosted and priority moves are blocked"
    }
}

-- Initialize terrain state for a battle
-- @param battleId: Battle instance identifier
-- @return: Initial terrain state
function TerrainEffects.initializeTerrainState(battleId)
    return {
        battle_id = battleId,
        current_terrain = TerrainEffects.TerrainType.NONE,
        duration_remaining = 0,
        source = nil,
        timestamp = os.time()
    }
end

-- Set terrain effect
-- @param terrainState: Current terrain state
-- @param terrainType: Terrain type to set
-- @param duration: Duration override (nil for default)
-- @param source: Source of terrain change (move name, ability, etc.)
-- @return: Updated terrain state and success status
function TerrainEffects.setTerrain(terrainState, terrainType, duration, source)
    if not terrainState or not terrainType then
        return terrainState, false, "Invalid parameters for terrain change"
    end
    
    local terrainData = TerrainEffects.TerrainData[terrainType]
    if not terrainData and terrainType ~= TerrainEffects.TerrainType.NONE then
        return terrainState, false, "Unknown terrain type: " .. tostring(terrainType)
    end
    
    local actualDuration = duration
    if not actualDuration and terrainData then
        actualDuration = terrainData.default_duration
    elseif terrainType == TerrainEffects.TerrainType.NONE then
        actualDuration = 0
    end
    
    -- Update terrain state
    terrainState.current_terrain = terrainType
    terrainState.duration_remaining = actualDuration or 0
    terrainState.source = source
    terrainState.timestamp = os.time()
    
    local terrainName = terrainData and terrainData.name or "None"
    return terrainState, true, "Terrain changed to " .. terrainName
end

-- Check if Pokemon is grounded (affected by terrain effects)
-- @param pokemon: Pokemon data
-- @return: Boolean indicating if Pokemon is grounded
function TerrainEffects.isPokemonGrounded(pokemon)
    if not pokemon then
        return false
    end
    
    -- Iron Ball forces Pokemon to be grounded (overrides Flying/Levitate)
    if pokemon.item == Enums.ItemId.IRON_BALL then
        return true
    end
    
    -- Air Balloon makes Pokemon not grounded (until hit by a damaging move)
    if pokemon.item == Enums.ItemId.AIR_BALLOON then
        -- TODO: Check if balloon has been popped by a damaging move
        return false
    end
    
    -- Flying type Pokemon are not grounded (unless forced by Iron Ball)
    if pokemon.types then
        for _, pokemonType in ipairs(pokemon.types) do
            if pokemonType == Enums.PokemonType.FLYING then
                return false
            end
        end
    end
    
    -- Levitate ability makes Pokemon not grounded (unless forced by Iron Ball)
    if pokemon.ability == Enums.AbilityId.LEVITATE then
        return false
    end
    
    -- TODO: Add checks for temporary effects that affect grounding:
    -- - Magnet Rise (not grounded for 5 turns)
    -- - Telekinesis (not grounded for 3 turns)
    -- - Ingrain (forces grounding)
    -- - Smack Down (forces grounding until switching out)
    
    return true
end

-- Get terrain move power modifier
-- @param moveData: Move information including type
-- @param terrainState: Current terrain state
-- @param attackerGrounded: Whether the attacking Pokemon is grounded
-- @return: Power multiplier (1.0 = no change)
function TerrainEffects.getTerrainMovePowerModifier(moveData, terrainState, attackerGrounded)
    if not terrainState or not moveData or terrainState.current_terrain == TerrainEffects.TerrainType.NONE then
        return 1.0
    end
    
    local terrainData = TerrainEffects.TerrainData[terrainState.current_terrain]
    if not terrainData then
        return 1.0
    end
    
    -- Terrain effects only apply to grounded Pokemon
    if terrainData.grounded_only and not attackerGrounded then
        return 1.0
    end
    
    -- Check for type-based power boost
    if terrainData.type_boost and moveData.type == terrainData.type_boost then
        return terrainData.power_multiplier
    end
    
    -- Check for move-specific power reductions (Grassy Terrain)
    if terrainData.move_power_reduction and moveData.name then
        local moveName = string.lower(moveData.name)
        if terrainData.move_power_reduction[moveName] then
            return terrainData.move_power_reduction[moveName]
        end
    end
    
    -- Check for Dragon-type move reduction (Misty Terrain)
    if terrainData.dragon_move_reduction and moveData.type == Enums.PokemonType.DRAGON then
        return terrainData.dragon_move_reduction
    end
    
    return 1.0
end

-- Check if terrain blocks a move
-- @param moveData: Move data including type and priority
-- @param terrainState: Current terrain state
-- @param targetGrounded: Whether the target is grounded
-- @return: Boolean indicating if move is blocked, reason string
function TerrainEffects.doesTerrainBlockMove(moveData, terrainState, targetGrounded)
    if not terrainState or not moveData or terrainState.current_terrain == TerrainEffects.TerrainType.NONE then
        return false, nil
    end
    
    local terrainData = TerrainEffects.TerrainData[terrainState.current_terrain]
    if not terrainData then
        return false, nil
    end
    
    -- Terrain effects only apply to grounded Pokemon
    if terrainData.grounded_only and not targetGrounded then
        return false, nil
    end
    
    -- Psychic Terrain blocks priority moves
    if terrainData.priority_move_immunity and moveData.priority and moveData.priority > 0 then
        return true, "Priority moves are blocked by Psychic Terrain"
    end
    
    return false, nil
end

-- Check if terrain prevents status condition
-- @param statusEffect: Status effect to check ("sleep", "poison", "paralysis", "burn", "freeze")
-- @param terrainState: Current terrain state
-- @param pokemonGrounded: Whether Pokemon is grounded
-- @return: Boolean indicating if status is prevented
function TerrainEffects.doesTerrainPreventStatus(statusEffect, terrainState, pokemonGrounded)
    if not terrainState or not statusEffect or terrainState.current_terrain == TerrainEffects.TerrainType.NONE then
        return false
    end
    
    local terrainData = TerrainEffects.TerrainData[terrainState.current_terrain]
    if not terrainData or not terrainData.status_prevention then
        return false
    end
    
    -- Terrain effects only apply to grounded Pokemon
    if terrainData.grounded_only and not pokemonGrounded then
        return false
    end
    
    -- Check if terrain prevents all status conditions
    for _, preventedStatus in ipairs(terrainData.status_prevention) do
        if preventedStatus == "all" then
            return true
        elseif preventedStatus == statusEffect then
            return true
        end
    end
    
    return false
end

-- Process terrain healing effects at end of turn
-- @param terrainState: Current terrain state
-- @param pokemonList: List of Pokemon to process
-- @return: List of healing results
function TerrainEffects.processTerrainHealing(terrainState, pokemonList)
    if not terrainState or not pokemonList or terrainState.current_terrain == TerrainEffects.TerrainType.NONE then
        return {}
    end
    
    local terrainData = TerrainEffects.TerrainData[terrainState.current_terrain]
    if not terrainData or not terrainData.healing_per_turn then
        return {}
    end
    
    local healingResults = {}
    
    for _, pokemon in ipairs(pokemonList) do
        -- Check if Pokemon is grounded (affected by terrain)
        if terrainData.grounded_only and not TerrainEffects.isPokemonGrounded(pokemon) then
            goto continue
        end
        
        -- Skip if Pokemon is fainted or at full HP
        if pokemon.currentHP <= 0 or pokemon.currentHP >= pokemon.maxHP then
            goto continue
        end
        
        local maxHP = pokemon.maxHP or pokemon.stats[Enums.Stat.HP]
        local healing = 0
        
        if terrainData.healing_per_turn == "1/16" then
            healing = math.max(1, math.floor(maxHP / 16))
        end
        
        -- Cap healing to not exceed max HP
        local actualHealing = math.min(healing, maxHP - pokemon.currentHP)
        
        if actualHealing > 0 then
            table.insert(healingResults, {
                pokemon_id = pokemon.id,
                healing = actualHealing,
                terrain = terrainData.name,
                new_hp = pokemon.currentHP + actualHealing
            })
        end
        
        ::continue::
    end
    
    return healingResults
end

-- Update terrain duration at end of turn
-- @param terrainState: Current terrain state
-- @return: Updated terrain state, boolean indicating if terrain should end
function TerrainEffects.updateTerrainDuration(terrainState)
    if not terrainState or terrainState.current_terrain == TerrainEffects.TerrainType.NONE then
        return terrainState, false
    end
    
    if terrainState.duration_remaining == -1 then
        return terrainState, false -- Permanent terrain doesn't expire
    end
    
    if terrainState.duration_remaining <= 1 then
        -- Terrain expires
        terrainState.current_terrain = TerrainEffects.TerrainType.NONE
        terrainState.duration_remaining = 0
        terrainState.source = nil
        return terrainState, true
    end
    
    terrainState.duration_remaining = terrainState.duration_remaining - 1
    return terrainState, false
end

-- Get terrain information for display/debugging
-- @param terrainState: Current terrain state
-- @return: Terrain information table
function TerrainEffects.getTerrainInfo(terrainState)
    if not terrainState or terrainState.current_terrain == TerrainEffects.TerrainType.NONE then
        return {
            name = "None",
            type = TerrainEffects.TerrainType.NONE,
            duration = 0,
            active = false
        }
    end
    
    local terrainData = TerrainEffects.TerrainData[terrainState.current_terrain]
    return {
        name = terrainData and terrainData.name or "Unknown",
        type = terrainState.current_terrain,
        duration = terrainState.duration_remaining,
        active = true,
        source = terrainState.source,
        description = terrainData and terrainData.description or ""
    }
end


-- ===== END MODULE: game-logic.battle.terrain-effects =====


-- ===== MODULE: game-logic.battle.terrain-abilities =====
-- File: ao-processes/game-logic/battle/terrain-abilities.lua
-- Original require: local TerrainAbilities = require("game-logic.battle.terrain-abilities")

-- Terrain Abilities System
-- Handles terrain-related ability activations and interactions
-- Includes terrain-setting abilities, terrain-triggered abilities, and terrain duration modifications

local TerrainAbilities = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.battle.terrain-effects =====
-- File: ao-processes/game-logic/battle/terrain-effects.lua
-- Original require: local TerrainEffects = require("game-logic.battle.terrain-effects")


-- ===== END MODULE: game-logic.battle.terrain-effects =====


-- Terrain-setting abilities configuration
TerrainAbilities.TerrainSurgeAbilities = {
    [Enums.AbilityId.ELECTRIC_SURGE] = TerrainEffects.TerrainType.ELECTRIC,
    [Enums.AbilityId.GRASSY_SURGE] = TerrainEffects.TerrainType.GRASSY,
    [Enums.AbilityId.MISTY_SURGE] = TerrainEffects.TerrainType.MISTY,
    [Enums.AbilityId.PSYCHIC_SURGE] = TerrainEffects.TerrainType.PSYCHIC
}

-- Terrain-activated abilities configuration
TerrainAbilities.TerrainActivatedAbilities = {
    [Enums.AbilityId.SURGE_SURFER] = {
        terrain = TerrainEffects.TerrainType.ELECTRIC,
        effect = "speed_double",
        description = "Speed doubles in Electric Terrain"
    },
    [Enums.AbilityId.GRASS_PELT] = {
        terrain = TerrainEffects.TerrainType.GRASSY,
        effect = "defense_boost",
        description = "Defense is raised in Grassy Terrain"
    }
}

-- Check if Pokemon has a terrain-setting ability
-- @param pokemon: Pokemon data
-- @return: Terrain type to set, or nil if no terrain ability
function TerrainAbilities.getTerrainFromAbility(pokemon)
    if not pokemon or not pokemon.ability then
        return nil
    end
    
    return TerrainAbilities.TerrainSurgeAbilities[pokemon.ability]
end

-- Process terrain-setting ability on switch-in
-- @param pokemon: Pokemon switching in
-- @param terrainState: Current terrain state
-- @return: Updated terrain state, activation message
function TerrainAbilities.processTerrainSurgeAbility(pokemon, terrainState)
    if not pokemon or not pokemon.ability or not terrainState then
        return terrainState, nil
    end
    
    local newTerrainType = TerrainAbilities.TerrainSurgeAbilities[pokemon.ability]
    if not newTerrainType then
        return terrainState, nil
    end
    
    -- Don't activate if terrain is already active
    if terrainState.current_terrain == newTerrainType then
        return terrainState, nil
    end
    
    local abilityName = ""
    for abilityName, abilityId in pairs(Enums.AbilityId) do
        if abilityId == pokemon.ability then
            abilityName = abilityName
            break
        end
    end
    
    local updatedTerrainState, success, message = TerrainEffects.setTerrain(
        terrainState, 
        newTerrainType, 
        nil, -- Use default duration
        abilityName
    )
    
    if success then
        local activationMessage = pokemon.name .. "'s " .. abilityName .. " activated! " .. message
        return updatedTerrainState, activationMessage
    end
    
    return terrainState, nil
end

-- Check if Pokemon has a terrain-activated ability
-- @param pokemon: Pokemon data
-- @param terrainState: Current terrain state
-- @return: Boolean indicating if ability should activate
function TerrainAbilities.hasTerrainActivatedAbility(pokemon, terrainState)
    if not pokemon or not pokemon.ability or not terrainState then
        return false
    end
    
    local abilityData = TerrainAbilities.TerrainActivatedAbilities[pokemon.ability]
    if not abilityData then
        return false
    end
    
    -- Check if Pokemon is grounded (terrain-activated abilities require grounding)
    if not TerrainEffects.isPokemonGrounded(pokemon) then
        return false
    end
    
    return terrainState.current_terrain == abilityData.terrain
end

-- Get terrain ability stat modifier
-- @param pokemon: Pokemon data
-- @param terrainState: Current terrain state
-- @param statType: Stat type to check (Enums.Stat)
-- @return: Stat modifier value or 1.0 if no modifier
function TerrainAbilities.getTerrainAbilityStatModifier(pokemon, terrainState, statType)
    if not TerrainAbilities.hasTerrainActivatedAbility(pokemon, terrainState) then
        return 1.0
    end
    
    local abilityData = TerrainAbilities.TerrainActivatedAbilities[pokemon.ability]
    if not abilityData then
        return 1.0
    end
    
    -- Surge Surfer - Speed doubles in Electric Terrain
    if pokemon.ability == Enums.AbilityId.SURGE_SURFER and statType == Enums.Stat.SPD then
        return 2.0
    end
    
    -- Grass Pelt - Defense boost in Grassy Terrain
    if pokemon.ability == Enums.AbilityId.GRASS_PELT and statType == Enums.Stat.DEF then
        return 1.5 -- 50% defense boost
    end
    
    return 1.0
end

-- Process terrain ability activation messages
-- @param pokemon: Pokemon data
-- @param terrainState: Current terrain state
-- @return: Activation message or nil
function TerrainAbilities.getTerrainAbilityActivationMessage(pokemon, terrainState)
    if not TerrainAbilities.hasTerrainActivatedAbility(pokemon, terrainState) then
        return nil
    end
    
    local abilityData = TerrainAbilities.TerrainActivatedAbilities[pokemon.ability]
    if not abilityData then
        return nil
    end
    
    local abilityName = ""
    for name, abilityId in pairs(Enums.AbilityId) do
        if abilityId == pokemon.ability then
            abilityName = name
            break
        end
    end
    
    return pokemon.name .. "'s " .. abilityName .. " activated! " .. abilityData.description
end

-- Check if terrain duration should be extended by ability or item
-- @param pokemon: Pokemon data
-- @param terrainState: Current terrain state
-- @param baseDuration: Base duration for the terrain
-- @return: Modified duration
function TerrainAbilities.getModifiedTerrainDuration(pokemon, terrainState, baseDuration)
    if not pokemon or not terrainState or not baseDuration then
        return baseDuration
    end
    
    -- Terrain Extender item extends duration from 5 to 8 turns
    if pokemon.item == Enums.ItemId.TERRAIN_EXTENDER and baseDuration == 5 then
        return 8
    end
    
    -- TODO: Add other duration-extending effects like Power Herb for specific terrain moves
    
    return baseDuration
end

-- Get all terrain abilities for a Pokemon
-- @param pokemon: Pokemon data
-- @return: Table of terrain ability information
function TerrainAbilities.getTerrainAbilityInfo(pokemon)
    if not pokemon or not pokemon.ability then
        return {}
    end
    
    local info = {}
    
    -- Check for terrain-setting ability
    local terrainType = TerrainAbilities.TerrainSurgeAbilities[pokemon.ability]
    if terrainType then
        local terrainName = ""
        for name, type in pairs(TerrainEffects.TerrainType) do
            if type == terrainType then
                terrainName = name
                break
            end
        end
        
        table.insert(info, {
            type = "terrain_surge",
            terrain = terrainName,
            description = "Sets " .. terrainName .. " Terrain on switch-in"
        })
    end
    
    -- Check for terrain-activated ability
    local activatedData = TerrainAbilities.TerrainActivatedAbilities[pokemon.ability]
    if activatedData then
        local terrainName = ""
        for name, type in pairs(TerrainEffects.TerrainType) do
            if type == activatedData.terrain then
                terrainName = name
                break
            end
        end
        
        table.insert(info, {
            type = "terrain_activated",
            terrain = terrainName,
            effect = activatedData.effect,
            description = activatedData.description
        })
    end
    
    return info
end

-- Check if an ability prevents terrain effects
-- @param pokemon: Pokemon data
-- @param terrainType: Terrain type to check
-- @return: Boolean indicating if terrain effects are prevented
function TerrainAbilities.doesAbilityPreventTerrainEffects(pokemon, terrainType)
    if not pokemon or not pokemon.ability or not terrainType then
        return false
    end
    
    -- TODO: Add abilities that prevent terrain effects
    -- For example, some abilities might make Pokemon immune to terrain
    
    return false
end

-- Process end-of-turn terrain ability effects
-- @param pokemon: Pokemon data
-- @param terrainState: Current terrain state
-- @return: List of ability effects triggered
function TerrainAbilities.processEndOfTurnTerrainAbilities(pokemon, terrainState)
    if not pokemon or not terrainState then
        return {}
    end
    
    local effects = {}
    
    -- Process terrain-activated abilities that have end-of-turn effects
    if TerrainAbilities.hasTerrainActivatedAbility(pokemon, terrainState) then
        local abilityData = TerrainAbilities.TerrainActivatedAbilities[pokemon.ability]
        
        -- Add any end-of-turn effects here
        -- For now, Surge Surfer and Grass Pelt are stat modifiers, not end-of-turn effects
    end
    
    return effects
end


-- ===== END MODULE: game-logic.battle.terrain-abilities =====


-- Entry hazards system dependencies

-- ===== MODULE: game-logic.battle.entry-hazards =====
-- File: ao-processes/game-logic/battle/entry-hazards.lua
-- Original require: local EntryHazards = require("game-logic.battle.entry-hazards")


-- ===== END MODULE: game-logic.battle.entry-hazards =====


-- ===== MODULE: game-logic.battle.switch-in-effects =====
-- File: ao-processes/game-logic/battle/switch-in-effects.lua
-- Original require: local SwitchInEffects = require("game-logic.battle.switch-in-effects")

-- Switch-In Effects System
-- Handles ability activation, entry hazards, and effect processing when Pokemon switch in
-- Integrates with existing ability systems and battle conditions
-- Provides correct trigger order for multiple simultaneous switch-in effects

local SwitchInEffects = {}

-- Load dependencies

-- ===== MODULE: game-logic.battle.battle-state-manager =====
-- File: ao-processes/game-logic/battle/battle-state-manager.lua
-- Original require: local BattleStateManager = require("game-logic.battle.battle-state-manager")

-- Battle State Manager
-- Manages active Pokemon, battle state transitions, and Pokemon status persistence
-- Integrates with turn processor and provides battle state consistency
-- Handles battle state serialization for session persistence and replay

local BattleStateManager = {}

-- Load dependencies

-- ===== MODULE: game-logic.battle.battle-conditions =====
-- File: ao-processes/game-logic/battle/battle-conditions.lua
-- Original require: local BattleConditions = require("game-logic.battle.battle-conditions")


-- ===== END MODULE: game-logic.battle.battle-conditions =====


-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Battle state types
BattleStateManager.BattlePhase = {
    COMMAND_SELECTION = 1,
    EXECUTING_TURN = 2,
    END_OF_TURN = 3,
    BATTLE_END = 4
}

BattleStateManager.BattleType = {
    SINGLE = "single",
    DOUBLE = "double",
    TRIPLE = "triple",
    ROTATION = "rotation"
}

-- Battle constants
BattleStateManager.Constants = {
    MAX_DOUBLE_BATTLE_POKEMON = 2,
    MAX_STAT_STAGE = 6,
    MIN_STAT_STAGE = -6,
    DEFAULT_LEVEL = 50,
    DEFAULT_HP = 100
}

-- Initialize battle state manager
-- @param battleId: Unique battle identifier
-- @param battleType: Battle format (single/double)
-- @param battleSeed: Deterministic RNG seed
-- @return: Success status
function BattleStateManager.init(battleId, battleType, battleSeed)
    if not battleId then
        return false, "Battle ID required for state manager initialization"
    end
    
    BattleStateManager.battleId = battleId
    BattleStateManager.battleType = battleType or BattleStateManager.BattleType.SINGLE
    BattleStateManager.battleSeed = battleSeed
    
    return true, "Battle state manager initialized"
end

-- Create new battle state structure
-- @param battleId: Unique battle identifier  
-- @param battleSeed: Deterministic RNG seed
-- @param playerParty: Player's Pokemon party
-- @param enemyParty: Enemy's Pokemon party
-- @param battleType: Battle format (single/double)
-- @return: Complete battle state object
function BattleStateManager.createBattleState(battleId, battleSeed, playerParty, enemyParty, battleType)
    if not battleId or not battleSeed then
        return nil, "Invalid battle state creation parameters"
    end
    
    local battleState = {
        -- Core battle identifiers
        battleId = battleId,
        battleSeed = battleSeed,
        battleType = battleType or BattleStateManager.BattleType.SINGLE,
        
        -- Battle progression tracking
        turn = 0,
        phase = BattleStateManager.BattlePhase.COMMAND_SELECTION,
        
        -- Pokemon parties with full state tracking
        playerParty = BattleStateManager.initializeParty(playerParty, "player"),
        enemyParty = BattleStateManager.initializeParty(enemyParty, "enemy"),
        
        -- Active Pokemon tracking
        activePlayer = {},
        activeEnemy = {},
        
        -- Battle state persistence
        battleConditions = BattleStateManager.createBattleConditions(),
        turnHistory = {},
        battleEvents = {},
        
        -- Turn processing state
        turnOrder = {},
        currentAction = nil,
        pendingActions = {},
        interruptQueue = {},
        turnCommands = {},
        
        -- Battle result tracking
        battleResult = nil,
        battleStats = {
            startTime = os.time(),
            totalTurns = 0,
            totalDamageDealt = 0,
            pokemonFainted = 0
        },
        
        -- Multi-turn tracking
        multiTurnData = {},
        
        -- Battle participation tracking
        participationData = {}
    }
    
    -- Initialize active Pokemon for battle start
    BattleStateManager.initializeActivePokemon(battleState)
    
    return battleState, nil
end

-- Initialize Pokemon party with battle-specific data
-- @param party: Raw Pokemon party data
-- @param side: "player" or "enemy"
-- @return: Initialized party with battle data
function BattleStateManager.initializeParty(party, side)
    if not party then
        return {}
    end
    
    local initializedParty = {}
    
    for i, pokemon in ipairs(party) do
        if pokemon then
            local battlePokemon = {
                -- Core Pokemon data
                id = pokemon.id or (side .. "_pokemon_" .. i),
                name = pokemon.name or "Unknown",
                species = pokemon.species,
                level = pokemon.level or BattleStateManager.Constants.DEFAULT_LEVEL,
                
                -- Battle stats
                stats = pokemon.stats or {hp = BattleStateManager.Constants.DEFAULT_HP, attack = BattleStateManager.Constants.DEFAULT_HP, defense = BattleStateManager.Constants.DEFAULT_HP, spatk = BattleStateManager.Constants.DEFAULT_HP, spdef = BattleStateManager.Constants.DEFAULT_HP, speed = BattleStateManager.Constants.DEFAULT_HP},
                currentHP = pokemon.currentHP or pokemon.stats and pokemon.stats.hp or BattleStateManager.Constants.DEFAULT_HP,
                maxHP = pokemon.maxHP or pokemon.stats and pokemon.stats.hp or BattleStateManager.Constants.DEFAULT_HP,
                
                -- Status and conditions
                status = pokemon.status or nil,
                statusTurns = pokemon.statusTurns or nil,
                fainted = pokemon.fainted or false,
                
                -- Battle-specific data
                battleData = {
                    side = side,
                    partyIndex = i,
                    statStages = {atk = 0, def = 0, spa = 0, spd = 0, spe = 0, accuracy = 0, evasion = 0},
                    turnsSinceSwitchIn = 0,
                    damageThisTurn = 0,
                    healingThisTurn = 0,
                    moveUsedThisTurn = nil,
                    lastDamageSource = nil,
                    hasMoved = false
                },
                
                -- Pokemon moveset and ability
                moves = pokemon.moves or {},
                ability = pokemon.ability,
                item = pokemon.item,
                nature = pokemon.nature,
                
                -- Participation tracking
                participated = false,
                turnCount = 0,
                damageDealt = 0,
                damageTaken = 0
            }
            
            table.insert(initializedParty, battlePokemon)
        end
    end
    
    return initializedParty
end

-- Initialize active Pokemon for battle start
-- @param battleState: Battle state to initialize
function BattleStateManager.initializeActivePokemon(battleState)
    -- Find first non-fainted Pokemon for player
    for _, pokemon in ipairs(battleState.playerParty) do
        if pokemon.currentHP > 0 and not pokemon.fainted then
            battleState.activePlayer[1] = pokemon.id
            pokemon.battleData.turnsSinceSwitchIn = 0
            pokemon.participated = true
            break
        end
    end
    
    -- Find first non-fainted Pokemon for enemy
    for _, pokemon in ipairs(battleState.enemyParty) do
        if pokemon.currentHP > 0 and not pokemon.fainted then
            battleState.activeEnemy[1] = pokemon.id
            pokemon.battleData.turnsSinceSwitchIn = 0
            pokemon.participated = true
            break
        end
    end
    
    -- For double battles, initialize second Pokemon
    if battleState.battleType == BattleStateManager.BattleType.DOUBLE then
        local playerCount = 0
        for _, pokemon in ipairs(battleState.playerParty) do
            if pokemon.currentHP > 0 and not pokemon.fainted then
                playerCount = playerCount + 1
                if playerCount == BattleStateManager.Constants.MAX_DOUBLE_BATTLE_POKEMON and not battleState.activePlayer[2] then
                    battleState.activePlayer[2] = pokemon.id
                    pokemon.battleData.turnsSinceSwitchIn = 0
                    pokemon.participated = true
                    break
                end
            end
        end
        
        local enemyCount = 0
        for _, pokemon in ipairs(battleState.enemyParty) do
            if pokemon.currentHP > 0 and not pokemon.fainted then
                enemyCount = enemyCount + 1
                if enemyCount == BattleStateManager.Constants.MAX_DOUBLE_BATTLE_POKEMON and not battleState.activeEnemy[2] then
                    battleState.activeEnemy[2] = pokemon.id
                    pokemon.battleData.turnsSinceSwitchIn = 0
                    pokemon.participated = true
                    break
                end
            end
        end
    end
end

-- Create initial battle conditions structure
-- @return: Battle conditions object
function BattleStateManager.createBattleConditions()
    return {
        weather = BattleConditions.WeatherType and BattleConditions.WeatherType.NONE or "none",
        weatherDuration = 0,
        terrain = BattleConditions.TerrainType and BattleConditions.TerrainType.NONE or "none",
        terrainDuration = 0,
        trickRoom = 0,
        tailwind = {[0] = 0, [1] = 0},
        gravity = 0,
        magicRoom = 0,
        wonderRoom = 0,
        entryHazards = {
            player = {spikes = 0, toxicSpikes = 0, stealthRock = false, stickyWeb = false},
            enemy = {spikes = 0, toxicSpikes = 0, stealthRock = false, stickyWeb = false}
        }
    }
end

-- Get active Pokemon for a side
-- @param battleState: Current battle state
-- @param side: "player" or "enemy"
-- @param position: Active position (1 for single, 1-2 for double)
-- @return: Active Pokemon object or nil
function BattleStateManager.getActivePokemon(battleState, side, position)
    if not battleState then
        return nil
    end
    
    position = position or 1
    local activePokemonId = nil
    
    if side == "player" then
        activePokemonId = battleState.activePlayer[position]
    elseif side == "enemy" then
        activePokemonId = battleState.activeEnemy[position]
    else
        return nil
    end
    
    if not activePokemonId then
        return nil
    end
    
    return BattleStateManager.findPokemonById(battleState, activePokemonId, side)
end

-- Get all active Pokemon for a side
-- @param battleState: Current battle state
-- @param side: "player" or "enemy"
-- @return: Array of active Pokemon
function BattleStateManager.getAllActivePokemon(battleState, side)
    if not battleState then
        return {}
    end
    
    local activePokemon = {}
    local activeIds = nil
    
    if side == "player" then
        activeIds = battleState.activePlayer
    elseif side == "enemy" then
        activeIds = battleState.activeEnemy
    else
        return {}
    end
    
    for position, pokemonId in pairs(activeIds) do
        if pokemonId then
            local pokemon = BattleStateManager.findPokemonById(battleState, pokemonId, side)
            if pokemon then
                pokemon.battlePosition = position
                table.insert(activePokemon, pokemon)
            end
        end
    end
    
    return activePokemon
end

-- Find Pokemon by ID in battle state
-- @param battleState: Current battle state
-- @param pokemonId: Pokemon ID to find
-- @param side: Optional side hint for faster search
-- @return: Pokemon object or nil
function BattleStateManager.findPokemonById(battleState, pokemonId, side)
    if not battleState or not pokemonId then
        return nil
    end
    
    -- Search specific side if provided
    if side == "player" then
        for _, pokemon in ipairs(battleState.playerParty) do
            if pokemon.id == pokemonId then
                return pokemon
            end
        end
    elseif side == "enemy" then
        for _, pokemon in ipairs(battleState.enemyParty) do
            if pokemon.id == pokemonId then
                return pokemon
            end
        end
    else
        -- Search both sides
        for _, pokemon in ipairs(battleState.playerParty) do
            if pokemon.id == pokemonId then
                return pokemon
            end
        end
        for _, pokemon in ipairs(battleState.enemyParty) do
            if pokemon.id == pokemonId then
                return pokemon
            end
        end
    end
    
    return nil
end

-- Update battle phase
-- @param battleState: Current battle state
-- @param newPhase: New battle phase
-- @return: Success status
function BattleStateManager.updateBattlePhase(battleState, newPhase)
    if not battleState then
        return false, "Invalid battle state"
    end
    
    local validPhases = {
        [BattleStateManager.BattlePhase.COMMAND_SELECTION] = true,
        [BattleStateManager.BattlePhase.EXECUTING_TURN] = true,
        [BattleStateManager.BattlePhase.END_OF_TURN] = true,
        [BattleStateManager.BattlePhase.BATTLE_END] = true
    }
    
    if not validPhases[newPhase] then
        return false, "Invalid battle phase"
    end
    
    local previousPhase = battleState.phase
    battleState.phase = newPhase
    
    -- Log phase transition
    table.insert(battleState.battleEvents, {
        type = "phase_change",
        from = previousPhase,
        to = newPhase,
        turn = battleState.turn,
        timestamp = os.time()
    })
    
    return true, "Battle phase updated"
end

-- Persist Pokemon status across battle state changes
-- @param battleState: Current battle state
-- @param pokemonId: Pokemon to update
-- @param statusUpdate: Status information to persist
-- @return: Success status
function BattleStateManager.persistPokemonStatus(battleState, pokemonId, statusUpdate)
    if not battleState or not pokemonId or not statusUpdate then
        return false, "Invalid status persistence parameters"
    end
    
    local pokemon = BattleStateManager.findPokemonById(battleState, pokemonId)
    if not pokemon then
        return false, "Pokemon not found for status persistence"
    end
    
    -- Update status condition
    if statusUpdate.status ~= nil then
        pokemon.status = statusUpdate.status
        pokemon.statusTurns = statusUpdate.statusTurns or nil
    end
    
    -- Update HP
    if statusUpdate.currentHP ~= nil then
        pokemon.currentHP = math.max(0, math.min(statusUpdate.currentHP, pokemon.maxHP))
        if pokemon.currentHP <= 0 and not pokemon.fainted then
            pokemon.fainted = true
        end
    end
    
    -- Update stat stages
    if statusUpdate.statStages then
        for stat, value in pairs(statusUpdate.statStages) do
            if pokemon.battleData.statStages[stat] then
                pokemon.battleData.statStages[stat] = math.max(BattleStateManager.Constants.MIN_STAT_STAGE, math.min(BattleStateManager.Constants.MAX_STAT_STAGE, value))
            end
        end
    end
    
    -- Update battle-specific data
    if statusUpdate.battleData then
        for key, value in pairs(statusUpdate.battleData) do
            pokemon.battleData[key] = value
        end
    end
    
    return true, "Pokemon status persisted successfully"
end

-- Serialize battle state for persistence
-- @param battleState: Battle state to serialize
-- @return: Serialized battle state data
function BattleStateManager.serializeBattleState(battleState)
    if not battleState then
        return nil, "Invalid battle state for serialization"
    end
    
    local serializedState = {
        -- Core identifiers
        battleId = battleState.battleId,
        battleSeed = battleState.battleSeed,
        battleType = battleState.battleType,
        
        -- Battle progress
        turn = battleState.turn,
        phase = battleState.phase,
        
        -- Pokemon parties (without functions)
        playerParty = BattleStateManager.serializeParty(battleState.playerParty),
        enemyParty = BattleStateManager.serializeParty(battleState.enemyParty),
        
        -- Active Pokemon tracking
        activePlayer = battleState.activePlayer,
        activeEnemy = battleState.activeEnemy,
        
        -- Battle conditions
        battleConditions = battleState.battleConditions,
        
        -- Turn state
        turnOrder = battleState.turnOrder,
        pendingActions = battleState.pendingActions,
        interruptQueue = battleState.interruptQueue,
        
        -- Results and stats
        battleResult = battleState.battleResult,
        battleStats = battleState.battleStats,
        
        -- Multi-turn and participation
        multiTurnData = battleState.multiTurnData,
        participationData = battleState.participationData,
        
        -- Serialization metadata
        serializedAt = os.time(),
        version = "1.0"
    }
    
    return serializedState, nil
end

-- Deserialize battle state from persistence
-- @param serializedData: Serialized battle state data
-- @return: Restored battle state object
function BattleStateManager.deserializeBattleState(serializedData)
    if not serializedData then
        return nil, "Invalid serialized data for deserialization"
    end
    
    local battleState = {
        -- Core identifiers
        battleId = serializedData.battleId,
        battleSeed = serializedData.battleSeed,
        battleType = serializedData.battleType or BattleStateManager.BattleType.SINGLE,
        
        -- Battle progress
        turn = serializedData.turn or 0,
        phase = serializedData.phase or BattleStateManager.BattlePhase.COMMAND_SELECTION,
        
        -- Pokemon parties
        playerParty = BattleStateManager.deserializeParty(serializedData.playerParty),
        enemyParty = BattleStateManager.deserializeParty(serializedData.enemyParty),
        
        -- Active Pokemon tracking
        activePlayer = serializedData.activePlayer or {},
        activeEnemy = serializedData.activeEnemy or {},
        
        -- Battle conditions
        battleConditions = serializedData.battleConditions or BattleStateManager.createBattleConditions(),
        
        -- Turn state
        turnOrder = serializedData.turnOrder or {},
        currentAction = nil,
        pendingActions = serializedData.pendingActions or {},
        interruptQueue = serializedData.interruptQueue or {},
        turnCommands = {},
        
        -- History and events
        turnHistory = serializedData.turnHistory or {},
        battleEvents = serializedData.battleEvents or {},
        
        -- Results and stats
        battleResult = serializedData.battleResult,
        battleStats = serializedData.battleStats or {
            startTime = os.time(),
            totalTurns = 0,
            totalDamageDealt = 0,
            pokemonFainted = 0
        },
        
        -- Multi-turn and participation
        multiTurnData = serializedData.multiTurnData or {},
        participationData = serializedData.participationData or {}
    }
    
    return battleState, nil
end

-- Serialize party for persistence
-- @param party: Pokemon party to serialize
-- @return: Serialized party data
function BattleStateManager.serializeParty(party)
    if not party then
        return {}
    end
    
    local serializedParty = {}
    
    for _, pokemon in ipairs(party) do
        table.insert(serializedParty, {
            -- Core Pokemon data
            id = pokemon.id,
            name = pokemon.name,
            species = pokemon.species,
            level = pokemon.level,
            
            -- Battle stats
            stats = pokemon.stats,
            currentHP = pokemon.currentHP,
            maxHP = pokemon.maxHP,
            
            -- Status and conditions
            status = pokemon.status,
            statusTurns = pokemon.statusTurns,
            fainted = pokemon.fainted,
            
            -- Battle-specific data
            battleData = pokemon.battleData,
            
            -- Pokemon data
            moves = pokemon.moves,
            ability = pokemon.ability,
            item = pokemon.item,
            nature = pokemon.nature,
            
            -- Participation
            participated = pokemon.participated,
            turnCount = pokemon.turnCount,
            damageDealt = pokemon.damageDealt,
            damageTaken = pokemon.damageTaken
        })
    end
    
    return serializedParty
end

-- Deserialize party from persistence
-- @param serializedParty: Serialized party data
-- @return: Restored party object
function BattleStateManager.deserializeParty(serializedParty)
    if not serializedParty then
        return {}
    end
    
    local party = {}
    
    for _, pokemonData in ipairs(serializedParty) do
        table.insert(party, {
            -- Core Pokemon data
            id = pokemonData.id,
            name = pokemonData.name,
            species = pokemonData.species,
            level = pokemonData.level,
            
            -- Battle stats
            stats = pokemonData.stats,
            currentHP = pokemonData.currentHP,
            maxHP = pokemonData.maxHP,
            
            -- Status and conditions
            status = pokemonData.status,
            statusTurns = pokemonData.statusTurns,
            fainted = pokemonData.fainted or false,
            
            -- Battle-specific data
            battleData = pokemonData.battleData or {
                statStages = {atk = 0, def = 0, spa = 0, spd = 0, spe = 0, accuracy = 0, evasion = 0},
                turnsSinceSwitchIn = 0,
                damageThisTurn = 0,
                healingThisTurn = 0
            },
            
            -- Pokemon data
            moves = pokemonData.moves,
            ability = pokemonData.ability,
            item = pokemonData.item,
            nature = pokemonData.nature,
            
            -- Participation
            participated = pokemonData.participated or false,
            turnCount = pokemonData.turnCount or 0,
            damageDealt = pokemonData.damageDealt or 0,
            damageTaken = pokemonData.damageTaken or 0
        })
    end
    
    return party
end

-- Reset turn-specific battle data
-- @param battleState: Current battle state
function BattleStateManager.resetTurnData(battleState)
    if not battleState then
        return
    end
    
    -- Reset turn-specific data for all Pokemon
    local allPokemon = {}
    for _, pokemon in ipairs(battleState.playerParty) do
        table.insert(allPokemon, pokemon)
    end
    for _, pokemon in ipairs(battleState.enemyParty) do
        table.insert(allPokemon, pokemon)
    end
    
    for _, pokemon in ipairs(allPokemon) do
        if pokemon.battleData then
            pokemon.battleData.damageThisTurn = 0
            pokemon.battleData.healingThisTurn = 0
            pokemon.battleData.moveUsedThisTurn = nil
            pokemon.battleData.hasMoved = false
            pokemon.battleData.turnsSinceSwitchIn = pokemon.battleData.turnsSinceSwitchIn + 1
        end
    end
end

-- Validate battle state consistency
-- @param battleState: Battle state to validate
-- @return: Validation result
function BattleStateManager.validateBattleState(battleState)
    if not battleState then
        return false, "No battle state provided"
    end
    
    -- Check required fields
    if not battleState.battleId then
        return false, "Missing battle ID"
    end
    
    if not battleState.playerParty or not battleState.enemyParty then
        return false, "Missing Pokemon parties"
    end
    
    -- Validate active Pokemon
    for _, pokemonId in pairs(battleState.activePlayer) do
        local pokemon = BattleStateManager.findPokemonById(battleState, pokemonId, "player")
        if not pokemon then
            return false, "Invalid active player Pokemon: " .. tostring(pokemonId)
        end
        if pokemon.currentHP <= 0 then
            return false, "Active player Pokemon is fainted: " .. tostring(pokemonId)
        end
    end
    
    for _, pokemonId in pairs(battleState.activeEnemy) do
        local pokemon = BattleStateManager.findPokemonById(battleState, pokemonId, "enemy")
        if not pokemon then
            return false, "Invalid active enemy Pokemon: " .. tostring(pokemonId)
        end
        if pokemon.currentHP <= 0 then
            return false, "Active enemy Pokemon is fainted: " .. tostring(pokemonId)
        end
    end
    
    return true, "Battle state is valid"
end


-- ===== END MODULE: game-logic.battle.battle-state-manager =====


-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- ===== MODULE: game-logic.battle.entry-hazards =====
-- File: ao-processes/game-logic/battle/entry-hazards.lua
-- Original require: local EntryHazards = require("game-logic.battle.entry-hazards")


-- ===== END MODULE: game-logic.battle.entry-hazards =====


-- Optional dependencies  
local BattleMessages = nil
local AbilityInteractions = nil
local Enums = nil

-- ===== MODULE: game-logic.battle.battle-messages =====
-- File: ao-processes/game-logic/battle/battle-messages.lua
-- Original require: pcall(function() BattleMessages = require("game-logic.battle.battle-messages") end)

-- Battle Message Generation System
-- Creates narrative battle messages matching current game output format
-- Handles move descriptions, damage reporting, status changes, and battle flow
-- Provides localized and contextual battle text generation

local BattleMessages = {}

-- Load dependencies

-- ===== MODULE: data.moves.move-database =====
-- File: ao-processes/data/moves/move-database.lua
-- Original require: local MoveDatabase = require("data.moves.move-database")


-- ===== END MODULE: data.moves.move-database =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Message templates for different battle events
local MessageTemplates = {
    -- Move usage messages
    move_use = "{attacker} used {move_name}!",
    move_miss = "{attacker}'s attack missed!",
    move_failed = "But it failed!",
    move_no_effect = "It had no effect on {target}!",
    
    -- Damage and effectiveness messages
    damage_super_effective = "It's super effective!",
    damage_not_very_effective = "It's not very effective...",
    damage_critical = "A critical hit!",
    damage_generic = "{target} took {damage} damage!",
    
    -- Status effect messages
    status_burned = "{pokemon} was burned!",
    status_poisoned = "{pokemon} was poisoned!",
    status_paralyzed = "{pokemon} is paralyzed! It may not be able to move!",
    status_frozen = "{pokemon} was frozen solid!",
    status_asleep = "{pokemon} fell asleep!",
    status_confused = "{pokemon} became confused!",
    
    -- Status effect damage
    burn_damage = "{pokemon} was hurt by its burn!",
    poison_damage = "{pokemon} was hurt by poison!",
    confusion_damage = "{pokemon} hurt itself in its confusion!",
    
    -- Recovery messages
    status_thawed = "{pokemon} thawed out!",
    status_woke_up = "{pokemon} woke up!",
    status_cured = "{pokemon} recovered from its status condition!",
    
    -- Stat modification messages
    stat_rose = "{pokemon}'s {stat} rose!",
    stat_rose_sharply = "{pokemon}'s {stat} rose sharply!",
    stat_rose_drastically = "{pokemon}'s {stat} rose drastically!",
    stat_fell = "{pokemon}'s {stat} fell!",
    stat_fell_harshly = "{pokemon}'s {stat} fell harshly!",
    stat_fell_severely = "{pokemon}'s {stat} fell severely!",
    stat_maxed = "{pokemon}'s {stat} won't go any higher!",
    stat_minimized = "{pokemon}'s {stat} won't go any lower!",
    
    -- Weather and terrain messages
    weather_sunny = "The sunlight turned harsh!",
    weather_rain = "It started to rain!",
    weather_sandstorm = "A sandstorm kicked up!",
    weather_hail = "It started to hail!",
    weather_ended = "The weather cleared up!",
    
    terrain_electric = "An electric current ran across the battlefield!",
    terrain_grassy = "Grass grew to cover the battlefield!",
    terrain_misty = "Mist swirled around the battlefield!",
    terrain_psychic = "The battlefield got weird!",
    terrain_ended = "The terrain returned to normal!",
    
    -- Pokemon switching messages
    switch_out = "{pokemon}, come back!",
    switch_in = "Go! {pokemon}!",
    switch_forced = "{pokemon} was forced to switch out!",
    
    -- Fainting and battle end messages
    pokemon_fainted = "{pokemon} fainted!",
    battle_victory = "You won the battle!",
    battle_defeat = "You lost the battle!",
    battle_draw = "The battle ended in a draw!",
    battle_forfeit = "The battle was forfeited!",
    
    -- Ability activation messages
    ability_activated = "{pokemon}'s {ability} activated!",
    ability_prevented = "{pokemon}'s {ability} prevented the effect!",
    
    -- Item usage messages
    item_used = "{trainer} used a {item}!",
    item_effect = "{item} had an effect on {pokemon}!",
    item_consumed = "{pokemon}'s {item} was consumed!",
    
    -- Turn phase messages
    turn_start = "Turn {turn}",
    turn_end = "End of turn {turn}",
    command_phase = "Select your command for {pokemon}!",
    
    -- Error and fallback messages
    unknown_move = "{pokemon} tried to use an unknown move!",
    no_pp = "{pokemon} has no PP left for {move}!",
    cannot_act = "{pokemon} cannot act!",
    invalid_target = "There is no target for the move!"
}

-- Stat name mappings for message generation
local StatNames = {
    [Enums.Stat.HP] = "HP",
    [Enums.Stat.ATK] = "Attack",
    [Enums.Stat.DEF] = "Defense",
    [Enums.Stat.SPATK] = "Sp. Atk",
    [Enums.Stat.SPDEF] = "Sp. Def",
    [Enums.Stat.SPD] = "Speed",
    [Enums.Stat.ACC] = "accuracy",
    [Enums.Stat.EVA] = "evasiveness"
}

-- Initialize message system
function BattleMessages.init()
    -- Ensure move database is loaded for move names
    if not MoveDatabase.moves or #MoveDatabase.moves == 0 then
        MoveDatabase.init()
    end
    
    return true
end

-- Generate move usage message
-- @param attacker: Pokemon using the move
-- @param move: Move data or move ID
-- @param target: Target Pokemon (optional)
-- @param result: Move execution result
-- @return: List of message strings
function BattleMessages.generateMoveMessage(attacker, move, target, result)
    if not attacker then
        return {"A Pokemon used a move!"}
    end
    
    local messages = {}
    local moveName = "a move"
    
    -- Get move name
    if type(move) == "number" then
        local moveData = MoveDatabase.moves[move]
        moveName = moveData and moveData.name or "Unknown Move"
    elseif type(move) == "table" and move.name then
        moveName = move.name
    end
    
    -- Primary move usage message
    local attackerName = attacker.name or "Pokemon"
    local useMessage = BattleMessages.formatMessage(MessageTemplates.move_use, {
        attacker = attackerName,
        move_name = moveName
    })
    table.insert(messages, useMessage)
    
    -- Add result-specific messages
    if result then
        if result.missed then
            table.insert(messages, BattleMessages.formatMessage(MessageTemplates.move_miss, {
                attacker = attackerName
            }))
        elseif result.failed then
            table.insert(messages, MessageTemplates.move_failed)
        elseif result.no_effect and target then
            table.insert(messages, BattleMessages.formatMessage(MessageTemplates.move_no_effect, {
                target = target.name or "the target"
            }))
        elseif result.damage_dealt and result.damage_dealt > 0 and target then
            -- Add effectiveness messages
            if result.effectiveness > 1 then
                table.insert(messages, MessageTemplates.damage_super_effective)
            elseif result.effectiveness < 1 and result.effectiveness > 0 then
                table.insert(messages, MessageTemplates.damage_not_very_effective)
            end
            
            -- Add critical hit message
            if result.critical_hit then
                table.insert(messages, MessageTemplates.damage_critical)
            end
        end
    end
    
    return messages
end

-- Generate damage reporting message
-- @param target: Pokemon taking damage
-- @param damage: Amount of damage
-- @param damageType: Type of damage (move, weather, status, etc.)
-- @param effectiveness: Type effectiveness multiplier (optional)
-- @param critical: Whether damage was critical (optional)
-- @return: List of damage message strings
function BattleMessages.generateDamageMessage(target, damage, damageType, effectiveness, critical)
    local messages = {}
    
    if not target or not damage or damage <= 0 then
        return messages
    end
    
    local targetName = target.name or "Pokemon"
    
    -- Add effectiveness message first (for move damage)
    if damageType == "move" and effectiveness then
        if effectiveness > 1 then
            table.insert(messages, MessageTemplates.damage_super_effective)
        elseif effectiveness < 1 and effectiveness > 0 then
            table.insert(messages, MessageTemplates.damage_not_very_effective)
        end
        
        if critical then
            table.insert(messages, MessageTemplates.damage_critical)
        end
    end
    
    -- Generate specific damage message based on type
    if damageType == "burn" then
        table.insert(messages, BattleMessages.formatMessage(MessageTemplates.burn_damage, {
            pokemon = targetName
        }))
    elseif damageType == "poison" then
        table.insert(messages, BattleMessages.formatMessage(MessageTemplates.poison_damage, {
            pokemon = targetName
        }))
    elseif damageType == "confusion" then
        table.insert(messages, BattleMessages.formatMessage(MessageTemplates.confusion_damage, {
            pokemon = targetName
        }))
    else
        -- Generic damage message
        table.insert(messages, BattleMessages.formatMessage(MessageTemplates.damage_generic, {
            target = targetName,
            damage = tostring(damage)
        }))
    end
    
    return messages
end

-- Generate status change message
-- @param pokemon: Pokemon receiving status change
-- @param statusEffect: Status effect being applied/removed
-- @param applied: Whether status is being applied (true) or removed (false)
-- @return: Status change message string
function BattleMessages.generateStatusMessage(pokemon, statusEffect, applied)
    if not pokemon or not statusEffect then
        return "A status effect occurred!"
    end
    
    local pokemonName = pokemon.name or "Pokemon"
    
    if applied then
        -- Status being applied
        if statusEffect == "burn" then
            return BattleMessages.formatMessage(MessageTemplates.status_burned, {pokemon = pokemonName})
        elseif statusEffect == "poison" then
            return BattleMessages.formatMessage(MessageTemplates.status_poisoned, {pokemon = pokemonName})
        elseif statusEffect == "paralysis" then
            return BattleMessages.formatMessage(MessageTemplates.status_paralyzed, {pokemon = pokemonName})
        elseif statusEffect == "freeze" then
            return BattleMessages.formatMessage(MessageTemplates.status_frozen, {pokemon = pokemonName})
        elseif statusEffect == "sleep" then
            return BattleMessages.formatMessage(MessageTemplates.status_asleep, {pokemon = pokemonName})
        elseif statusEffect == "confusion" then
            return BattleMessages.formatMessage(MessageTemplates.status_confused, {pokemon = pokemonName})
        end
    else
        -- Status being removed
        if statusEffect == "freeze" then
            return BattleMessages.formatMessage(MessageTemplates.status_thawed, {pokemon = pokemonName})
        elseif statusEffect == "sleep" then
            return BattleMessages.formatMessage(MessageTemplates.status_woke_up, {pokemon = pokemonName})
        else
            return BattleMessages.formatMessage(MessageTemplates.status_cured, {pokemon = pokemonName})
        end
    end
    
    return pokemonName .. "'s status changed!"
end

-- Generate stat modification message
-- @param pokemon: Pokemon whose stats are modified
-- @param stat: Stat being modified (using Enums.Stat)
-- @param stages: Number of stat stages changed (positive = increase, negative = decrease)
-- @return: Stat modification message string
function BattleMessages.generateStatMessage(pokemon, stat, stages)
    if not pokemon or not stat or not stages or stages == 0 then
        return "A stat was modified!"
    end
    
    local pokemonName = pokemon.name or "Pokemon"
    local statName = StatNames[stat] or "stat"
    
    if stages > 0 then
        -- Stat increase
        if stages == 1 then
            return BattleMessages.formatMessage(MessageTemplates.stat_rose, {
                pokemon = pokemonName,
                stat = statName
            })
        elseif stages == 2 then
            return BattleMessages.formatMessage(MessageTemplates.stat_rose_sharply, {
                pokemon = pokemonName,
                stat = statName
            })
        else
            return BattleMessages.formatMessage(MessageTemplates.stat_rose_drastically, {
                pokemon = pokemonName,
                stat = statName
            })
        end
    else
        -- Stat decrease
        local absStages = math.abs(stages)
        if absStages == 1 then
            return BattleMessages.formatMessage(MessageTemplates.stat_fell, {
                pokemon = pokemonName,
                stat = statName
            })
        elseif absStages == 2 then
            return BattleMessages.formatMessage(MessageTemplates.stat_fell_harshly, {
                pokemon = pokemonName,
                stat = statName
            })
        else
            return BattleMessages.formatMessage(MessageTemplates.stat_fell_severely, {
                pokemon = pokemonName,
                stat = statName
            })
        end
    end
end

-- Generate weather change message
-- @param weatherType: New weather type (using BattleConditions.WeatherType)
-- @param ended: Whether weather is ending (optional)
-- @return: Weather message string
function BattleMessages.generateWeatherMessage(weatherType, ended)
    if ended then
        return MessageTemplates.weather_ended
    end
    

-- ===== MODULE: game-logic.battle.battle-conditions =====
-- File: ao-processes/game-logic/battle/battle-conditions.lua
-- Original require:     local BattleConditions = require("game-logic.battle.battle-conditions")


-- ===== END MODULE: game-logic.battle.battle-conditions =====

    
    if weatherType == BattleConditions.WeatherType.SUNNY then
        return MessageTemplates.weather_sunny
    elseif weatherType == BattleConditions.WeatherType.RAIN then
        return MessageTemplates.weather_rain
    elseif weatherType == BattleConditions.WeatherType.SANDSTORM then
        return MessageTemplates.weather_sandstorm
    elseif weatherType == BattleConditions.WeatherType.HAIL then
        return MessageTemplates.weather_hail
    end
    
    return "The weather changed!"
end

-- Generate terrain change message
-- @param terrainType: New terrain type (using BattleConditions.TerrainType)
-- @param ended: Whether terrain is ending (optional)
-- @return: Terrain message string
function BattleMessages.generateTerrainMessage(terrainType, ended)
    if ended then
        return MessageTemplates.terrain_ended
    end
    

-- ===== MODULE: game-logic.battle.battle-conditions =====
-- File: ao-processes/game-logic/battle/battle-conditions.lua
-- Original require:     local BattleConditions = require("game-logic.battle.battle-conditions")


-- ===== END MODULE: game-logic.battle.battle-conditions =====

    
    if terrainType == BattleConditions.TerrainType.ELECTRIC then
        return MessageTemplates.terrain_electric
    elseif terrainType == BattleConditions.TerrainType.GRASSY then
        return MessageTemplates.terrain_grassy
    elseif terrainType == BattleConditions.TerrainType.MISTY then
        return MessageTemplates.terrain_misty
    elseif terrainType == BattleConditions.TerrainType.PSYCHIC then
        return MessageTemplates.terrain_psychic
    end
    
    return "The terrain changed!"
end

-- Generate Pokemon switching messages
-- @param outPokemon: Pokemon being switched out
-- @param inPokemon: Pokemon being switched in
-- @param forced: Whether switch was forced (optional)
-- @return: List of switching message strings
function BattleMessages.generateSwitchMessage(outPokemon, inPokemon, forced)
    local messages = {}
    
    if outPokemon then
        local outName = outPokemon.name or "Pokemon"
        if forced then
            table.insert(messages, BattleMessages.formatMessage(MessageTemplates.switch_forced, {
                pokemon = outName
            }))
        else
            table.insert(messages, BattleMessages.formatMessage(MessageTemplates.switch_out, {
                pokemon = outName
            }))
        end
    end
    
    if inPokemon then
        local inName = inPokemon.name or "Pokemon"
        table.insert(messages, BattleMessages.formatMessage(MessageTemplates.switch_in, {
            pokemon = inName
        }))
    end
    
    return messages
end

-- Generate battle end message
-- @param battleResult: Battle result ("victory", "defeat", "draw", "forfeit")
-- @param reason: Reason for battle end (optional)
-- @return: Battle end message string
function BattleMessages.generateBattleEndMessage(battleResult, reason)
    if battleResult == "victory" then
        return MessageTemplates.battle_victory
    elseif battleResult == "defeat" then
        return MessageTemplates.battle_defeat
    elseif battleResult == "draw" then
        return MessageTemplates.battle_draw
    elseif battleResult == "forfeit" then
        return MessageTemplates.battle_forfeit
    end
    
    return "The battle has ended!"
end

-- Generate fainting message
-- @param pokemon: Pokemon that fainted
-- @return: Fainting message string
function BattleMessages.generateFaintMessage(pokemon)
    if not pokemon then
        return "A Pokemon fainted!"
    end
    
    local pokemonName = pokemon.name or "Pokemon"
    return BattleMessages.formatMessage(MessageTemplates.pokemon_fainted, {
        pokemon = pokemonName
    })
end

-- Generate turn phase message
-- @param phase: Turn phase ("start", "end", "command")
-- @param turnNumber: Current turn number
-- @param pokemon: Active Pokemon (for command phase)
-- @return: Turn phase message string
function BattleMessages.generateTurnPhaseMessage(phase, turnNumber, pokemon)
    if phase == "start" then
        return BattleMessages.formatMessage(MessageTemplates.turn_start, {
            turn = tostring(turnNumber)
        })
    elseif phase == "end" then
        return BattleMessages.formatMessage(MessageTemplates.turn_end, {
            turn = tostring(turnNumber)
        })
    elseif phase == "command" and pokemon then
        return BattleMessages.formatMessage(MessageTemplates.command_phase, {
            pokemon = pokemon.name or "Pokemon"
        })
    end
    
    return "Turn phase: " .. (phase or "unknown")
end

-- Generate ability activation message
-- @param pokemon: Pokemon whose ability activated
-- @param abilityName: Name of the ability
-- @param prevented: Whether ability prevented an effect (optional)
-- @return: Ability message string
function BattleMessages.generateAbilityMessage(pokemon, abilityName, prevented)
    if not pokemon or not abilityName then
        return "An ability activated!"
    end
    
    local pokemonName = pokemon.name or "Pokemon"
    
    if prevented then
        return BattleMessages.formatMessage(MessageTemplates.ability_prevented, {
            pokemon = pokemonName,
            ability = abilityName
        })
    else
        return BattleMessages.formatMessage(MessageTemplates.ability_activated, {
            pokemon = pokemonName,
            ability = abilityName
        })
    end
end

-- Generate item usage message
-- @param trainer: Trainer using item (optional)
-- @param item: Item being used
-- @param pokemon: Target Pokemon (optional)
-- @param consumed: Whether item was consumed (optional)
-- @return: Item usage message string
function BattleMessages.generateItemMessage(trainer, item, pokemon, consumed)
    if not item then
        return "An item was used!"
    end
    
    local trainerName = trainer or "Trainer"
    local itemName = type(item) == "string" and item or "item"
    
    if consumed and pokemon then
        return BattleMessages.formatMessage(MessageTemplates.item_consumed, {
            pokemon = pokemon.name or "Pokemon",
            item = itemName
        })
    elseif pokemon then
        return BattleMessages.formatMessage(MessageTemplates.item_effect, {
            item = itemName,
            pokemon = pokemon.name or "Pokemon"
        })
    else
        return BattleMessages.formatMessage(MessageTemplates.item_used, {
            trainer = trainerName,
            item = itemName
        })
    end
end

-- Format message template with parameters
-- @param template: Message template string with {parameter} placeholders
-- @param params: Table of parameter values
-- @return: Formatted message string
function BattleMessages.formatMessage(template, params)
    if not template then
        return "Message template error!"
    end
    
    local message = template
    
    if params then
        for key, value in pairs(params) do
            local placeholder = "{" .. key .. "}"
            message = string.gsub(message, placeholder, tostring(value))
        end
    end
    
    return message
end

-- Generate comprehensive battle action description
-- @param action: Battle action data
-- @param result: Action execution result
-- @return: List of descriptive message strings
function BattleMessages.generateActionDescription(action, result)
    local messages = {}
    
    if not action then
        return {"A battle action occurred!"}
    end
    
    -- Generate messages based on action type
    if action.type == "move" then
        local moveMessages = BattleMessages.generateMoveMessage(action.pokemon, action.moveId, action.target, result)
        for _, msg in ipairs(moveMessages) do
            table.insert(messages, msg)
        end
        
        -- Add damage messages if applicable
        if result and result.damage_dealt and result.damage_dealt > 0 and action.target then
            local damageMessages = BattleMessages.generateDamageMessage(
                action.target, 
                result.damage_dealt, 
                "move", 
                result.effectiveness, 
                result.critical_hit
            )
            for _, msg in ipairs(damageMessages) do
                table.insert(messages, msg)
            end
        end
        
        -- Add status effect messages
        if result and result.status_effects then
            for _, statusEffect in ipairs(result.status_effects) do
                local statusMsg = BattleMessages.generateStatusMessage(
                    statusEffect.target, 
                    statusEffect.status, 
                    statusEffect.applied
                )
                table.insert(messages, statusMsg)
            end
        end
        
    elseif action.type == "switch" then
        local switchMessages = BattleMessages.generateSwitchMessage(action.pokemon, action.switchTo)
        for _, msg in ipairs(switchMessages) do
            table.insert(messages, msg)
        end
        
    elseif action.type == "item" then
        local itemMsg = BattleMessages.generateItemMessage("Trainer", action.itemId, action.pokemon)
        table.insert(messages, itemMsg)
    end
    
    return messages
end

-- Generate error message for invalid actions
-- @param errorType: Type of error
-- @param pokemon: Pokemon involved (optional)
-- @param move: Move involved (optional)
-- @return: Error message string
function BattleMessages.generateErrorMessage(errorType, pokemon, move)
    local pokemonName = pokemon and pokemon.name or "Pokemon"
    local moveName = "move"
    
    if move then
        if type(move) == "number" then
            local moveData = MoveDatabase.moves[move]
            moveName = moveData and moveData.name or "unknown move"
        elseif type(move) == "table" and move.name then
            moveName = move.name
        end
    end
    
    if errorType == "no_pp" then
        return BattleMessages.formatMessage(MessageTemplates.no_pp, {
            pokemon = pokemonName,
            move = moveName
        })
    elseif errorType == "cannot_act" then
        return BattleMessages.formatMessage(MessageTemplates.cannot_act, {
            pokemon = pokemonName
        })
    elseif errorType == "invalid_target" then
        return MessageTemplates.invalid_target
    elseif errorType == "unknown_move" then
        return BattleMessages.formatMessage(MessageTemplates.unknown_move, {
            pokemon = pokemonName
        })
    end
    
    return "An error occurred during battle!"
end


-- ===== END MODULE: game-logic.battle.battle-messages =====


-- ===== MODULE: game-logic.battle.ability-interactions =====
-- File: ao-processes/game-logic/battle/ability-interactions.lua
-- Original require: pcall(function() AbilityInteractions = require("game-logic.battle.ability-interactions") end)

-- Ability-Move Interaction System
-- Handles ability-based move interactions including redirections, absorptions, and immunities
-- Provides Lightning Rod, Water Absorb, Flash Fire, and other ability interactions

local AbilityInteractions = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Ability interaction types
AbilityInteractions.InteractionType = {
    ABSORPTION = "ABSORPTION",        -- Move absorbed and provides benefit (Water Absorb, Volt Absorb)
    REDIRECTION = "REDIRECTION",      -- Move redirected to different target (Lightning Rod, Storm Drain)
    IMMUNITY = "IMMUNITY",            -- Move completely nullified (Levitate, Sap Sipper)
    BOOST = "BOOST",                  -- Move nullified with stat boost (Motor Drive, Sap Sipper)
    ACTIVATION = "ACTIVATION"         -- Ability activates due to move (Flash Fire, Water Veil)
}

-- Ability interaction data
-- Maps ability IDs to their interaction effects
AbilityInteractions.interactionData = {
    [Enums.AbilityId.LIGHTNING_ROD] = {
        type = AbilityInteractions.InteractionType.REDIRECTION,
        moveTypes = {Enums.PokemonType.ELECTRIC},
        effect = {
            redirect = true,
            statBoost = {stat = Enums.Stat.SPATK, stages = 1},
            absorb = true,
            message = "Lightning Rod drew the Electric-type attack!"
        },
        priority = 10 -- High priority for redirection
    },
    
    [Enums.AbilityId.WATER_ABSORB] = {
        type = AbilityInteractions.InteractionType.ABSORPTION,
        moveTypes = {Enums.PokemonType.WATER},
        effect = {
            healingFraction = "1/4", -- Heal 1/4 max HP
            absorb = true,
            message = "Water Absorb restored HP!"
        },
        priority = 5
    },
    
    [Enums.AbilityId.VOLT_ABSORB] = {
        type = AbilityInteractions.InteractionType.ABSORPTION,
        moveTypes = {Enums.PokemonType.ELECTRIC},
        effect = {
            healingFraction = "1/4",
            absorb = true,
            message = "Volt Absorb restored HP!"
        },
        priority = 5
    },
    
    [Enums.AbilityId.FLASH_FIRE] = {
        type = AbilityInteractions.InteractionType.ACTIVATION,
        moveTypes = {Enums.PokemonType.FIRE},
        effect = {
            absorb = true,
            firePowerBoost = 1.5,
            message = "Flash Fire raised the power of Fire-type moves!"
        },
        priority = 5
    },
    
    [Enums.AbilityId.LEVITATE] = {
        type = AbilityInteractions.InteractionType.IMMUNITY,
        moveTypes = {Enums.PokemonType.GROUND},
        effect = {
            immune = true,
            message = "Levitate makes Ground-type moves miss!"
        },
        priority = 8
    },
    
    [118] = { -- SAP_SIPPER placeholder ID
        type = AbilityInteractions.InteractionType.BOOST,
        moveTypes = {Enums.PokemonType.GRASS},
        effect = {
            statBoost = {stat = Enums.Stat.ATK, stages = 1},
            absorb = true,
            message = "Sap Sipper boosted Attack!"
        },
        priority = 5
    },
    
    -- Add Motor Drive for Electric moves
    [77] = { -- MOTOR_DRIVE placeholder ID
        type = AbilityInteractions.InteractionType.BOOST,
        moveTypes = {Enums.PokemonType.ELECTRIC},
        effect = {
            statBoost = {stat = Enums.Stat.SPD, stages = 1},
            absorb = true,
            message = "Motor Drive boosted Speed!"
        },
        priority = 5
    },
    
    -- Add Storm Drain for Water moves
    [114] = { -- STORM_DRAIN placeholder ID
        type = AbilityInteractions.InteractionType.REDIRECTION,
        moveTypes = {Enums.PokemonType.WATER},
        effect = {
            redirect = true,
            statBoost = {stat = Enums.Stat.SPATK, stages = 1},
            absorb = true,
            message = "Storm Drain drew the Water-type attack!"
        },
        priority = 10
    }
}

-- Check if ability can interact with move
-- @param abilityId: Ability ID to check
-- @param moveType: Type of the move
-- @param moveCategory: Category of the move (Physical/Special/Status)
-- @return: Boolean indicating if interaction exists
function AbilityInteractions.canInteract(abilityId, moveType, moveCategory)
    local interaction = AbilityInteractions.interactionData[abilityId]
    if not interaction then
        return false
    end
    
    -- Check if move type matches ability interaction
    for _, interactionType in ipairs(interaction.moveTypes) do
        if moveType == interactionType then
            return true
        end
    end
    
    return false
end

-- Process ability interaction with move
-- @param battleState: Current battle state
-- @param abilityPokemon: Pokemon with the ability
-- @param attacker: Pokemon using the move
-- @param moveData: Move being used
-- @param targets: Original move targets
-- @return: Interaction result with new targets, effects, and success flag
function AbilityInteractions.processInteraction(battleState, abilityPokemon, attacker, moveData, targets)
    if not AbilityInteractions.canInteract(abilityPokemon.ability, moveData.type, moveData.category) then
        return {success = false, reason = "No ability interaction"}
    end
    
    local interaction = AbilityInteractions.interactionData[abilityPokemon.ability]
    local result = {
        success = true,
        interactionType = interaction.type,
        effects = {},
        newTargets = targets,
        message = interaction.effect.message or "",
        priority = interaction.priority
    }
    
    -- Process different interaction types
    if interaction.type == AbilityInteractions.InteractionType.ABSORPTION then
        result.effects.absorbed = true
        result.effects.blocked = true
        result.newTargets = {} -- No targets - move absorbed
        
        -- Apply healing
        if interaction.effect.healingFraction then
            local maxHP = abilityPokemon.maxHP or abilityPokemon.stats[Enums.Stat.HP]
            local healAmount = 0
            
            if interaction.effect.healingFraction == "1/4" then
                healAmount = math.max(1, math.floor(maxHP / 4))
            elseif interaction.effect.healingFraction == "1/3" then
                healAmount = math.max(1, math.floor(maxHP / 3))
            elseif interaction.effect.healingFraction == "1/2" then
                healAmount = math.max(1, math.floor(maxHP / 2))
            end
            
            result.effects.healing = {
                target = abilityPokemon.id,
                amount = healAmount
            }
        end
        
    elseif interaction.type == AbilityInteractions.InteractionType.REDIRECTION then
        result.effects.redirected = true
        result.effects.blocked = true
        result.newTargets = {abilityPokemon.id} -- Redirect to ability user
        
        -- Apply stat boost after redirection
        if interaction.effect.statBoost then
            result.effects.statBoost = {
                target = abilityPokemon.id,
                stat = interaction.effect.statBoost.stat,
                stages = interaction.effect.statBoost.stages
            }
        end
        
    elseif interaction.type == AbilityInteractions.InteractionType.IMMUNITY then
        result.effects.immune = true
        result.effects.blocked = true
        result.newTargets = {} -- No targets - move has no effect
        
    elseif interaction.type == AbilityInteractions.InteractionType.BOOST then
        result.effects.absorbed = true
        result.effects.blocked = true
        result.newTargets = {} -- No targets - move absorbed
        
        -- Apply stat boost
        if interaction.effect.statBoost then
            result.effects.statBoost = {
                target = abilityPokemon.id,
                stat = interaction.effect.statBoost.stat,
                stages = interaction.effect.statBoost.stages
            }
        end
        
    elseif interaction.type == AbilityInteractions.InteractionType.ACTIVATION then
        result.effects.activated = true
        -- Move still hits, but ability activates
        -- Flash Fire boosts fire moves for future use
        if interaction.effect.firePowerBoost then
            -- Set battle state flag for Flash Fire activation
            battleState.abilityStates = battleState.abilityStates or {}
            battleState.abilityStates[abilityPokemon.id] = battleState.abilityStates[abilityPokemon.id] or {}
            battleState.abilityStates[abilityPokemon.id].flashFireActive = true
            battleState.abilityStates[abilityPokemon.id].firePowerMultiplier = interaction.effect.firePowerBoost
        end
    end
    
    return result
end

-- Check for multi-target redirection (doubles/triples)
-- @param battleState: Current battle state
-- @param moveData: Move being used
-- @param originalTargets: Original move targets
-- @return: Array of Pokemon with redirecting abilities and their priorities
function AbilityInteractions.getRedirectingAbilities(battleState, moveData, originalTargets)
    local redirectors = {}
    
    -- Check all Pokemon on the field for redirecting abilities
    for _, pokemon in pairs(battleState.activePokemon or {}) do
        if pokemon and pokemon.ability and not pokemon.fainted then
            local interaction = AbilityInteractions.interactionData[pokemon.ability]
            if interaction and interaction.type == AbilityInteractions.InteractionType.REDIRECTION then
                -- Check if this ability can redirect this move type
                for _, moveType in ipairs(interaction.moveTypes) do
                    if moveData.type == moveType then
                        table.insert(redirectors, {
                            pokemon = pokemon,
                            priority = interaction.priority,
                            interaction = interaction
                        })
                        break
                    end
                end
            end
        end
    end
    
    -- Sort by priority (highest first)
    table.sort(redirectors, function(a, b)
        return a.priority > b.priority
    end)
    
    return redirectors
end

-- Apply ability interaction effects to battle state
-- @param battleState: Battle state to modify
-- @param interactionResult: Result from processInteraction
-- @return: Updated battle state and effect messages
function AbilityInteractions.applyInteractionEffects(battleState, interactionResult)
    local messages = {}
    
    if not interactionResult.success then
        return battleState, messages
    end
    
    -- Add interaction message
    if interactionResult.message then
        table.insert(messages, interactionResult.message)
    end
    
    -- Apply healing effect
    if interactionResult.effects.healing then
        local target = interactionResult.effects.healing.target
        local amount = interactionResult.effects.healing.amount
        
        for _, pokemon in pairs(battleState.activePokemon or {}) do
            if pokemon and pokemon.id == target then
                local oldHP = pokemon.currentHP
                pokemon.currentHP = math.min(pokemon.currentHP + amount, 
                                           pokemon.maxHP or pokemon.stats[Enums.Stat.HP])
                local actualHealing = pokemon.currentHP - oldHP
                if actualHealing > 0 then
                    table.insert(messages, pokemon.name .. " restored " .. actualHealing .. " HP!")
                end
                break
            end
        end
    end
    
    -- Apply stat boost effect
    if interactionResult.effects.statBoost then
        local target = interactionResult.effects.statBoost.target
        local stat = interactionResult.effects.statBoost.stat
        local stages = interactionResult.effects.statBoost.stages
        
        for _, pokemon in pairs(battleState.activePokemon or {}) do
            if pokemon and pokemon.id == target then
                pokemon.statStages = pokemon.statStages or {}
                pokemon.statStages[stat] = (pokemon.statStages[stat] or 0) + stages
                
                -- Cap at +/-6
                pokemon.statStages[stat] = math.max(-6, math.min(6, pokemon.statStages[stat]))
                
                local statName = "Unknown"
                for name, id in pairs(Enums.Stat) do
                    if id == stat then
                        statName = name
                        break
                    end
                end
                
                if stages > 0 then
                    table.insert(messages, pokemon.name .. "'s " .. statName .. " rose!")
                else
                    table.insert(messages, pokemon.name .. "'s " .. statName .. " fell!")
                end
                break
            end
        end
    end
    
    return battleState, messages
end

-- Get active ability states for move power calculations
-- @param battleState: Current battle state
-- @param pokemonId: Pokemon ID to check
-- @return: Ability state data or nil
function AbilityInteractions.getAbilityState(battleState, pokemonId)
    if not battleState.abilityStates or not battleState.abilityStates[pokemonId] then
        return nil
    end
    
    return battleState.abilityStates[pokemonId]
end

-- Check if Flash Fire is active for Fire-type move power boost
-- @param battleState: Current battle state
-- @param pokemonId: Pokemon ID using Fire-type move
-- @return: Power multiplier (1.5 if Flash Fire active, 1.0 otherwise)
function AbilityInteractions.getFirePowerMultiplier(battleState, pokemonId)
    local abilityState = AbilityInteractions.getAbilityState(battleState, pokemonId)
    if abilityState and abilityState.flashFireActive then
        return abilityState.firePowerMultiplier or 1.5
    end
    return 1.0
end

-- Validate ability interaction data integrity
-- @return: Boolean indicating if all interaction data is valid
function AbilityInteractions.validateInteractionData()
    for abilityId, interaction in pairs(AbilityInteractions.interactionData) do
        -- Check required fields
        if not interaction.type or not interaction.moveTypes or not interaction.effect then
            print("Warning: Invalid interaction data for ability " .. tostring(abilityId))
            return false
        end
        
        -- Validate interaction type
        local validType = false
        for _, validTypeValue in pairs(AbilityInteractions.InteractionType) do
            if interaction.type == validTypeValue then
                validType = true
                break
            end
        end
        
        if not validType then
            print("Warning: Invalid interaction type for ability " .. tostring(abilityId) .. ": " .. tostring(interaction.type))
            return false
        end
        
        -- Validate move types
        for _, moveType in ipairs(interaction.moveTypes) do
            if not Enums.PokemonTypeName[moveType] then
                print("Warning: Invalid move type in ability " .. tostring(abilityId) .. ": " .. tostring(moveType))
                return false
            end
        end
    end
    
    return true
end

-- Initialize ability interactions system
function AbilityInteractions.init()
    if not AbilityInteractions.validateInteractionData() then
        return false, "Invalid ability interaction data"
    end
    
    print("Ability Interactions system initialized with " .. 
          #AbilityInteractions.interactionData .. " ability interactions")
    return true
end


-- ===== END MODULE: game-logic.battle.ability-interactions =====

-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- Switch-in effect types and priorities
SwitchInEffects.EffectType = {
    ENTRY_HAZARDS = "ENTRY_HAZARDS",
    ABILITY_ACTIVATION = "ABILITY_ACTIVATION",
    WEATHER_RESPONSE = "WEATHER_RESPONSE", 
    TERRAIN_RESPONSE = "TERRAIN_RESPONSE",
    INTIMIDATE_REACTION = "INTIMIDATE_REACTION",
    FORM_CHANGE = "FORM_CHANGE"
}

-- Effect processing priorities (lower numbers execute first)
SwitchInEffects.EffectPriority = {
    [SwitchInEffects.EffectType.ENTRY_HAZARDS] = 1,
    [SwitchInEffects.EffectType.ABILITY_ACTIVATION] = 2,
    [SwitchInEffects.EffectType.WEATHER_RESPONSE] = 3,
    [SwitchInEffects.EffectType.TERRAIN_RESPONSE] = 4,
    [SwitchInEffects.EffectType.INTIMIDATE_REACTION] = 5,
    [SwitchInEffects.EffectType.FORM_CHANGE] = 6
}

-- Entry hazard damage calculations
SwitchInEffects.EntryHazards = {
    SPIKES = {
        maxLayers = 3,
        damagePerLayer = "1/8", -- 1/8 max HP per layer
        blockedByFlying = true,
        blockedByLevitate = true
    },
    TOXIC_SPIKES = {
        maxLayers = 2,
        layer1Effect = "poison",
        layer2Effect = "badly_poison",
        blockedByFlying = true,
        blockedByLevitate = true,
        absorbedByPoison = true
    },
    STEALTH_ROCK = {
        damageBase = "1/8", -- Base 1/8 max HP, modified by type effectiveness
        useTypeEffectiveness = true
    },
    STICKY_WEB = {
        effect = "speed_drop",
        stages = -1,
        blockedByFlying = true,
        blockedByLevitate = true
    }
}

-- Initialize switch-in effects system
function SwitchInEffects.init()
    -- Initialize battle messages if available
    if BattleMessages and BattleMessages.init then
        BattleMessages.init()
    end
    
    return true, "Switch-in effects system initialized"
end

-- Process all switch-in effects for a Pokemon
-- @param battleState: Current battle state
-- @param pokemon: Pokemon that switched in
-- @param position: Battle position
-- @param previousPokemon: Pokemon that was switched out (optional)
-- @return: Switch-in effects result
function SwitchInEffects.processAllSwitchInEffects(battleState, pokemon, position, previousPokemon)
    if not battleState or not pokemon then
        return {
            success = false,
            error = "Invalid parameters for switch-in effects processing"
        }
    end
    
    local result = {
        success = true,
        pokemon = pokemon,
        position = position,
        effects = {},
        messages = {},
        damageTaken = 0,
        healing = 0,
        statusChanges = {},
        statStages = {},
        timestamp = os.time()
    }
    
    -- Collect all switch-in effects
    local effects = SwitchInEffects.collectSwitchInEffects(battleState, pokemon, position)
    
    -- Sort effects by priority
    table.sort(effects, function(a, b)
        return (SwitchInEffects.EffectPriority[a.type] or 99) < (SwitchInEffects.EffectPriority[b.type] or 99)
    end)
    
    -- Process effects in order
    for _, effect in ipairs(effects) do
        local effectResult = SwitchInEffects.processEffect(battleState, pokemon, effect)
        
        if effectResult then
            table.insert(result.effects, effectResult)
            
            -- Combine messages
            if effectResult.messages then
                for _, message in ipairs(effectResult.messages) do
                    table.insert(result.messages, message)
                end
            end
            
            -- Accumulate damage and healing
            result.damageTaken = result.damageTaken + (effectResult.damage or 0)
            result.healing = result.healing + (effectResult.healing or 0)
            
            -- Combine status changes
            if effectResult.statusChange then
                table.insert(result.statusChanges, effectResult.statusChange)
            end
            
            -- Combine stat stage changes
            if effectResult.statStageChanges then
                for stat, change in pairs(effectResult.statStageChanges) do
                    result.statStages[stat] = (result.statStages[stat] or 0) + change
                end
            end
            
            -- Check if Pokemon fainted from entry hazards
            if pokemon.currentHP <= 0 then
                pokemon.fainted = true
                table.insert(result.messages, pokemon.name .. " fainted from entry hazards!")
                break -- No more effects if Pokemon fainted
            end
        end
    end
    
    -- Record switch-in effects in battle events
    table.insert(battleState.battleEvents, {
        type = "switch_in_effects",
        pokemon = pokemon.id,
        position = position,
        effects = result.effects,
        damage = result.damageTaken,
        healing = result.healing,
        turn = battleState.turn,
        timestamp = os.time()
    })
    
    return result
end

-- Collect all applicable switch-in effects for a Pokemon
-- @param battleState: Current battle state
-- @param pokemon: Pokemon that switched in
-- @param position: Battle position
-- @return: Array of switch-in effects
function SwitchInEffects.collectSwitchInEffects(battleState, pokemon, position)
    local effects = {}
    
    -- Entry hazards (processed first)
    local hazardEffects = SwitchInEffects.getEntryHazardEffects(battleState, pokemon, position)
    for _, effect in ipairs(hazardEffects) do
        table.insert(effects, effect)
    end
    
    -- Ability activations
    local abilityEffects = SwitchInEffects.getAbilitySwitchInEffects(battleState, pokemon, position)
    for _, effect in ipairs(abilityEffects) do
        table.insert(effects, effect)
    end
    
    -- Weather responses
    local weatherEffects = SwitchInEffects.getWeatherSwitchInEffects(battleState, pokemon)
    for _, effect in ipairs(weatherEffects) do
        table.insert(effects, effect)
    end
    
    -- Terrain responses
    local terrainEffects = SwitchInEffects.getTerrainSwitchInEffects(battleState, pokemon)
    for _, effect in ipairs(terrainEffects) do
        table.insert(effects, effect)
    end
    
    -- Intimidate reactions (if opponent has Intimidate)
    local intimidateEffects = SwitchInEffects.getIntimidateReactionEffects(battleState, pokemon, position)
    for _, effect in ipairs(intimidateEffects) do
        table.insert(effects, effect)
    end
    
    return effects
end

-- Get entry hazard effects for switching Pokemon
-- @param battleState: Current battle state
-- @param pokemon: Pokemon switching in
-- @param position: Battle position
-- @return: Array of entry hazard effects
function SwitchInEffects.getEntryHazardEffects(battleState, pokemon, position)
    local effects = {}
    
    if not battleState.battleConditions or not battleState.battleConditions.entryHazards then
        return effects
    end
    
    local side = pokemon.battleData.side
    local hazards = battleState.battleConditions.entryHazards[side]
    
    if not hazards then
        return effects
    end
    
    -- Stealth Rock
    if hazards.stealthRock then
        table.insert(effects, {
            type = SwitchInEffects.EffectType.ENTRY_HAZARDS,
            hazardType = "STEALTH_ROCK",
            pokemon = pokemon,
            data = SwitchInEffects.EntryHazards.STEALTH_ROCK
        })
    end
    
    -- Spikes
    if hazards.spikes and hazards.spikes > 0 then
        table.insert(effects, {
            type = SwitchInEffects.EffectType.ENTRY_HAZARDS,
            hazardType = "SPIKES",
            layers = hazards.spikes,
            pokemon = pokemon,
            data = SwitchInEffects.EntryHazards.SPIKES
        })
    end
    
    -- Toxic Spikes
    if hazards.toxicSpikes and hazards.toxicSpikes > 0 then
        table.insert(effects, {
            type = SwitchInEffects.EffectType.ENTRY_HAZARDS,
            hazardType = "TOXIC_SPIKES",
            layers = hazards.toxicSpikes,
            pokemon = pokemon,
            data = SwitchInEffects.EntryHazards.TOXIC_SPIKES
        })
    end
    
    -- Sticky Web
    if hazards.stickyWeb then
        table.insert(effects, {
            type = SwitchInEffects.EffectType.ENTRY_HAZARDS,
            hazardType = "STICKY_WEB",
            pokemon = pokemon,
            data = SwitchInEffects.EntryHazards.STICKY_WEB
        })
    end
    
    return effects
end

-- Get ability-based switch-in effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon switching in
-- @param position: Battle position
-- @return: Array of ability effects
function SwitchInEffects.getAbilitySwitchInEffects(battleState, pokemon, position)
    local effects = {}
    
    -- Skip ability effects if dependencies not loaded or no ability
    if not pokemon.ability then
        return effects
    end
    
    -- For testing, just return empty effects - full ability system integration
    -- would require the complete Enums system which may not be available in tests
    return effects
end

-- Get weather-responsive switch-in effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon switching in
-- @return: Array of weather effects
function SwitchInEffects.getWeatherSwitchInEffects(battleState, pokemon)
    -- Simplified for testing - full weather response system would need Enums integration
    return {}
end

-- Get terrain-responsive switch-in effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon switching in
-- @return: Array of terrain effects
function SwitchInEffects.getTerrainSwitchInEffects(battleState, pokemon)
    local effects = {}
    
    if not battleState.battleConditions or not battleState.battleConditions.terrain then
        return effects
    end
    
    -- Future terrain-based abilities can be added here
    
    return effects
end

-- Get Intimidate reaction effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon switching in
-- @param position: Battle position
-- @return: Array of Intimidate reaction effects
function SwitchInEffects.getIntimidateReactionEffects(battleState, pokemon, position)
    -- Simplified for testing - full intimidate reaction system would need Enums integration
    return {}
end

-- Process individual switch-in effect
-- @param battleState: Current battle state
-- @param pokemon: Pokemon being affected
-- @param effect: Effect to process
-- @return: Effect processing result
function SwitchInEffects.processEffect(battleState, pokemon, effect)
    if not effect then
        return nil
    end
    
    if effect.type == SwitchInEffects.EffectType.ENTRY_HAZARDS then
        return SwitchInEffects.processEntryHazardEffect(battleState, pokemon, effect)
    elseif effect.type == SwitchInEffects.EffectType.ABILITY_ACTIVATION then
        return SwitchInEffects.processAbilityEffect(battleState, pokemon, effect)
    elseif effect.type == SwitchInEffects.EffectType.WEATHER_RESPONSE then
        return SwitchInEffects.processWeatherEffect(battleState, pokemon, effect)
    elseif effect.type == SwitchInEffects.EffectType.TERRAIN_RESPONSE then
        return SwitchInEffects.processTerrainEffect(battleState, pokemon, effect)
    elseif effect.type == SwitchInEffects.EffectType.INTIMIDATE_REACTION then
        return SwitchInEffects.processIntimidateReactionEffect(battleState, pokemon, effect)
    elseif effect.type == SwitchInEffects.EffectType.FORM_CHANGE then
        return SwitchInEffects.processFormChangeEffect(battleState, pokemon, effect)
    end
    
    return nil
end

-- Process entry hazard effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon being affected
-- @param effect: Entry hazard effect
-- @return: Entry hazard processing result
function SwitchInEffects.processEntryHazardEffect(battleState, pokemon, effect)
    -- Delegate to comprehensive EntryHazards module
    local hazardResult = EntryHazards.processHazardEffects(battleState, pokemon)
    
    if not hazardResult or not hazardResult.success then
        return nil
    end
    
    -- Convert EntryHazards result format to SwitchInEffects format
    local result = {
        type = "entry_hazards",
        pokemon = pokemon.id,
        damage = hazardResult.damageTaken or 0,
        messages = hazardResult.messages or {},
        statusChange = nil,
        statStageChanges = hazardResult.statChanges or {},
        hazardEffects = hazardResult.effects or {}
    }
    
    -- Add status changes if any
    if hazardResult.statusChanges and #hazardResult.statusChanges > 0 then
        result.statusChange = hazardResult.statusChanges[1] -- Take the first status change
    end
    
    return result
end

-- Process ability activation effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon with activating ability
-- @param effect: Ability effect
-- @return: Ability processing result
function SwitchInEffects.processAbilityEffect(battleState, pokemon, effect)
    local result = {
        type = "ability_activation",
        ability = effect.ability,
        pokemon = pokemon.id,
        messages = {}
    }
    
    if effect.effect == "weather_change" then
        battleState.battleConditions.weather = effect.weather
        battleState.battleConditions.weatherDuration = 5
        result.messages = {pokemon.name .. "'s " .. SwitchInEffects.getAbilityName(effect.ability) .. " changed the weather!"}
        
    elseif effect.effect == "intimidate" then
        -- Apply Attack reduction to all opposing Pokemon
        result.messages = {pokemon.name .. "'s Intimidate lowered opposing Pokemon's Attack!"}
        -- Implementation would interact with opposing Pokemon stat stages
        
    elseif effect.effect == "download" then
        -- Compare opposing Defense vs Special Defense and boost accordingly
        result.messages = {pokemon.name .. "'s Download boosted its stats!"}
        -- Implementation would analyze opposing stats and boost Attack or Special Attack
        
    elseif effect.effect == "trace" then
        -- Copy ability from opposing Pokemon
        result.messages = {pokemon.name .. " traced an opposing Pokemon's ability!"}
        -- Implementation would copy a random opposing Pokemon's ability
        
    elseif effect.effect == "weather_nullify" then
        result.messages = {pokemon.name .. "'s " .. SwitchInEffects.getAbilityName(effect.ability) .. " nullified the weather!"}
        -- Weather effects are suppressed while this Pokemon is active
    end
    
    return result
end

-- Process weather response effects
-- @param battleState: Current battle state  
-- @param pokemon: Pokemon responding to weather
-- @param effect: Weather effect
-- @return: Weather processing result
function SwitchInEffects.processWeatherEffect(battleState, pokemon, effect)
    local result = {
        type = "weather_response",
        pokemon = pokemon.id,
        messages = {}
    }
    
    if effect.effect == "form_change" then
        -- Castform form change based on weather
        result.messages = {pokemon.name .. " transformed!"}
        -- Implementation would change Pokemon's form/type based on weather
    end
    
    return result
end

-- Process terrain response effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon responding to terrain
-- @param effect: Terrain effect
-- @return: Terrain processing result
function SwitchInEffects.processTerrainEffect(battleState, pokemon, effect)
    local result = {
        type = "terrain_response", 
        pokemon = pokemon.id,
        messages = {}
    }
    
    -- Future terrain effects can be implemented here
    
    return result
end

-- Process Intimidate reaction effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon reacting to Intimidate
-- @param effect: Intimidate reaction effect
-- @return: Intimidate reaction processing result
function SwitchInEffects.processIntimidateReactionEffect(battleState, pokemon, effect)
    local result = {
        type = "intimidate_reaction",
        pokemon = pokemon.id,
        ability = effect.ability,
        messages = {},
        statStageChanges = {}
    }
    
    if effect.effect == "stat_boost_on_intimidate" and Enums and Enums.AbilityId then
        if effect.ability == Enums.AbilityId.COMPETITIVE then
            -- Boost Special Attack by 2 stages
            pokemon.battleData.statStages.spa = math.min(6, pokemon.battleData.statStages.spa + 2)
            result.statStageChanges.spa = 2
            result.messages = {pokemon.name .. "'s Competitive boosted its Special Attack!"}
            
        elseif effect.ability == Enums.AbilityId.DEFIANT then
            -- Boost Attack by 2 stages
            pokemon.battleData.statStages.atk = math.min(6, pokemon.battleData.statStages.atk + 2)
            result.statStageChanges.atk = 2
            result.messages = {pokemon.name .. "'s Defiant boosted its Attack!"}
        end
    end
    
    return result
end

-- Process form change effects
-- @param battleState: Current battle state
-- @param pokemon: Pokemon changing form
-- @param effect: Form change effect
-- @return: Form change processing result
function SwitchInEffects.processFormChangeEffect(battleState, pokemon, effect)
    local result = {
        type = "form_change",
        pokemon = pokemon.id,
        messages = {}
    }
    
    -- Implementation would handle form changes like Castform, Cherrim, etc.
    result.messages = {pokemon.name .. " changed form!"}
    
    return result
end

-- Helper functions for effect processing

-- Check entry hazard immunity
-- @param pokemon: Pokemon to check
-- @param effect: Entry hazard effect
-- @return: Immunity check result
function SwitchInEffects.checkEntryHazardImmunity(pokemon, effect)
    local result = {immune = false, messages = {}}
    
    if not Enums or not Enums.AbilityId then
        return result -- Skip immunity checks if Enums not available
    end
    
    -- Magic Guard immunity
    if pokemon.ability == Enums.AbilityId.MAGIC_GUARD then
        result.immune = true
        result.messages = {pokemon.name .. "'s Magic Guard prevents entry hazard damage!"}
        return result
    end
    
    -- Flying type immunity to ground hazards
    if effect.data.blockedByFlying and Enums.PokemonType and SwitchInEffects.hasType(pokemon, Enums.PokemonType.FLYING) then
        result.immune = true
        return result
    end
    
    -- Levitate immunity to ground hazards
    if effect.data.blockedByLevitate and pokemon.ability == Enums.AbilityId.LEVITATE then
        result.immune = true
        return result
    end
    
    return result
end

-- Get Stealth Rock type effectiveness
-- @param pokemon: Pokemon to check
-- @return: Type effectiveness multiplier
function SwitchInEffects.getStealthRockEffectiveness(pokemon)
    -- This would integrate with the type chart system
    -- For now, return neutral effectiveness
    local effectiveness = 1.0
    
    -- Implementation would check Pokemon's types against Rock-type effectiveness
    -- and return the appropriate multiplier (0.25x to 4x)
    
    return effectiveness
end

-- Check if Pokemon is grounded
-- @param pokemon: Pokemon to check
-- @return: True if Pokemon is affected by ground-based effects
function SwitchInEffects.isGrounded(pokemon)
    if not Enums then
        return true -- Assume grounded if no type checking available
    end
    
    if Enums.PokemonType and SwitchInEffects.hasType(pokemon, Enums.PokemonType.FLYING) then
        return false
    end
    
    if Enums.AbilityId and pokemon.ability == Enums.AbilityId.LEVITATE then
        return false
    end
    
    -- Check for Air Balloon item
    if Enums.ItemId and pokemon.item == Enums.ItemId.AIR_BALLOON then
        return false
    end
    
    return true
end

-- Check if Pokemon has specific type
-- @param pokemon: Pokemon to check
-- @param typeId: Type ID to check for
-- @return: True if Pokemon has the type
function SwitchInEffects.hasType(pokemon, typeId)
    if not pokemon.species then
        return false
    end
    
    -- This would integrate with species data
    -- For now, assume basic type checking
    return false
end

-- Check if Pokemon is Poison type
-- @param pokemon: Pokemon to check
-- @return: True if Pokemon is Poison type
function SwitchInEffects.isPoisonType(pokemon)
    if not Enums or not Enums.PokemonType then
        return false
    end
    return SwitchInEffects.hasType(pokemon, Enums.PokemonType.POISON)
end

-- Get ability name for messages
-- @param abilityId: Ability ID
-- @return: Ability name string
function SwitchInEffects.getAbilityName(abilityId)
    -- This would integrate with ability data
    local abilityNames = {}
    if Enums and Enums.AbilityId then
        abilityNames = {
            [Enums.AbilityId.DROUGHT] = "Drought",
            [Enums.AbilityId.DRIZZLE] = "Drizzle",
            [Enums.AbilityId.SAND_STREAM] = "Sand Stream",
            [Enums.AbilityId.SNOW_WARNING] = "Snow Warning",
            [Enums.AbilityId.AIR_LOCK] = "Air Lock",
            [Enums.AbilityId.CLOUD_NINE] = "Cloud Nine"
        }
    end
    
    return abilityNames[abilityId] or "Unknown Ability"
end


-- ===== END MODULE: game-logic.battle.switch-in-effects =====


-- Field conditions system dependencies

-- ===== MODULE: game-logic.battle.field-conditions =====
-- File: ao-processes/game-logic/battle/field-conditions.lua
-- Original require: local FieldConditions = require("game-logic.battle.field-conditions")


-- ===== END MODULE: game-logic.battle.field-conditions =====


-- Turn phase enumeration
TurnProcessor.TurnPhase = {
    COMMAND_SELECTION = 1,
    ACTION_EXECUTION = 2,
    END_OF_TURN = 3,
    BATTLE_END = 4
}

-- Action type enumeration
TurnProcessor.ActionType = {
    MOVE = "move",
    SWITCH = "switch",
    ITEM = "item",
    MEGA_EVOLUTION = "mega_evolution",
    Z_MOVE = "z_move",
    DYNAMAX = "dynamax",
    ABILITY = "ability"
}

-- Battle state structure template
TurnProcessor.BattleState = {
    battleId = nil,
    turn = 0,
    phase = TurnProcessor.TurnPhase.COMMAND_SELECTION,
    turnOrder = {},
    currentAction = nil,
    pendingActions = {},
    interruptQueue = {},
    battleSeed = nil,
    playerParty = {},
    enemyParty = {},
    battleConditions = {},
    turnCommands = {},
    battleResult = nil
}

-- Initialize turn processor for a battle
-- @param battleId: Unique battle identifier
-- @param battleSeed: Deterministic RNG seed
-- @param playerParty: Player's Pokemon party
-- @param enemyParty: Enemy's Pokemon party
-- @return: Battle state object
function TurnProcessor.initializeBattle(battleId, battleSeed, playerParty, enemyParty)
    if not battleId or not battleSeed then
        return nil, "Invalid battle initialization parameters"
    end
    
    -- Initialize battle RNG with seed
    BattleRNG.initSeed(battleSeed)
    
    -- Create new battle state
    local battleState = {
        battleId = battleId,
        turn = 0,
        phase = TurnProcessor.TurnPhase.COMMAND_SELECTION,
        turnOrder = {},
        currentAction = nil,
        pendingActions = {},
        interruptQueue = {},
        battleSeed = battleSeed,
        playerParty = playerParty or {},
        enemyParty = enemyParty or {},
        battleConditions = {
            weather = nil,
            terrain = nil,
            fieldEffects = {},
            sideConditions = {
                player = {},
                enemy = {}
            }
        },
        turnCommands = {},
        battleResult = nil,
        activePlayerPokemon = {},
        activeEnemyPokemon = {}
    }
    
    -- Set initial active Pokemon
    if playerParty and #playerParty > 0 then
        table.insert(battleState.activePlayerPokemon, playerParty[1])
    end
    
    if enemyParty and #enemyParty > 0 then
        table.insert(battleState.activeEnemyPokemon, enemyParty[1])
    end
    
    return battleState, nil
end

-- Find Pokemon in battle parties
-- @param battleState: Battle state object
-- @param pokemonId: Pokemon identifier
-- @param playerId: Player identifier (optional)
-- @return: Pokemon data if found
function TurnProcessor.findPokemon(battleState, pokemonId, playerId)
    if not battleState or not pokemonId then
        return nil
    end
    
    -- Check player party
    for _, pokemon in ipairs(battleState.playerParty) do
        if pokemon.id == pokemonId then
            return pokemon
        end
    end
    
    -- Check enemy party
    for _, pokemon in ipairs(battleState.enemyParty) do
        if pokemon.id == pokemonId then
            return pokemon
        end
    end
    
    return nil
end

-- Validate battle command
-- @param battleState: Current battle state
-- @param pokemon: Pokemon executing the command
-- @param command: Command to validate
-- @return: Validation result with success/error
function TurnProcessor.validateCommand(battleState, pokemon, command)
    if not battleState or not pokemon or not command then
        return {valid = false, error = "Missing required parameters"}
    end
    
    -- Check if Pokemon can act
    if not TurnProcessor.canPokemonAct(pokemon) then
        return {valid = false, error = "Pokemon cannot act"}
    end
    
    -- Validate based on command type
    if command.type == TurnProcessor.ActionType.MOVE then
        return TurnProcessor.validateMoveCommand(pokemon, command)
    elseif command.type == TurnProcessor.ActionType.SWITCH then
        return TurnProcessor.validateSwitchCommand(battleState, pokemon, command)
    elseif command.type == TurnProcessor.ActionType.ITEM then
        return TurnProcessor.validateItemCommand(pokemon, command)
    else
        return {valid = false, error = "Unknown command type"}
    end
end

-- Check if Pokemon can perform actions
-- @param pokemon: Pokemon to check
-- @return: Boolean indicating if Pokemon can act
function TurnProcessor.canPokemonAct(pokemon)
    if not pokemon then
        return false
    end
    
    -- Check if fainted
    if pokemon.hp <= 0 then
        return false
    end
    
    -- Check status conditions that prevent action
    if pokemon.status == Enums.StatusCondition.SLEEP then
        -- Pokemon might wake up during action
        return true
    end
    
    if pokemon.status == Enums.StatusCondition.FREEZE then
        -- Pokemon might thaw during action
        return true
    end
    
    if pokemon.status == Enums.StatusCondition.PARALYSIS then
        -- Pokemon might be able to act despite paralysis
        return true
    end
    
    return true
end

-- Validate move command
-- @param pokemon: Pokemon using the move
-- @param command: Move command data
-- @return: Validation result
function TurnProcessor.validateMoveCommand(pokemon, command)
    if not command.moveId then
        return {valid = false, error = "Move ID required"}
    end
    
    -- Check if Pokemon knows the move
    local knowsMove = false
    for _, move in ipairs(pokemon.moves or {}) do
        if move.id == command.moveId then
            knowsMove = true
            -- Check PP
            if move.pp <= 0 then
                return {valid = false, error = "Move has no PP remaining"}
            end
            break
        end
    end
    
    if not knowsMove then
        return {valid = false, error = "Pokemon doesn't know this move"}
    end
    
    return {valid = true}
end

-- Validate switch command
-- @param battleState: Current battle state
-- @param pokemon: Current Pokemon
-- @param command: Switch command data
-- @return: Validation result
function TurnProcessor.validateSwitchCommand(battleState, pokemon, command)
    if not command.switchPokemonId then
        return {valid = false, error = "Switch Pokemon ID required"}
    end
    
    -- Find the Pokemon to switch to
    local switchPokemon = TurnProcessor.findPokemon(battleState, command.switchPokemonId)
    if not switchPokemon then
        return {valid = false, error = "Switch Pokemon not found"}
    end
    
    -- Check if switch Pokemon is available
    if switchPokemon.hp <= 0 then
        return {valid = false, error = "Cannot switch to fainted Pokemon"}
    end
    
    -- Check if already active
    if switchPokemon.id == pokemon.id then
        return {valid = false, error = "Pokemon is already active"}
    end
    
    return {valid = true}
end

-- Validate item command
-- @param pokemon: Pokemon using the item
-- @param command: Item command data
-- @return: Validation result
function TurnProcessor.validateItemCommand(pokemon, command)
    if not command.itemId then
        return {valid = false, error = "Item ID required"}
    end
    
    -- Additional item validation would be implemented here
    -- This is a placeholder for item system integration
    
    return {valid = true}
end

-- Add command to current turn
-- @param battleState: Battle state object
-- @param playerId: Player issuing command
-- @param command: Battle command data
-- @return: Success status and validation result
function TurnProcessor.addTurnCommand(battleState, playerId, command)
    if not battleState or battleState.phase ~= TurnProcessor.TurnPhase.COMMAND_SELECTION then
        return false, "Not in command selection phase"
    end
    
    if not playerId or not command then
        return false, "Invalid command parameters"
    end
    
    -- Validate command structure
    if not command.type or not command.pokemonId then
        return false, "Command missing required fields"
    end
    
    -- Find Pokemon in appropriate party
    local pokemon = TurnProcessor.findPokemon(battleState, command.pokemonId, playerId)
    if not pokemon then
        return false, "Pokemon not found or not available"
    end
    
    -- Validate command based on type
    local validationResult = TurnProcessor.validateCommand(battleState, pokemon, command)
    if not validationResult.valid then
        return false, validationResult.error
    end
    
    -- Store command
    if not battleState.turnCommands[playerId] then
        battleState.turnCommands[playerId] = {}
    end
    
    command.pokemon = pokemon
    command.playerId = playerId
    table.insert(battleState.turnCommands[playerId], command)
    
    return true, {
        command_accepted = true,
        pokemon_id = command.pokemonId,
        action_type = command.type
    }
end

-- Create turn actions from commands
-- @param battleState: Current battle state
-- @return: Array of turn actions
function TurnProcessor.createTurnActions(battleState)
    local actions = {}
    
    for playerId, commands in pairs(battleState.turnCommands) do
        for _, command in ipairs(commands) do
            local action = {
                type = command.type,
                pokemonId = command.pokemonId,
                pokemon = command.pokemon,
                playerId = playerId,
                priority = 0,
                speed = command.pokemon.stats.speed or 0,
                timestamp = 0
            }
            
            -- Add action-specific data
            if command.type == TurnProcessor.ActionType.MOVE then
                action.moveId = command.moveId
                action.target = command.target
                -- Priority will be calculated by PriorityCalculator
            elseif command.type == TurnProcessor.ActionType.SWITCH then
                action.switchPokemonId = command.switchPokemonId
                action.priority = 6  -- Switch has high priority
            elseif command.type == TurnProcessor.ActionType.ITEM then
                action.itemId = command.itemId
                action.priority = 6  -- Item use has high priority
            end
            
            table.insert(actions, action)
        end
    end
    
    return actions
end

-- Process complete battle turn with all phases
-- @param battleState: Current battle state
-- @return: Turn result with actions executed and battle state updates
function TurnProcessor.processBattleTurn(battleState)
    if not battleState or battleState.phase ~= TurnProcessor.TurnPhase.COMMAND_SELECTION then
        return nil, "Invalid battle state or phase"
    end
    
    -- Initialize berry activation state for this battle
    BerryActivationManager.initializeBattleState(battleState.battleId)
    
    -- Transition to action execution phase
    battleState.phase = TurnProcessor.TurnPhase.ACTION_EXECUTION
    battleState.turn = battleState.turn + 1
    
    -- Create turn actions from commands
    local turnActions = TurnProcessor.createTurnActions(battleState)
    if not turnActions or #turnActions == 0 then
        return nil, "No valid actions to process"
    end
    
    -- Calculate turn order with priority and speed
    local completeConditions = battleState.battleConditions or {}
    completeConditions.fieldConditions = battleState.fieldConditions
    battleState.turnOrder = PriorityCalculator.calculateTurnOrder(turnActions, completeConditions)
    
    local turnResult = {
        turn = battleState.turn,
        actions_executed = {},
        battle_events = {},
        interruptions = {},
        phase_results = {}
    }
    
    -- Execute all actions in priority order
    for _, action in ipairs(battleState.turnOrder) do
        battleState.currentAction = action
        
        local actionResult = TurnProcessor.executeAction(battleState, action)
        table.insert(turnResult.actions_executed, actionResult)
        
        -- Check for battle end conditions after each action
        local battleEnd = TurnProcessor.checkBattleEndConditions(battleState)
        if battleEnd then
            battleState.battleResult = battleEnd
            battleState.phase = TurnProcessor.TurnPhase.BATTLE_END
            turnResult.battle_end = battleEnd
            return turnResult, nil
        end
    end
    
    -- Process end-of-turn effects
    battleState.phase = TurnProcessor.TurnPhase.END_OF_TURN
    local endTurnResult = TurnProcessor.processEndOfTurnEffects(battleState)
    turnResult.phase_results.end_of_turn = endTurnResult
    
    -- Check battle end conditions after end-of-turn effects
    local battleEnd = TurnProcessor.checkBattleEndConditions(battleState)
    if battleEnd then
        battleState.battleResult = battleEnd
        battleState.phase = TurnProcessor.TurnPhase.BATTLE_END
        turnResult.battle_end = battleEnd
        return turnResult, nil
    end
    
    -- Clear turn commands and return to command selection phase
    battleState.turnCommands = {}
    battleState.phase = TurnProcessor.TurnPhase.COMMAND_SELECTION
    
    return turnResult, nil
end

-- Execute individual battle action
-- @param battleState: Current battle state
-- @param action: Action to execute
-- @return: Action execution result
function TurnProcessor.executeAction(battleState, action)
    if not battleState or not action then
        return {success = false, error = "Invalid action parameters"}
    end
    
    local result = {
        action_type = action.type,
        pokemon_id = action.pokemonId,
        success = false,
        effects = {},
        messages = {},
        timestamp = 0
    }
    
    -- Check if Pokemon is still able to act
    if not TurnProcessor.canPokemonAct(action.pokemon) then
        result.error = "Pokemon cannot act"
        result.messages = {"Pokemon is unable to act!"}
        return result
    end
    
    -- Execute based on action type
    if action.type == TurnProcessor.ActionType.MOVE then
        result = TurnProcessor.executeMoveAction(battleState, action)
    elseif action.type == TurnProcessor.ActionType.SWITCH then
        result = TurnProcessor.executeSwitchAction(battleState, action)
    elseif action.type == TurnProcessor.ActionType.ITEM then
        result = TurnProcessor.executeItemAction(battleState, action)
    else
        result.error = "Unknown action type: " .. tostring(action.type)
    end
    
    return result
end

-- Execute move action (placeholder for move system integration)
-- @param battleState: Current battle state
-- @param action: Move action to execute
-- @return: Move execution result
function TurnProcessor.executeMoveAction(battleState, action)
    local result = {
        action_type = "move",
        pokemon_id = action.pokemonId,
        move_id = action.moveId,
        success = true,
        damage_dealt = 0,
        effects = {},
        messages = {"Move executed successfully"}
    }
    
    -- This will integrate with the move system and damage calculator
    -- Placeholder implementation for now
    
    return result
end

-- Execute switch action
-- @param battleState: Current battle state
-- @param action: Switch action to execute
-- @return: Switch execution result
function TurnProcessor.executeSwitchAction(battleState, action)
    local result = {
        action_type = "switch",
        pokemon_id = action.pokemonId,
        switch_pokemon_id = action.switchPokemonId,
        success = true,
        effects = {},
        messages = {"Pokemon switched successfully"}
    }
    
    -- Implement switch logic here
    -- This is a placeholder for switch system integration
    
    return result
end

-- Execute item action
-- @param battleState: Current battle state
-- @param action: Item action to execute
-- @return: Item execution result
function TurnProcessor.executeItemAction(battleState, action)
    local result = {
        action_type = "item",
        pokemon_id = action.pokemonId,
        item_id = action.itemId,
        success = true,
        effects = {},
        messages = {"Item used successfully"}
    }
    
    -- Implement item usage logic here
    -- This is a placeholder for item system integration
    
    return result
end

-- Process end-of-turn effects
-- @param battleState: Current battle state
-- @return: End of turn processing result
function TurnProcessor.processEndOfTurnEffects(battleState)
    local result = {
        weather_effects = {},
        status_effects = {},
        terrain_effects = {},
        field_effects = {}
    }
    
    -- Process weather effects
    if battleState.battleConditions.weather then
        result.weather_effects = WeatherEffects.processEndOfTurn(battleState)
    end
    
    -- Process terrain effects
    if battleState.battleConditions.terrain then
        result.terrain_effects = TerrainEffects.processEndOfTurn(battleState)
    end
    
    -- Process status effects on all active Pokemon
    for _, pokemon in ipairs(battleState.activePlayerPokemon) do
        if pokemon.status then
            local statusResult = StatusEffects.processEndOfTurn(pokemon, battleState)
            table.insert(result.status_effects, statusResult)
        end
    end
    
    for _, pokemon in ipairs(battleState.activeEnemyPokemon) do
        if pokemon.status then
            local statusResult = StatusEffects.processEndOfTurn(pokemon, battleState)
            table.insert(result.status_effects, statusResult)
        end
    end
    
    return result
end

-- Check for battle end conditions
-- @param battleState: Current battle state
-- @return: Battle end result if battle is over, nil otherwise
function TurnProcessor.checkBattleEndConditions(battleState)
    if not battleState then
        return nil
    end
    
    -- Check if all player Pokemon are fainted
    local playerHasActivePokemon = false
    for _, pokemon in ipairs(battleState.playerParty) do
        if pokemon.hp > 0 then
            playerHasActivePokemon = true
            break
        end
    end
    
    -- Check if all enemy Pokemon are fainted
    local enemyHasActivePokemon = false
    for _, pokemon in ipairs(battleState.enemyParty) do
        if pokemon.hp > 0 then
            enemyHasActivePokemon = true
            break
        end
    end
    
    if not playerHasActivePokemon and not enemyHasActivePokemon then
        return {
            result = "DRAW",
            reason = "All Pokemon fainted"
        }
    elseif not playerHasActivePokemon then
        return {
            result = "DEFEAT",
            reason = "All player Pokemon fainted"
        }
    elseif not enemyHasActivePokemon then
        return {
            result = "VICTORY",
            reason = "All enemy Pokemon fainted"
        }
    end
    
    return nil
end


-- ===== END MODULE: battle.components.turn-processor =====


-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Battle instance management
local BattleInstances = {}
local ResourcePools = {}
local LoadBalancer = {}
local PerformanceMonitor = {}

-- Configuration
local CONFIG = {
    maxConcurrentBattles = 100,
    maxBattlesPerPool = 10,
    resourcePoolSize = 10,
    performanceWindowSize = 100,
    loadBalancingEnabled = true,
    resourceIsolation = true
}

-- Battle instance status
ConcurrentBattleManager.InstanceStatus = {
    IDLE = "IDLE",
    PROCESSING = "PROCESSING",
    WAITING = "WAITING",
    ERROR = "ERROR",
    COMPLETED = "COMPLETED"
}

-- Load balancing strategy
ConcurrentBattleManager.LoadBalanceStrategy = {
    ROUND_ROBIN = "ROUND_ROBIN",
    LEAST_LOADED = "LEAST_LOADED",
    PERFORMANCE_BASED = "PERFORMANCE_BASED"
}

-- Initialize concurrent battle management
-- @param maxConcurrentBattles: Maximum concurrent battles (optional)
-- @return: Initialization result
function ConcurrentBattleManager.initialize(maxConcurrentBattles)
    CONFIG.maxConcurrentBattles = maxConcurrentBattles or CONFIG.maxConcurrentBattles
    
    -- Initialize battle instances
    BattleInstances = {}
    
    -- Initialize resource pools
    ResourcePools = {
        rngSeeds = {},
        calculationCache = {},
        turnProcessors = {},
        availablePools = {}
    }
    
    -- Initialize load balancer
    LoadBalancer = {
        strategy = ConcurrentBattleManager.LoadBalanceStrategy.PERFORMANCE_BASED,
        roundRobinIndex = 1,
        poolLoad = {},
        lastAssignment = 0
    }
    
    -- Initialize performance monitor
    PerformanceMonitor = {
        battleLatency = {},
        throughputHistory = {},
        resourceUtilization = {},
        errorRates = {},
        windowStart = 0
    }
    
    -- Create resource pools
    ConcurrentBattleManager.initializeResourcePools()
    
    print("[ConcurrentBattleManager] Initialized with max " .. CONFIG.maxConcurrentBattles .. " concurrent battles")
    
    return {
        success = true,
        maxConcurrentBattles = CONFIG.maxConcurrentBattles,
        resourcePools = #ResourcePools.availablePools,
        loadBalanceStrategy = LoadBalancer.strategy
    }
end

-- Initialize resource pools for battle processing
function ConcurrentBattleManager.initializeResourcePools()
    local poolCount = math.ceil(CONFIG.maxConcurrentBattles / CONFIG.maxBattlesPerPool)
    
    for i = 1, poolCount do
        local pool = {
            poolId = "pool_" .. i,
            activeBattles = {},
            maxBattles = CONFIG.maxBattlesPerPool,
            rngSeed = BattleRNG.generateSeed(),
            calculationCache = {},
            performanceMetrics = {
                averageLatency = 0,
                battlesProcessed = 0,
                errorCount = 0,
                lastUpdate = 0
            }
        }
        
        table.insert(ResourcePools.availablePools, pool)
        LoadBalancer.poolLoad[pool.poolId] = 0
    end
    
    print("[ConcurrentBattleManager] Created " .. poolCount .. " resource pools")
end

-- Start new concurrent battle
-- @param battleId: Unique battle identifier
-- @param battleParams: Battle initialization parameters
-- @param coordinatorId: Coordinator process ID
-- @return: Battle instance result or error
function ConcurrentBattleManager.startBattle(battleId, battleParams, coordinatorId)
    if not battleId or not battleParams then
        return nil, "Invalid battle parameters"
    end
    
    -- Check if battle already exists
    if BattleInstances[battleId] then
        return nil, "Battle instance already exists"
    end
    
    -- Check concurrent battle limit
    local activeBattleCount = ConcurrentBattleManager.getActiveBattleCount()
    if activeBattleCount >= CONFIG.maxConcurrentBattles then
        return nil, "Maximum concurrent battles reached (" .. CONFIG.maxConcurrentBattles .. ")"
    end
    
    -- Select resource pool using load balancing
    local resourcePool = ConcurrentBattleManager.selectResourcePool()
    if not resourcePool then
        return nil, "No available resource pool"
    end
    
    -- Create battle state
    local battleState, stateError = BattleStateManager.createBattleState(battleId, battleParams, coordinatorId)
    if not battleState then
        return nil, "Failed to create battle state: " .. (stateError or "Unknown error")
    end
    
    -- Create battle instance
    local battleInstance = {
        battleId = battleId,
        status = ConcurrentBattleManager.InstanceStatus.IDLE,
        resourcePoolId = resourcePool.poolId,
        battleState = battleState,
        coordinatorId = coordinatorId,
        createdAt = 0,
        lastProcessed = 0,
        performanceMetrics = {
            turnLatency = {},
            totalTurns = 0,
            errors = 0,
            startTime = 0
        }
    }
    
    -- Add to instance storage and resource pool
    BattleInstances[battleId] = battleInstance
    table.insert(resourcePool.activeBattles, battleInstance)
    LoadBalancer.poolLoad[resourcePool.poolId] = LoadBalancer.poolLoad[resourcePool.poolId] + 1
    
    -- Initialize battle with turn processor
    local turnResult, turnError = TurnProcessor.initializeBattle(
        battleId,
        battleParams.battleSeed,
        battleParams.playerParty,
        battleParams.enemyParty
    )
    
    if turnError then
        ConcurrentBattleManager.removeBattleFromPool(battleId, resourcePool)
        return nil, "Failed to initialize battle: " .. turnError
    end
    
    print("[ConcurrentBattleManager] Started battle: " .. battleId .. " in pool: " .. resourcePool.poolId)
    
    return {
        success = true,
        battleId = battleId,
        resourcePoolId = resourcePool.poolId,
        battleState = battleState
    }, nil
end

-- Select resource pool using load balancing strategy
-- @return: Selected resource pool or nil if none available
function ConcurrentBattleManager.selectResourcePool()
    local availablePools = {}
    
    -- Find pools with available capacity
    for _, pool in ipairs(ResourcePools.availablePools) do
        if #pool.activeBattles < pool.maxBattles then
            table.insert(availablePools, pool)
        end
    end
    
    if #availablePools == 0 then
        return nil
    end
    
    -- Apply load balancing strategy
    if LoadBalancer.strategy == ConcurrentBattleManager.LoadBalanceStrategy.ROUND_ROBIN then
        local selectedIndex = ((LoadBalancer.roundRobinIndex - 1) % #availablePools) + 1
        LoadBalancer.roundRobinIndex = LoadBalancer.roundRobinIndex + 1
        return availablePools[selectedIndex]
        
    elseif LoadBalancer.strategy == ConcurrentBattleManager.LoadBalanceStrategy.LEAST_LOADED then
        local leastLoaded = availablePools[1]
        for _, pool in ipairs(availablePools) do
            if #pool.activeBattles < #leastLoaded.activeBattles then
                leastLoaded = pool
            end
        end
        return leastLoaded
        
    elseif LoadBalancer.strategy == ConcurrentBattleManager.LoadBalanceStrategy.PERFORMANCE_BASED then
        local bestPerformance = availablePools[1]
        local bestScore = ConcurrentBattleManager.calculatePoolPerformanceScore(bestPerformance)
        
        for _, pool in ipairs(availablePools) do
            local score = ConcurrentBattleManager.calculatePoolPerformanceScore(pool)
            if score > bestScore then
                bestPerformance = pool
                bestScore = score
            end
        end
        
        return bestPerformance
    end
    
    return availablePools[1]
end

-- Calculate performance score for resource pool selection
-- @param pool: Resource pool to evaluate
-- @return: Performance score (higher is better)
function ConcurrentBattleManager.calculatePoolPerformanceScore(pool)
    if not pool.performanceMetrics then
        return 0
    end
    
    local metrics = pool.performanceMetrics
    local currentLoad = #pool.activeBattles / pool.maxBattles
    
    -- Calculate weighted score
    local latencyScore = metrics.averageLatency > 0 and (1000 / metrics.averageLatency) or 1
    local loadScore = 1 - currentLoad
    local reliabilityScore = metrics.battlesProcessed > 0 and (1 - metrics.errorCount / metrics.battlesProcessed) or 1
    
    return (latencyScore * 0.4) + (loadScore * 0.4) + (reliabilityScore * 0.2)
end

-- Process battle turn in concurrent environment
-- @param battleId: Battle identifier
-- @param turnCommands: Turn commands from players
-- @return: Turn processing result
function ConcurrentBattleManager.processBattleTurn(battleId, turnCommands)
    local battleInstance = BattleInstances[battleId]
    if not battleInstance then
        return nil, "Battle instance not found"
    end
    
    -- Mark as processing
    battleInstance.status = ConcurrentBattleManager.InstanceStatus.PROCESSING
    local startTime = msg.Timestamp
    
    -- Get resource pool
    local resourcePool = ConcurrentBattleManager.getResourcePool(battleInstance.resourcePoolId)
    if not resourcePool then
        return nil, "Resource pool not found"
    end
    
    -- Add turn commands to battle state
    for playerId, commands in pairs(turnCommands or {}) do
        for _, command in ipairs(commands) do
            local success, error = TurnProcessor.addTurnCommand(battleInstance.battleState, playerId, command)
            if not success then
                battleInstance.performanceMetrics.errors = battleInstance.performanceMetrics.errors + 1
                return nil, "Failed to add turn command: " .. (error or "Unknown error")
            end
        end
    end
    
    -- Process the turn
    local turnResult, turnError = TurnProcessor.processBattleTurn(battleInstance.battleState)
    
    local endTime = 0
    local turnLatency = endTime - startTime
    
    -- Update performance metrics
    table.insert(battleInstance.performanceMetrics.turnLatency, turnLatency)
    battleInstance.performanceMetrics.totalTurns = battleInstance.performanceMetrics.totalTurns + 1
    battleInstance.lastProcessed = endTime
    
    -- Limit latency history size
    while #battleInstance.performanceMetrics.turnLatency > CONFIG.performanceWindowSize do
        table.remove(battleInstance.performanceMetrics.turnLatency, 1)
    end
    
    -- Update pool performance metrics
    ConcurrentBattleManager.updatePoolPerformanceMetrics(resourcePool, turnLatency, turnError ~= nil)
    
    -- Handle turn processing result
    if turnError then
        battleInstance.status = ConcurrentBattleManager.InstanceStatus.ERROR
        battleInstance.performanceMetrics.errors = battleInstance.performanceMetrics.errors + 1
        return nil, "Turn processing failed: " .. turnError
    end
    
    -- Check if battle is completed
    if turnResult.battle_end then
        battleInstance.status = ConcurrentBattleManager.InstanceStatus.COMPLETED
        BattleStateManager.completeBattle(battleId, turnResult.battle_end)
        
        -- Schedule for cleanup
        ConcurrentBattleManager.scheduleBattleCleanup(battleId, 300) -- 5 minutes
    else
        battleInstance.status = ConcurrentBattleManager.InstanceStatus.IDLE
    end
    
    return {
        success = true,
        battleId = battleId,
        turnResult = turnResult,
        performanceMetrics = {
            turnLatency = turnLatency,
            totalTurns = battleInstance.performanceMetrics.totalTurns
        }
    }, nil
end

-- Update resource pool performance metrics
-- @param pool: Resource pool
-- @param turnLatency: Latest turn latency
-- @param hadError: Whether turn processing had an error
function ConcurrentBattleManager.updatePoolPerformanceMetrics(pool, turnLatency, hadError)
    local metrics = pool.performanceMetrics
    
    metrics.battlesProcessed = metrics.battlesProcessed + 1
    if hadError then
        metrics.errorCount = metrics.errorCount + 1
    end
    
    -- Update average latency (exponential moving average)
    if metrics.averageLatency == 0 then
        metrics.averageLatency = turnLatency
    else
        metrics.averageLatency = (metrics.averageLatency * 0.9) + (turnLatency * 0.1)
    end
    
    metrics.lastUpdate = 0
end

-- Get resource pool by ID
-- @param poolId: Resource pool identifier
-- @return: Resource pool or nil
function ConcurrentBattleManager.getResourcePool(poolId)
    for _, pool in ipairs(ResourcePools.availablePools) do
        if pool.poolId == poolId then
            return pool
        end
    end
    return nil
end

-- Remove battle from resource pool
-- @param battleId: Battle identifier
-- @param pool: Resource pool
function ConcurrentBattleManager.removeBattleFromPool(battleId, pool)
    for i, battle in ipairs(pool.activeBattles) do
        if battle.battleId == battleId then
            table.remove(pool.activeBattles, i)
            LoadBalancer.poolLoad[pool.poolId] = LoadBalancer.poolLoad[pool.poolId] - 1
            break
        end
    end
    
    BattleInstances[battleId] = nil
end

-- Schedule battle cleanup after delay
-- @param battleId: Battle identifier
-- @param delaySeconds: Delay before cleanup
function ConcurrentBattleManager.scheduleBattleCleanup(battleId, delaySeconds)
    -- This would be implemented with a cleanup scheduler in production
    -- For now, we'll just mark for immediate cleanup
    ConcurrentBattleManager.cleanupBattle(battleId)
end

-- Cleanup completed battle
-- @param battleId: Battle identifier
-- @return: Cleanup success status
function ConcurrentBattleManager.cleanupBattle(battleId)
    local battleInstance = BattleInstances[battleId]
    if not battleInstance then
        return false
    end
    
    -- Get resource pool and remove battle
    local resourcePool = ConcurrentBattleManager.getResourcePool(battleInstance.resourcePoolId)
    if resourcePool then
        ConcurrentBattleManager.removeBattleFromPool(battleId, resourcePool)
    end
    
    print("[ConcurrentBattleManager] Cleaned up battle: " .. battleId)
    return true
end

-- Get count of active battles
-- @return: Number of active battles
function ConcurrentBattleManager.getActiveBattleCount()
    local count = 0
    for _, instance in pairs(BattleInstances) do
        if instance.status ~= ConcurrentBattleManager.InstanceStatus.COMPLETED then
            count = count + 1
        end
    end
    return count
end

-- Get battle instance by ID
-- @param battleId: Battle identifier
-- @return: Battle instance or nil
function ConcurrentBattleManager.getBattleInstance(battleId)
    return BattleInstances[battleId]
end

-- Get performance statistics
-- @return: Performance statistics for concurrent battle processing
function ConcurrentBattleManager.getPerformanceStatistics()
    local stats = {
        totalBattles = 0,
        activeBattles = 0,
        completedBattles = 0,
        errorBattles = 0,
        poolUtilization = {},
        averageLatency = 0,
        throughput = 0,
        resourcePools = #ResourcePools.availablePools
    }
    
    local totalLatency = 0
    local latencyCount = 0
    local totalTurns = 0
    
    -- Calculate battle statistics
    for _, instance in pairs(BattleInstances) do
        stats.totalBattles = stats.totalBattles + 1
        
        if instance.status == ConcurrentBattleManager.InstanceStatus.IDLE or 
           instance.status == ConcurrentBattleManager.InstanceStatus.PROCESSING then
            stats.activeBattles = stats.activeBattles + 1
        elseif instance.status == ConcurrentBattleManager.InstanceStatus.COMPLETED then
            stats.completedBattles = stats.completedBattles + 1
        elseif instance.status == ConcurrentBattleManager.InstanceStatus.ERROR then
            stats.errorBattles = stats.errorBattles + 1
        end
        
        -- Aggregate latency data
        for _, latency in ipairs(instance.performanceMetrics.turnLatency) do
            totalLatency = totalLatency + latency
            latencyCount = latencyCount + 1
        end
        
        totalTurns = totalTurns + instance.performanceMetrics.totalTurns
    end
    
    -- Calculate pool utilization
    for _, pool in ipairs(ResourcePools.availablePools) do
        stats.poolUtilization[pool.poolId] = {
            activeBattles = #pool.activeBattles,
            maxBattles = pool.maxBattles,
            utilization = #pool.activeBattles / pool.maxBattles,
            averageLatency = pool.performanceMetrics.averageLatency,
            battlesProcessed = pool.performanceMetrics.battlesProcessed,
            errorCount = pool.performanceMetrics.errorCount
        }
    end
    
    -- Calculate overall metrics
    if latencyCount > 0 then
        stats.averageLatency = totalLatency / latencyCount
    end
    
    stats.throughput = totalTurns
    
    return stats
end


-- ===== END MODULE: battle.components.concurrent-battle-manager =====


-- ===== MODULE: battle.components.turn-processor =====
-- File: ao-processes/battle/components/turn-processor.lua
-- Original require: local TurnProcessor = require("battle.components.turn-processor")


-- ===== END MODULE: battle.components.turn-processor =====


-- ===== MODULE: battle.components.damage-calculator =====
-- File: ao-processes/battle/components/damage-calculator.lua
-- Original require: local DamageCalculator = require("battle.components.damage-calculator")


-- ===== END MODULE: battle.components.damage-calculator =====


-- ===== MODULE: battle.components.move-effect-processor =====
-- File: ao-processes/battle/components/move-effect-processor.lua
-- Original require: local MoveEffectProcessor = require("battle.components.move-effect-processor")

-- Battle Process Move Effect Processor
-- Extracted from game-logic.battle.move-effects for dedicated battle process
-- Maintains identical behavior for all existing move effects and status conditions
-- Epic 32.3: Battle Engine Process Extraction

local MoveEffectProcessor = {}

-- Load dependencies
-- SHARED MODULE REFERENCE: data.constants.enums (already included)

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====

-- SHARED MODULE REFERENCE: data.constants.type-chart (already included)

-- Status effect definitions (matching TypeScript StatusEffect enum)
MoveEffectProcessor.StatusEffect = {
    NONE = 0,
    POISON = 1,
    SLEEP = 2,
    PARALYSIS = 3,
    BURN = 4,
    FREEZE = 5,
    FAINT = 6,
    TOXIC = 7
}

-- Move effect categories
MoveEffectProcessor.EffectCategory = {
    STATUS_CONDITION = "STATUS_CONDITION",
    STAT_MODIFICATION = "STAT_MODIFICATION",
    HEALING = "HEALING",
    DAMAGE_OVER_TIME = "DAMAGE_OVER_TIME",
    FIELD_CONDITION = "FIELD_CONDITION",
    SPECIAL_EFFECT = "SPECIAL_EFFECT"
}

-- Stat stage modifications
MoveEffectProcessor.StatStage = {
    ATTACK = "attack",
    DEFENSE = "defense",
    SPECIAL_ATTACK = "special_attack", 
    SPECIAL_DEFENSE = "special_defense",
    SPEED = "speed",
    ACCURACY = "accuracy",
    EVASION = "evasion"
}

-- Status effect data with exact behavioral parameters
local STATUS_EFFECT_DATA = {
    [MoveEffectProcessor.StatusEffect.POISON] = {
        name = "Poison",
        duration = -1, -- Permanent until cured
        damagePerTurn = 1/8, -- 1/8 of max HP per turn
        immunityTypes = {Enums.PokemonType.POISON, Enums.PokemonType.STEEL},
        immunityAbilities = {Enums.AbilityId.IMMUNITY, Enums.AbilityId.POISON_HEAL},
        cureConditions = {"natural_cure", "pecha_berry", "aromatherapy", "heal_bell"}
    },
    [MoveEffectProcessor.StatusEffect.SLEEP] = {
        name = "Sleep",
        duration = {min = 1, max = 3}, -- 1-3 turns
        preventsAction = true,
        cureOnDamage = false,
        immunityAbilities = {Enums.AbilityId.INSOMNIA, Enums.AbilityId.VITAL_SPIRIT},
        terrainPrevention = {"ELECTRIC", "MISTY"}
    },
    [MoveEffectProcessor.StatusEffect.PARALYSIS] = {
        name = "Paralysis", 
        duration = -1, -- Permanent until cured
        speedReduction = 0.25, -- Speed reduced to 25%
        actionFailureChance = 0.25, -- 25% chance to fail action
        immunityTypes = {Enums.PokemonType.ELECTRIC},
        immunityAbilities = {Enums.AbilityId.LIMBER},
        cureConditions = {"natural_cure", "cheri_berry", "aromatherapy", "heal_bell"}
    },
    [MoveEffectProcessor.StatusEffect.BURN] = {
        name = "Burn",
        duration = -1, -- Permanent until cured
        damagePerTurn = 1/16, -- 1/16 of max HP per turn
        attackReduction = 0.5, -- Physical attack reduced to 50%
        immunityTypes = {Enums.PokemonType.FIRE},
        immunityAbilities = {Enums.AbilityId.WATER_VEIL},
        cureConditions = {"natural_cure", "rawst_berry", "aromatherapy", "heal_bell"}
    },
    [MoveEffectProcessor.StatusEffect.FREEZE] = {
        name = "Freeze",
        duration = -1, -- Until thawed (variable)
        preventsAction = true,
        thawChance = 0.2, -- 20% chance to thaw each turn
        immunityTypes = {Enums.PokemonType.ICE},
        immunityAbilities = {Enums.AbilityId.MAGMA_ARMOR},
        thawOnFireMove = true
    },
    [MoveEffectProcessor.StatusEffect.TOXIC] = {
        name = "Toxic",
        duration = -1, -- Permanent until cured
        damagePerTurn = "escalating", -- 1/16, 2/16, 3/16, etc.
        immunityTypes = {Enums.PokemonType.POISON, Enums.PokemonType.STEEL},
        immunityAbilities = {Enums.AbilityId.IMMUNITY, Enums.AbilityId.POISON_HEAL},
        cureConditions = {"natural_cure", "pecha_berry", "aromatherapy", "heal_bell"}
    }
}

-- Check if Pokemon is immune to status effect
-- @param pokemon: Target Pokemon
-- @param statusEffect: Status effect to check
-- @param battleState: Current battle state
-- @return: Boolean indicating immunity and reason
function MoveEffectProcessor.checkStatusImmunity(pokemon, statusEffect, battleState)
    if not pokemon or not statusEffect then
        return false, "Invalid parameters"
    end
    
    local effectData = STATUS_EFFECT_DATA[statusEffect]
    if not effectData then
        return false, "Unknown status effect"
    end
    
    -- Check type immunity
    if effectData.immunityTypes then
        for _, immuneType in ipairs(effectData.immunityTypes) do
            for _, pokemonType in ipairs(pokemon.types or {}) do
                if pokemonType == immuneType then
                    return true, effectData.name .. " immunity due to " .. Enums.PokemonType[immuneType] .. " type"
                end
            end
        end
    end
    
    -- Check ability immunity
    if effectData.immunityAbilities and pokemon.ability then
        for _, immuneAbility in ipairs(effectData.immunityAbilities) do
            if pokemon.ability == immuneAbility then
                return true, effectData.name .. " immunity due to ability"
            end
        end
    end
    
    -- Check terrain prevention
    if effectData.terrainPrevention and battleState and battleState.battleConditions and battleState.battleConditions.terrain then
        for _, preventingTerrain in ipairs(effectData.terrainPrevention) do
            if battleState.battleConditions.terrain == preventingTerrain then
                return true, effectData.name .. " prevented by " .. preventingTerrain .. " terrain"
            end
        end
    end
    
    return false, nil
end

-- Apply status effect to Pokemon
-- @param target: Target Pokemon
-- @param statusEffect: Status effect to apply
-- @param battleState: Current battle state
-- @param source: Source Pokemon (optional)
-- @return: Success status and result message
function MoveEffectProcessor.applyStatusEffect(target, statusEffect, battleState, source)
    if not target or not statusEffect then
        return false, "Invalid status effect parameters"
    end
    
    -- Check if Pokemon already has a status condition
    if target.status and target.status ~= MoveEffectProcessor.StatusEffect.NONE then
        return false, "Pokemon already has status condition: " .. (target.status or "unknown")
    end
    
    -- Check immunity
    local isImmune, immunityReason = MoveEffectProcessor.checkStatusImmunity(target, statusEffect, battleState)
    if isImmune then
        return false, immunityReason
    end
    
    -- Apply status effect
    target.status = statusEffect
    
    -- Set status-specific data
    local effectData = STATUS_EFFECT_DATA[statusEffect]
    if effectData then
        if statusEffect == MoveEffectProcessor.StatusEffect.SLEEP then
            -- Set sleep duration
            if effectData.duration.min and effectData.duration.max then
                target.sleepTurns = BattleRNG.random(effectData.duration.min, effectData.duration.max)
            end
        elseif statusEffect == MoveEffectProcessor.StatusEffect.TOXIC then
            -- Initialize toxic damage counter
            target.toxicTurns = 1
        end
    end
    
    return true, "Status effect " .. (effectData.name or "unknown") .. " applied successfully"
end

-- Apply stat stage modifications
-- @param target: Target Pokemon
-- @param statModifications: Table of stat modifications {stat = stage_change}
-- @param battleState: Current battle state
-- @param source: Source Pokemon (optional)
-- @return: Success status and applied modifications
function MoveEffectProcessor.applyStatModifications(target, statModifications, battleState, source)
    if not target or not statModifications then
        return false, "Invalid stat modification parameters"
    end
    
    if not target.statStages then
        target.statStages = {
            attack = 0,
            defense = 0,
            special_attack = 0,
            special_defense = 0,
            speed = 0,
            accuracy = 0,
            evasion = 0
        }
    end
    
    local appliedModifications = {}
    local totalChanges = 0
    
    for stat, stageChange in pairs(statModifications) do
        if target.statStages[stat] then
            local currentStage = target.statStages[stat]
            local newStage = math.max(-6, math.min(6, currentStage + stageChange))
            local actualChange = newStage - currentStage
            
            if actualChange ~= 0 then
                target.statStages[stat] = newStage
                appliedModifications[stat] = actualChange
                totalChanges = totalChanges + math.abs(actualChange)
            end
        end
    end
    
    if totalChanges > 0 then
        return true, appliedModifications
    else
        return false, "No stat changes applied"
    end
end

-- Process healing effects
-- @param target: Target Pokemon
-- @param healingAmount: Amount to heal (can be percentage or absolute)
-- @param healingType: Type of healing ("PERCENTAGE", "ABSOLUTE", "FULL")
-- @param battleState: Current battle state
-- @return: Success status and amount healed
function MoveEffectProcessor.processHealing(target, healingAmount, healingType, battleState)
    if not target or not target.hp or not target.maxHp then
        return false, "Invalid healing target"
    end
    
    if target.hp >= target.maxHp then
        return false, "Pokemon already at full HP"
    end
    
    local amountToHeal = 0
    
    if healingType == "PERCENTAGE" then
        amountToHeal = math.floor(target.maxHp * healingAmount)
    elseif healingType == "ABSOLUTE" then
        amountToHeal = healingAmount
    elseif healingType == "FULL" then
        amountToHeal = target.maxHp - target.hp
    else
        return false, "Unknown healing type: " .. tostring(healingType)
    end
    
    -- Ensure healing doesn't exceed max HP
    local previousHp = target.hp
    target.hp = math.min(target.maxHp, target.hp + amountToHeal)
    local actualHealing = target.hp - previousHp
    
    return true, actualHealing
end

-- Process damage over time effects
-- @param pokemon: Pokemon receiving damage
-- @param battleState: Current battle state
-- @return: Damage dealt and effect description
function MoveEffectProcessor.processDamageOverTime(pokemon, battleState)
    if not pokemon or not pokemon.status then
        return 0, nil
    end
    
    local statusEffect = pokemon.status
    local effectData = STATUS_EFFECT_DATA[statusEffect]
    
    if not effectData or not effectData.damagePerTurn then
        return 0, nil
    end
    
    local damage = 0
    local description = ""
    
    if statusEffect == MoveEffectProcessor.StatusEffect.POISON then
        damage = math.max(1, math.floor(pokemon.maxHp * effectData.damagePerTurn))
        description = pokemon.species .. " is hurt by poison!"
        
    elseif statusEffect == MoveEffectProcessor.StatusEffect.BURN then
        damage = math.max(1, math.floor(pokemon.maxHp * effectData.damagePerTurn))
        description = pokemon.species .. " is hurt by burn!"
        
    elseif statusEffect == MoveEffectProcessor.StatusEffect.TOXIC then
        local toxicTurns = pokemon.toxicTurns or 1
        damage = math.max(1, math.floor(pokemon.maxHp * (toxicTurns / 16)))
        pokemon.toxicTurns = toxicTurns + 1
        description = pokemon.species .. " is badly poisoned!"
    end
    
    -- Apply damage
    if damage > 0 then
        pokemon.hp = math.max(0, pokemon.hp - damage)
    end
    
    return damage, description
end

-- Check if Pokemon can perform action (status condition check)
-- @param pokemon: Pokemon to check
-- @param actionType: Type of action ("MOVE", "SWITCH", "ITEM")
-- @return: Boolean indicating if action is allowed and reason if blocked
function MoveEffectProcessor.checkActionAllowed(pokemon, actionType)
    if not pokemon or not pokemon.status then
        return true, nil
    end
    
    local statusEffect = pokemon.status
    local effectData = STATUS_EFFECT_DATA[statusEffect]
    
    if not effectData then
        return true, nil
    end
    
    -- Check if status prevents action
    if effectData.preventsAction then
        if statusEffect == MoveEffectProcessor.StatusEffect.SLEEP then
            -- Check if Pokemon wakes up
            if pokemon.sleepTurns and pokemon.sleepTurns > 0 then
                pokemon.sleepTurns = pokemon.sleepTurns - 1
                if pokemon.sleepTurns <= 0 then
                    pokemon.status = MoveEffectProcessor.StatusEffect.NONE
                    return true, pokemon.species .. " woke up!"
                else
                    return false, pokemon.species .. " is fast asleep!"
                end
            end
        elseif statusEffect == MoveEffectProcessor.StatusEffect.FREEZE then
            -- Check if Pokemon thaws
            if BattleRNG.randomFloat() < effectData.thawChance then
                pokemon.status = MoveEffectProcessor.StatusEffect.NONE
                return true, pokemon.species .. " thawed out!"
            else
                return false, pokemon.species .. " is frozen solid!"
            end
        end
    end
    
    -- Check paralysis action failure
    if statusEffect == MoveEffectProcessor.StatusEffect.PARALYSIS and actionType == "MOVE" then
        if BattleRNG.randomFloat() < effectData.actionFailureChance then
            return false, pokemon.species .. " is paralyzed! It can't move!"
        end
    end
    
    return true, nil
end

-- Process move effect based on move data
-- @param moveData: Move data with effect information
-- @param attacker: Pokemon using the move
-- @param target: Pokemon receiving the effect
-- @param battleState: Current battle state
-- @return: Effect processing result
function MoveEffectProcessor.processMoveEffect(moveData, attacker, target, battleState)
    if not moveData or not moveData.effect then
        return {success = false, message = "No move effect to process"}
    end
    
    local result = {
        success = true,
        effects_applied = {},
        messages = {}
    }
    
    local effect = moveData.effect
    
    -- Process status effect application
    if effect.statusEffect and effect.statusEffect ~= MoveEffectProcessor.StatusEffect.NONE then
        -- Check effect chance
        local effectChance = effect.chance or 100
        if BattleRNG.randomFloat() * 100 < effectChance then
            local success, message = MoveEffectProcessor.applyStatusEffect(target, effect.statusEffect, battleState, attacker)
            table.insert(result.effects_applied, {
                type = "STATUS_EFFECT",
                target = target.id,
                effect = effect.statusEffect,
                success = success
            })
            table.insert(result.messages, message)
        end
    end
    
    -- Process stat modifications
    if effect.statChanges then
        local success, modifications = MoveEffectProcessor.applyStatModifications(target, effect.statChanges, battleState, attacker)
        table.insert(result.effects_applied, {
            type = "STAT_MODIFICATIONS",
            target = target.id,
            modifications = modifications,
            success = success
        })
        if success then
            for stat, change in pairs(modifications) do
                local direction = change > 0 and "rose" or "fell"
                local magnitude = math.abs(change) > 1 and " sharply" or ""
                table.insert(result.messages, target.species .. "'s " .. stat .. magnitude .. " " .. direction .. "!")
            end
        end
    end
    
    -- Process healing effects
    if effect.healing then
        local healingType = effect.healing.type or "PERCENTAGE"
        local healingAmount = effect.healing.amount or 0.5
        local success, amountHealed = MoveEffectProcessor.processHealing(target, healingAmount, healingType, battleState)
        table.insert(result.effects_applied, {
            type = "HEALING",
            target = target.id,
            amount_healed = amountHealed,
            success = success
        })
        if success then
            table.insert(result.messages, target.species .. " recovered " .. amountHealed .. " HP!")
        end
    end
    
    return result
end

-- Cure status condition
-- @param pokemon: Pokemon to cure
-- @param cureType: Type of cure ("ALL", specific status effect, or ability)
-- @return: Success status and cure description
function MoveEffectProcessor.cureStatusCondition(pokemon, cureType)
    if not pokemon or not pokemon.status or pokemon.status == MoveEffectProcessor.StatusEffect.NONE then
        return false, "No status condition to cure"
    end
    
    local curedStatus = pokemon.status
    local statusName = STATUS_EFFECT_DATA[curedStatus] and STATUS_EFFECT_DATA[curedStatus].name or "unknown"
    
    -- Clear status and related data
    pokemon.status = MoveEffectProcessor.StatusEffect.NONE
    pokemon.sleepTurns = nil
    pokemon.toxicTurns = nil
    
    return true, pokemon.species .. " was cured of " .. statusName .. "!"
end


-- ===== END MODULE: battle.components.move-effect-processor =====


-- ===== MODULE: battle.components.battle-state-manager =====
-- File: ao-processes/battle/components/battle-state-manager.lua
-- Original require: local BattleStateManager = require("battle.components.battle-state-manager")


-- ===== END MODULE: battle.components.battle-state-manager =====


-- Load inter-process communication components
-- SHARED MODULE REFERENCE: game-logic.process-coordination.message-correlator (already included)
-- SHARED MODULE REFERENCE: game-logic.process-coordination.process-authenticator (already included)

-- Timeout and retry configuration
local TIMEOUT_CONFIG = {
    DEFAULT_TIMEOUT = 30, -- seconds
    COORDINATOR_TIMEOUT = 15, -- seconds
    POKEMON_PROCESS_TIMEOUT = 10, -- seconds
    RNG_TIMEOUT = 5, -- seconds
    MAX_RETRIES = 3,
    RETRY_BACKOFF_BASE = 2 -- exponential backoff multiplier
}

-- Load validation

-- ===== MODULE: handlers.validation-handler =====
-- File: ao-processes/handlers/validation-handler.lua
-- Original require: local ValidationHandler = require("handlers.validation-handler")

-- validation-handler.lua: Game Action Validation Framework
-- Validates game actions, moves, stats, and battle operations

local ValidationHandler = {}

-- Constants
local VALIDATION_ERRORS = {
    INVALID_MOVE = "VAL_001",
    ILLEGAL_STAT = "VAL_002", 
    BATTLE_ACTION_DENIED = "VAL_003",
    INVALID_POKEMON_DATA = "VAL_004",
    MOVE_LEARNING_VIOLATION = "VAL_005",
    BATTLE_TIMING_ERROR = "VAL_006",
    INVALID_ACTION_TYPE = "VAL_007"
}

-- Game constants (normally loaded from data files)
local GAME_CONSTANTS = {
    MAX_POKEMON_LEVEL = 100,
    MIN_POKEMON_LEVEL = 1,
    MAX_STAT_VALUE = 999,
    MIN_STAT_VALUE = 1,
    MAX_IV_VALUE = 31,
    MIN_IV_VALUE = 0,
    MAX_MOVES_PER_POKEMON = 4,
    NATURE_MULTIPLIERS = {0.9, 1.0, 1.1}
}

-- Validate Pokemon stat values against game rules
function ValidationHandler.validatePokemonStats(pokemonData)
    if not pokemonData then
        error({
            code = VALIDATION_ERRORS.INVALID_POKEMON_DATA,
            message = "Pokemon data is required",
            success = false
        })
    end
    
    -- Level validation
    local level = pokemonData.level
    if not level or level < GAME_CONSTANTS.MIN_POKEMON_LEVEL or level > GAME_CONSTANTS.MAX_POKEMON_LEVEL then
        error({
            code = VALIDATION_ERRORS.ILLEGAL_STAT,
            message = string.format("Invalid Pokemon level: %s (must be %d-%d)", 
                tostring(level), GAME_CONSTANTS.MIN_POKEMON_LEVEL, GAME_CONSTANTS.MAX_POKEMON_LEVEL),
            success = false
        })
    end
    
    -- Stat validation
    local stats = pokemonData.stats or {}
    local statNames = {"hp", "attack", "defense", "spAttack", "spDefense", "speed"}
    
    for _, statName in ipairs(statNames) do
        local statValue = stats[statName]
        if statValue and (statValue < GAME_CONSTANTS.MIN_STAT_VALUE or statValue > GAME_CONSTANTS.MAX_STAT_VALUE) then
            error({
                code = VALIDATION_ERRORS.ILLEGAL_STAT,
                message = string.format("Invalid %s stat: %d (must be %d-%d)", 
                    statName, statValue, GAME_CONSTANTS.MIN_STAT_VALUE, GAME_CONSTANTS.MAX_STAT_VALUE),
                success = false
            })
        end
    end
    
    -- IV validation
    local ivs = pokemonData.ivs or {}
    for _, statName in ipairs(statNames) do
        local ivValue = ivs[statName]
        if ivValue and (ivValue < GAME_CONSTANTS.MIN_IV_VALUE or ivValue > GAME_CONSTANTS.MAX_IV_VALUE) then
            error({
                code = VALIDATION_ERRORS.ILLEGAL_STAT,
                message = string.format("Invalid %s IV: %d (must be %d-%d)", 
                    statName, ivValue, GAME_CONSTANTS.MIN_IV_VALUE, GAME_CONSTANTS.MAX_IV_VALUE),
                success = false
            })
        end
    end
    
    return true
end

-- Validate move against Pokemon's legal moveset
function ValidationHandler.validatePokemonMove(pokemonSpeciesId, moveId, pokemonLevel, learnedMoves)
    if not pokemonSpeciesId or not moveId then
        error({
            code = VALIDATION_ERRORS.INVALID_MOVE,
            message = "Pokemon species and move ID required for validation",
            success = false
        })
    end
    
    -- Check if move is in learned moves list (simplified validation)
    if learnedMoves then
        local moveFound = false
        for _, learnedMove in ipairs(learnedMoves) do
            if learnedMove.id == moveId then
                moveFound = true
                break
            end
        end
        
        if not moveFound then
            error({
                code = VALIDATION_ERRORS.MOVE_LEARNING_VIOLATION,
                message = string.format("Pokemon species %s cannot learn move %s", pokemonSpeciesId, moveId),
                success = false
            })
        end
    end
    
    return true
end

-- Validate Pokemon moveset (max 4 moves, all legal)
function ValidationHandler.validatePokemonMoveset(pokemonData, moveDatabase)
    if not pokemonData or not pokemonData.moves then
        return true -- No moves to validate
    end
    
    local moves = pokemonData.moves
    
    -- Check move count
    if #moves > GAME_CONSTANTS.MAX_MOVES_PER_POKEMON then
        error({
            code = VALIDATION_ERRORS.INVALID_MOVE,
            message = string.format("Pokemon can have maximum %d moves, got %d", 
                GAME_CONSTANTS.MAX_MOVES_PER_POKEMON, #moves),
            success = false
        })
    end
    
    -- Validate each move
    local learnedMoves = moveDatabase and moveDatabase[pokemonData.speciesId]
    for _, move in ipairs(moves) do
        ValidationHandler.validatePokemonMove(pokemonData.speciesId, move.id, pokemonData.level, learnedMoves)
    end
    
    return true
end

-- Validate battle action timing and legality
function ValidationHandler.validateBattleAction(action, battleState, pokemonData)
    if not action or not action.type then
        error({
            code = VALIDATION_ERRORS.INVALID_ACTION_TYPE,
            message = "Battle action must have a type",
            success = false
        })
    end
    
    local actionType = action.type
    local validActions = {"move", "switch", "item", "run"}
    local isValidType = false
    
    for _, validType in ipairs(validActions) do
        if actionType == validType then
            isValidType = true
            break
        end
    end
    
    if not isValidType then
        error({
            code = VALIDATION_ERRORS.INVALID_ACTION_TYPE,
            message = string.format("Invalid battle action type: %s", actionType),
            success = false
        })
    end
    
    -- Validate move action
    if actionType == "move" then
        if not action.moveId then
            error({
                code = VALIDATION_ERRORS.INVALID_MOVE,
                message = "Move action requires moveId",
                success = false
            })
        end
        
        -- Check if Pokemon knows the move
        if pokemonData and pokemonData.moves then
            local moveFound = false
            for _, move in ipairs(pokemonData.moves) do
                if move.id == action.moveId then
                    moveFound = true
                    break
                end
            end
            
            if not moveFound then
                error({
                    code = VALIDATION_ERRORS.INVALID_MOVE,
                    message = string.format("Pokemon does not know move %s", action.moveId),
                    success = false
                })
            end
        end
    end
    
    -- Validate switch action
    if actionType == "switch" then
        if not action.pokemonIndex then
            error({
                code = VALIDATION_ERRORS.BATTLE_ACTION_DENIED,
                message = "Switch action requires pokemonIndex",
                success = false
            })
        end
    end
    
    return true
end

-- Validate battle turn timing
function ValidationHandler.validateBattleTiming(battleState, playerId, actionTimestamp)
    if not battleState then
        error({
            code = VALIDATION_ERRORS.BATTLE_TIMING_ERROR,
            message = "Battle state required for timing validation",
            success = false
        })
    end
    
    -- Check if it's player's turn
    if battleState.currentTurn and battleState.currentTurn ~= playerId then
        error({
            code = VALIDATION_ERRORS.BATTLE_TIMING_ERROR,
            message = "Action submitted out of turn",
            success = false
        })
    end
    
    -- Check turn timeout (simplified - would use actual timestamps in production)
    if actionTimestamp and battleState.turnStartTime then
        local turnDuration = actionTimestamp - battleState.turnStartTime
        local maxTurnTime = 30 -- 30 seconds max per turn
        
        if turnDuration > maxTurnTime then
            error({
                code = VALIDATION_ERRORS.BATTLE_TIMING_ERROR,
                message = "Turn action timeout exceeded",
                success = false
            })
        end
    end
    
    return true
end

-- Comprehensive validation for battle actions
function ValidationHandler.validateCompleteAction(actionData, battleState, playerPokemon, moveDatabase)
    local success, result = pcall(function()
        -- Validate action structure
        ValidationHandler.validateBattleAction(actionData.action, battleState, playerPokemon)
        
        -- Validate timing
        ValidationHandler.validateBattleTiming(battleState, actionData.playerId, actionData.timestamp)
        
        -- Validate Pokemon data if present
        if playerPokemon then
            ValidationHandler.validatePokemonStats(playerPokemon)
            ValidationHandler.validatePokemonMoveset(playerPokemon, moveDatabase)
        end
        
        return {
            success = true,
            validatedAction = actionData.action,
            playerId = actionData.playerId
        }
    end)
    
    if not success then
        return {
            success = false,
            error = result
        }
    end
    
    return result
end

-- Get validation error information
function ValidationHandler.getErrorInfo(errorCode)
    local errorMessages = {
        [VALIDATION_ERRORS.INVALID_MOVE] = "Move validation failed",
        [VALIDATION_ERRORS.ILLEGAL_STAT] = "Pokemon stat validation failed", 
        [VALIDATION_ERRORS.BATTLE_ACTION_DENIED] = "Battle action not permitted",
        [VALIDATION_ERRORS.INVALID_POKEMON_DATA] = "Pokemon data validation failed",
        [VALIDATION_ERRORS.MOVE_LEARNING_VIOLATION] = "Pokemon cannot learn specified move",
        [VALIDATION_ERRORS.BATTLE_TIMING_ERROR] = "Battle timing validation failed",
        [VALIDATION_ERRORS.INVALID_ACTION_TYPE] = "Invalid battle action type"
    }
    
    return {
        code = errorCode,
        message = errorMessages[errorCode] or "Unknown validation error",
        category = "VALIDATION"
    }
end


-- ===== END MODULE: handlers.validation-handler =====


-- ===== MODULE: handlers.error-handler =====
-- File: ao-processes/handlers/error-handler.lua
-- Original require: local ErrorHandler = require("handlers.error-handler")

-- Error Handling Framework
-- Provides comprehensive error handling, logging, and response formatting

local ErrorHandler = {}

-- Import required modules
-- SHARED MODULE REFERENCE: game-logic.rng.crypto-rng (already included)

-- JSON module (optional for testing environments)
local json = nil
local success, module = pcall(require, "json")
if success then
    json = module
else
    -- Fallback JSON implementation for testing
    json = {
        encode = function(obj)
            if type(obj) == "table" then
                return "{}"
            elseif type(obj) == "string" then
                return '"' .. obj .. '"'
            else
                return tostring(obj)
            end
        end,
        decode = function(str)
            return {}
        end
    }
end

-- Error Type Constants
ErrorHandler.ERROR_TYPES = {
    VALIDATION = "VALIDATION_ERROR",
    HANDLER = "HANDLER_ERROR",
    SYSTEM = "SYSTEM_ERROR", 
    NOT_FOUND = "NOT_FOUND_ERROR",
    AUTHENTICATION = "AUTHENTICATION_ERROR",
    RATE_LIMIT = "RATE_LIMIT_ERROR",
    TIMEOUT = "TIMEOUT_ERROR",
    DATA_CORRUPTION = "DATA_CORRUPTION_ERROR"
}

-- Error Severity Levels
ErrorHandler.SEVERITY_LEVELS = {
    LOW = "low",
    MEDIUM = "medium",
    HIGH = "high",
    CRITICAL = "critical"
}

-- Error Code Registry
ErrorHandler.ERROR_CODES = {
    -- Validation Errors (1000-1999)
    MISSING_REQUIRED_TAG = 1001,
    INVALID_TAG_VALUE = 1002,
    MISSING_REQUIRED_DATA = 1003,
    INVALID_DATA_FORMAT = 1004,
    SCHEMA_VALIDATION_FAILED = 1005,
    
    -- Handler Errors (2000-2999)
    HANDLER_NOT_FOUND = 2001,
    HANDLER_EXECUTION_FAILED = 2002,
    HANDLER_TIMEOUT = 2003,
    HANDLER_INITIALIZATION_FAILED = 2004,
    
    -- System Errors (3000-3999)
    PROCESS_STARTUP_FAILED = 3001,
    MEMORY_ALLOCATION_FAILED = 3002,
    RESOURCE_UNAVAILABLE = 3003,
    INTERNAL_STATE_ERROR = 3004,
    
    -- Authentication Errors (4000-4999)
    INVALID_SENDER = 4001,
    INSUFFICIENT_PERMISSIONS = 4002,
    AUTHENTICATION_REQUIRED = 4003,
    TOKEN_EXPIRED = 4004,
    
    -- Rate Limit Errors (5000-5999)
    REQUEST_RATE_EXCEEDED = 5001,
    CONCURRENT_LIMIT_EXCEEDED = 5002,
    DAILY_QUOTA_EXCEEDED = 5003
}

-- Initialize error tracking
ErrorHandler.errorStats = {
    total_errors = 0,
    errors_by_type = {},
    errors_by_handler = {},
    last_error_time = 0
}

-- Create structured error object
function ErrorHandler.createError(errorType, errorCode, message, details)
    local error = {
        type = errorType,
        code = errorCode,
        message = message,
        details = details or {},
        timestamp = os.time(),
        correlation_id = ErrorHandler.generateCorrelationId(),
        severity = ErrorHandler.getSeverityForErrorType(errorType)
    }
    
    -- Update error statistics
    ErrorHandler.trackError(error)
    
    return error
end

-- Generate unique correlation ID for error tracking
function ErrorHandler.generateCorrelationId()
    local timestamp = os.time() * 1000 + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(10000, 99999)
    return "err_" .. timestamp .. "_" .. randomSuffix
end

-- Get severity level based on error type
function ErrorHandler.getSeverityForErrorType(errorType)
    local severityMap = {
        [ErrorHandler.ERROR_TYPES.VALIDATION] = ErrorHandler.SEVERITY_LEVELS.LOW,
        [ErrorHandler.ERROR_TYPES.HANDLER] = ErrorHandler.SEVERITY_LEVELS.MEDIUM,
        [ErrorHandler.ERROR_TYPES.SYSTEM] = ErrorHandler.SEVERITY_LEVELS.HIGH,
        [ErrorHandler.ERROR_TYPES.NOT_FOUND] = ErrorHandler.SEVERITY_LEVELS.LOW,
        [ErrorHandler.ERROR_TYPES.AUTHENTICATION] = ErrorHandler.SEVERITY_LEVELS.MEDIUM,
        [ErrorHandler.ERROR_TYPES.RATE_LIMIT] = ErrorHandler.SEVERITY_LEVELS.LOW,
        [ErrorHandler.ERROR_TYPES.TIMEOUT] = ErrorHandler.SEVERITY_LEVELS.MEDIUM,
        [ErrorHandler.ERROR_TYPES.DATA_CORRUPTION] = ErrorHandler.SEVERITY_LEVELS.CRITICAL
    }
    
    return severityMap[errorType] or ErrorHandler.SEVERITY_LEVELS.MEDIUM
end

-- Track error statistics
function ErrorHandler.trackError(error)
    ErrorHandler.errorStats.total_errors = ErrorHandler.errorStats.total_errors + 1
    ErrorHandler.errorStats.last_error_time = error.timestamp
    
    -- Track by type
    if not ErrorHandler.errorStats.errors_by_type[error.type] then
        ErrorHandler.errorStats.errors_by_type[error.type] = 0
    end
    ErrorHandler.errorStats.errors_by_type[error.type] = ErrorHandler.errorStats.errors_by_type[error.type] + 1
end

-- Send standardized error response to AO message
function ErrorHandler.sendErrorResponse(msg, error)
    if not msg or not msg.reply then
        return false
    end
    
    local responseData = {
        error = {
            type = error.type,
            code = error.code,
            message = error.message,
            correlation_id = error.correlation_id,
            timestamp = os.date("%Y-%m-%d %H:%M:%S", error.timestamp),
            severity = error.severity
        }
    }
    
    -- Add details if present
    if error.details and next(error.details) then
        responseData.error.details = error.details
    end
    
    msg.reply({
        Target = msg.From,
        Tags = {
            Action = "Error-Response",
            Success = "false",
            ["Error-Type"] = error.type,
            ["Error-Code"] = tostring(error.code),
            ["Correlation-ID"] = error.correlation_id,
            ["Severity"] = error.severity
        },
        Data = json.encode(responseData)
    })
    
    return true
end

-- Wrap handler execution with error handling
function ErrorHandler.wrapHandler(handlerName, handlerFunction)
    return function(msg)
        local success, result = pcall(handlerFunction, msg)
        
        if not success then
            -- Create error object from the caught error
            local error = ErrorHandler.createError(
                ErrorHandler.ERROR_TYPES.HANDLER,
                ErrorHandler.ERROR_CODES.HANDLER_EXECUTION_FAILED,
                "Handler execution failed: " .. tostring(result),
                {
                    handler_name = handlerName,
                    message_from = msg.From,
                    message_tags = msg.Tags
                }
            )
            
            -- Track handler-specific errors
            if not ErrorHandler.errorStats.errors_by_handler[handlerName] then
                ErrorHandler.errorStats.errors_by_handler[handlerName] = 0
            end
            ErrorHandler.errorStats.errors_by_handler[handlerName] = 
                ErrorHandler.errorStats.errors_by_handler[handlerName] + 1
                
            -- Send error response
            ErrorHandler.sendErrorResponse(msg, error)
            
            -- Log error for debugging
            ErrorHandler.logError(error)
            
            return false
        end
        
        return result
    end
end

-- Log error for debugging and monitoring
function ErrorHandler.logError(error)
    local logMessage = string.format(
        "[ERROR] [%s] [%s] %s (Code: %d, Correlation: %s)",
        os.date("%Y-%m-%d %H:%M:%S", error.timestamp),
        error.severity:upper(),
        error.message,
        error.code,
        error.correlation_id
    )
    
    -- Print to console (in production, this would go to proper logging system)
    print(logMessage)
    
    -- Add details if present
    if error.details and next(error.details) then
        for key, value in pairs(error.details) do
            print("  " .. key .. ": " .. tostring(value))
        end
    end
end

-- Validate message format and return structured error if invalid
function ErrorHandler.validateMessage(msg, requiredTags, optionalTags)
    local errors = {}
    
    -- Check if message has Tags
    if not msg.Tags then
        table.insert(errors, "Message missing Tags")
    else
        -- Check required tags
        if requiredTags then
            for _, tag in ipairs(requiredTags) do
                if not msg.Tags[tag] then
                    table.insert(errors, "Missing required tag: " .. tag)
                end
            end
        end
    end
    
    -- Check if sender is present
    if not msg.From then
        table.insert(errors, "Message missing From field")
    end
    
    if #errors > 0 then
        return ErrorHandler.createError(
            ErrorHandler.ERROR_TYPES.VALIDATION,
            ErrorHandler.ERROR_CODES.MISSING_REQUIRED_TAG,
            "Message validation failed",
            { validation_errors = errors }
        )
    end
    
    return nil -- No errors
end

-- Get error statistics for monitoring
function ErrorHandler.getErrorStats()
    return {
        total_errors = ErrorHandler.errorStats.total_errors,
        errors_by_type = ErrorHandler.errorStats.errors_by_type,
        errors_by_handler = ErrorHandler.errorStats.errors_by_handler,
        last_error_time = ErrorHandler.errorStats.last_error_time > 0 and 
            os.date("%Y-%m-%d %H:%M:%S", ErrorHandler.errorStats.last_error_time) or "None"
    }
end

-- Reset error statistics (for testing or maintenance)
function ErrorHandler.resetErrorStats()
    ErrorHandler.errorStats = {
        total_errors = 0,
        errors_by_type = {},
        errors_by_handler = {},
        last_error_time = 0
    }
end

-- Create error response for AO messages (commonly used function)
function ErrorHandler.createErrorResponse(errorCode, message, messageId)
    return {
        success = false,
        error = {
            code = errorCode,
            message = message,
            messageId = messageId,
            timestamp = os.time()
        }
    }
end

-- Health check for error handling system
function ErrorHandler.healthCheck()
    local stats = ErrorHandler.getErrorStats()
    local health = {
        status = "healthy",
        error_rate = stats.total_errors,
        high_severity_errors = 0,
        critical_errors = 0
    }
    
    -- Count high severity and critical errors
    for errorType, count in pairs(stats.errors_by_type) do
        local severity = ErrorHandler.getSeverityForErrorType(errorType)
        if severity == ErrorHandler.SEVERITY_LEVELS.HIGH then
            health.high_severity_errors = health.high_severity_errors + count
        elseif severity == ErrorHandler.SEVERITY_LEVELS.CRITICAL then
            health.critical_errors = health.critical_errors + count
        end
    end
    
    -- Determine overall health status
    if health.critical_errors > 0 then
        health.status = "critical"
    elseif health.high_severity_errors > 5 then
        health.status = "degraded"
    elseif stats.total_errors > 100 then
        health.status = "warning"
    end
    
    return health
end


-- ===== END MODULE: handlers.error-handler =====


-- Command types
BattleCommandHandler.CommandType = {
    INITIALIZE_BATTLE = "INITIALIZE_BATTLE",
    PROCESS_BATTLE_TURN = "PROCESS_BATTLE_TURN",
    BATTLE_COMMAND = "BATTLE_COMMAND",
    END_BATTLE = "END_BATTLE"
}

-- Battle command validation schemas
local COMMAND_SCHEMAS = {
    INITIALIZE_BATTLE = {
        required = {"battleId", "battleParams"},
        optional = {"coordinatorId", "correlation"}
    },
    PROCESS_BATTLE_TURN = {
        required = {"battleId", "turnCommands"},
        optional = {"correlation"}
    },
    BATTLE_COMMAND = {
        required = {"battleId", "playerId", "command"},
        optional = {"correlation"}
    }
}

-- Timeout wrapper for inter-process operations
-- @param operation: Function to execute with timeout
-- @param timeoutSeconds: Timeout in seconds
-- @param operationName: Name for logging
-- @return: success, result, error
function BattleCommandHandler.withTimeout(operation, timeoutSeconds, operationName)
    local startTime = msg.Timestamp
    local success, result = pcall(operation)
    local elapsed = 0 - startTime
    
    if elapsed > timeoutSeconds then
        return false, nil, "Operation '" .. (operationName or "unknown") .. "' timed out after " .. elapsed .. " seconds"
    end
    
    if not success then
        return false, nil, "Operation '" .. (operationName or "unknown") .. "' failed: " .. (result or "unknown error")
    end
    
    return true, result, nil
end

-- Retry wrapper with exponential backoff
-- @param operation: Function to retry
-- @param maxRetries: Maximum retry attempts
-- @param operationName: Name for logging
-- @return: success, result, error
function BattleCommandHandler.withRetry(operation, maxRetries, operationName)
    local attempts = 0
    maxRetries = maxRetries or TIMEOUT_CONFIG.MAX_RETRIES
    
    while attempts < maxRetries do
        attempts = attempts + 1
        local success, result = pcall(operation)
        
        if success then
            return true, result, nil
        end
        
        -- Calculate backoff delay
        if attempts < maxRetries then
            local backoffDelay = math.floor(TIMEOUT_CONFIG.RETRY_BACKOFF_BASE ^ attempts)
            -- In real AO environment, we would use proper delay mechanism
            -- For now, we log the backoff attempt
            print("Retry attempt " .. attempts .. " for " .. (operationName or "operation") .. 
                  " in " .. backoffDelay .. " seconds")
        end
    end
    
    return false, nil, "Operation '" .. (operationName or "unknown") .. 
           "' failed after " .. attempts .. " attempts"
end

-- Enhanced inter-process communication with error handling
-- @param processId: Target process ID
-- @param message: Message to send
-- @param timeout: Timeout in seconds
-- @param retries: Number of retries
-- @return: success, response, error
function BattleCommandHandler.sendInterProcessMessage(processId, message, timeout, retries)
    timeout = timeout or TIMEOUT_CONFIG.DEFAULT_TIMEOUT
    retries = retries or TIMEOUT_CONFIG.MAX_RETRIES
    
    local operation = function()
        -- Create correlation ID for tracking
        local correlationId = MessageCorrelator.generateCorrelationId()
        message.correlation = message.correlation or {}
        message.correlation.id = correlationId
        
        -- Send message with timeout
        local success, response = BattleCommandHandler.withTimeout(
            function() 
                return ao.send({
                    Target = processId,
                    Action = message.action,
                    Data = json.encode(message),
                    ["X-Correlation-Id"] = correlationId
                })
            end,
            timeout,
            "inter-process-send-" .. processId
        )
        
        if not success then
            return false, nil, response
        end
        
        return true, response, nil
    end
    
    return BattleCommandHandler.withRetry(operation, retries, "inter-process-communication")
end

-- Graceful degradation for process failures
-- @param processType: Type of process (coordinator, pokemon, rng)
-- @param operation: Primary operation to attempt
-- @param fallbackOperation: Fallback operation if primary fails
-- @return: success, result, error, usedFallback
function BattleCommandHandler.withGracefulDegradation(processType, operation, fallbackOperation)
    local success, result, error = pcall(operation)
    
    if success then
        return true, result, nil, false
    end
    
    -- Log primary failure
    print("Primary operation failed for " .. processType .. ": " .. (error or "unknown error"))
    
    -- Attempt fallback if provided
    if fallbackOperation then
        local fallbackSuccess, fallbackResult, fallbackError = pcall(fallbackOperation)
        if fallbackSuccess then
            print("Fallback operation succeeded for " .. processType)
            return true, fallbackResult, nil, true
        else
            return false, nil, "Primary and fallback operations failed. Primary: " .. 
                   (error or "unknown") .. ". Fallback: " .. (fallbackError or "unknown"), true
        end
    end
    
    return false, nil, error, false
end

-- Process battle command message
-- @param msg: AO message with battle command data
-- @return: JSON response string
function BattleCommandHandler.process(msg)
    local startTime = msg.Timestamp
    
    -- Parse message data
    local success, messageData = pcall(json.decode, msg.Data or "{}")
    if not success then
        return json.encode({
            success = false,
            error = "Invalid JSON in message data",
            timestamp = 0
        })
    end
    
    -- Extract correlation information
    local correlation = messageData.correlation or {}
    local correlationId = correlation.id
    
    -- Determine command type
    local action = msg.Tags and msg.Tags.Action
    if not action then
        return BattleCommandHandler.createErrorResponse(
            correlationId, 
            "Missing Action tag", 
            "INVALID_REQUEST"
        )
    end
    
    -- Validate command structure
    local schema = COMMAND_SCHEMAS[action]
    if not schema then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            "Unknown command type: " .. action,
            "UNKNOWN_COMMAND"
        )
    end
    
    local validationResult = BattleCommandHandler.validateCommandData(messageData, schema)
    if not validationResult.valid then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            validationResult.error,
            "VALIDATION_ERROR"
        )
    end
    
    -- Process based on command type
    local result
    if action == BattleCommandHandler.CommandType.INITIALIZE_BATTLE then
        result = BattleCommandHandler.processInitializeBattle(messageData, msg)
    elseif action == BattleCommandHandler.CommandType.PROCESS_BATTLE_TURN then
        result = BattleCommandHandler.processProcessBattleTurn(messageData, msg)
    elseif action == BattleCommandHandler.CommandType.BATTLE_COMMAND then
        result = BattleCommandHandler.processBattleCommand(messageData, msg)
    elseif action == BattleCommandHandler.CommandType.END_BATTLE then
        result = BattleCommandHandler.processEndBattle(messageData, msg)
    else
        result = BattleCommandHandler.createErrorResponse(
            correlationId,
            "Unhandled command type: " .. action,
            "UNHANDLED_COMMAND"
        )
    end
    
    -- Add processing metrics
    local processingTime = 0 - startTime
    if type(result) == "table" then
        local resultData = json.decode(result)
        resultData.processing_time = processingTime
        result = json.encode(resultData)
    end
    
    return result
end

-- Validate command data against schema
-- @param messageData: Parsed message data
-- @param schema: Validation schema
-- @return: Validation result
function BattleCommandHandler.validateCommandData(messageData, schema)
    -- Check required fields
    for _, field in ipairs(schema.required) do
        if not messageData[field] then
            return {
                valid = false,
                error = "Missing required field: " .. field
            }
        end
    end
    
    return {valid = true}
end

-- Process initialize battle command
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCommandHandler.processInitializeBattle(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    
    local battleId = messageData.battleId
    local battleParams = messageData.battleParams
    local coordinatorId = messageData.coordinatorId or msg.From
    
    -- Start concurrent battle with error handling and timeout
    local success, battleResult, error, usedFallback = BattleCommandHandler.withGracefulDegradation(
        "coordinator",
        function()
            return BattleCommandHandler.withTimeout(
                function() 
                    return ConcurrentBattleManager.startBattle(
                        battleId,
                        battleParams,
                        coordinatorId
                    )
                end,
                TIMEOUT_CONFIG.COORDINATOR_TIMEOUT,
                "initialize-battle"
            )
        end,
        function()
            -- Fallback: Initialize battle with minimal coordinator dependency
            return ConcurrentBattleManager.startBattleOffline(
                battleId,
                battleParams
            )
        end
    )
    
    if not success then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            "Failed to initialize battle: " .. (error or "Unknown error"),
            "INITIALIZATION_FAILED"
        )
    end
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "BATTLE_INITIALIZATION_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            resourcePoolId = battleResult.resourcePoolId,
            battleState = {
                status = battleResult.battleState.status,
                turn = battleResult.battleState.turn,
                phase = battleResult.battleState.phase
            }
        },
        timestamp = 0
    })
end

-- Process battle turn processing command
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCommandHandler.processProcessBattleTurn(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    
    local battleId = messageData.battleId
    local turnCommands = messageData.turnCommands or {}
    
    -- Process battle turn with error handling and retry
    local success, turnResult, error = BattleCommandHandler.withRetry(
        function()
            return BattleCommandHandler.withTimeout(
                function()
                    return ConcurrentBattleManager.processBattleTurn(
                        battleId,
                        turnCommands
                    )
                end,
                TIMEOUT_CONFIG.DEFAULT_TIMEOUT,
                "process-battle-turn"
            )
        end,
        TIMEOUT_CONFIG.MAX_RETRIES,
        "battle-turn-processing"
    )
    
    if not success then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            "Failed to process battle turn: " .. (error or "Unknown error"),
            "TURN_PROCESSING_FAILED"
        )
    end
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "BATTLE_TURN_RESULT"
        },
        result = turnResult,
        timestamp = 0
    })
end

-- Process individual battle command
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCommandHandler.processBattleCommand(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    
    local battleId = messageData.battleId
    local playerId = messageData.playerId
    local command = messageData.command
    
    -- Get battle instance
    local battleInstance = ConcurrentBattleManager.getBattleInstance(battleId)
    if not battleInstance then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            "Battle instance not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    -- Add command to battle turn
    local success, commandResult = TurnProcessor.addTurnCommand(
        battleInstance.battleState,
        playerId,
        command
    )
    
    if not success then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            "Failed to add battle command: " .. (commandResult or "Unknown error"),
            "COMMAND_FAILED"
        )
    end
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "BATTLE_COMMAND_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            playerId = playerId,
            commandResult = commandResult
        },
        timestamp = 0
    })
end

-- Process end battle command
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCommandHandler.processEndBattle(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    
    local battleId = messageData.battleId
    local battleResult = messageData.battleResult or {result = "MANUAL_END"}
    
    -- Get battle instance
    local battleInstance = ConcurrentBattleManager.getBattleInstance(battleId)
    if not battleInstance then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            "Battle instance not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    -- Complete battle
    local success = BattleStateManager.completeBattle(battleId, battleResult)
    if not success then
        return BattleCommandHandler.createErrorResponse(
            correlationId,
            "Failed to complete battle",
            "COMPLETION_FAILED"
        )
    end
    
    -- Cleanup battle instance
    ConcurrentBattleManager.cleanupBattle(battleId)
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "BATTLE_END_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            battleResult = battleResult
        },
        timestamp = 0
    })
end

-- Create standardized error response
-- @param correlationId: Correlation ID for response tracking
-- @param errorMessage: Human-readable error message
-- @param errorCode: Machine-readable error code
-- @return: JSON error response string
function BattleCommandHandler.createErrorResponse(correlationId, errorMessage, errorCode)
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "ERROR"
        },
        success = false,
        error = errorMessage,
        errorCode = errorCode,
        timestamp = 0
    })
end

-- Get handler statistics for monitoring
-- @return: Handler processing statistics
function BattleCommandHandler.getStatistics()
    return {
        commandsProcessed = 0, -- This would be tracked in production
        averageProcessingTime = 0,
        errorRate = 0,
        supportedCommands = {
            BattleCommandHandler.CommandType.INITIALIZE_BATTLE,
            BattleCommandHandler.CommandType.PROCESS_BATTLE_TURN,
            BattleCommandHandler.CommandType.BATTLE_COMMAND,
            BattleCommandHandler.CommandType.END_BATTLE
        }
    }
end


-- ===== END MODULE: battle.handlers.battle-command-handler =====


-- ===== MODULE: battle.handlers.battle-state-handler =====
-- File: ao-processes/battle/handlers/battle-state-handler.lua
-- Original require: local BattleStateHandler = require("battle.handlers.battle-state-handler")

-- Battle State Handler
-- Processes battle state queries and synchronization requests
-- Provides real-time battle state access for UI and agent decision making
-- Epic 32.3: Battle Engine Process Extraction

local BattleStateHandler = {}

-- Load dependencies

-- ===== MODULE: battle.components.battle-state-manager =====
-- File: ao-processes/battle/components/battle-state-manager.lua
-- Original require: local BattleStateManager = require("battle.components.battle-state-manager")


-- ===== END MODULE: battle.components.battle-state-manager =====


-- ===== MODULE: battle.components.concurrent-battle-manager =====
-- File: ao-processes/battle/components/concurrent-battle-manager.lua
-- Original require: local ConcurrentBattleManager = require("battle.components.concurrent-battle-manager")


-- ===== END MODULE: battle.components.concurrent-battle-manager =====


-- Load inter-process communication components
-- SHARED MODULE REFERENCE: game-logic.process-coordination.message-correlator (already included)
-- SHARED MODULE REFERENCE: game-logic.process-coordination.process-authenticator (already included)

-- Query types
BattleStateHandler.QueryType = {
    FULL_STATE = "FULL_STATE",
    BATTLE_STATUS = "BATTLE_STATUS",
    TURN_RESULT = "TURN_RESULT",
    AVAILABLE_ACTIONS = "AVAILABLE_ACTIONS",
    BATTLE_HISTORY = "BATTLE_HISTORY",
    POKEMON_STATE = "POKEMON_STATE",
    BATTLE_CONDITIONS = "BATTLE_CONDITIONS"
}

-- State access levels
BattleStateHandler.AccessLevel = {
    PUBLIC = "PUBLIC",
    PLAYER = "PLAYER",
    COORDINATOR = "COORDINATOR",
    ADMIN = "ADMIN"
}

-- Query validation schemas
local QUERY_SCHEMAS = {
    FULL_STATE = {
        required = {"battleId"},
        optional = {"accessLevel", "correlation"}
    },
    BATTLE_STATUS = {
        required = {"battleId"},
        optional = {"correlation"}
    },
    BATTLE_HISTORY = {
        required = {"battleId"},
        optional = {"limit", "correlation"}
    },
    POKEMON_STATE = {
        required = {"battleId", "pokemonId"},
        optional = {"playerId", "correlation"}
    }
}

-- Process battle state query message
-- @param msg: AO message with query data
-- @return: JSON response string
function BattleStateHandler.process(msg)
    local startTime = msg.Timestamp
    
    -- Parse message data
    local success, messageData = pcall(json.decode, msg.Data or "{}")
    if not success then
        return json.encode({
            success = false,
            error = "Invalid JSON in message data",
            timestamp = 0
        })
    end
    
    -- Extract query information
    local query = messageData.query or {}
    local correlationId = messageData.correlation and messageData.correlation.id
    
    -- Determine query type
    local queryType = query.queryType
    if not queryType then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Missing queryType in query data",
            "INVALID_QUERY"
        )
    end
    
    -- Validate query structure
    local schema = QUERY_SCHEMAS[queryType]
    if not schema then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Unknown query type: " .. queryType,
            "UNKNOWN_QUERY"
        )
    end
    
    local validationResult = BattleStateHandler.validateQueryData(query, schema)
    if not validationResult.valid then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            validationResult.error,
            "VALIDATION_ERROR"
        )
    end
    
    -- Determine access level
    local accessLevel = BattleStateHandler.determineAccessLevel(msg, query)
    
    -- Process based on query type
    local result
    if queryType == BattleStateHandler.QueryType.FULL_STATE then
        result = BattleStateHandler.processFullStateQuery(query, accessLevel, msg)
    elseif queryType == BattleStateHandler.QueryType.BATTLE_STATUS then
        result = BattleStateHandler.processBattleStatusQuery(query, accessLevel, msg)
    elseif queryType == BattleStateHandler.QueryType.BATTLE_HISTORY then
        result = BattleStateHandler.processBattleHistoryQuery(query, accessLevel, msg)
    elseif queryType == BattleStateHandler.QueryType.POKEMON_STATE then
        result = BattleStateHandler.processPokemonStateQuery(query, accessLevel, msg)
    elseif queryType == BattleStateHandler.QueryType.BATTLE_CONDITIONS then
        result = BattleStateHandler.processBattleConditionsQuery(query, accessLevel, msg)
    elseif queryType == BattleStateHandler.QueryType.AVAILABLE_ACTIONS then
        result = BattleStateHandler.processAvailableActionsQuery(query, accessLevel, msg)
    else
        result = BattleStateHandler.createErrorResponse(
            correlationId,
            "Unhandled query type: " .. queryType,
            "UNHANDLED_QUERY"
        )
    end
    
    -- Add processing metrics
    local processingTime = 0 - startTime
    if type(result) == "table" then
        local resultData = json.decode(result)
        resultData.processing_time = processingTime
        result = json.encode(resultData)
    end
    
    return result
end

-- Validate query data against schema
-- @param query: Query data
-- @param schema: Validation schema
-- @return: Validation result
function BattleStateHandler.validateQueryData(query, schema)
    -- Check required fields
    for _, field in ipairs(schema.required) do
        if not query[field] then
            return {
                valid = false,
                error = "Missing required field: " .. field
            }
        end
    end
    
    return {valid = true}
end

-- Determine access level based on message source and query data
-- @param msg: Original AO message
-- @param query: Query data
-- @return: Access level string
function BattleStateHandler.determineAccessLevel(msg, query)
    -- In production, this would check message authentication
    -- For now, default to PLAYER level
    return query.accessLevel or BattleStateHandler.AccessLevel.PLAYER
end

-- Process full state query
-- @param query: Query data
-- @param accessLevel: Access level for response filtering
-- @param msg: Original AO message
-- @return: JSON response string
function BattleStateHandler.processFullStateQuery(query, accessLevel, msg)
    local correlationId = query.correlation and query.correlation.id
    local battleId = query.battleId
    
    -- Get battle state
    local battleState = BattleStateManager.getBattleState(battleId)
    if not battleState then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Battle state not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    -- Filter state based on access level
    local filteredState = BattleStateHandler.filterBattleState(battleState, accessLevel)
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "FULL_STATE_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            battleState = filteredState,
            accessLevel = accessLevel
        },
        timestamp = 0
    })
end

-- Process battle status query
-- @param query: Query data
-- @param accessLevel: Access level
-- @param msg: Original AO message
-- @return: JSON response string
function BattleStateHandler.processBattleStatusQuery(query, accessLevel, msg)
    local correlationId = query.correlation and query.correlation.id
    local battleId = query.battleId
    
    -- Get battle instance
    local battleInstance = ConcurrentBattleManager.getBattleInstance(battleId)
    if not battleInstance then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Battle instance not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    local status = {
        battleId = battleId,
        status = battleInstance.status,
        turn = battleInstance.battleState.turn,
        phase = battleInstance.battleState.phase,
        lastProcessed = battleInstance.lastProcessed,
        resourcePoolId = battleInstance.resourcePoolId
    }
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "BATTLE_STATUS_RESULT"
        },
        result = {
            success = true,
            battleStatus = status
        },
        timestamp = 0
    })
end

-- Process battle history query
-- @param query: Query data
-- @param accessLevel: Access level
-- @param msg: Original AO message
-- @return: JSON response string
function BattleStateHandler.processBattleHistoryQuery(query, accessLevel, msg)
    local correlationId = query.correlation and query.correlation.id
    local battleId = query.battleId
    local limit = query.limit or 50
    
    -- Get battle history
    local history = BattleStateManager.getBattleHistory(battleId, limit)
    
    -- Filter history based on access level
    local filteredHistory = BattleStateHandler.filterBattleHistory(history, accessLevel)
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "BATTLE_HISTORY_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            history = filteredHistory,
            entryCount = #filteredHistory
        },
        timestamp = 0
    })
end

-- Process Pokemon state query
-- @param query: Query data
-- @param accessLevel: Access level
-- @param msg: Original AO message
-- @return: JSON response string
function BattleStateHandler.processPokemonStateQuery(query, accessLevel, msg)
    local correlationId = query.correlation and query.correlation.id
    local battleId = query.battleId
    local pokemonId = query.pokemonId
    
    -- Get battle state
    local battleState = BattleStateManager.getBattleState(battleId)
    if not battleState then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Battle state not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    -- Find Pokemon in battle
    local pokemon = nil
    for _, p in ipairs(battleState.playerParty) do
        if p.id == pokemonId then
            pokemon = p
            break
        end
    end
    
    if not pokemon then
        for _, p in ipairs(battleState.enemyParty) do
            if p.id == pokemonId then
                pokemon = p
                break
            end
        end
    end
    
    if not pokemon then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Pokemon not found: " .. pokemonId,
            "POKEMON_NOT_FOUND"
        )
    end
    
    -- Filter Pokemon data based on access level
    local filteredPokemon = BattleStateHandler.filterPokemonState(pokemon, accessLevel)
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "POKEMON_STATE_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            pokemonId = pokemonId,
            pokemonState = filteredPokemon
        },
        timestamp = 0
    })
end

-- Process battle conditions query
-- @param query: Query data
-- @param accessLevel: Access level
-- @param msg: Original AO message
-- @return: JSON response string
function BattleStateHandler.processBattleConditionsQuery(query, accessLevel, msg)
    local correlationId = query.correlation and query.correlation.id
    local battleId = query.battleId
    
    -- Get battle state
    local battleState = BattleStateManager.getBattleState(battleId)
    if not battleState then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Battle state not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "BATTLE_CONDITIONS_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            battleConditions = battleState.battleConditions
        },
        timestamp = 0
    })
end

-- Process available actions query
-- @param query: Query data
-- @param accessLevel: Access level
-- @param msg: Original AO message
-- @return: JSON response string
function BattleStateHandler.processAvailableActionsQuery(query, accessLevel, msg)
    local correlationId = query.correlation and query.correlation.id
    local battleId = query.battleId
    
    -- Get battle instance
    local battleInstance = ConcurrentBattleManager.getBattleInstance(battleId)
    if not battleInstance then
        return BattleStateHandler.createErrorResponse(
            correlationId,
            "Battle instance not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    -- Calculate available actions based on battle state
    local availableActions = BattleStateHandler.calculateAvailableActions(battleInstance.battleState)
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "AVAILABLE_ACTIONS_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            availableActions = availableActions
        },
        timestamp = 0
    })
end

-- Filter battle state based on access level
-- @param battleState: Full battle state
-- @param accessLevel: Access level for filtering
-- @return: Filtered battle state
function BattleStateHandler.filterBattleState(battleState, accessLevel)
    local filtered = {
        battleId = battleState.battleId,
        status = battleState.status,
        turn = battleState.turn,
        phase = battleState.phase,
        battleConditions = battleState.battleConditions
    }
    
    if accessLevel == BattleStateHandler.AccessLevel.PUBLIC then
        -- Minimal information for public access
        filtered.playerPartyCount = #battleState.playerParty
        filtered.enemyPartyCount = #battleState.enemyParty
        
    elseif accessLevel == BattleStateHandler.AccessLevel.PLAYER then
        -- Player can see their own Pokemon and limited enemy info
        filtered.playerParty = battleState.playerParty
        filtered.activePlayerPokemon = battleState.activePlayerPokemon
        filtered.activeEnemyPokemon = BattleStateHandler.filterEnemyPokemon(battleState.activeEnemyPokemon)
        
    elseif accessLevel == BattleStateHandler.AccessLevel.COORDINATOR or 
           accessLevel == BattleStateHandler.AccessLevel.ADMIN then
        -- Full access to all battle data
        filtered = battleState
    end
    
    return filtered
end

-- Filter enemy Pokemon data for player access
-- @param enemyPokemon: Enemy Pokemon array
-- @return: Filtered enemy Pokemon data
function BattleStateHandler.filterEnemyPokemon(enemyPokemon)
    local filtered = {}
    for _, pokemon in ipairs(enemyPokemon) do
        table.insert(filtered, {
            id = pokemon.id,
            species = pokemon.species,
            level = pokemon.level,
            hp = pokemon.hp,
            maxHp = pokemon.maxHp,
            status = pokemon.status,
            types = pokemon.types
            -- Hide detailed stats, moves, abilities, items
        })
    end
    return filtered
end

-- Filter battle history based on access level
-- @param history: Full battle history
-- @param accessLevel: Access level for filtering
-- @return: Filtered history
function BattleStateHandler.filterBattleHistory(history, accessLevel)
    if accessLevel == BattleStateHandler.AccessLevel.ADMIN or
       accessLevel == BattleStateHandler.AccessLevel.COORDINATOR then
        return history
    end
    
    -- Filter sensitive information for lower access levels
    local filtered = {}
    for _, entry in ipairs(history) do
        table.insert(filtered, {
            turn = entry.turn,
            timestamp = entry.timestamp,
            action = entry.action,
            stateSnapshot = {
                turn = entry.stateSnapshot.turn,
                phase = entry.stateSnapshot.phase,
                status = entry.stateSnapshot.status
            }
        })
    end
    
    return filtered
end

-- Filter Pokemon state based on access level
-- @param pokemon: Full Pokemon data
-- @param accessLevel: Access level for filtering
-- @return: Filtered Pokemon data
function BattleStateHandler.filterPokemonState(pokemon, accessLevel)
    if accessLevel == BattleStateHandler.AccessLevel.ADMIN or
       accessLevel == BattleStateHandler.AccessLevel.COORDINATOR then
        return pokemon
    end
    
    -- Basic Pokemon information for other access levels
    return {
        id = pokemon.id,
        species = pokemon.species,
        level = pokemon.level,
        hp = pokemon.hp,
        maxHp = pokemon.maxHp,
        status = pokemon.status,
        types = pokemon.types,
        statStages = pokemon.statStages
    }
end

-- Calculate available actions for current battle state
-- @param battleState: Current battle state
-- @return: Available actions data
function BattleStateHandler.calculateAvailableActions(battleState)
    if not battleState then
        return {}
    end
    
    local actions = {
        canFight = false,
        canSwitch = false,
        canUseItem = false,
        availableMoves = {},
        availableSwitch = {},
        availableItems = {}
    }
    
    -- Check if battle is in command selection phase
    if battleState.phase == "COMMAND_SELECTION" then
        actions.canFight = true
        actions.canSwitch = true
        actions.canUseItem = true
        
        -- Calculate available moves (simplified)
        for _, pokemon in ipairs(battleState.activePlayerPokemon) do
            if pokemon.moves then
                for _, move in ipairs(pokemon.moves) do
                    if move.pp > 0 then
                        table.insert(actions.availableMoves, {
                            moveId = move.id,
                            name = move.name,
                            pp = move.pp,
                            maxPp = move.maxPp
                        })
                    end
                end
            end
        end
        
        -- Calculate available Pokemon for switching
        for _, pokemon in ipairs(battleState.playerParty) do
            if pokemon.hp > 0 then
                local isActive = false
                for _, activePokemon in ipairs(battleState.activePlayerPokemon) do
                    if activePokemon.id == pokemon.id then
                        isActive = true
                        break
                    end
                end
                
                if not isActive then
                    table.insert(actions.availableSwitch, {
                        pokemonId = pokemon.id,
                        species = pokemon.species,
                        hp = pokemon.hp,
                        maxHp = pokemon.maxHp
                    })
                end
            end
        end
    end
    
    return actions
end

-- Create standardized error response
-- @param correlationId: Correlation ID for response tracking
-- @param errorMessage: Human-readable error message
-- @param errorCode: Machine-readable error code
-- @return: JSON error response string
function BattleStateHandler.createErrorResponse(correlationId, errorMessage, errorCode)
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "ERROR"
        },
        success = false,
        error = errorMessage,
        errorCode = errorCode,
        timestamp = 0
    })
end


-- ===== END MODULE: battle.handlers.battle-state-handler =====


-- ===== MODULE: battle.handlers.battle-coordination-handler =====
-- File: ao-processes/battle/handlers/battle-coordination-handler.lua
-- Original require: local BattleCoordinationHandler = require("battle.handlers.battle-coordination-handler")

-- Battle Coordination Handler
-- Manages inter-process communication with coordinator and other processes
-- Handles battle registration, synchronization, and coordination messages
-- Epic 32.3: Battle Engine Process Extraction

local BattleCoordinationHandler = {}

-- Load dependencies

-- ===== MODULE: battle.components.battle-state-manager =====
-- File: ao-processes/battle/components/battle-state-manager.lua
-- Original require: local BattleStateManager = require("battle.components.battle-state-manager")


-- ===== END MODULE: battle.components.battle-state-manager =====


-- ===== MODULE: battle.components.concurrent-battle-manager =====
-- File: ao-processes/battle/components/concurrent-battle-manager.lua
-- Original require: local ConcurrentBattleManager = require("battle.components.concurrent-battle-manager")


-- ===== END MODULE: battle.components.concurrent-battle-manager =====


-- Load inter-process communication components
-- SHARED MODULE REFERENCE: game-logic.process-coordination.message-correlator (already included)
-- SHARED MODULE REFERENCE: game-logic.process-coordination.process-authenticator (already included)
-- SHARED MODULE REFERENCE: game-logic.process-coordination.message-router (already included)

-- Timeout and retry configuration
local TIMEOUT_CONFIG = {
    DEFAULT_TIMEOUT = 30, -- seconds
    COORDINATOR_TIMEOUT = 15, -- seconds
    POKEMON_PROCESS_TIMEOUT = 10, -- seconds
    RNG_TIMEOUT = 5, -- seconds
    MAX_RETRIES = 3,
    RETRY_BACKOFF_BASE = 2 -- exponential backoff multiplier
}

-- Coordination message types
BattleCoordinationHandler.MessageType = {
    PROCESS_REGISTRATION = "PROCESS_REGISTRATION",
    BATTLE_STATE_SYNC = "BATTLE_STATE_SYNC",
    HEALTH_CHECK = "HEALTH_CHECK",
    LOAD_BALANCE_UPDATE = "LOAD_BALANCE_UPDATE",
    POKEMON_DATA_REQUEST = "POKEMON_DATA_REQUEST",
    RNG_COORDINATION = "RNG_COORDINATION",
    ERROR_NOTIFICATION = "ERROR_NOTIFICATION"
}

-- Coordination response types
BattleCoordinationHandler.ResponseType = {
    REGISTRATION_ACK = "REGISTRATION_ACK",
    STATE_SYNC_ACK = "STATE_SYNC_ACK",
    HEALTH_STATUS = "HEALTH_STATUS",
    LOAD_UPDATE_ACK = "LOAD_UPDATE_ACK",
    POKEMON_DATA_RESPONSE = "POKEMON_DATA_RESPONSE",
    RNG_COORDINATION_ACK = "RNG_COORDINATION_ACK",
    ERROR_ACK = "ERROR_ACK"
}

-- Process coordination message
-- @param msg: AO message with coordination data
-- @return: JSON response string
function BattleCoordinationHandler.process(msg)
    local startTime = msg.Timestamp
    
    -- Parse message data
    local success, messageData = pcall(json.decode, msg.Data or "{}")
    if not success then
        return json.encode({
            success = false,
            error = "Invalid JSON in coordination message",
            timestamp = 0
        })
    end
    
    -- Extract coordination information
    local correlation = messageData.correlation or {}
    local coordinationType = correlation.requestType or messageData.coordinationType
    local correlationId = correlation.id
    
    if not coordinationType then
        return BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Missing coordination type",
            "INVALID_COORDINATION"
        )
    end
    
    -- Authenticate inter-process message
    local authResult = ProcessAuthenticator.authenticate(msg)
    if not authResult.success then
        return BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Authentication failed: " .. (authResult.error or "Unknown error"),
            "AUTHENTICATION_FAILED"
        )
    end
    
    -- Process based on coordination type
    local result
    if coordinationType == BattleCoordinationHandler.MessageType.PROCESS_REGISTRATION then
        result = BattleCoordinationHandler.processProcessRegistration(messageData, msg)
    elseif coordinationType == BattleCoordinationHandler.MessageType.BATTLE_STATE_SYNC then
        result = BattleCoordinationHandler.processBattleStateSync(messageData, msg)
    elseif coordinationType == BattleCoordinationHandler.MessageType.HEALTH_CHECK then
        result = BattleCoordinationHandler.processHealthCheck(messageData, msg)
    elseif coordinationType == BattleCoordinationHandler.MessageType.LOAD_BALANCE_UPDATE then
        result = BattleCoordinationHandler.processLoadBalanceUpdate(messageData, msg)
    elseif coordinationType == BattleCoordinationHandler.MessageType.POKEMON_DATA_REQUEST then
        result = BattleCoordinationHandler.processPokemonDataRequest(messageData, msg)
    elseif coordinationType == BattleCoordinationHandler.MessageType.RNG_COORDINATION then
        result = BattleCoordinationHandler.processRngCoordination(messageData, msg)
    elseif coordinationType == BattleCoordinationHandler.MessageType.ERROR_NOTIFICATION then
        result = BattleCoordinationHandler.processErrorNotification(messageData, msg)
    else
        result = BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Unknown coordination type: " .. coordinationType,
            "UNKNOWN_COORDINATION"
        )
    end
    
    -- Add processing metrics
    local processingTime = 0 - startTime
    if type(result) == "table" then
        local resultData = json.decode(result)
        resultData.processing_time = processingTime
        result = json.encode(resultData)
    end
    
    return result
end

-- Process process registration request
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCoordinationHandler.processProcessRegistration(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    
    -- Get battle process statistics
    local stats = ConcurrentBattleManager.getPerformanceStatistics()
    
    local registrationData = {
        processId = ao.id,
        processType = "BATTLE_PROCESS",
        capabilities = {
            "BATTLE_COMMAND_PROCESSING",
            "DAMAGE_CALCULATION",
            "MOVE_EFFECT_PROCESSING",
            "BATTLE_STATE_MANAGEMENT",
            "CONCURRENT_BATTLES",
            "BATTLE_REPLAY"
        },
        capacity = {
            maxConcurrentBattles = stats.resourcePools * 10, -- Approximation
            currentActiveBattles = stats.activeBattles,
            averageLatency = stats.averageLatency,
            throughput = stats.throughput
        },
        status = "AVAILABLE",
        lastUpdate = 0
    }
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = BattleCoordinationHandler.ResponseType.REGISTRATION_ACK
        },
        result = {
            success = true,
            processRegistration = registrationData
        },
        timestamp = 0
    })
end

-- Process battle state synchronization request
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCoordinationHandler.processBattleStateSync(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    local battleData = messageData.battleData or {}
    
    if not battleData.battleId then
        return BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Missing battleId in sync request",
            "INVALID_SYNC_REQUEST"
        )
    end
    
    local battleId = battleData.battleId
    
    -- Get current battle state
    local battleState = BattleStateManager.getBattleState(battleId)
    if not battleState then
        return BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Battle state not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    -- Create synchronization response with state snapshot
    local syncData = {
        battleId = battleId,
        syncVersion = battleState.syncVersion,
        status = battleState.status,
        turn = battleState.turn,
        phase = battleState.phase,
        lastUpdated = battleState.lastUpdated,
        stateSnapshot = BattleStateManager.createStateSnapshot(battleState)
    }
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = BattleCoordinationHandler.ResponseType.STATE_SYNC_ACK
        },
        result = {
            success = true,
            syncData = syncData
        },
        timestamp = 0
    })
end

-- Process health check request
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCoordinationHandler.processHealthCheck(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    
    -- Get battle process health data
    local stats = ConcurrentBattleManager.getPerformanceStatistics()
    local stateStats = BattleStateManager.getStatistics()
    
    local healthData = {
        processId = ao.id,
        status = "HEALTHY",
        uptime = 0, -- Simplified uptime
        performance = {
            activeBattles = stats.activeBattles,
            totalBattles = stats.totalBattles,
            completedBattles = stats.completedBattles,
            errorBattles = stats.errorBattles,
            averageLatency = stats.averageLatency,
            throughput = stats.throughput
        },
        resources = {
            resourcePools = stats.resourcePools,
            poolUtilization = stats.poolUtilization
        },
        stateManager = {
            totalBattles = stateStats.totalBattles,
            activeBattles = stateStats.activeBattles,
            queuedSyncs = stateStats.queuedSyncs,
            historyEntries = stateStats.totalHistoryEntries
        }
    }
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = BattleCoordinationHandler.ResponseType.HEALTH_STATUS
        },
        result = {
            success = true,
            healthData = healthData
        },
        timestamp = 0
    })
end

-- Process load balance update request
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCoordinationHandler.processLoadBalanceUpdate(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    local loadData = messageData.loadData or {}
    
    -- Update load balancing configuration if needed
    -- This would integrate with the load balancer in the concurrent battle manager
    
    local currentLoad = {
        activeBattles = ConcurrentBattleManager.getActiveBattleCount(),
        capacity = 100, -- From configuration
        utilization = ConcurrentBattleManager.getActiveBattleCount() / 100
    }
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = BattleCoordinationHandler.ResponseType.LOAD_UPDATE_ACK
        },
        result = {
            success = true,
            currentLoad = currentLoad,
            loadUpdateApplied = true
        },
        timestamp = 0
    })
end

-- Process Pokemon data request from Pokemon process
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCoordinationHandler.processPokemonDataRequest(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    local pokemonRequest = messageData.pokemonRequest or {}
    
    local battleId = pokemonRequest.battleId
    local pokemonId = pokemonRequest.pokemonId
    
    if not battleId or not pokemonId then
        return BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Missing battleId or pokemonId in Pokemon data request",
            "INVALID_POKEMON_REQUEST"
        )
    end
    
    -- Get battle state and find Pokemon
    local battleState = BattleStateManager.getBattleState(battleId)
    if not battleState then
        return BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Battle state not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    local pokemon = nil
    for _, p in ipairs(battleState.playerParty) do
        if p.id == pokemonId then
            pokemon = p
            break
        end
    end
    
    if not pokemon then
        for _, p in ipairs(battleState.enemyParty) do
            if p.id == pokemonId then
                pokemon = p
                break
            end
        end
    end
    
    if not pokemon then
        return BattleCoordinationHandler.createErrorResponse(
            correlationId,
            "Pokemon not found: " .. pokemonId,
            "POKEMON_NOT_FOUND"
        )
    end
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = BattleCoordinationHandler.ResponseType.POKEMON_DATA_RESPONSE
        },
        result = {
            success = true,
            pokemonData = pokemon
        },
        timestamp = 0
    })
end

-- Process RNG coordination request
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCoordinationHandler.processRngCoordination(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    local rngRequest = messageData.rngRequest or {}
    
    -- This would coordinate with RNG process for deterministic battle outcomes
    -- For now, acknowledge the coordination request
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = BattleCoordinationHandler.ResponseType.RNG_COORDINATION_ACK
        },
        result = {
            success = true,
            rngCoordinated = true,
            battleId = rngRequest.battleId
        },
        timestamp = 0
    })
end

-- Process error notification from other processes
-- @param messageData: Parsed message data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleCoordinationHandler.processErrorNotification(messageData, msg)
    local correlationId = messageData.correlation and messageData.correlation.id
    local errorData = messageData.errorData or {}
    
    -- Log error and take appropriate action
    print("[BattleCoordinationHandler] Received error notification: " .. 
          (errorData.error or "Unknown error"))
    
    -- If error is related to a specific battle, handle it
    if errorData.battleId then
        local battleInstance = ConcurrentBattleManager.getBattleInstance(errorData.battleId)
        if battleInstance then
            -- Mark battle as error state if needed
            -- This would trigger error recovery procedures
        end
    end
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = BattleCoordinationHandler.ResponseType.ERROR_ACK
        },
        result = {
            success = true,
            errorAcknowledged = true,
            recoveryAction = "LOGGED"
        },
        timestamp = 0
    })
end

-- Timeout wrapper for coordination operations
-- @param operation: Function to execute with timeout
-- @param timeoutSeconds: Timeout in seconds
-- @param operationName: Name for logging
-- @return: success, result, error
function BattleCoordinationHandler.withTimeout(operation, timeoutSeconds, operationName)
    local startTime = msg.Timestamp
    local success, result = pcall(operation)
    local elapsed = 0 - startTime
    
    if elapsed > timeoutSeconds then
        return false, nil, "Operation '" .. (operationName or "unknown") .. "' timed out after " .. elapsed .. " seconds"
    end
    
    if not success then
        return false, nil, "Operation '" .. (operationName or "unknown") .. "' failed: " .. (result or "unknown error")
    end
    
    return true, result, nil
end

-- Retry wrapper with exponential backoff for coordination
-- @param operation: Function to retry
-- @param maxRetries: Maximum retry attempts
-- @param operationName: Name for logging
-- @return: success, result, error
function BattleCoordinationHandler.withRetry(operation, maxRetries, operationName)
    local attempts = 0
    maxRetries = maxRetries or TIMEOUT_CONFIG.MAX_RETRIES
    
    while attempts < maxRetries do
        attempts = attempts + 1
        local success, result = pcall(operation)
        
        if success then
            return true, result, nil
        end
        
        -- Calculate backoff delay
        if attempts < maxRetries then
            local backoffDelay = math.floor(TIMEOUT_CONFIG.RETRY_BACKOFF_BASE ^ attempts)
            print("Retry attempt " .. attempts .. " for " .. (operationName or "operation") .. 
                  " in " .. backoffDelay .. " seconds")
        end
    end
    
    return false, nil, "Operation '" .. (operationName or "unknown") .. 
           "' failed after " .. attempts .. " attempts"
end

-- Enhanced coordination with fallback mechanisms
-- @param primaryOperation: Primary coordination function
-- @param fallbackOperation: Fallback function if primary fails
-- @param operationName: Name for logging
-- @return: success, result, error, usedFallback
function BattleCoordinationHandler.withFallback(primaryOperation, fallbackOperation, operationName)
    local success, result, error = pcall(primaryOperation)
    
    if success then
        return true, result, nil, false
    end
    
    print("Primary coordination failed for " .. (operationName or "operation") .. ": " .. (error or "unknown error"))
    
    if fallbackOperation then
        local fallbackSuccess, fallbackResult, fallbackError = pcall(fallbackOperation)
        if fallbackSuccess then
            print("Fallback coordination succeeded for " .. (operationName or "operation"))
            return true, fallbackResult, nil, true
        else
            return false, nil, "Primary and fallback coordination failed. Primary: " .. 
                   (error or "unknown") .. ". Fallback: " .. (fallbackError or "unknown"), true
        end
    end
    
    return false, nil, error, false
end

-- Send coordination message to another process
-- @param targetProcessId: Target process ID
-- @param coordinationType: Type of coordination message
-- @param coordinationData: Data to send
-- @return: Success status
function BattleCoordinationHandler.sendCoordinationMessage(targetProcessId, coordinationType, coordinationData)
    if not targetProcessId or not coordinationType then
        return false, "Invalid coordination parameters"
    end
    
    -- Determine appropriate timeout based on coordination type
    local timeout = TIMEOUT_CONFIG.DEFAULT_TIMEOUT
    if coordinationType == BattleCoordinationHandler.MessageType.RNG_COORDINATION then
        timeout = TIMEOUT_CONFIG.RNG_TIMEOUT
    elseif coordinationType == BattleCoordinationHandler.MessageType.POKEMON_DATA_REQUEST then
        timeout = TIMEOUT_CONFIG.POKEMON_PROCESS_TIMEOUT
    else
        timeout = TIMEOUT_CONFIG.COORDINATOR_TIMEOUT
    end
    
    -- Send with retry and timeout handling
    local success, result, error = BattleCoordinationHandler.withRetry(
        function()
            return BattleCoordinationHandler.withTimeout(
                function()
                    -- Create correlation for tracking
                    local correlationId = MessageCorrelator.createCorrelation(
                        ao.id,
                        targetProcessId,
                        coordinationType,
                        nil
                    )
                    
                    local message = {
                        correlation = {
                            id = correlationId,
                            requestType = coordinationType
                        },
                        coordinationData = coordinationData,
                        processAuth = {
                            sourceProcessId = ao.id,
                            timestamp = 0
                        }
                    }
                    
                    -- Send message using AO's message mechanism
                    return ao.send({
                        Target = targetProcessId,
                        Action = "COORDINATION",
                        Data = json.encode(message),
                        ["X-Correlation-Id"] = correlationId
                    })
                end,
                timeout,
                "coordination-" .. coordinationType
            )
        end,
        TIMEOUT_CONFIG.MAX_RETRIES,
        "coordination-message-send"
    )
    
    if not success then
        print("[BattleCoordinationHandler] Failed to send coordination message: " .. (error or "unknown error"))
        return false, error
    end
    
    print("[BattleCoordinationHandler] Successfully sent coordination message: " .. coordinationType)
    return true, result
end

-- Create standardized error response
-- @param correlationId: Correlation ID for response tracking
-- @param errorMessage: Human-readable error message
-- @param errorCode: Machine-readable error code
-- @return: JSON error response string
function BattleCoordinationHandler.createErrorResponse(correlationId, errorMessage, errorCode)
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "ERROR"
        },
        success = false,
        error = errorMessage,
        errorCode = errorCode,
        timestamp = 0
    })
end


-- ===== END MODULE: battle.handlers.battle-coordination-handler =====


-- ===== MODULE: battle.handlers.battle-replay-handler =====
-- File: ao-processes/battle/handlers/battle-replay-handler.lua
-- Original require: local BattleReplayHandler = require("battle.handlers.battle-replay-handler")

-- Battle Replay Handler
-- Manages battle history and replay functionality for battle process
-- Enables identical battle reproduction using deterministic RNG seeds
-- Epic 32.3: Battle Engine Process Extraction

local BattleReplayHandler = {}

-- Load dependencies

-- ===== MODULE: battle.components.battle-state-manager =====
-- File: ao-processes/battle/components/battle-state-manager.lua
-- Original require: local BattleStateManager = require("battle.components.battle-state-manager")


-- ===== END MODULE: battle.components.battle-state-manager =====


-- ===== MODULE: battle.components.concurrent-battle-manager =====
-- File: ao-processes/battle/components/concurrent-battle-manager.lua
-- Original require: local ConcurrentBattleManager = require("battle.components.concurrent-battle-manager")


-- ===== END MODULE: battle.components.concurrent-battle-manager =====


-- ===== MODULE: battle.components.turn-processor =====
-- File: ao-processes/battle/components/turn-processor.lua
-- Original require: local TurnProcessor = require("battle.components.turn-processor")


-- ===== END MODULE: battle.components.turn-processor =====


-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: local BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Replay request types
BattleReplayHandler.ReplayType = {
    FULL_REPLAY = "FULL_REPLAY",
    TURN_REPLAY = "TURN_REPLAY", 
    STATE_RECONSTRUCTION = "STATE_RECONSTRUCTION",
    REPLAY_VALIDATION = "REPLAY_VALIDATION"
}

-- Replay data format version
BattleReplayHandler.REPLAY_FORMAT_VERSION = "1.0.0"

-- Process battle replay request
-- @param msg: AO message with replay request data
-- @return: JSON response string
function BattleReplayHandler.process(msg)
    local startTime = msg.Timestamp
    
    -- Parse message data
    local success, messageData = pcall(json.decode, msg.Data or "{}")
    if not success then
        return json.encode({
            success = false,
            error = "Invalid JSON in replay request",
            timestamp = 0
        })
    end
    
    -- Extract replay information
    local replayRequest = messageData.replayRequest or {}
    local correlationId = messageData.correlation and messageData.correlation.id
    
    local replayType = replayRequest.replayType
    if not replayType then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Missing replayType in request",
            "INVALID_REPLAY_REQUEST"
        )
    end
    
    -- Process based on replay type
    local result
    if replayType == BattleReplayHandler.ReplayType.FULL_REPLAY then
        result = BattleReplayHandler.processFullReplay(replayRequest, msg)
    elseif replayType == BattleReplayHandler.ReplayType.TURN_REPLAY then
        result = BattleReplayHandler.processTurnReplay(replayRequest, msg)
    elseif replayType == BattleReplayHandler.ReplayType.STATE_RECONSTRUCTION then
        result = BattleReplayHandler.processStateReconstruction(replayRequest, msg)
    elseif replayType == BattleReplayHandler.ReplayType.REPLAY_VALIDATION then
        result = BattleReplayHandler.processReplayValidation(replayRequest, msg)
    else
        result = BattleReplayHandler.createErrorResponse(
            correlationId,
            "Unknown replay type: " .. replayType,
            "UNKNOWN_REPLAY_TYPE"
        )
    end
    
    -- Add processing metrics
    local processingTime = 0 - startTime
    if type(result) == "table" then
        local resultData = json.decode(result)
        resultData.processing_time = processingTime
        result = json.encode(resultData)
    end
    
    return result
end

-- Process full battle replay request
-- @param replayRequest: Replay request data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleReplayHandler.processFullReplay(replayRequest, msg)
    local correlationId = replayRequest.correlation and replayRequest.correlation.id
    local battleId = replayRequest.battleId
    
    if not battleId then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Missing battleId in full replay request",
            "INVALID_REPLAY_REQUEST"
        )
    end
    
    -- Get complete battle history
    local history = BattleStateManager.getBattleHistory(battleId)
    if not history or #history == 0 then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "No battle history found for battle: " .. battleId,
            "HISTORY_NOT_FOUND"
        )
    end
    
    -- Get battle state for replay data
    local battleState = BattleStateManager.getBattleState(battleId)
    if not battleState then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Battle state not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    -- Create comprehensive replay data
    local replayData = BattleReplayHandler.createReplayData(battleState, history)
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "FULL_REPLAY_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            replayData = replayData,
            formatVersion = BattleReplayHandler.REPLAY_FORMAT_VERSION
        },
        timestamp = 0
    })
end

-- Process turn-specific replay request
-- @param replayRequest: Replay request data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleReplayHandler.processTurnReplay(replayRequest, msg)
    local correlationId = replayRequest.correlation and replayRequest.correlation.id
    local battleId = replayRequest.battleId
    local turnNumber = replayRequest.turnNumber
    
    if not battleId or not turnNumber then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Missing battleId or turnNumber in turn replay request",
            "INVALID_REPLAY_REQUEST"
        )
    end
    
    -- Get battle history for specific turn
    local history = BattleStateManager.getBattleHistory(battleId)
    if not history then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "No battle history found for battle: " .. battleId,
            "HISTORY_NOT_FOUND"
        )
    end
    
    -- Find the specified turn in history
    local turnHistory = nil
    for _, entry in ipairs(history) do
        if entry.turn == turnNumber then
            turnHistory = entry
            break
        end
    end
    
    if not turnHistory then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Turn " .. turnNumber .. " not found in battle history",
            "TURN_NOT_FOUND"
        )
    end
    
    -- Create turn-specific replay data
    local turnReplayData = {
        turn = turnNumber,
        timestamp = turnHistory.timestamp,
        action = turnHistory.action,
        stateSnapshot = turnHistory.stateSnapshot,
        turnData = turnHistory.turnData or {}
    }
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "TURN_REPLAY_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            turnReplayData = turnReplayData
        },
        timestamp = 0
    })
end

-- Process state reconstruction request
-- @param replayRequest: Replay request data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleReplayHandler.processStateReconstruction(replayRequest, msg)
    local correlationId = replayRequest.correlation and replayRequest.correlation.id
    local battleId = replayRequest.battleId
    local targetTurn = replayRequest.targetTurn or 0
    
    if not battleId then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Missing battleId in state reconstruction request",
            "INVALID_REPLAY_REQUEST"
        )
    end
    
    -- Get battle state and history
    local battleState = BattleStateManager.getBattleState(battleId)
    if not battleState then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Battle state not found: " .. battleId,
            "BATTLE_NOT_FOUND"
        )
    end
    
    local history = BattleStateManager.getBattleHistory(battleId)
    if not history then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Battle history not found: " .. battleId,
            "HISTORY_NOT_FOUND"
        )
    end
    
    -- Reconstruct battle state at target turn
    local reconstructedState = BattleReplayHandler.reconstructBattleState(
        battleState,
        history,
        targetTurn
    )
    
    if not reconstructedState then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Failed to reconstruct state at turn " .. targetTurn,
            "RECONSTRUCTION_FAILED"
        )
    end
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "STATE_RECONSTRUCTION_RESULT"
        },
        result = {
            success = true,
            battleId = battleId,
            targetTurn = targetTurn,
            reconstructedState = reconstructedState
        },
        timestamp = 0
    })
end

-- Process replay validation request
-- @param replayRequest: Replay request data
-- @param msg: Original AO message
-- @return: JSON response string
function BattleReplayHandler.processReplayValidation(replayRequest, msg)
    local correlationId = replayRequest.correlation and replayRequest.correlation.id
    local replayData = replayRequest.replayData
    
    if not replayData then
        return BattleReplayHandler.createErrorResponse(
            correlationId,
            "Missing replayData in validation request",
            "INVALID_REPLAY_REQUEST"
        )
    end
    
    -- Validate replay data integrity
    local validationResult = BattleReplayHandler.validateReplayData(replayData)
    
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "REPLAY_VALIDATION_RESULT"
        },
        result = validationResult,
        timestamp = 0
    })
end

-- Create comprehensive replay data from battle state and history
-- @param battleState: Current battle state
-- @param history: Complete battle history
-- @return: Replay data structure
function BattleReplayHandler.createReplayData(battleState, history)
    local replayData = {
        formatVersion = BattleReplayHandler.REPLAY_FORMAT_VERSION,
        battleId = battleState.battleId,
        battleSeed = battleState.battleSeed,
        createdAt = battleState.createdAt,
        lastUpdated = battleState.lastUpdated,
        
        -- Initial battle setup
        initialState = {
            playerParty = battleState.playerParty,
            enemyParty = battleState.enemyParty,
            battleType = battleState.battleType,
            battleConditions = battleState.battleConditions
        },
        
        -- Complete turn history
        turnHistory = history,
        
        -- Final battle result
        finalResult = battleState.battleResult,
        
        -- Metadata for validation
        metadata = {
            totalTurns = battleState.turn,
            historyEntries = #history,
            syncVersion = battleState.syncVersion,
            replayGenerated = 0
        }
    }
    
    return replayData
end

-- Reconstruct battle state at specific turn
-- @param currentBattleState: Current battle state
-- @param history: Battle history
-- @param targetTurn: Turn to reconstruct to
-- @return: Reconstructed battle state or nil
function BattleReplayHandler.reconstructBattleState(currentBattleState, history, targetTurn)
    if not currentBattleState or not history then
        return nil
    end
    
    -- Find the closest state snapshot at or before target turn
    local baseSnapshot = nil
    local baseSnapshotTurn = -1
    
    for _, entry in ipairs(history) do
        if entry.turn <= targetTurn and entry.turn > baseSnapshotTurn then
            baseSnapshot = entry.stateSnapshot
            baseSnapshotTurn = entry.turn
        end
    end
    
    if not baseSnapshot then
        return nil
    end
    
    -- If exact turn match, return the snapshot
    if baseSnapshotTurn == targetTurn then
        return baseSnapshot
    end
    
    -- Reconstruct state by replaying turns from base snapshot to target turn
    local reconstructedState = BattleReplayHandler.deepCopy(baseSnapshot)
    
    -- Apply turn-by-turn changes from base to target
    for _, entry in ipairs(history) do
        if entry.turn > baseSnapshotTurn and entry.turn <= targetTurn then
            -- Apply state changes from this turn
            if entry.stateChanges then
                BattleReplayHandler.applyStateChanges(reconstructedState, entry.stateChanges)
            end
        end
    end
    
    return reconstructedState
end

-- Apply state changes to reconstructed state
-- @param state: State to modify
-- @param changes: Changes to apply
function BattleReplayHandler.applyStateChanges(state, changes)
    -- This would implement the logic to apply incremental state changes
    -- For now, this is a placeholder that would be expanded based on
    -- the specific state change format used in the system
    
    if changes.turn then
        state.turn = changes.turn
    end
    
    if changes.phase then
        state.phase = changes.phase
    end
    
    if changes.pokemonUpdates then
        -- Apply Pokemon HP/status updates
        for _, update in ipairs(changes.pokemonUpdates) do
            -- Find and update Pokemon in state
            -- This would be implemented based on Pokemon storage structure
        end
    end
end

-- Validate replay data integrity
-- @param replayData: Replay data to validate
-- @return: Validation result
function BattleReplayHandler.validateReplayData(replayData)
    local validation = {
        success = true,
        errors = {},
        warnings = {},
        checks = {
            formatVersion = false,
            battleSeed = false,
            historyIntegrity = false,
            stateConsistency = false
        }
    }
    
    -- Check format version
    if replayData.formatVersion == BattleReplayHandler.REPLAY_FORMAT_VERSION then
        validation.checks.formatVersion = true
    else
        table.insert(validation.errors, "Unsupported replay format version: " .. 
                    (replayData.formatVersion or "unknown"))
        validation.success = false
    end
    
    -- Check battle seed presence
    if replayData.battleSeed and type(replayData.battleSeed) == "string" then
        validation.checks.battleSeed = true
    else
        table.insert(validation.errors, "Missing or invalid battle seed")
        validation.success = false
    end
    
    -- Check history integrity
    if replayData.turnHistory and type(replayData.turnHistory) == "table" then
        local historyValid = true
        local lastTurn = -1
        
        for i, entry in ipairs(replayData.turnHistory) do
            if not entry.turn or entry.turn <= lastTurn then
                historyValid = false
                table.insert(validation.errors, "Invalid turn order at history entry " .. i)
                break
            end
            lastTurn = entry.turn
        end
        
        validation.checks.historyIntegrity = historyValid
        if not historyValid then
            validation.success = false
        end
    else
        table.insert(validation.errors, "Missing or invalid turn history")
        validation.success = false
    end
    
    -- Check state consistency (basic check)
    if replayData.initialState and replayData.metadata then
        if replayData.metadata.totalTurns and replayData.metadata.historyEntries then
            validation.checks.stateConsistency = true
        else
            table.insert(validation.warnings, "Incomplete metadata for state consistency check")
        end
    else
        table.insert(validation.errors, "Missing initial state or metadata")
        validation.success = false
    end
    
    return validation
end

-- Deep copy utility for state reconstruction
-- @param original: Original table to copy
-- @return: Deep copy of the table
function BattleReplayHandler.deepCopy(original)
    if type(original) ~= "table" then
        return original
    end
    
    local copy = {}
    for key, value in pairs(original) do
        copy[key] = BattleReplayHandler.deepCopy(value)
    end
    
    return copy
end

-- Create standardized error response
-- @param correlationId: Correlation ID for response tracking
-- @param errorMessage: Human-readable error message
-- @param errorCode: Machine-readable error code
-- @return: JSON error response string
function BattleReplayHandler.createErrorResponse(correlationId, errorMessage, errorCode)
    return json.encode({
        correlation = {
            id = correlationId,
            responseType = "ERROR"
        },
        success = false,
        error = errorMessage,
        errorCode = errorCode,
        timestamp = 0
    })
end


-- ===== END MODULE: battle.handlers.battle-replay-handler =====


-- Load core battle components

-- ===== MODULE: battle.components.damage-calculator =====
-- File: ao-processes/battle/components/damage-calculator.lua
-- Original require: local DamageCalculator = require("battle.components.damage-calculator")


-- ===== END MODULE: battle.components.damage-calculator =====


-- ===== MODULE: battle.components.turn-processor =====
-- File: ao-processes/battle/components/turn-processor.lua
-- Original require: local TurnProcessor = require("battle.components.turn-processor")


-- ===== END MODULE: battle.components.turn-processor =====


-- ===== MODULE: battle.components.move-effect-processor =====
-- File: ao-processes/battle/components/move-effect-processor.lua
-- Original require: local MoveEffectProcessor = require("battle.components.move-effect-processor")


-- ===== END MODULE: battle.components.move-effect-processor =====


-- ===== MODULE: battle.components.battle-state-manager =====
-- File: ao-processes/battle/components/battle-state-manager.lua
-- Original require: local BattleStateManager = require("battle.components.battle-state-manager")


-- ===== END MODULE: battle.components.battle-state-manager =====


-- ===== MODULE: battle.components.concurrent-battle-manager =====
-- File: ao-processes/battle/components/concurrent-battle-manager.lua
-- Original require: local ConcurrentBattleManager = require("battle.components.concurrent-battle-manager")


-- ===== END MODULE: battle.components.concurrent-battle-manager =====


-- Battle process storage
local BattleInstances = {}
local ProcessStats = {
    activeBattles = 0,
    totalBattlesProcessed = 0,
    averageLatency = 0,
    concurrentBattleCapacity = 100
}

-- Expose globals for health checks
BattleEngine = ConcurrentBattleManager
DamageCalculator = DamageCalculator

-- ===== MODULE: game-logic.rng.battle-rng =====
-- File: ao-processes/game-logic/rng/battle-rng.lua
-- Original require: BattleRNG = require("game-logic.rng.battle-rng")


-- ===== END MODULE: game-logic.rng.battle-rng =====


-- Initialize battle process
local function initializeBattleProcess()
    print("[BattleProcess] Initializing dedicated battle engine...")
    
    -- Initialize inter-process communication
    MessageCorrelator.initialize()
    ProcessAuthenticator.initialize()
    MessageRouter.initialize()
    
    -- Initialize battle components
    ConcurrentBattleManager.initialize(ProcessStats.concurrentBattleCapacity)
    BattleStateManager.initialize()
    
    -- Register with coordinator process for discovery
    local registrationData = {
        processInfo = PROCESS_INFO,
        processId = ao.id,
        capabilities = PROCESS_INFO.capabilities,
        maxConcurrentBattles = ProcessStats.concurrentBattleCapacity
    }
    
    print("[BattleProcess] Battle engine initialized successfully")
    return registrationData
end

-- Process authentication for incoming messages
local function authenticateMessage(msg)
    local authResult = ProcessAuthenticator.authenticate(msg)
    if not authResult.success then
        print("[BattleProcess] Authentication failed: " .. (authResult.error or "Unknown error"))
        return false, authResult.error
    end
    return true, authResult.authLevel
end

-- Handle battle process info requests (AO protocol compliance)
Handlers.add(
    "BATTLE_PROCESS_INFO",
    Handlers.utils.hasMatchingTag("Action", "Info"),
    function(msg)
        local response = {
            name = PROCESS_INFO.name,
            version = PROCESS_INFO.version,
            description = PROCESS_INFO.description,
            capabilities = PROCESS_INFO.capabilities,
            stats = ProcessStats,
            timestamp = 0
        }
        
        Handlers.utils.reply(json.encode({
            success = true,
            data = response
        }))(msg)
    end
)

-- Handle battle command processing requests
Handlers.add(
    "BATTLE_COMMAND",
    Handlers.utils.hasMatchingTag("Action", "BATTLE_COMMAND"),
    function(msg)
        -- Authenticate the message
        local authSuccess, authLevel = authenticateMessage(msg)
        if not authSuccess then
            Handlers.utils.reply(json.encode({
                success = false,
                error = "Authentication failed",
                timestamp = 0
            }))(msg)
            return
        end
        
        -- Process battle command through handler
        local response = BattleCommandHandler.process(msg)
        Handlers.utils.reply(response)(msg)
    end
)

-- Handle battle state queries
Handlers.add(
    "BATTLE_STATE_QUERY",
    Handlers.utils.hasMatchingTag("Action", "BATTLE_STATE_QUERY"),
    function(msg)
        -- Authenticate the message
        local authSuccess, authLevel = authenticateMessage(msg)
        if not authSuccess then
            Handlers.utils.reply(json.encode({
                success = false,
                error = "Authentication failed",
                timestamp = 0
            }))(msg)
            return
        end
        
        -- Process state query through handler
        local response = BattleStateHandler.process(msg)
        Handlers.utils.reply(response)(msg)
    end
)

-- Handle inter-process coordination messages
Handlers.add(
    "BATTLE_COORDINATION",
    Handlers.utils.hasMatchingTag("Action", "BATTLE_COORDINATION"),
    function(msg)
        -- Process coordination messages through handler
        local response = BattleCoordinationHandler.process(msg)
        Handlers.utils.reply(response)(msg)
    end
)

-- Handle battle replay requests
Handlers.add(
    "BATTLE_REPLAY", 
    Handlers.utils.hasMatchingTag("Action", "BATTLE_REPLAY"),
    function(msg)
        -- Authenticate the message
        local authSuccess, authLevel = authenticateMessage(msg)
        if not authSuccess then
            Handlers.utils.reply(json.encode({
                success = false,
                error = "Authentication failed",
                timestamp = 0
            }))(msg)
            return
        end
        
        -- Process replay request through handler
        local response = BattleReplayHandler.process(msg)
        Handlers.utils.reply(response)(msg)
    end
)

-- Handle process health checks
Handlers.add(
    "BATTLE_HEALTH_CHECK",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_CHECK"),
    function(msg)
        local healthData = {
            processId = ao.id,
            status = "HEALTHY",
            activeBattles = ProcessStats.activeBattles,
            totalProcessed = ProcessStats.totalBattlesProcessed,
            averageLatency = ProcessStats.averageLatency,
            capacity = ProcessStats.concurrentBattleCapacity,
            timestamp = 0
        }
        
        Handlers.utils.reply(json.encode({
            success = true,
            data = healthData
        }))(msg)
    end
)

-- Initialize the battle process
initializeBattleProcess()

-- Export process components for testing
if _G.TEST_MODE then
    _G.BattleProcess = {
        DamageCalculator = DamageCalculator,
        TurnProcessor = TurnProcessor,
        MoveEffectProcessor = MoveEffectProcessor,
        BattleStateManager = BattleStateManager,
        ConcurrentBattleManager = ConcurrentBattleManager,
        ProcessStats = ProcessStats,
        PROCESS_INFO = PROCESS_INFO
    }
end

