-- Bundled Lua file for AO Environment
-- Generated by custom-lua-bundler.sh
-- Entry point: ao-processes/security/main.lua
-- Bundle timestamp: Fri Sep  5 17:51:28 EDT 2025

-- JSON require (allowed in AO environment)
local json = require('json')

-- Security Process Main Entry Point
-- Centralized security validation and anti-cheat detection for distributed architecture

-- JSON handling for AO environment
local json = {}
local success, jsonModule = pcall(require, 'json')
if success then
    json = jsonModule
else
    -- Pure Lua JSON implementation for AO environment compatibility
    json = {
        encode = function(obj)
            if type(obj) == "string" then
                return '"' .. obj:gsub('"', '\\"'):gsub('\n', '\\n'):gsub('\r', '\\r'):gsub('\t', '\\t') .. '"'
            elseif type(obj) == "number" then
                return tostring(obj)
            elseif type(obj) == "boolean" then
                return obj and "true" or "false"
            elseif obj == nil then
                return "null"
            elseif type(obj) == "table" then
                local isArray = true
                local maxIndex = 0
                for k, v in pairs(obj) do
                    if type(k) ~= "number" then
                        isArray = false
                        break
                    end
                    maxIndex = math.max(maxIndex, k)
                end
                
                if isArray then
                    local result = "["
                    for i = 1, maxIndex do
                        if i > 1 then result = result .. "," end
                        result = result .. json.encode(obj[i])
                    end
                    return result .. "]"
                else
                    local result = "{"
                    local first = true
                    for k, v in pairs(obj) do
                        if not first then result = result .. "," end
                        result = result .. json.encode(tostring(k)) .. ":" .. json.encode(v)
                        first = false
                    end
                    return result .. "}"
                end
            else
                return "null"
            end
        end,
        decode = function(str)
            -- Basic decode implementation for common patterns
            if not str or str == "" then return {} end
            if str == "null" then return nil end
            if str == "true" then return true end
            if str == "false" then return false end
            if str:match("^%d+$") then return tonumber(str) end
            if str:match('^".*"$') then return str:sub(2, -2) end
            return {}
        end
    }
end

-- Load process coordination components from foundation

-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")

-- Message Correlation System for Inter-Process Communication
-- Provides unique correlation ID generation and tracking across message chains


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")

-- Cryptographically secure RNG wrapper for AO processes
-- Replaces non-deterministic math.random() with seedable crypto-based randomness

local CryptoRNG = {
    -- Battle RNG state for deterministic battles
    battleSeed = nil,
    battleCounter = 0,
    
    -- General RNG state for non-battle operations
    globalSeed = nil,
    globalCounter = 0
}

-- Initialize battle RNG with a specific seed for deterministic battles
function CryptoRNG.initBattleRNG(seed)
    if not seed or type(seed) ~= "string" then
        error("Battle RNG seed must be a string")
    end
    CryptoRNG.battleSeed = seed
    CryptoRNG.battleCounter = 0
end

-- Initialize global RNG with a seed (or generate one from ao.crypto)
function CryptoRNG.initGlobalRNG(seed, timestamp)
    if seed then
        CryptoRNG.globalSeed = seed
    else
        -- Use AO crypto to generate a random seed (with fallback for testing)
        if ao and ao.crypto and ao.crypto.cipher then
            CryptoRNG.globalSeed = ao.crypto.cipher.issuer()
        else
            -- Fallback for testing environment - use current time
            CryptoRNG.globalSeed = tostring(timestamp or 0)
        end
    end
    CryptoRNG.globalCounter = 0
end

-- Get deterministic random integer in battle context
function CryptoRNG.battleRandomInt(min, max)
    if not CryptoRNG.battleSeed then
        error("Battle RNG not initialized - call CryptoRNG.initBattleRNG(seed) first")
    end
    
    -- Increment counter for deterministic sequence
    CryptoRNG.battleCounter = CryptoRNG.battleCounter + 1
    
    -- Create deterministic input combining seed and counter
    local input = CryptoRNG.battleSeed .. ":" .. tostring(CryptoRNG.battleCounter)
    
    -- Use AO crypto to generate deterministic hash (with fallback)
    local hash
    if ao and ao.crypto and ao.crypto.utils then
        hash = ao.crypto.utils.hash(input)
    else
        -- Fallback hash function for testing using simple string hashing
        local hashNum = 0
        for i = 1, #input do
            hashNum = hashNum + string.byte(input, i) * (i * 31)
        end
        hash = tostring(math.abs(hashNum))
    end
    
    -- Convert hash to number and normalize to range
    local num = 0
    for i = 1, math.min(8, #hash) do
        num = num + string.byte(hash, i) * (256 ^ (i - 1))
    end
    
    -- Normalize to requested range
    if min and max then
        return min + (num % (max - min + 1))
    else
        return num % 100 + 1  -- Default 1-100 range
    end
end

-- Get random number in battle context (0-1 float)
function CryptoRNG.battleRandom()
    local randomInt = CryptoRNG.battleRandomInt(0, 999999)
    return randomInt / 999999
end

-- Get random integer in global context
function CryptoRNG.globalRandomInt(min, max)
    if not CryptoRNG.globalSeed then
        CryptoRNG.initGlobalRNG()
    end
    
    CryptoRNG.globalCounter = CryptoRNG.globalCounter + 1
    
    -- Create deterministic input
    local input = CryptoRNG.globalSeed .. ":" .. tostring(CryptoRNG.globalCounter)
    
    -- Use AO crypto for randomness (with fallback)
    local hash
    if ao and ao.crypto and ao.crypto.utils then
        hash = ao.crypto.utils.hash(input)
    else
        -- Fallback hash function for testing using simple string hashing
        local hashNum = 0
        for i = 1, #input do
            hashNum = hashNum + string.byte(input, i) * (i * 37)
        end
        hash = tostring(math.abs(hashNum))
    end
    
    -- Convert to number
    local num = 0
    for i = 1, math.min(8, #hash) do
        num = num + string.byte(hash, i) * (256 ^ (i - 1))
    end
    
    -- Normalize to range
    if min and max then
        return min + (num % (max - min + 1))
    else
        return num % 100 + 1
    end
end

-- Get random float in global context (0-1)
function CryptoRNG.globalRandom()
    local randomInt = CryptoRNG.globalRandomInt(0, 999999)
    return randomInt / 999999
end

-- Compatibility functions that match math.random() interface
function CryptoRNG.random(...)
    local args = {...}
    local argCount = #args
    
    if argCount == 0 then
        -- math.random() -> 0-1 float
        return CryptoRNG.globalRandom()
    elseif argCount == 1 then
        -- math.random(n) -> 1 to n
        return CryptoRNG.globalRandomInt(1, args[1])
    elseif argCount == 2 then
        -- math.random(m, n) -> m to n
        return CryptoRNG.globalRandomInt(args[1], args[2])
    else
        error("Invalid number of arguments to CryptoRNG.random()")
    end
end

-- Battle-specific random that follows the same interface
function CryptoRNG.battleRandomCompat(...)
    local args = {...}
    local argCount = #args
    
    if argCount == 0 then
        return CryptoRNG.battleRandom()
    elseif argCount == 1 then
        return CryptoRNG.battleRandomInt(1, args[1])
    elseif argCount == 2 then
        return CryptoRNG.battleRandomInt(args[1], args[2])
    else
        error("Invalid number of arguments to CryptoRNG.battleRandomCompat()")
    end
end

-- Reset battle RNG state (for new battles)
function CryptoRNG.resetBattleRNG()
    CryptoRNG.battleSeed = nil
    CryptoRNG.battleCounter = 0
end

-- Get current battle RNG state for debugging
function CryptoRNG.getBattleState()
    return {
        seed = CryptoRNG.battleSeed,
        counter = CryptoRNG.battleCounter
    }
end


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local MessageCorrelator = {
    -- Correlation tracking storage
    activeCorrelations = {},
    correlationHistory = {},
    maxHistorySize = 10000
}

-- Correlation Types
MessageCorrelator.CORRELATION_TYPES = {
    INTER_PROCESS = "INTER_PROCESS",
    INTRA_PROCESS = "INTRA_PROCESS",
    CLIENT_REQUEST = "CLIENT_REQUEST"
}

-- Message Status
MessageCorrelator.MESSAGE_STATUS = {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING", 
    COMPLETED = "COMPLETED",
    FAILED = "FAILED",
    TIMEOUT = "TIMEOUT"
}

-- Initialize the correlation system
function MessageCorrelator.initialize()
    MessageCorrelator.activeCorrelations = {}
    MessageCorrelator.correlationHistory = {}
    CryptoRNG.initGlobalRNG()
    print("[MessageCorrelator] Correlation system initialized")
end

-- Generate unique correlation ID using AO crypto module
function MessageCorrelator.generateCorrelationId(correlationType, timestamp)
    local currentTimestamp = timestamp or (msg and msg.Timestamp) or 0
    local baseTimestamp = currentTimestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    local prefix = correlationType == MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS and "ipc" or "cor"
    
    return prefix .. "_" .. baseTimestamp .. "_" .. randomSuffix
end

-- Create new correlation with full metadata
function MessageCorrelator.createCorrelation(originProcessId, targetProcessId, messageType, parentCorrelationId, timestamp)
    local correlationId = MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS, timestamp)
    local currentTimestamp = timestamp or 0
    
    local correlation = {
        id = correlationId,
        parent = parentCorrelationId,
        origin = originProcessId,
        target = targetProcessId,
        messageType = messageType,
        status = MessageCorrelator.MESSAGE_STATUS.PENDING,
        created = currentTimestamp,
        lastUpdated = currentTimestamp,
        chain = {}
    }
    
    -- Add to parent chain if this is a nested operation
    if parentCorrelationId and MessageCorrelator.activeCorrelations[parentCorrelationId] then
        table.insert(MessageCorrelator.activeCorrelations[parentCorrelationId].chain, correlationId)
        correlation.depth = (MessageCorrelator.activeCorrelations[parentCorrelationId].depth or 0) + 1
    else
        correlation.depth = 0
    end
    
    MessageCorrelator.activeCorrelations[correlationId] = correlation
    
    return correlationId
end

-- Update correlation status
function MessageCorrelator.updateCorrelationStatus(correlationId, status, errorMessage, timestamp)
    local correlation = MessageCorrelator.activeCorrelations[correlationId]
    if not correlation then
        return false, "Correlation not found: " .. tostring(correlationId)
    end
    
    correlation.status = status
    correlation.lastUpdated = timestamp or 0
    
    if errorMessage then
        correlation.error = errorMessage
    end
    
    -- Move to history if completed or failed
    if status == MessageCorrelator.MESSAGE_STATUS.COMPLETED or 
       status == MessageCorrelator.MESSAGE_STATUS.FAILED or 
       status == MessageCorrelator.MESSAGE_STATUS.TIMEOUT then
        MessageCorrelator.moveToHistory(correlationId)
    end
    
    return true
end

-- Get correlation metadata
function MessageCorrelator.getCorrelation(correlationId)
    return MessageCorrelator.activeCorrelations[correlationId] or 
           MessageCorrelator.correlationHistory[correlationId]
end

-- Get all active correlations for a process
function MessageCorrelator.getProcessCorrelations(processId)
    local processCorrelations = {}
    
    for correlationId, correlation in pairs(MessageCorrelator.activeCorrelations) do
        if correlation.origin == processId or correlation.target == processId then
            processCorrelations[correlationId] = correlation
        end
    end
    
    return processCorrelations
end

-- Get correlation chain (parent and all children)
function MessageCorrelator.getCorrelationChain(correlationId)
    local correlation = MessageCorrelator.getCorrelation(correlationId)
    if not correlation then
        return nil
    end
    
    local chain = { correlation }
    
    -- Get parent chain
    local parent = correlation.parent
    while parent do
        local parentCorrelation = MessageCorrelator.getCorrelation(parent)
        if parentCorrelation then
            table.insert(chain, 1, parentCorrelation)
            parent = parentCorrelation.parent
        else
            break
        end
    end
    
    -- Get child chain
    local function addChildren(currentId)
        local current = MessageCorrelator.getCorrelation(currentId)
        if current and current.chain then
            for _, childId in ipairs(current.chain) do
                local childCorrelation = MessageCorrelator.getCorrelation(childId)
                if childCorrelation then
                    table.insert(chain, childCorrelation)
                    addChildren(childId)
                end
            end
        end
    end
    
    addChildren(correlationId)
    
    return chain
end

-- Move correlation to history and cleanup
function MessageCorrelator.moveToHistory(correlationId)
    local correlation = MessageCorrelator.activeCorrelations[correlationId]
    if not correlation then
        return false
    end
    
    -- Move to history
    MessageCorrelator.correlationHistory[correlationId] = correlation
    MessageCorrelator.activeCorrelations[correlationId] = nil
    
    -- Cleanup old history if at max size
    MessageCorrelator.cleanupHistory()
    
    return true
end

-- Cleanup old correlation history
function MessageCorrelator.cleanupHistory()
    local historySize = 0
    for _ in pairs(MessageCorrelator.correlationHistory) do
        historySize = historySize + 1
    end
    
    if historySize > MessageCorrelator.maxHistorySize then
        local oldestCorrelations = {}
        for correlationId, correlation in pairs(MessageCorrelator.correlationHistory) do
            table.insert(oldestCorrelations, {id = correlationId, lastUpdated = correlation.lastUpdated})
        end
        
        table.sort(oldestCorrelations, function(a, b) return a.lastUpdated < b.lastUpdated end)
        
        -- Remove oldest 20%
        local removeCount = math.floor(MessageCorrelator.maxHistorySize * 0.2)
        for i = 1, removeCount do
            MessageCorrelator.correlationHistory[oldestCorrelations[i].id] = nil
        end
    end
end

-- Create correlation metadata for message
function MessageCorrelator.createCorrelationMetadata(correlationId, originProcessId, targetProcessId, parentCorrelationId)
    return {
        id = correlationId,
        parent = parentCorrelationId,
        origin = originProcessId,
        target = targetProcessId
    }
end

-- Validate correlation metadata format
function MessageCorrelator.validateCorrelationMetadata(correlationMeta)
    if not correlationMeta or type(correlationMeta) ~= "table" then
        return false, "Correlation metadata must be a table"
    end
    
    if not correlationMeta.id or type(correlationMeta.id) ~= "string" then
        return false, "Correlation ID is required and must be a string"
    end
    
    if not correlationMeta.origin or type(correlationMeta.origin) ~= "string" then
        return false, "Origin process ID is required and must be a string"
    end
    
    if not correlationMeta.target or type(correlationMeta.target) ~= "string" then
        return false, "Target process ID is required and must be a string"
    end
    
    return true
end

-- Get correlation statistics
function MessageCorrelator.getStatistics()
    local activeCount = 0
    local historyCount = 0
    local statusCounts = {}
    
    for _ in pairs(MessageCorrelator.activeCorrelations) do
        activeCount = activeCount + 1
    end
    
    for _ in pairs(MessageCorrelator.correlationHistory) do
        historyCount = historyCount + 1
    end
    
    for _, correlation in pairs(MessageCorrelator.activeCorrelations) do
        statusCounts[correlation.status] = (statusCounts[correlation.status] or 0) + 1
    end
    
    for _, correlation in pairs(MessageCorrelator.correlationHistory) do
        statusCounts[correlation.status] = (statusCounts[correlation.status] or 0) + 1
    end
    
    return {
        activeCorrelations = activeCount,
        historyCorrelations = historyCount,
        totalCorrelations = activeCount + historyCount,
        statusBreakdown = statusCounts,
        maxHistorySize = MessageCorrelator.maxHistorySize
    }
end


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")

-- Inter-Process Authentication Framework
-- Provides secure process identity validation and token-based authentication


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local ProcessAuthenticator = {
    -- Process registry storage
    processRegistry = {},
    
    -- Authentication token storage (active tokens)
    activeTokens = {},
    
    -- Token configuration
    tokenExpirationTime = 3600, -- 1 hour in seconds
    maxTokensPerProcess = 5,
    
    -- Process types for capability-based authentication
    PROCESS_TYPES = {
        COORDINATOR = "coordinator",
        BATTLE = "battle", 
        POKEMON = "pokemon",
        SHOP = "shop",
        SECURITY = "security",
        ADMIN = "admin"
    },
    
    -- Authentication levels
    AUTH_LEVELS = {
        NONE = "none",
        BASIC = "basic", 
        ELEVATED = "elevated",
        ADMIN = "admin"
    }
}

-- Initialize the authentication system
function ProcessAuthenticator.initialize()
    ProcessAuthenticator.processRegistry = {}
    ProcessAuthenticator.activeTokens = {}
    CryptoRNG.initGlobalRNG()
    print("[ProcessAuthenticator] Authentication system initialized")
end

-- Register a process with identity validation
function ProcessAuthenticator.registerProcess(processId, processType, walletAddress, capabilities, timestamp)
    if not processId or type(processId) ~= "string" or processId == "" then
        return false, "Process ID is required and must be a non-empty string"
    end
    
    if not processType or not ProcessAuthenticator.PROCESS_TYPES[processType:upper()] then
        return false, "Invalid process type. Must be one of: " .. table.concat(ProcessAuthenticator._getProcessTypeList(), ", ")
    end
    
    if not walletAddress or type(walletAddress) ~= "string" or walletAddress == "" then
        return false, "Wallet address is required for process identity validation"
    end
    
    if not capabilities or type(capabilities) ~= "table" then
        return false, "Capabilities must be provided as a table"
    end
    
    -- Validate wallet address format (basic validation)
    if not ProcessAuthenticator._validateWalletAddress(walletAddress) then
        return false, "Invalid wallet address format"
    end
    
    -- Check if process is already registered
    if ProcessAuthenticator.processRegistry[processId] then
        return false, "Process already registered: " .. processId
    end
    
    local currentTime = timestamp or 0
    local processRecord = {
        id = processId,
        type = processType:lower(),
        walletAddress = walletAddress,
        capabilities = capabilities,
        authLevel = ProcessAuthenticator._determineAuthLevel(processType, capabilities),
        status = "active",
        registeredAt = currentTime,
        lastHeartbeat = currentTime,
        tokenCount = 0
    }
    
    ProcessAuthenticator.processRegistry[processId] = processRecord
    
    print(string.format("[ProcessAuthenticator] Process registered: %s (Type: %s, Auth: %s)", 
          processId, processType, processRecord.authLevel))
    
    return true
end

-- Generate authentication token for a registered process
function ProcessAuthenticator.generateAuthToken(processId, requestingWallet, expirationTime, timestamp)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return nil, "Process not registered: " .. tostring(processId)
    end
    
    -- Validate requesting wallet matches registered wallet
    if processRecord.walletAddress ~= requestingWallet then
        return nil, "Wallet address mismatch for process authentication"
    end
    
    if processRecord.status ~= "active" then
        return nil, "Process is not active: " .. processId
    end
    
    -- Check token limit
    if processRecord.tokenCount >= ProcessAuthenticator.maxTokensPerProcess then
        return nil, "Maximum tokens exceeded for process: " .. processId
    end
    
    local tokenExpiration = expirationTime or ProcessAuthenticator.tokenExpirationTime
    local currentTime = timestamp or 0
    
    -- Generate unique token
    local tokenId = ProcessAuthenticator._generateTokenId()
    local tokenSignature = ProcessAuthenticator._generateTokenSignature(processId, tokenId, currentTime)
    
    local token = {
        id = tokenId,
        processId = processId,
        walletAddress = requestingWallet,
        signature = tokenSignature,
        authLevel = processRecord.authLevel,
        capabilities = processRecord.capabilities,
        issuedAt = currentTime,
        expiresAt = currentTime + tokenExpiration,
        status = "active"
    }
    
    ProcessAuthenticator.activeTokens[tokenId] = token
    processRecord.tokenCount = processRecord.tokenCount + 1
    processRecord.lastHeartbeat = currentTime
    
    return {
        tokenId = tokenId,
        signature = tokenSignature,
        expiresAt = token.expiresAt,
        authLevel = token.authLevel
    }
end

-- Validate authentication token and return process context
function ProcessAuthenticator.validateAuthToken(tokenId, signature, timestamp)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if not token then
        return false, nil, "Invalid token: not found"
    end
    
    if token.status ~= "active" then
        return false, nil, "Token is not active"
    end
    
    if (timestamp or 0) > token.expiresAt then
        ProcessAuthenticator._expireToken(tokenId)
        return false, nil, "Token has expired"
    end
    
    if token.signature ~= signature then
        return false, nil, "Token signature validation failed"
    end
    
    -- Return process authentication context
    local authContext = {
        processId = token.processId,
        walletAddress = token.walletAddress,
        authLevel = token.authLevel,
        capabilities = token.capabilities,
        tokenExpiration = token.expiresAt
    }
    
    return true, authContext, nil
end

-- Revoke authentication token
function ProcessAuthenticator.revokeAuthToken(tokenId, requestingProcessId)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if not token then
        return false, "Token not found: " .. tostring(tokenId)
    end
    
    -- Only the token owner or admin process can revoke
    if token.processId ~= requestingProcessId then
        local requestingProcess = ProcessAuthenticator.processRegistry[requestingProcessId]
        if not requestingProcess or requestingProcess.authLevel ~= ProcessAuthenticator.AUTH_LEVELS.ADMIN then
            return false, "Insufficient privileges to revoke token"
        end
    end
    
    ProcessAuthenticator._expireToken(tokenId)
    return true
end

-- Validate process-to-process communication authorization
function ProcessAuthenticator.validateProcessAuth(sourceProcessId, targetProcessId, operation, authToken, timestamp)
    -- Validate source process token
    local isValidToken, authContext, tokenError = ProcessAuthenticator.validateAuthToken(authToken.tokenId, authToken.signature, timestamp)
    if not isValidToken then
        return false, "Source process authentication failed: " .. tostring(tokenError)
    end
    
    if authContext.processId ~= sourceProcessId then
        return false, "Token process ID mismatch"
    end
    
    -- Check if target process exists and is active
    local targetProcess = ProcessAuthenticator.processRegistry[targetProcessId]
    if not targetProcess then
        return false, "Target process not registered: " .. targetProcessId
    end
    
    if targetProcess.status ~= "active" then
        return false, "Target process is not active: " .. targetProcessId
    end
    
    -- Validate operation authorization based on capabilities
    if not ProcessAuthenticator._isOperationAuthorized(authContext.capabilities, operation) then
        return false, "Operation not authorized for source process capabilities"
    end
    
    return true
end

-- Update process heartbeat
function ProcessAuthenticator.updateProcessHeartbeat(processId, timestamp)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return false, "Process not registered: " .. processId
    end
    
    processRecord.lastHeartbeat = timestamp or 0
    return true
end

-- Get registered process information
function ProcessAuthenticator.getProcessInfo(processId)
    local processRecord = ProcessAuthenticator.processRegistry[processId]
    if not processRecord then
        return nil
    end
    
    return {
        id = processRecord.id,
        type = processRecord.type,
        capabilities = processRecord.capabilities,
        authLevel = processRecord.authLevel,
        status = processRecord.status,
        registeredAt = processRecord.registeredAt,
        lastHeartbeat = processRecord.lastHeartbeat
    }
end

-- List all registered processes
function ProcessAuthenticator.listRegisteredProcesses(filterByType, filterByAuthLevel)
    local processes = {}
    
    for processId, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        local includeProcess = true
        
        if filterByType and processRecord.type ~= filterByType then
            includeProcess = false
        end
        
        if filterByAuthLevel and processRecord.authLevel ~= filterByAuthLevel then
            includeProcess = false
        end
        
        if includeProcess then
            processes[processId] = ProcessAuthenticator.getProcessInfo(processId)
        end
    end
    
    return processes
end

-- Clean up expired tokens and inactive processes
function ProcessAuthenticator.cleanup(timestamp)
    local currentTime = timestamp or 0
    local expiredTokens = 0
    local inactiveProcesses = 0
    
    -- Clean up expired tokens
    for tokenId, token in pairs(ProcessAuthenticator.activeTokens) do
        if currentTime > token.expiresAt then
            ProcessAuthenticator._expireToken(tokenId)
            expiredTokens = expiredTokens + 1
        end
    end
    
    -- Mark processes inactive if no heartbeat for too long (2x token expiration)
    local inactiveThreshold = ProcessAuthenticator.tokenExpirationTime * 2
    for processId, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        if processRecord.status == "active" and 
           (currentTime - processRecord.lastHeartbeat) > inactiveThreshold then
            processRecord.status = "inactive"
            inactiveProcesses = inactiveProcesses + 1
        end
    end
    
    return {
        expiredTokens = expiredTokens,
        inactiveProcesses = inactiveProcesses
    }
end

-- Get authentication statistics
function ProcessAuthenticator.getStatistics()
    local registeredProcesses = 0
    local activeProcesses = 0
    local activeTokens = 0
    local processTypes = {}
    local authLevels = {}
    
    for _, processRecord in pairs(ProcessAuthenticator.processRegistry) do
        registeredProcesses = registeredProcesses + 1
        if processRecord.status == "active" then
            activeProcesses = activeProcesses + 1
        end
        
        processTypes[processRecord.type] = (processTypes[processRecord.type] or 0) + 1
        authLevels[processRecord.authLevel] = (authLevels[processRecord.authLevel] or 0) + 1
    end
    
    for _ in pairs(ProcessAuthenticator.activeTokens) do
        activeTokens = activeTokens + 1
    end
    
    return {
        registeredProcesses = registeredProcesses,
        activeProcesses = activeProcesses,
        inactiveProcesses = registeredProcesses - activeProcesses,
        activeTokens = activeTokens,
        maxTokensPerProcess = ProcessAuthenticator.maxTokensPerProcess,
        tokenExpirationTime = ProcessAuthenticator.tokenExpirationTime,
        processTypeBreakdown = processTypes,
        authLevelBreakdown = authLevels
    }
end

-- Private helper functions

function ProcessAuthenticator._validateWalletAddress(walletAddress)
    -- Basic validation: should be 43 characters and alphanumeric with specific chars
    if type(walletAddress) ~= "string" or #walletAddress ~= 43 then
        return false
    end
    
    -- Check for valid Arweave wallet address pattern (Base64URL)
    return string.match(walletAddress, "^[A-Za-z0-9_%-]+$") ~= nil
end

function ProcessAuthenticator._determineAuthLevel(processType, capabilities)
    local normalizedType = processType:lower()
    
    if normalizedType == ProcessAuthenticator.PROCESS_TYPES.ADMIN then
        return ProcessAuthenticator.AUTH_LEVELS.ADMIN
    elseif normalizedType == ProcessAuthenticator.PROCESS_TYPES.SECURITY or
           normalizedType == ProcessAuthenticator.PROCESS_TYPES.COORDINATOR then
        return ProcessAuthenticator.AUTH_LEVELS.ELEVATED
    else
        return ProcessAuthenticator.AUTH_LEVELS.BASIC
    end
end

function ProcessAuthenticator._generateTokenId()
    local timestamp = msg.Timestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    return "token_" .. timestamp .. "_" .. randomSuffix
end

function ProcessAuthenticator._generateTokenSignature(processId, tokenId, timestamp)
    -- Generate signature using process ID, token ID, and timestamp
    local signatureBase = processId .. "|" .. tokenId .. "|" .. timestamp
    
    -- Use crypto module for signing (in real AO environment)
    -- For now, use a deterministic hash-like generation
    local signature = ""
    for i = 1, #signatureBase do
        local char = string.sub(signatureBase, i, i)
        signature = signature .. string.format("%02x", string.byte(char))
    end
    
    -- Add random suffix using CryptoRNG
    local randomSuffix = CryptoRNG.random(1000000, 9999999)
    return signature .. "_" .. randomSuffix
end

function ProcessAuthenticator._expireToken(tokenId)
    local token = ProcessAuthenticator.activeTokens[tokenId]
    if token then
        -- Decrease token count for the process
        local processRecord = ProcessAuthenticator.processRegistry[token.processId]
        if processRecord then
            processRecord.tokenCount = math.max(0, processRecord.tokenCount - 1)
        end
        
        -- Remove token from active tokens
        ProcessAuthenticator.activeTokens[tokenId] = nil
    end
end

function ProcessAuthenticator._isOperationAuthorized(capabilities, operation)
    if not capabilities or type(capabilities) ~= "table" then
        return false
    end
    
    -- Check if operation is in capabilities list
    for _, capability in ipairs(capabilities) do
        if capability == operation or capability == "*" then
            return true
        end
    end
    
    return false
end

function ProcessAuthenticator._getProcessTypeList()
    local types = {}
    for _, processType in pairs(ProcessAuthenticator.PROCESS_TYPES) do
        table.insert(types, processType:upper())
    end
    return types
end


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: game-logic.process-coordination.message-router =====
-- File: ao-processes/game-logic/process-coordination/message-router.lua
-- Original require: local MessageRouter = require("game-logic.process-coordination.message-router")

-- Message Routing Layer for Inter-Process Communication
-- Routes messages based on operation type and maintains routing tables


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


local MessageRouter = {
    -- Routing table mapping operation types to process types
    operationRoutes = {},
    
    -- Process capability routing cache
    processCapabilities = {},
    
    -- Load balancing state for multiple processes of same type
    loadBalancingState = {},
    
    -- Routing statistics
    routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
}

-- Operation types for routing classification
MessageRouter.OPERATION_TYPES = {
    -- Battle operations
    BATTLE_RESOLUTION = "BATTLE_RESOLUTION",
    BATTLE_START = "BATTLE_START",
    BATTLE_END = "BATTLE_END",
    MOVE_EXECUTION = "MOVE_EXECUTION",
    
    -- Pokemon operations  
    POKEMON_UPDATE = "POKEMON_UPDATE",
    POKEMON_EVOLUTION = "POKEMON_EVOLUTION",
    STAT_CALCULATION = "STAT_CALCULATION",
    POKEMON_CAPTURE = "POKEMON_CAPTURE",
    
    -- Shop operations
    SHOP_TRANSACTION = "SHOP_TRANSACTION", 
    SHOP_INVENTORY = "SHOP_INVENTORY",
    ITEM_PURCHASE = "ITEM_PURCHASE",
    ITEM_SALE = "ITEM_SALE",
    
    -- Game state operations
    SAVE_GAME = "SAVE_GAME",
    LOAD_GAME = "LOAD_GAME",
    SYNC_STATE = "SYNC_STATE",
    
    -- Admin operations
    PROCESS_HEALTH = "PROCESS_HEALTH",
    SYSTEM_STATUS = "SYSTEM_STATUS",
    CONFIGURATION_UPDATE = "CONFIGURATION_UPDATE"
}

-- Default routing table
MessageRouter.DEFAULT_ROUTES = {
    -- Battle operations route to battle processes
    [MessageRouter.OPERATION_TYPES.BATTLE_RESOLUTION] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.BATTLE_START] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.BATTLE_END] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    [MessageRouter.OPERATION_TYPES.MOVE_EXECUTION] = ProcessAuthenticator.PROCESS_TYPES.BATTLE,
    
    -- Pokemon operations route to pokemon processes
    [MessageRouter.OPERATION_TYPES.POKEMON_UPDATE] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.POKEMON_EVOLUTION] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.STAT_CALCULATION] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    [MessageRouter.OPERATION_TYPES.POKEMON_CAPTURE] = ProcessAuthenticator.PROCESS_TYPES.POKEMON,
    
    -- Shop operations route to shop processes
    [MessageRouter.OPERATION_TYPES.SHOP_TRANSACTION] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.SHOP_INVENTORY] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.ITEM_PURCHASE] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    [MessageRouter.OPERATION_TYPES.ITEM_SALE] = ProcessAuthenticator.PROCESS_TYPES.SHOP,
    
    -- Game state operations route to coordinator processes
    [MessageRouter.OPERATION_TYPES.SAVE_GAME] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    [MessageRouter.OPERATION_TYPES.LOAD_GAME] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    [MessageRouter.OPERATION_TYPES.SYNC_STATE] = ProcessAuthenticator.PROCESS_TYPES.COORDINATOR,
    
    -- Admin operations route to admin processes
    [MessageRouter.OPERATION_TYPES.PROCESS_HEALTH] = ProcessAuthenticator.PROCESS_TYPES.ADMIN,
    [MessageRouter.OPERATION_TYPES.SYSTEM_STATUS] = ProcessAuthenticator.PROCESS_TYPES.ADMIN,
    [MessageRouter.OPERATION_TYPES.CONFIGURATION_UPDATE] = ProcessAuthenticator.PROCESS_TYPES.ADMIN
}

-- Routing strategies
MessageRouter.ROUTING_STRATEGIES = {
    ROUND_ROBIN = "round_robin",
    LEAST_LOADED = "least_loaded",
    CAPABILITY_MATCH = "capability_match",
    RANDOM = "random"
}

-- Initialize the message router
function MessageRouter.initialize()
    -- Copy default routes to active routing table
    MessageRouter.operationRoutes = {}
    for operation, processType in pairs(MessageRouter.DEFAULT_ROUTES) do
        MessageRouter.operationRoutes[operation] = processType
    end
    
    MessageRouter.processCapabilities = {}
    MessageRouter.loadBalancingState = {}
    MessageRouter.routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
    
    print("[MessageRouter] Message routing system initialized")
end

-- Add or update routing rule
function MessageRouter.addRoute(operationType, targetProcessType, priority)
    if not operationType or not targetProcessType then
        return false, "Operation type and target process type are required"
    end
    
    if not MessageRouter.OPERATION_TYPES[operationType] and not operationType then
        return false, "Invalid operation type: " .. tostring(operationType)
    end
    
    local validProcessTypes = ProcessAuthenticator._getProcessTypeList()
    local isValidProcessType = false
    for _, processType in ipairs(validProcessTypes) do
        if processType:lower() == targetProcessType:lower() then
            isValidProcessType = true
            break
        end
    end
    
    if not isValidProcessType then
        return false, "Invalid target process type: " .. tostring(targetProcessType)
    end
    
    MessageRouter.operationRoutes[operationType] = {
        processType = targetProcessType:lower(),
        priority = priority or "NORMAL",
        addedAt = timestamp or 0
    }
    
    return true
end

-- Remove routing rule
function MessageRouter.removeRoute(operationType)
    if not operationType then
        return false, "Operation type is required"
    end
    
    if MessageRouter.operationRoutes[operationType] then
        MessageRouter.operationRoutes[operationType] = nil
        return true
    end
    
    return false, "Route not found for operation: " .. tostring(operationType)
end

-- Route a message to appropriate process based on operation type
function MessageRouter.routeMessage(operationType, messageData, routingStrategy)
    MessageRouter.routingStats.totalRoutes = MessageRouter.routingStats.totalRoutes + 1
    MessageRouter.routingStats.routesByOperation[operationType] = (MessageRouter.routingStats.routesByOperation[operationType] or 0) + 1
    
    local strategy = routingStrategy or MessageRouter.ROUTING_STRATEGIES.CAPABILITY_MATCH
    
    -- Get target process type from routing table
    local routeInfo = MessageRouter.operationRoutes[operationType]
    if not routeInfo then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "No route found for operation: " .. tostring(operationType)
    end
    
    local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
    
    -- Get available processes for target type
    local availableProcesses = ProcessAuthenticator.listRegisteredProcesses(targetProcessType)
    if not availableProcesses or MessageRouter._getTableSize(availableProcesses) == 0 then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "No available processes of type: " .. targetProcessType
    end
    
    -- Select target process based on routing strategy
    local targetProcessId = MessageRouter._selectTargetProcess(availableProcesses, strategy, operationType)
    if not targetProcessId then
        MessageRouter.routingStats.failedRoutes = MessageRouter.routingStats.failedRoutes + 1
        return nil, "Failed to select target process for operation: " .. operationType
    end
    
    -- Create routing context
    local routingContext = {
        operationType = operationType,
        targetProcessId = targetProcessId,
        targetProcessType = targetProcessType,
        routingStrategy = strategy,
        routedAt = timestamp or 0,
        messageData = messageData
    }
    
    MessageRouter.routingStats.successfulRoutes = MessageRouter.routingStats.successfulRoutes + 1
    MessageRouter.routingStats.routesByProcessType[targetProcessType] = (MessageRouter.routingStats.routesByProcessType[targetProcessType] or 0) + 1
    
    return routingContext
end

-- Get routing information for operation type
function MessageRouter.getRouteInfo(operationType)
    local routeInfo = MessageRouter.operationRoutes[operationType]
    if not routeInfo then
        return nil
    end
    
    local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
    local availableProcesses = ProcessAuthenticator.listRegisteredProcesses(targetProcessType)
    
    return {
        operationType = operationType,
        targetProcessType = targetProcessType,
        priority = type(routeInfo) == "table" and routeInfo.priority or "NORMAL",
        availableProcessCount = MessageRouter._getTableSize(availableProcesses),
        availableProcessIds = MessageRouter._getProcessIds(availableProcesses)
    }
end

-- Validate message routing capability
function MessageRouter.validateRouting(operationType, sourceProcessId, targetProcessId)
    -- Check if operation type has a valid route
    local routeInfo = MessageRouter.getRouteInfo(operationType)
    if not routeInfo then
        return false, "No route configured for operation: " .. tostring(operationType)
    end
    
    -- Check if target process exists and is active
    local targetProcess = ProcessAuthenticator.getProcessInfo(targetProcessId)
    if not targetProcess then
        return false, "Target process not found: " .. tostring(targetProcessId)
    end
    
    if targetProcess.status ~= "active" then
        return false, "Target process is not active: " .. targetProcessId
    end
    
    -- Check if target process type matches route
    if targetProcess.type ~= routeInfo.targetProcessType then
        return false, string.format("Process type mismatch. Expected: %s, Got: %s", 
                                   routeInfo.targetProcessType, targetProcess.type)
    end
    
    -- Check if target process has required capability
    if not MessageRouter._processHasCapability(targetProcess.capabilities, operationType) then
        return false, "Target process lacks required capability for operation: " .. operationType
    end
    
    return true
end

-- Update process capabilities cache
function MessageRouter.updateProcessCapabilities(processId, capabilities)
    if not processId or not capabilities then
        return false
    end
    
    MessageRouter.processCapabilities[processId] = {
        capabilities = capabilities,
        lastUpdated = timestamp or 0
    }
    
    return true
end

-- Get all configured routes
function MessageRouter.getAllRoutes()
    local routes = {}
    
    for operationType, routeInfo in pairs(MessageRouter.operationRoutes) do
        local targetProcessType = type(routeInfo) == "table" and routeInfo.processType or routeInfo
        local priority = type(routeInfo) == "table" and routeInfo.priority or "NORMAL"
        
        routes[operationType] = {
            targetProcessType = targetProcessType,
            priority = priority,
            availableProcesses = MessageRouter._getTableSize(ProcessAuthenticator.listRegisteredProcesses(targetProcessType))
        }
    end
    
    return routes
end

-- Get routing statistics
function MessageRouter.getRoutingStatistics()
    return {
        totalRoutes = MessageRouter.routingStats.totalRoutes,
        successfulRoutes = MessageRouter.routingStats.successfulRoutes,
        failedRoutes = MessageRouter.routingStats.failedRoutes,
        successRate = MessageRouter.routingStats.totalRoutes > 0 and 
                     (MessageRouter.routingStats.successfulRoutes / MessageRouter.routingStats.totalRoutes) or 0,
        routesByOperation = MessageRouter.routingStats.routesByOperation,
        routesByProcessType = MessageRouter.routingStats.routesByProcessType,
        configuredRoutes = MessageRouter._getTableSize(MessageRouter.operationRoutes)
    }
end

-- Reset routing statistics
function MessageRouter.resetStatistics()
    MessageRouter.routingStats = {
        totalRoutes = 0,
        successfulRoutes = 0,
        failedRoutes = 0,
        routesByOperation = {},
        routesByProcessType = {}
    }
end

-- Private helper functions

function MessageRouter._selectTargetProcess(availableProcesses, strategy, operationType)
    if MessageRouter._getTableSize(availableProcesses) == 0 then
        return nil
    end
    
    local processIds = MessageRouter._getProcessIds(availableProcesses)
    
    if strategy == MessageRouter.ROUTING_STRATEGIES.ROUND_ROBIN then
        return MessageRouter._roundRobinSelection(processIds, operationType)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.CAPABILITY_MATCH then
        return MessageRouter._capabilityMatchSelection(availableProcesses, operationType)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.RANDOM then
        return MessageRouter._randomSelection(processIds)
        
    elseif strategy == MessageRouter.ROUTING_STRATEGIES.LEAST_LOADED then
        -- For now, fallback to round robin (load tracking would be implemented later)
        return MessageRouter._roundRobinSelection(processIds, operationType)
        
    else
        -- Default to first available process
        return processIds[1]
    end
end

function MessageRouter._roundRobinSelection(processIds, operationType)
    if not MessageRouter.loadBalancingState[operationType] then
        MessageRouter.loadBalancingState[operationType] = 0
    end
    
    local index = (MessageRouter.loadBalancingState[operationType] % #processIds) + 1
    MessageRouter.loadBalancingState[operationType] = MessageRouter.loadBalancingState[operationType] + 1
    
    return processIds[index]
end

function MessageRouter._capabilityMatchSelection(availableProcesses, operationType)
    -- Select process with best capability match
    for processId, processInfo in pairs(availableProcesses) do
        if MessageRouter._processHasCapability(processInfo.capabilities, operationType) then
            return processId
        end
    end
    
    -- Fallback to first available if no perfect match
    local processIds = MessageRouter._getProcessIds(availableProcesses)
    return processIds[1]
end

function MessageRouter._randomSelection(processIds)
    local randomIndex = math.random(1, #processIds)
    return processIds[randomIndex]
end

function MessageRouter._processHasCapability(capabilities, operationType)
    if not capabilities or type(capabilities) ~= "table" then
        return false
    end
    
    for _, capability in ipairs(capabilities) do
        if capability == "*" or capability == operationType or 
           MessageRouter._isRelatedCapability(capability, operationType) then
            return true
        end
    end
    
    return false
end

function MessageRouter._isRelatedCapability(capability, operationType)
    -- Check if capability covers the operation type
    local capabilityMappings = {
        ["battle-resolution"] = {"BATTLE_RESOLUTION", "BATTLE_START", "BATTLE_END", "MOVE_EXECUTION"},
        ["pokemon-management"] = {"POKEMON_UPDATE", "POKEMON_EVOLUTION", "STAT_CALCULATION", "POKEMON_CAPTURE"},
        ["shop-operations"] = {"SHOP_TRANSACTION", "SHOP_INVENTORY", "ITEM_PURCHASE", "ITEM_SALE"},
        ["game-state"] = {"SAVE_GAME", "LOAD_GAME", "SYNC_STATE"},
        ["admin-operations"] = {"PROCESS_HEALTH", "SYSTEM_STATUS", "CONFIGURATION_UPDATE"}
    }
    
    local relatedOperations = capabilityMappings[capability]
    if relatedOperations then
        for _, operation in ipairs(relatedOperations) do
            if operation == operationType then
                return true
            end
        end
    end
    
    return false
end

function MessageRouter._getProcessIds(processes)
    local ids = {}
    for processId, _ in pairs(processes) do
        table.insert(ids, processId)
    end
    return ids
end

function MessageRouter._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: game-logic.process-coordination.message-router =====


-- ===== MODULE: game-logic.process-coordination.performance-monitor =====
-- File: ao-processes/game-logic/process-coordination/performance-monitor.lua
-- Original require: local PerformanceMonitor = require("game-logic.process-coordination.performance-monitor")

-- Performance Monitoring and Benchmarking System
-- Provides baseline performance metrics and inter-process communication monitoring

local PerformanceMonitor = {
    -- Performance metrics storage
    metrics = {
        totalOperations = 0,
        totalLatency = 0,
        minLatency = nil,
        maxLatency = nil,
        averageLatency = 0,
        
        -- Operation-specific metrics
        operationMetrics = {},
        
        -- Process-specific metrics  
        processMetrics = {},
        
        -- Throughput tracking
        operationsPerSecond = 0,
        lastThroughputUpdate = 0,
        currentSecondOperations = 0,
        
        -- Memory and resource usage
        memoryUsage = {},
        
        -- Error rate tracking
        totalErrors = 0,
        errorRate = 0
    },
    
    -- Benchmark baselines for comparison
    baselines = {
        monolithicLatency = 0, -- To be measured
        maxAcceptableLatency = 100, -- milliseconds
        targetThroughput = 100, -- operations per second
        maxMemoryUsage = 1024 * 1024 * 50 -- 50MB in bytes
    },
    
    -- Active performance measurements
    activeMeasurements = {}
}

-- Initialize performance monitoring system
function PerformanceMonitor.initialize(timestamp)
    PerformanceMonitor.metrics.totalOperations = 0
    PerformanceMonitor.metrics.totalLatency = 0
    PerformanceMonitor.metrics.averageLatency = 0
    PerformanceMonitor.metrics.lastThroughputUpdate = timestamp or 0
    
    return true
end

-- Start measuring operation performance
function PerformanceMonitor.startMeasurement(operationId, operationType, processId, timestamp)
    if not operationId then
        return false, "Operation ID is required for performance measurement"
    end
    
    local startTime = os.clock() * 1000 -- Convert to milliseconds
    local startMemory = collectgarbage("count") * 1024 -- Convert KB to bytes
    
    PerformanceMonitor.activeMeasurements[operationId] = {
        operationType = operationType,
        processId = processId,
        startTime = startTime,
        startMemory = startMemory,
        timestamp = timestamp or 0
    }
    
    return true
end

-- End measuring operation performance and record metrics
function PerformanceMonitor.endMeasurement(operationId, success, errorCode)
    local measurement = PerformanceMonitor.activeMeasurements[operationId]
    if not measurement then
        return false, "No active measurement found for operation: " .. tostring(operationId)
    end
    
    local endTime = os.clock() * 1000 -- Convert to milliseconds
    local endMemory = collectgarbage("count") * 1024 -- Convert KB to bytes
    
    local latency = endTime - measurement.startTime
    local memoryDelta = endMemory - measurement.startMemory
    
    -- Update global metrics
    PerformanceMonitor.metrics.totalOperations = PerformanceMonitor.metrics.totalOperations + 1
    PerformanceMonitor.metrics.totalLatency = PerformanceMonitor.metrics.totalLatency + latency
    PerformanceMonitor.metrics.averageLatency = PerformanceMonitor.metrics.totalLatency / PerformanceMonitor.metrics.totalOperations
    
    -- Update min/max latency
    if not PerformanceMonitor.metrics.minLatency or latency < PerformanceMonitor.metrics.minLatency then
        PerformanceMonitor.metrics.minLatency = latency
    end
    if not PerformanceMonitor.metrics.maxLatency or latency > PerformanceMonitor.metrics.maxLatency then
        PerformanceMonitor.metrics.maxLatency = latency
    end
    
    -- Update operation-specific metrics
    local opType = measurement.operationType or "unknown"
    if not PerformanceMonitor.metrics.operationMetrics[opType] then
        PerformanceMonitor.metrics.operationMetrics[opType] = {
            count = 0,
            totalLatency = 0,
            averageLatency = 0,
            minLatency = nil,
            maxLatency = nil,
            successCount = 0,
            errorCount = 0,
            memoryUsage = { total = 0, average = 0, min = nil, max = nil }
        }
    end
    
    local opMetrics = PerformanceMonitor.metrics.operationMetrics[opType]
    opMetrics.count = opMetrics.count + 1
    opMetrics.totalLatency = opMetrics.totalLatency + latency
    opMetrics.averageLatency = opMetrics.totalLatency / opMetrics.count
    
    if not opMetrics.minLatency or latency < opMetrics.minLatency then
        opMetrics.minLatency = latency
    end
    if not opMetrics.maxLatency or latency > opMetrics.maxLatency then
        opMetrics.maxLatency = latency
    end
    
    if success then
        opMetrics.successCount = opMetrics.successCount + 1
    else
        opMetrics.errorCount = opMetrics.errorCount + 1
        PerformanceMonitor.metrics.totalErrors = PerformanceMonitor.metrics.totalErrors + 1
    end
    
    -- Track memory usage
    opMetrics.memoryUsage.total = opMetrics.memoryUsage.total + memoryDelta
    opMetrics.memoryUsage.average = opMetrics.memoryUsage.total / opMetrics.count
    if not opMetrics.memoryUsage.min or memoryDelta < opMetrics.memoryUsage.min then
        opMetrics.memoryUsage.min = memoryDelta
    end
    if not opMetrics.memoryUsage.max or memoryDelta > opMetrics.memoryUsage.max then
        opMetrics.memoryUsage.max = memoryDelta
    end
    
    -- Update process-specific metrics
    local processId = measurement.processId or "unknown"
    if not PerformanceMonitor.metrics.processMetrics[processId] then
        PerformanceMonitor.metrics.processMetrics[processId] = {
            operationCount = 0,
            totalLatency = 0,
            averageLatency = 0,
            errorCount = 0
        }
    end
    
    local procMetrics = PerformanceMonitor.metrics.processMetrics[processId]
    procMetrics.operationCount = procMetrics.operationCount + 1
    procMetrics.totalLatency = procMetrics.totalLatency + latency
    procMetrics.averageLatency = procMetrics.totalLatency / procMetrics.operationCount
    
    if not success then
        procMetrics.errorCount = procMetrics.errorCount + 1
    end
    
    -- Update throughput metrics
    PerformanceMonitor.updateThroughputMetrics()
    
    -- Update error rate
    PerformanceMonitor.metrics.errorRate = PerformanceMonitor.metrics.totalErrors / PerformanceMonitor.metrics.totalOperations
    
    -- Clean up active measurement
    PerformanceMonitor.activeMeasurements[operationId] = nil
    
    return {
        operationId = operationId,
        operationType = opType,
        processId = processId,
        latency = latency,
        memoryDelta = memoryDelta,
        success = success,
        errorCode = errorCode,
        timestamp = timestamp or 0
    }
end

-- Update throughput metrics (operations per second)
function PerformanceMonitor.updateThroughputMetrics(timestamp)
    local currentTime = timestamp or 0
    local timeDiff = currentTime - PerformanceMonitor.metrics.lastThroughputUpdate
    
    if timeDiff >= 1 then -- Update every second
        PerformanceMonitor.metrics.operationsPerSecond = PerformanceMonitor.metrics.currentSecondOperations / timeDiff
        PerformanceMonitor.metrics.currentSecondOperations = 0
        PerformanceMonitor.metrics.lastThroughputUpdate = currentTime
    end
    
    PerformanceMonitor.metrics.currentSecondOperations = PerformanceMonitor.metrics.currentSecondOperations + 1
end

-- Get current performance metrics
function PerformanceMonitor.getMetrics()
    return PerformanceMonitor.metrics
end

-- Get performance metrics for specific operation type
function PerformanceMonitor.getOperationMetrics(operationType)
    return PerformanceMonitor.metrics.operationMetrics[operationType]
end

-- Get performance metrics for specific process
function PerformanceMonitor.getProcessMetrics(processId)
    return PerformanceMonitor.metrics.processMetrics[processId]
end

-- Set performance baseline for comparison
function PerformanceMonitor.setBaseline(baselineType, value)
    if not baselineType or not value then
        return false, "Baseline type and value are required"
    end
    
    PerformanceMonitor.baselines[baselineType] = value
    return true
end

-- Get performance baselines
function PerformanceMonitor.getBaselines()
    return PerformanceMonitor.baselines
end

-- Compare current performance against baselines
function PerformanceMonitor.compareToBaselines()
    local comparison = {
        latencyComparison = {},
        throughputComparison = {},
        memoryComparison = {},
        performanceRegression = false,
        recommendations = {}
    }
    
    -- Latency comparison
    local avgLatency = PerformanceMonitor.metrics.averageLatency
    local baselineLatency = PerformanceMonitor.baselines.monolithicLatency
    
    if baselineLatency > 0 then
        local latencyRatio = avgLatency / baselineLatency
        comparison.latencyComparison = {
            current = avgLatency,
            baseline = baselineLatency,
            ratio = latencyRatio,
            degradation = latencyRatio > 1.1, -- 10% tolerance
            improvement = latencyRatio < 0.9
        }
        
        if latencyRatio > 1.2 then -- 20% degradation threshold
            comparison.performanceRegression = true
            table.insert(comparison.recommendations, "Latency degradation detected: " .. math.floor((latencyRatio - 1) * 100) .. "% slower than baseline")
        end
    end
    
    -- Throughput comparison
    local currentThroughput = PerformanceMonitor.metrics.operationsPerSecond
    local targetThroughput = PerformanceMonitor.baselines.targetThroughput
    
    comparison.throughputComparison = {
        current = currentThroughput,
        target = targetThroughput,
        meetingTarget = currentThroughput >= targetThroughput * 0.9 -- 10% tolerance
    }
    
    if not comparison.throughputComparison.meetingTarget then
        table.insert(comparison.recommendations, "Throughput below target: " .. currentThroughput .. " vs " .. targetThroughput .. " ops/sec")
    end
    
    -- Memory comparison
    local currentMemory = collectgarbage("count") * 1024
    local maxMemory = PerformanceMonitor.baselines.maxMemoryUsage
    
    comparison.memoryComparison = {
        current = currentMemory,
        maximum = maxMemory,
        withinLimits = currentMemory <= maxMemory
    }
    
    if not comparison.memoryComparison.withinLimits then
        comparison.performanceRegression = true
        table.insert(comparison.recommendations, "Memory usage exceeds limits: " .. math.floor(currentMemory/1024/1024) .. "MB vs " .. math.floor(maxMemory/1024/1024) .. "MB limit")
    end
    
    return comparison
end

-- Generate performance report
function PerformanceMonitor.generatePerformanceReport()
    local metrics = PerformanceMonitor.getMetrics()
    local baselines = PerformanceMonitor.getBaselines()
    local comparison = PerformanceMonitor.compareToBaselines()
    
    return {
        summary = {
            totalOperations = metrics.totalOperations,
            averageLatency = metrics.averageLatency,
            minLatency = metrics.minLatency,
            maxLatency = metrics.maxLatency,
            throughput = metrics.operationsPerSecond,
            errorRate = metrics.errorRate,
            memoryUsage = collectgarbage("count") * 1024
        },
        baselines = baselines,
        comparison = comparison,
        operationBreakdown = metrics.operationMetrics,
        processBreakdown = metrics.processMetrics,
        recommendations = comparison.recommendations,
        generatedAt = timestamp or 0
    }
end

-- Reset performance metrics (useful for testing)
function PerformanceMonitor.resetMetrics(timestamp)
    PerformanceMonitor.metrics = {
        totalOperations = 0,
        totalLatency = 0,
        minLatency = nil,
        maxLatency = nil,
        averageLatency = 0,
        operationMetrics = {},
        processMetrics = {},
        operationsPerSecond = 0,
        lastThroughputUpdate = timestamp or 0,
        currentSecondOperations = 0,
        memoryUsage = {},
        totalErrors = 0,
        errorRate = 0
    }
    PerformanceMonitor.activeMeasurements = {}
    return true
end

-- Clean up stale measurements (measurements older than 5 minutes)
function PerformanceMonitor.cleanupStaleMeasurements(timestamp)
    local currentTime = timestamp or 0
    local cleanedCount = 0
    
    for operationId, measurement in pairs(PerformanceMonitor.activeMeasurements) do
        if (currentTime - measurement.timestamp) > 300 then -- 5 minutes
            PerformanceMonitor.activeMeasurements[operationId] = nil
            cleanedCount = cleanedCount + 1
        end
    end
    
    return cleanedCount
end

-- Initialize on module load
PerformanceMonitor.initialize()


-- ===== END MODULE: game-logic.process-coordination.performance-monitor =====


-- Load security-specific components

-- ===== MODULE: security.components.validation-engine =====
-- File: ao-processes/security/components/validation-engine.lua
-- Original require: local ValidationEngine = require("security.components.validation-engine")

-- Security Validation Engine
-- Real-time validation system with custom Lua schemas


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local ValidationEngine = {
    -- Validation state
    validationRules = {},
    validationCache = {},
    validationMetrics = {
        totalValidations = 0,
        validationTime = 0,
        cacheHits = 0,
        validationFailures = 0
    },
    
    -- Configuration
    cacheTimeout = 300, -- 5 minutes
    maxCacheSize = 1000,
    maxValidationTime = 50 -- 50ms max for performance
}

-- Validation rule types
ValidationEngine.VALIDATION_TYPES = {
    INPUT = "INPUT",
    STATE = "STATE", 
    BEHAVIOR = "BEHAVIOR",
    INTEGRITY = "INTEGRITY"
}

-- Validation result actions
ValidationEngine.VALIDATION_ACTIONS = {
    ALLOW = "ALLOW",
    WARN = "WARN",
    BLOCK = "BLOCK",
    TERMINATE = "TERMINATE"
}

-- Initialize validation engine
function ValidationEngine.initialize()
    ValidationEngine.validationRules = {}
    ValidationEngine.validationCache = {}
    ValidationEngine.validationMetrics = {
        totalValidations = 0,
        validationTime = 0,
        cacheHits = 0,
        validationFailures = 0
    }
    
    -- Load default validation rules
    ValidationEngine._loadDefaultValidationRules()
    
    print("[ValidationEngine] Validation engine initialized with " .. 
          ValidationEngine._getTableSize(ValidationEngine.validationRules) .. " rules")
end

-- Load default validation rules
function ValidationEngine._loadDefaultValidationRules()
    -- Input validation rules
    ValidationEngine.addValidationRule({
        ruleId = "validate-message-format",
        ruleType = ValidationEngine.VALIDATION_TYPES.INPUT,
        processScope = {"*"},
        severity = "HIGH",
        enabled = true,
        validationLogic = function(data)
            if not data or type(data) ~= "table" then
                return false, "Data must be a table"
            end
            
            -- Check for required correlation metadata
            if not data.correlation or type(data.correlation) ~= "table" then
                return false, "Correlation metadata required"
            end
            
            if not data.correlation.id or type(data.correlation.id) ~= "string" then
                return false, "Correlation ID required"
            end
            
            return true, nil
        end
    })
    
    ValidationEngine.addValidationRule({
        ruleId = "validate-wallet-address",
        ruleType = ValidationEngine.VALIDATION_TYPES.INPUT,
        processScope = {"*"},
        severity = "HIGH",
        enabled = true,
        validationLogic = function(data)
            if data.playerId and type(data.playerId) == "string" then
                -- Basic Arweave wallet address validation (43 chars, Base64URL)
                if #data.playerId ~= 43 then
                    return false, "Invalid wallet address length"
                end
                
                if not string.match(data.playerId, "^[A-Za-z0-9_%-]+$") then
                    return false, "Invalid wallet address format"
                end
            end
            
            return true, nil
        end
    })
    
    ValidationEngine.addValidationRule({
        ruleId = "validate-data-types",
        ruleType = ValidationEngine.VALIDATION_TYPES.INPUT,
        processScope = {"*"},
        severity = "MEDIUM",
        enabled = true,
        validationLogic = function(data)
            -- Validate common data types
            if data.timestamp and type(data.timestamp) ~= "number" then
                return false, "Timestamp must be a number"
            end
            
            if data.processId and type(data.processId) ~= "string" then
                return false, "Process ID must be a string"
            end
            
            if data.operation and type(data.operation) ~= "string" then
                return false, "Operation must be a string"
            end
            
            return true, nil
        end
    })
    
    -- State validation rules
    ValidationEngine.addValidationRule({
        ruleId = "validate-pokemon-stats",
        ruleType = ValidationEngine.VALIDATION_TYPES.STATE,
        processScope = {"battle", "pokemon"},
        severity = "HIGH", 
        enabled = true,
        validationLogic = function(data)
            if data.pokemon then
                local pokemon = data.pokemon
                
                -- Check stat ranges (assuming max level 100)
                if pokemon.level and (pokemon.level < 1 or pokemon.level > 100) then
                    return false, "Invalid Pokemon level range"
                end
                
                -- Check HP range (basic validation)
                if pokemon.hp and pokemon.maxHp and pokemon.hp > pokemon.maxHp then
                    return false, "Pokemon HP exceeds max HP"
                end
                
                -- Check if stats are numbers
                local statNames = {"hp", "maxHp", "attack", "defense", "spAttack", "spDefense", "speed"}
                for _, statName in ipairs(statNames) do
                    if pokemon[statName] and type(pokemon[statName]) ~= "number" then
                        return false, "Pokemon " .. statName .. " must be a number"
                    end
                end
            end
            
            return true, nil
        end
    })
    
    -- Behavior validation rules
    ValidationEngine.addValidationRule({
        ruleId = "validate-action-frequency",
        ruleType = ValidationEngine.VALIDATION_TYPES.BEHAVIOR,
        processScope = {"battle"},
        severity = "MEDIUM",
        enabled = true,
        validationLogic = function(data)
            -- Check for rapid-fire actions (basic rate limiting)
            if data.playerId and data.timestamp then
                local cacheKey = "last_action_" .. data.playerId
                local lastActionTime = ValidationEngine.validationCache[cacheKey]
                
                if lastActionTime and (data.timestamp - lastActionTime) < 100 then -- 100ms minimum
                    return false, "Actions too frequent"
                end
                
                ValidationEngine.validationCache[cacheKey] = data.timestamp
            end
            
            return true, nil
        end
    })
end

-- Add validation rule
function ValidationEngine.addValidationRule(rule)
    if not rule.ruleId or type(rule.ruleId) ~= "string" then
        return false, "Rule ID required and must be a string"
    end
    
    if not rule.validationLogic or type(rule.validationLogic) ~= "function" then
        return false, "Validation logic function required"
    end
    
    if not rule.ruleType or not ValidationEngine.VALIDATION_TYPES[rule.ruleType] then
        return false, "Valid rule type required"
    end
    
    ValidationEngine.validationRules[rule.ruleId] = {
        ruleId = rule.ruleId,
        ruleType = rule.ruleType,
        processScope = rule.processScope or {"*"},
        validationLogic = rule.validationLogic,
        severity = rule.severity or "MEDIUM",
        enabled = rule.enabled ~= false,
        metadata = rule.metadata or {},
        createdAt = 0
    }
    
    return true, nil
end

-- Remove validation rule
function ValidationEngine.removeValidationRule(ruleId)
    if ValidationEngine.validationRules[ruleId] then
        ValidationEngine.validationRules[ruleId] = nil
        return true
    end
    return false
end

-- Enable/disable validation rule
function ValidationEngine.setRuleEnabled(ruleId, enabled)
    local rule = ValidationEngine.validationRules[ruleId]
    if rule then
        rule.enabled = enabled
        return true
    end
    return false
end

-- Perform validation with performance monitoring
function ValidationEngine.validate(validationType, data, processId)
    local startTime = msg.Timestamp -- milliseconds
    local violations = {}
    local applicableRules = 0
    
    -- Check cache first for identical validations
    local cacheKey = ValidationEngine._generateCacheKey(validationType, data, processId)
    local cachedResult = ValidationEngine._getCachedValidation(cacheKey)
    
    if cachedResult then
        ValidationEngine.validationMetrics.cacheHits = ValidationEngine.validationMetrics.cacheHits + 1
        return cachedResult.valid, cachedResult.violations, cachedResult.action, "CACHED"
    end
    
    -- Find applicable rules for this validation
    for ruleId, rule in pairs(ValidationEngine.validationRules) do
        if rule.enabled and 
           rule.ruleType == validationType and
           ValidationEngine._isRuleApplicable(rule, processId) then
            
            applicableRules = applicableRules + 1
            
            -- Execute validation logic
            local isValid, errorMessage = pcall(rule.validationLogic, data)
            
            if not isValid or errorMessage then
                table.insert(violations, {
                    ruleId = ruleId,
                    severity = rule.severity,
                    errorMessage = errorMessage or "Validation rule failed",
                    timestamp = 0
                })
                
                ValidationEngine.validationMetrics.validationFailures = 
                    ValidationEngine.validationMetrics.validationFailures + 1
            end
        end
    end
    
    -- Determine overall validation result and action
    local isValid = #violations == 0
    local action = ValidationEngine._determineValidationAction(violations)
    
    -- Calculate validation time
    local endTime = msg.Timestamp
    local validationTime = endTime - startTime
    
    -- Update metrics
    ValidationEngine.validationMetrics.totalValidations = ValidationEngine.validationMetrics.totalValidations + 1
    ValidationEngine.validationMetrics.validationTime = ValidationEngine.validationMetrics.validationTime + validationTime
    
    -- Cache result if validation was successful and not too complex
    if isValid and applicableRules <= 10 then
        ValidationEngine._cacheValidationResult(cacheKey, {
            valid = isValid,
            violations = violations,
            action = action,
            cachedAt = 0
        })
    end
    
    -- Performance warning if validation took too long
    if validationTime > ValidationEngine.maxValidationTime then
        print(string.format("[ValidationEngine] PERFORMANCE WARNING: Validation took %dms (max: %dms)", 
              validationTime, ValidationEngine.maxValidationTime))
    end
    
    return isValid, violations, action, "VALIDATED"
end

-- Determine validation action based on violations
function ValidationEngine._determineValidationAction(violations)
    if #violations == 0 then
        return ValidationEngine.VALIDATION_ACTIONS.ALLOW
    end
    
    -- Check for highest severity violation
    local highestSeverity = "LOW"
    for _, violation in ipairs(violations) do
        if violation.severity == "CRITICAL" then
            return ValidationEngine.VALIDATION_ACTIONS.TERMINATE
        elseif violation.severity == "HIGH" and highestSeverity ~= "CRITICAL" then
            highestSeverity = "HIGH"
        elseif violation.severity == "MEDIUM" and 
               highestSeverity ~= "CRITICAL" and highestSeverity ~= "HIGH" then
            highestSeverity = "MEDIUM"
        end
    end
    
    -- Map severity to action
    if highestSeverity == "HIGH" then
        return ValidationEngine.VALIDATION_ACTIONS.BLOCK
    elseif highestSeverity == "MEDIUM" then
        return ValidationEngine.VALIDATION_ACTIONS.WARN
    else
        return ValidationEngine.VALIDATION_ACTIONS.ALLOW
    end
end

-- Check if validation rule applies to process
function ValidationEngine._isRuleApplicable(rule, processId)
    if not rule.processScope then
        return true
    end
    
    for _, scopePattern in ipairs(rule.processScope) do
        if scopePattern == "*" or 
           scopePattern == processId or
           string.match(processId or "", scopePattern) then
            return true
        end
    end
    
    return false
end

-- Cache management functions
function ValidationEngine._generateCacheKey(validationType, data, processId)
    -- Generate deterministic cache key
    local keyData = {
        type = validationType,
        process = processId or "unknown",
        dataHash = ValidationEngine._hashData(data)
    }
    
    return validationType .. "_" .. (processId or "unknown") .. "_" .. ValidationEngine._hashData(data)
end

function ValidationEngine._hashData(data)
    -- Simple hash function for cache keys
    local str = json.encode(data) or "null"
    local hash = 0
    for i = 1, #str do
        local char = string.byte(str, i)
        hash = ((hash * 31) + char) % 1000000
    end
    return tostring(hash)
end

function ValidationEngine._getCachedValidation(cacheKey)
    local cached = ValidationEngine.validationCache[cacheKey]
    
    if cached and (0 - cached.cachedAt) < ValidationEngine.cacheTimeout then
        return cached
    end
    
    -- Remove expired cache entry
    if cached then
        ValidationEngine.validationCache[cacheKey] = nil
    end
    
    return nil
end

function ValidationEngine._cacheValidationResult(cacheKey, result)
    -- Check cache size limit
    local cacheSize = ValidationEngine._getTableSize(ValidationEngine.validationCache)
    
    if cacheSize >= ValidationEngine.maxCacheSize then
        ValidationEngine._cleanupCache()
    end
    
    ValidationEngine.validationCache[cacheKey] = result
end

function ValidationEngine._cleanupCache()
    -- Remove oldest 20% of cache entries
    local cacheEntries = {}
    for key, entry in pairs(ValidationEngine.validationCache) do
        table.insert(cacheEntries, {key = key, cachedAt = entry.cachedAt})
    end
    
    table.sort(cacheEntries, function(a, b) return a.cachedAt < b.cachedAt end)
    
    local removeCount = math.floor(#cacheEntries * 0.2)
    for i = 1, removeCount do
        ValidationEngine.validationCache[cacheEntries[i].key] = nil
    end
end

-- Get validation statistics
function ValidationEngine.getStatistics()
    local avgValidationTime = 0
    if ValidationEngine.validationMetrics.totalValidations > 0 then
        avgValidationTime = ValidationEngine.validationMetrics.validationTime / 
                           ValidationEngine.validationMetrics.totalValidations
    end
    
    return {
        totalValidations = ValidationEngine.validationMetrics.totalValidations,
        averageValidationTime = avgValidationTime,
        cacheHits = ValidationEngine.validationMetrics.cacheHits,
        validationFailures = ValidationEngine.validationMetrics.validationFailures,
        cacheHitRate = ValidationEngine.validationMetrics.totalValidations > 0 and
                      (ValidationEngine.validationMetrics.cacheHits / ValidationEngine.validationMetrics.totalValidations) or 0,
        activeRules = ValidationEngine._getTableSize(ValidationEngine.validationRules),
        cacheSize = ValidationEngine._getTableSize(ValidationEngine.validationCache),
        maxValidationTime = ValidationEngine.maxValidationTime
    }
end

-- Get average validation time
function ValidationEngine.getAverageValidationTime()
    if ValidationEngine.validationMetrics.totalValidations > 0 then
        return ValidationEngine.validationMetrics.validationTime / ValidationEngine.validationMetrics.totalValidations
    end
    return 0
end

-- Get health status
function ValidationEngine.getHealth()
    local stats = ValidationEngine.getStatistics()
    
    -- Check health based on performance and error rates
    if stats.averageValidationTime > ValidationEngine.maxValidationTime * 2 then
        return "DEGRADED"
    end
    
    if stats.totalValidations > 0 and 
       (stats.validationFailures / stats.totalValidations) > 0.5 then
        return "DEGRADED"
    end
    
    return "HEALTHY"
end

-- Get list of validation rules
function ValidationEngine.getValidationRules(ruleType, processId)
    local rules = {}
    
    for ruleId, rule in pairs(ValidationEngine.validationRules) do
        local includeRule = true
        
        if ruleType and rule.ruleType ~= ruleType then
            includeRule = false
        end
        
        if processId and not ValidationEngine._isRuleApplicable(rule, processId) then
            includeRule = false
        end
        
        if includeRule then
            rules[ruleId] = {
                ruleId = rule.ruleId,
                ruleType = rule.ruleType,
                processScope = rule.processScope,
                severity = rule.severity,
                enabled = rule.enabled,
                metadata = rule.metadata,
                createdAt = rule.createdAt
            }
        end
    end
    
    return rules
end

-- Helper function
function ValidationEngine._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: security.components.validation-engine =====


-- ===== MODULE: security.components.anti-cheat-detector =====
-- File: ao-processes/security/components/anti-cheat-detector.lua
-- Original require: local AntiCheatDetector = require("security.components.anti-cheat-detector")

-- Anti-Cheat Detection Engine
-- Detects impossible game states and suspicious behavioral patterns


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local AntiCheatDetector = {
    -- Detection state
    playerBehaviorProfiles = {},
    suspiciousActivities = {},
    cheatDetectionRules = {},
    statisticalBaselines = {},
    
    -- Detection metrics
    detectionMetrics = {
        totalChecks = 0,
        cheatsDetected = 0,
        falsePositives = 0,
        behaviorAnalyses = 0
    },
    
    -- Configuration
    suspicionThreshold = 75, -- 75% confidence for cheat detection
    behaviorWindowSize = 100, -- Track last 100 actions per player
    statisticalDeviationThreshold = 3.0 -- 3 standard deviations for anomaly
}

-- Cheat detection types
AntiCheatDetector.CHEAT_TYPES = {
    IMPOSSIBLE_STATE = "IMPOSSIBLE_STATE",
    STATISTICAL_ANOMALY = "STATISTICAL_ANOMALY", 
    BEHAVIORAL_PATTERN = "BEHAVIORAL_PATTERN",
    DATA_MANIPULATION = "DATA_MANIPULATION",
    TIME_MANIPULATION = "TIME_MANIPULATION"
}

-- Suspicion levels
AntiCheatDetector.SUSPICION_LEVELS = {
    LOW = 25,
    MEDIUM = 50,
    HIGH = 75,
    CRITICAL = 90
}

-- Initialize anti-cheat detector
function AntiCheatDetector.initialize()
    AntiCheatDetector.playerBehaviorProfiles = {}
    AntiCheatDetector.suspiciousActivities = {}
    AntiCheatDetector.cheatDetectionRules = {}
    AntiCheatDetector.statisticalBaselines = {}
    
    AntiCheatDetector.detectionMetrics = {
        totalChecks = 0,
        cheatsDetected = 0,
        falsePositives = 0,
        behaviorAnalyses = 0
    }
    
    -- Load default cheat detection rules
    AntiCheatDetector._loadDefaultDetectionRules()
    
    -- Initialize statistical baselines
    AntiCheatDetector._initializeStatisticalBaselines()
    
    print("[AntiCheatDetector] Anti-cheat detection engine initialized with " .. 
          AntiCheatDetector._getTableSize(AntiCheatDetector.cheatDetectionRules) .. " detection rules")
end

-- Load default cheat detection rules
function AntiCheatDetector._loadDefaultDetectionRules()
    -- Impossible Pokemon state detection
    AntiCheatDetector.addDetectionRule({
        ruleId = "impossible-pokemon-stats",
        cheatType = AntiCheatDetector.CHEAT_TYPES.IMPOSSIBLE_STATE,
        suspicionLevel = AntiCheatDetector.SUSPICION_LEVELS.CRITICAL,
        detectionLogic = function(data)
            if data.pokemon then
                local pokemon = data.pokemon
                
                -- Check for impossible stat values
                if pokemon.level and pokemon.level > 100 then
                    return true, "Pokemon level exceeds maximum (100)"
                end
                
                -- Check for negative stats
                local stats = {"hp", "maxHp", "attack", "defense", "spAttack", "spDefense", "speed"}
                for _, stat in ipairs(stats) do
                    if pokemon[stat] and pokemon[stat] < 0 then
                        return true, "Pokemon has negative " .. stat
                    end
                end
                
                -- Check for impossibly high stats (rough calculation)
                if pokemon.level and pokemon.level > 0 then
                    local maxBaseStat = 255 -- Highest possible base stat
                    local maxStatAtLevel = math.floor((2 * maxBaseStat + 31 + 252/4) * pokemon.level / 100) + 5
                    
                    for _, stat in ipairs({"attack", "defense", "spAttack", "spDefense", "speed"}) do
                        if pokemon[stat] and pokemon[stat] > maxStatAtLevel * 1.5 then -- 1.5x tolerance
                            return true, "Pokemon " .. stat .. " impossibly high for level " .. pokemon.level
                        end
                    end
                end
            end
            
            return false, nil
        end
    })
    
    -- Battle outcome manipulation detection
    AntiCheatDetector.addDetectionRule({
        ruleId = "impossible-battle-outcomes",
        cheatType = AntiCheatDetector.CHEAT_TYPES.IMPOSSIBLE_STATE,
        suspicionLevel = AntiCheatDetector.SUSPICION_LEVELS.HIGH,
        detectionLogic = function(data)
            if data.battleResult then
                local result = data.battleResult
                
                -- Check for impossible damage values
                if result.damageDealt and result.damageDealt < 0 then
                    return true, "Negative damage dealt"
                end
                
                -- Check for healing without healing moves/items
                if result.hpRestored and result.hpRestored > 0 and 
                   not result.healingSource then
                    return true, "HP restored without healing source"
                end
                
                -- Check for impossible critical hit rates
                if result.criticalHits and result.totalMoves and 
                   result.totalMoves > 0 and
                   (result.criticalHits / result.totalMoves) > 0.5 then -- 50%+ crit rate suspicious
                    return true, "Impossibly high critical hit rate: " .. 
                                (result.criticalHits / result.totalMoves * 100) .. "%"
                end
            end
            
            return false, nil
        end
    })
    
    -- Rapid action detection (speed hacking)
    AntiCheatDetector.addDetectionRule({
        ruleId = "rapid-action-detection",
        cheatType = AntiCheatDetector.CHEAT_TYPES.TIME_MANIPULATION,
        suspicionLevel = AntiCheatDetector.SUSPICION_LEVELS.MEDIUM,
        detectionLogic = function(data)
            if data.playerId and data.timestamp and data.actionType then
                local profile = AntiCheatDetector._getPlayerProfile(data.playerId)
                
                -- Check last action timing
                if profile.lastActionTime then
                    local timeDiff = data.timestamp - profile.lastActionTime
                    
                    -- Different minimum times for different action types
                    local minTimes = {
                        ["BATTLE_MOVE"] = 500,  -- 500ms minimum between battle moves
                        ["MENU_NAVIGATION"] = 100, -- 100ms minimum between menu actions
                        ["ITEM_USE"] = 300,     -- 300ms minimum between item uses
                        ["POKEMON_SWITCH"] = 200 -- 200ms minimum between switches
                    }
                    
                    local minTime = minTimes[data.actionType] or 200
                    
                    if timeDiff < minTime then
                        return true, "Action too rapid: " .. timeDiff .. "ms (min: " .. minTime .. "ms)"
                    end
                end
                
                -- Update profile
                profile.lastActionTime = data.timestamp
                profile.actionCount = (profile.actionCount or 0) + 1
            end
            
            return false, nil
        end
    })
    
    -- Statistical anomaly detection
    AntiCheatDetector.addDetectionRule({
        ruleId = "win-rate-anomaly",
        cheatType = AntiCheatDetector.CHEAT_TYPES.STATISTICAL_ANOMALY,
        suspicionLevel = AntiCheatDetector.SUSPICION_LEVELS.MEDIUM,
        detectionLogic = function(data)
            if data.playerId and data.battleResult then
                local profile = AntiCheatDetector._getPlayerProfile(data.playerId)
                
                -- Track win/loss record
                profile.battles = profile.battles or {}
                table.insert(profile.battles, {
                    result = data.battleResult.won and "WIN" or "LOSS",
                    timestamp = data.timestamp or 0
                })
                
                -- Keep only recent battles (last 50)
                if #profile.battles > 50 then
                    table.remove(profile.battles, 1)
                end
                
                -- Calculate win rate for statistical analysis
                if #profile.battles >= 10 then -- Need at least 10 battles
                    local wins = 0
                    for _, battle in ipairs(profile.battles) do
                        if battle.result == "WIN" then
                            wins = wins + 1
                        end
                    end
                    
                    local winRate = wins / #profile.battles
                    
                    -- Check against statistical baselines (95% win rate is suspicious)
                    if winRate > 0.95 and #profile.battles >= 20 then
                        return true, "Suspiciously high win rate: " .. 
                                    string.format("%.1f%%", winRate * 100) .. 
                                    " (" .. wins .. "/" .. #profile.battles .. ")"
                    end
                end
            end
            
            return false, nil
        end
    })
    
    -- Data manipulation detection
    AntiCheatDetector.addDetectionRule({
        ruleId = "data-integrity-check",
        cheatType = AntiCheatDetector.CHEAT_TYPES.DATA_MANIPULATION,
        suspicionLevel = AntiCheatDetector.SUSPICION_LEVELS.HIGH,
        detectionLogic = function(data)
            if data.gameState then
                local state = data.gameState
                
                -- Check for data consistency
                if state.pokemon then
                    for _, pokemon in ipairs(state.pokemon) do
                        -- HP consistency
                        if pokemon.hp and pokemon.maxHp and pokemon.hp > pokemon.maxHp then
                            return true, "Pokemon HP exceeds maxHp"
                        end
                        
                        -- Move PP consistency
                        if pokemon.moves then
                            for _, move in ipairs(pokemon.moves) do
                                if move.pp and move.maxPP and move.pp > move.maxPP then
                                    return true, "Move PP exceeds maxPP"
                                end
                            end
                        end
                        
                        -- Experience consistency
                        if pokemon.level and pokemon.exp then
                            -- Basic level-exp consistency check
                            local minExpForLevel = pokemon.level > 1 and (pokemon.level - 1) ^ 3 or 0
                            if pokemon.exp < minExpForLevel then
                                return true, "Pokemon experience too low for level"
                            end
                        end
                    end
                end
                
                -- Check for impossible item quantities
                if state.items then
                    for itemId, quantity in pairs(state.items) do
                        if quantity < 0 then
                            return true, "Negative item quantity"
                        end
                        
                        if quantity > 999 then -- Max stack size check
                            return true, "Item quantity exceeds maximum stack size"
                        end
                    end
                end
            end
            
            return false, nil
        end
    })
end

-- Initialize statistical baselines
function AntiCheatDetector._initializeStatisticalBaselines()
    AntiCheatDetector.statisticalBaselines = {
        averageWinRate = 0.5, -- 50% baseline win rate
        averageBattleTime = 180, -- 3 minutes average battle time
        averageActionsPerBattle = 15, -- 15 actions per battle average
        averageDamagePerMove = 50 -- 50 damage per move average
    }
end

-- Add detection rule
function AntiCheatDetector.addDetectionRule(rule)
    if not rule.ruleId or type(rule.ruleId) ~= "string" then
        return false, "Rule ID required and must be a string"
    end
    
    if not rule.detectionLogic or type(rule.detectionLogic) ~= "function" then
        return false, "Detection logic function required"
    end
    
    if not rule.cheatType or not AntiCheatDetector.CHEAT_TYPES[rule.cheatType:upper()] then
        return false, "Valid cheat type required"
    end
    
    AntiCheatDetector.cheatDetectionRules[rule.ruleId] = {
        ruleId = rule.ruleId,
        cheatType = rule.cheatType,
        suspicionLevel = rule.suspicionLevel or AntiCheatDetector.SUSPICION_LEVELS.MEDIUM,
        detectionLogic = rule.detectionLogic,
        enabled = rule.enabled ~= false,
        metadata = rule.metadata or {},
        createdAt = 0
    }
    
    return true, nil
end

-- Perform cheat detection analysis
function AntiCheatDetector.analyzeForCheating(data, playerId)
    local startTime = msg.Timestamp
    local detectedCheats = {}
    local totalSuspicion = 0
    local rulesTriggered = 0
    
    AntiCheatDetector.detectionMetrics.totalChecks = AntiCheatDetector.detectionMetrics.totalChecks + 1
    
    -- Run all enabled detection rules
    for ruleId, rule in pairs(AntiCheatDetector.cheatDetectionRules) do
        if rule.enabled then
            local success, isCheatDetected, reason = pcall(rule.detectionLogic, data)
            
            if success and isCheatDetected then
                rulesTriggered = rulesTriggered + 1
                totalSuspicion = totalSuspicion + rule.suspicionLevel
                
                table.insert(detectedCheats, {
                    ruleId = ruleId,
                    cheatType = rule.cheatType,
                    suspicionLevel = rule.suspicionLevel,
                    reason = reason or "Cheat pattern detected",
                    timestamp = msg.Timestamp,
                    playerId = playerId
                })
                
                print(string.format("[AntiCheatDetector] Cheat detected by rule '%s': %s", 
                      ruleId, reason))
            elseif not success then
                print(string.format("[AntiCheatDetector] Error in detection rule '%s': %s", 
                      ruleId, tostring(isCheatDetected)))
            end
        end
    end
    
    -- Calculate overall suspicion score
    local suspicionScore = rulesTriggered > 0 and (totalSuspicion / rulesTriggered) or 0
    
    -- Update behavior profile
    if playerId then
        AntiCheatDetector._updatePlayerBehaviorProfile(playerId, data, suspicionScore, detectedCheats)
    end
    
    -- Determine if cheating is detected above threshold
    local cheatDetected = suspicionScore >= AntiCheatDetector.suspicionThreshold
    
    if cheatDetected then
        AntiCheatDetector.detectionMetrics.cheatsDetected = AntiCheatDetector.detectionMetrics.cheatsDetected + 1
    end
    
    -- Record suspicious activity
    if #detectedCheats > 0 then
        AntiCheatDetector._recordSuspiciousActivity(playerId, detectedCheats, suspicionScore)
    end
    
    local endTime = msg.Timestamp
    local analysisTime = endTime - startTime
    
    return cheatDetected, detectedCheats, suspicionScore, analysisTime
end

-- Update player behavior profile
function AntiCheatDetector._updatePlayerBehaviorProfile(playerId, data, suspicionScore, detectedCheats)
    local profile = AntiCheatDetector._getPlayerProfile(playerId)
    
    -- Update behavior tracking
    profile.totalAnalyses = (profile.totalAnalyses or 0) + 1
    profile.totalSuspicionScore = (profile.totalSuspicionScore or 0) + suspicionScore
    profile.averageSuspicion = profile.totalSuspicionScore / profile.totalAnalyses
    
    -- Track cheat detections
    profile.cheatDetections = (profile.cheatDetections or 0) + #detectedCheats
    profile.lastAnalyzed = 0
    
    -- Track recent suspicious activities (last 50)
    profile.recentActivities = profile.recentActivities or {}
    if #detectedCheats > 0 then
        table.insert(profile.recentActivities, {
            timestamp = msg.Timestamp,
            suspicionScore = suspicionScore,
            cheatTypes = AntiCheatDetector._extractCheatTypes(detectedCheats)
        })
        
        -- Keep only recent activities
        if #profile.recentActivities > 50 then
            table.remove(profile.recentActivities, 1)
        end
    end
    
    AntiCheatDetector.detectionMetrics.behaviorAnalyses = AntiCheatDetector.detectionMetrics.behaviorAnalyses + 1
end

-- Get or create player profile
function AntiCheatDetector._getPlayerProfile(playerId)
    if not AntiCheatDetector.playerBehaviorProfiles[playerId] then
        AntiCheatDetector.playerBehaviorProfiles[playerId] = {
            playerId = playerId,
            createdAt = 0,
            totalAnalyses = 0,
            totalSuspicionScore = 0,
            averageSuspicion = 0,
            cheatDetections = 0,
            recentActivities = {},
            lastActionTime = nil,
            actionCount = 0
        }
    end
    
    return AntiCheatDetector.playerBehaviorProfiles[playerId]
end

-- Record suspicious activity
function AntiCheatDetector._recordSuspiciousActivity(playerId, detectedCheats, suspicionScore)
    local activityId = "id_" .. msg.Timestamp .. "_" .. CryptoRNG.random(1000, 9999)
    
    AntiCheatDetector.suspiciousActivities[activityId] = {
        activityId = activityId,
        playerId = playerId,
        timestamp = msg.Timestamp,
        suspicionScore = suspicionScore,
        detectedCheats = detectedCheats,
        status = "OPEN",
        investigatorNotes = {}
    }
end

-- Extract cheat types from detections
function AntiCheatDetector._extractCheatTypes(detectedCheats)
    local cheatTypes = {}
    for _, cheat in ipairs(detectedCheats) do
        if not cheatTypes[cheat.cheatType] then
            cheatTypes[cheat.cheatType] = 0
        end
        cheatTypes[cheat.cheatType] = cheatTypes[cheat.cheatType] + 1
    end
    return cheatTypes
end

-- Get player behavior analysis
function AntiCheatDetector.getPlayerBehaviorAnalysis(playerId)
    local profile = AntiCheatDetector.playerBehaviorProfiles[playerId]
    if not profile then
        return nil, "Player profile not found"
    end
    
    return {
        playerId = playerId,
        profileCreated = profile.createdAt,
        totalAnalyses = profile.totalAnalyses,
        averageSuspicion = profile.averageSuspicion,
        cheatDetections = profile.cheatDetections,
        recentActivityCount = #profile.recentActivities,
        lastAnalyzed = profile.lastAnalyzed,
        riskLevel = AntiCheatDetector._calculateRiskLevel(profile),
        behaviorTrends = AntiCheatDetector._analyzeBehaviorTrends(profile)
    }
end

-- Calculate risk level for player
function AntiCheatDetector._calculateRiskLevel(profile)
    if profile.averageSuspicion >= AntiCheatDetector.SUSPICION_LEVELS.CRITICAL then
        return "CRITICAL"
    elseif profile.averageSuspicion >= AntiCheatDetector.SUSPICION_LEVELS.HIGH then
        return "HIGH"
    elseif profile.averageSuspicion >= AntiCheatDetector.SUSPICION_LEVELS.MEDIUM then
        return "MEDIUM"
    else
        return "LOW"
    end
end

-- Analyze behavior trends
function AntiCheatDetector._analyzeBehaviorTrends(profile)
    local trends = {
        suspicionTrend = "STABLE",
        mostCommonCheatType = nil,
        recentActivitySpike = false
    }
    
    if #profile.recentActivities >= 10 then
        -- Analyze suspicion trend over recent activities
        local recentAvg = 0
        local olderAvg = 0
        local midpoint = math.floor(#profile.recentActivities / 2)
        
        for i = 1, midpoint do
            olderAvg = olderAvg + profile.recentActivities[i].suspicionScore
        end
        olderAvg = olderAvg / midpoint
        
        for i = midpoint + 1, #profile.recentActivities do
            recentAvg = recentAvg + profile.recentActivities[i].suspicionScore
        end
        recentAvg = recentAvg / (#profile.recentActivities - midpoint)
        
        if recentAvg > olderAvg * 1.2 then
            trends.suspicionTrend = "INCREASING"
        elseif recentAvg < olderAvg * 0.8 then
            trends.suspicionTrend = "DECREASING"
        end
        
        -- Check for recent activity spike
        local recentCount = 0
        local cutoffTime = 0 - 3600 -- Last hour
        for _, activity in ipairs(profile.recentActivities) do
            if activity.timestamp > cutoffTime then
                recentCount = recentCount + 1
            end
        end
        
        trends.recentActivitySpike = recentCount > 5 -- More than 5 suspicious activities in last hour
    end
    
    return trends
end

-- Get detection statistics
function AntiCheatDetector.getStatistics()
    local totalSuspiciousActivities = AntiCheatDetector._getTableSize(AntiCheatDetector.suspiciousActivities)
    local totalProfiles = AntiCheatDetector._getTableSize(AntiCheatDetector.playerBehaviorProfiles)
    
    return {
        totalChecks = AntiCheatDetector.detectionMetrics.totalChecks,
        cheatsDetected = AntiCheatDetector.detectionMetrics.cheatsDetected,
        falsePositives = AntiCheatDetector.detectionMetrics.falsePositives,
        behaviorAnalyses = AntiCheatDetector.detectionMetrics.behaviorAnalyses,
        detectionRate = AntiCheatDetector.detectionMetrics.totalChecks > 0 and 
                       (AntiCheatDetector.detectionMetrics.cheatsDetected / AntiCheatDetector.detectionMetrics.totalChecks) or 0,
        activeRules = AntiCheatDetector._getTableSize(AntiCheatDetector.cheatDetectionRules),
        suspiciousActivities = totalSuspiciousActivities,
        playerProfiles = totalProfiles,
        suspicionThreshold = AntiCheatDetector.suspicionThreshold
    }
end

-- Get health status
function AntiCheatDetector.getHealth()
    local stats = AntiCheatDetector.getStatistics()
    
    -- Check if detection system is functioning properly
    if stats.totalChecks > 100 and stats.detectionRate > 0.8 then
        return "DEGRADED" -- Too many detections might indicate false positives
    end
    
    if AntiCheatDetector._getTableSize(AntiCheatDetector.cheatDetectionRules) < 3 then
        return "DEGRADED" -- Too few rules
    end
    
    return "HEALTHY"
end

-- Helper function
function AntiCheatDetector._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: security.components.anti-cheat-detector =====


-- ===== MODULE: security.components.audit-logger =====
-- File: ao-processes/security/components/audit-logger.lua
-- Original require: local AuditLogger = require("security.components.audit-logger")

-- Security Audit Logger
-- Comprehensive event logging with correlation tracking


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")


-- ===== END MODULE: game-logic.rng.crypto-rng =====


local AuditLogger = {
    -- Audit storage
    auditEvents = {},
    eventIndex = {},
    
    -- Audit metrics
    auditMetrics = {
        totalEvents = 0,
        eventsByType = {},
        eventsBySeverity = {},
        lastPurgeTime = 0
    },
    
    -- Configuration
    maxAuditEvents = 50000,
    auditRetentionDays = 30,
    batchSize = 100
}

-- Event types
AuditLogger.EVENT_TYPES = {
    SECURITY_VALIDATION = "SECURITY_VALIDATION",
    CHEAT_DETECTED = "CHEAT_DETECTED",
    AUTH_VIOLATION = "AUTH_VIOLATION",
    POLICY_VIOLATION = "POLICY_VIOLATION",
    DATA_INTEGRITY_VIOLATION = "DATA_INTEGRITY_VIOLATION",
    PROCESS_MONITORING_STARTED = "PROCESS_MONITORING_STARTED",
    PROCESS_MONITORING_STOPPED = "PROCESS_MONITORING_STOPPED",
    INCIDENT_CREATED = "INCIDENT_CREATED",
    INCIDENT_RESOLVED = "INCIDENT_RESOLVED",
    SECURITY_ALERT = "SECURITY_ALERT",
    SYSTEM_EVENT = "SYSTEM_EVENT",
    UNHANDLED_MESSAGE = "UNHANDLED_MESSAGE"
}

-- Severity levels
AuditLogger.SEVERITY_LEVELS = {
    LOW = "LOW",
    MEDIUM = "MEDIUM", 
    HIGH = "HIGH",
    CRITICAL = "CRITICAL"
}

-- Initialize audit logger
function AuditLogger.initialize()
    AuditLogger.auditEvents = {}
    AuditLogger.eventIndex = {
        byType = {},
        bySeverity = {},
        byPlayer = {},
        byProcess = {},
        byCorrelation = {}
    }
    
    AuditLogger.auditMetrics = {
        totalEvents = 0,
        eventsByType = {},
        eventsBySeverity = {},
        lastPurgeTime = 0
    }
    
    -- Log initialization event
    AuditLogger.logSecurityEvent({
        eventType = AuditLogger.EVENT_TYPES.SYSTEM_EVENT,
        severity = AuditLogger.SEVERITY_LEVELS.LOW,
        processId = ao.id or "security-process",
        eventData = {
            message = "Audit logging system initialized",
            maxEvents = AuditLogger.maxAuditEvents,
            retentionDays = AuditLogger.auditRetentionDays
        }
    })
    
    print("[AuditLogger] Audit logging system initialized")
end

-- Log security event with full correlation tracking
function AuditLogger.logSecurityEvent(eventData, correlationId)
    local timestamp = 0
    local eventId = AuditLogger._generateEventId()
    
    -- Validate required event data
    if not eventData.eventType or not AuditLogger.EVENT_TYPES[eventData.eventType] then
        print("[AuditLogger] Error: Invalid event type: " .. tostring(eventData.eventType))
        return nil
    end
    
    -- Create correlation if not provided
    if not correlationId then
        correlationId = MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTRA_PROCESS)
    end
    
    -- Build complete audit event
    local auditEvent = {
        eventId = eventId,
        eventType = eventData.eventType,
        severity = eventData.severity or AuditLogger.SEVERITY_LEVELS.MEDIUM,
        timestamp = timestamp,
        correlationId = correlationId,
        playerId = eventData.playerId,
        processId = eventData.processId or ao.id or "unknown",
        sourceIP = eventData.sourceIP,
        userAgent = eventData.userAgent,
        eventData = eventData.eventData or {},
        actionTaken = eventData.actionTaken,
        resolution = eventData.resolution,
        metadata = {
            loggedAt = timestamp,
            processVersion = "1.0.0",
            logLevel = "AUDIT"
        }
    }
    
    -- Store audit event
    AuditLogger.auditEvents[eventId] = auditEvent
    
    -- Update indexes for fast querying
    AuditLogger._updateEventIndexes(auditEvent)
    
    -- Update metrics
    AuditLogger._updateAuditMetrics(auditEvent)
    
    -- Auto-purge old events if needed
    AuditLogger._checkAndPurgeOldEvents()
    
    print(string.format("[AuditLogger] Event logged: %s [%s] - %s", 
          eventData.eventType, auditEvent.severity, eventId))
    
    return eventId
end

-- Log security validation result
function AuditLogger.logValidationResult(validationResult, correlationId)
    local eventData = {
        eventType = AuditLogger.EVENT_TYPES.SECURITY_VALIDATION,
        severity = validationResult.valid and AuditLogger.SEVERITY_LEVELS.LOW or 
                  AuditLogger._mapActionToSeverity(validationResult.securityAction),
        playerId = validationResult.playerId,
        processId = validationResult.processId,
        eventData = {
            validationType = validationResult.validationType,
            valid = validationResult.valid,
            violations = validationResult.violations or {},
            securityAction = validationResult.securityAction,
            validationLatency = validationResult.validationLatency,
            rulesEvaluated = validationResult.rulesEvaluated,
            cacheHit = validationResult.cacheHit
        },
        actionTaken = validationResult.securityAction
    }
    
    return AuditLogger.logSecurityEvent(eventData, correlationId)
end

-- Log cheat detection result
function AuditLogger.logCheatDetection(cheatDetection, correlationId)
    local eventData = {
        eventType = AuditLogger.EVENT_TYPES.CHEAT_DETECTED,
        severity = AuditLogger.SEVERITY_LEVELS.HIGH,
        playerId = cheatDetection.playerId,
        processId = cheatDetection.processId,
        eventData = {
            suspicionScore = cheatDetection.suspicionScore,
            detectedCheats = cheatDetection.detectedCheats or {},
            analysisTime = cheatDetection.analysisTime,
            cheatTypes = cheatDetection.cheatTypes
        },
        actionTaken = cheatDetection.actionTaken or "INVESTIGATION_REQUIRED"
    }
    
    return AuditLogger.logSecurityEvent(eventData, correlationId)
end

-- Log policy violation
function AuditLogger.logPolicyViolation(policyViolation, correlationId)
    local eventData = {
        eventType = AuditLogger.EVENT_TYPES.POLICY_VIOLATION,
        severity = AuditLogger._mapEnforcementToSeverity(policyViolation.enforcement),
        playerId = policyViolation.playerId,
        processId = policyViolation.processId,
        eventData = {
            policyId = policyViolation.policyId,
            policyName = policyViolation.policyName,
            violatedRules = policyViolation.violatedRules or {},
            enforcement = policyViolation.enforcement,
            context = policyViolation.context
        },
        actionTaken = policyViolation.enforcement
    }
    
    return AuditLogger.logSecurityEvent(eventData, correlationId)
end

-- Query audit events with filtering
function AuditLogger.queryAuditEvents(filters, limit, offset)
    local matchedEvents = {}
    local totalMatched = 0
    local processedCount = 0
    
    limit = limit or 100
    offset = offset or 0
    
    -- Use indexes for efficient querying when possible
    local candidateEvents = AuditLogger._getCandidateEvents(filters)
    
    for eventId, event in pairs(candidateEvents) do
        if AuditLogger._eventMatchesFilters(event, filters) then
            totalMatched = totalMatched + 1
            
            if processedCount >= offset and #matchedEvents < limit then
                table.insert(matchedEvents, event)
            end
            
            processedCount = processedCount + 1
            
            if #matchedEvents >= limit then
                break
            end
        end
    end
    
    return matchedEvents, totalMatched
end

-- Get audit events by correlation ID (for tracking request chains)
function AuditLogger.getEventsByCorrelation(correlationId)
    local correlatedEvents = {}
    
    if AuditLogger.eventIndex.byCorrelation[correlationId] then
        for eventId in pairs(AuditLogger.eventIndex.byCorrelation[correlationId]) do
            local event = AuditLogger.auditEvents[eventId]
            if event then
                table.insert(correlatedEvents, event)
            end
        end
        
        -- Sort by timestamp
        table.sort(correlatedEvents, function(a, b) return a.timestamp < b.timestamp end)
    end
    
    return correlatedEvents
end

-- Get security events for a specific player
function AuditLogger.getPlayerSecurityEvents(playerId, eventTypes, days)
    local playerEvents = {}
    days = days or 7 -- Default to last 7 days
    local cutoffTime = 0 - (days * 24 * 3600)
    
    if AuditLogger.eventIndex.byPlayer[playerId] then
        for eventId in pairs(AuditLogger.eventIndex.byPlayer[playerId]) do
            local event = AuditLogger.auditEvents[eventId]
            if event and event.timestamp >= cutoffTime then
                local includeEvent = true
                
                if eventTypes then
                    includeEvent = false
                    for _, eventType in ipairs(eventTypes) do
                        if event.eventType == eventType then
                            includeEvent = true
                            break
                        end
                    end
                end
                
                if includeEvent then
                    table.insert(playerEvents, event)
                end
            end
        end
        
        -- Sort by timestamp (most recent first)
        table.sort(playerEvents, function(a, b) return a.timestamp > b.timestamp end)
    end
    
    return playerEvents
end

-- Get audit statistics
function AuditLogger.getStatistics()
    local eventTypeStats = {}
    for eventType, count in pairs(AuditLogger.auditMetrics.eventsByType) do
        eventTypeStats[eventType] = count
    end
    
    local severityStats = {}
    for severity, count in pairs(AuditLogger.auditMetrics.eventsBySeverity) do
        severityStats[severity] = count
    end
    
    return {
        totalEvents = AuditLogger.auditMetrics.totalEvents,
        storedEvents = AuditLogger._getTableSize(AuditLogger.auditEvents),
        eventsByType = eventTypeStats,
        eventsBySeverity = severityStats,
        lastPurgeTime = AuditLogger.auditMetrics.lastPurgeTime,
        indexedPlayers = AuditLogger._getTableSize(AuditLogger.eventIndex.byPlayer),
        indexedProcesses = AuditLogger._getTableSize(AuditLogger.eventIndex.byProcess),
        indexedCorrelations = AuditLogger._getTableSize(AuditLogger.eventIndex.byCorrelation),
        maxAuditEvents = AuditLogger.maxAuditEvents,
        retentionDays = AuditLogger.auditRetentionDays
    }
end

-- Get health status
function AuditLogger.getHealth()
    local stats = AuditLogger.getStatistics()
    
    -- Check if audit storage is near capacity
    if stats.storedEvents > AuditLogger.maxAuditEvents * 0.9 then
        return "DEGRADED"
    end
    
    -- Check if purging is working
    local daysSinceLastPurge = (0 - stats.lastPurgeTime) / (24 * 3600)
    if daysSinceLastPurge > 2 then -- Should purge at least every 2 days
        return "DEGRADED"
    end
    
    return "HEALTHY"
end

-- Export audit events (for external analysis or compliance)
function AuditLogger.exportAuditEvents(startDate, endDate, eventTypes)
    local exportEvents = {}
    startDate = startDate or (0 - 7 * 24 * 3600) -- Default to last week
    endDate = endDate or 0
    
    for eventId, event in pairs(AuditLogger.auditEvents) do
        if event.timestamp >= startDate and event.timestamp <= endDate then
            local includeEvent = true
            
            if eventTypes then
                includeEvent = false
                for _, eventType in ipairs(eventTypes) do
                    if event.eventType == eventType then
                        includeEvent = true
                        break
                    end
                end
            end
            
            if includeEvent then
                -- Create export-friendly version (remove internal metadata)
                local exportEvent = {
                    eventId = event.eventId,
                    eventType = event.eventType,
                    severity = event.severity,
                    timestamp = event.timestamp,
                    correlationId = event.correlationId,
                    playerId = event.playerId,
                    processId = event.processId,
                    eventData = event.eventData,
                    actionTaken = event.actionTaken,
                    resolution = event.resolution
                }
                table.insert(exportEvents, exportEvent)
            end
        end
    end
    
    -- Sort by timestamp
    table.sort(exportEvents, function(a, b) return a.timestamp < b.timestamp end)
    
    return exportEvents
end

-- Private helper functions

function AuditLogger._generateEventId()
    local timestamp = msg.Timestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    return "audit_" .. timestamp .. "_" .. randomSuffix
end

function AuditLogger._updateEventIndexes(event)
    -- Index by event type
    if not AuditLogger.eventIndex.byType[event.eventType] then
        AuditLogger.eventIndex.byType[event.eventType] = {}
    end
    AuditLogger.eventIndex.byType[event.eventType][event.eventId] = true
    
    -- Index by severity
    if not AuditLogger.eventIndex.bySeverity[event.severity] then
        AuditLogger.eventIndex.bySeverity[event.severity] = {}
    end
    AuditLogger.eventIndex.bySeverity[event.severity][event.eventId] = true
    
    -- Index by player
    if event.playerId then
        if not AuditLogger.eventIndex.byPlayer[event.playerId] then
            AuditLogger.eventIndex.byPlayer[event.playerId] = {}
        end
        AuditLogger.eventIndex.byPlayer[event.playerId][event.eventId] = true
    end
    
    -- Index by process
    if event.processId then
        if not AuditLogger.eventIndex.byProcess[event.processId] then
            AuditLogger.eventIndex.byProcess[event.processId] = {}
        end
        AuditLogger.eventIndex.byProcess[event.processId][event.eventId] = true
    end
    
    -- Index by correlation
    if event.correlationId then
        if not AuditLogger.eventIndex.byCorrelation[event.correlationId] then
            AuditLogger.eventIndex.byCorrelation[event.correlationId] = {}
        end
        AuditLogger.eventIndex.byCorrelation[event.correlationId][event.eventId] = true
    end
end

function AuditLogger._updateAuditMetrics(event)
    AuditLogger.auditMetrics.totalEvents = AuditLogger.auditMetrics.totalEvents + 1
    
    -- Update event type counts
    AuditLogger.auditMetrics.eventsByType[event.eventType] = 
        (AuditLogger.auditMetrics.eventsByType[event.eventType] or 0) + 1
    
    -- Update severity counts
    AuditLogger.auditMetrics.eventsBySeverity[event.severity] = 
        (AuditLogger.auditMetrics.eventsBySeverity[event.severity] or 0) + 1
end

function AuditLogger._getCandidateEvents(filters)
    -- Use most selective index first
    if filters.eventType and AuditLogger.eventIndex.byType[filters.eventType] then
        return AuditLogger.eventIndex.byType[filters.eventType]
    elseif filters.playerId and AuditLogger.eventIndex.byPlayer[filters.playerId] then
        return AuditLogger.eventIndex.byPlayer[filters.playerId]
    elseif filters.processId and AuditLogger.eventIndex.byProcess[filters.processId] then
        return AuditLogger.eventIndex.byProcess[filters.processId]
    elseif filters.correlationId and AuditLogger.eventIndex.byCorrelation[filters.correlationId] then
        return AuditLogger.eventIndex.byCorrelation[filters.correlationId]
    else
        return AuditLogger.auditEvents
    end
end

function AuditLogger._eventMatchesFilters(event, filters)
    if filters.eventType and event.eventType ~= filters.eventType then
        return false
    end
    
    if filters.severity and event.severity ~= filters.severity then
        return false
    end
    
    if filters.playerId and event.playerId ~= filters.playerId then
        return false
    end
    
    if filters.processId and event.processId ~= filters.processId then
        return false
    end
    
    if filters.correlationId and event.correlationId ~= filters.correlationId then
        return false
    end
    
    if filters.startTime and event.timestamp < filters.startTime then
        return false
    end
    
    if filters.endTime and event.timestamp > filters.endTime then
        return false
    end
    
    return true
end

function AuditLogger._checkAndPurgeOldEvents()
    local currentTime = 0
    local eventCount = AuditLogger._getTableSize(AuditLogger.auditEvents)
    
    -- Purge if over max events or old events exist
    if eventCount > AuditLogger.maxAuditEvents or 
       (currentTime - AuditLogger.auditMetrics.lastPurgeTime) > 24 * 3600 then -- Daily check
        
        AuditLogger._purgeOldEvents(currentTime)
        AuditLogger.auditMetrics.lastPurgeTime = currentTime
    end
end

function AuditLogger._purgeOldEvents(currentTime)
    local cutoffTime = currentTime - (AuditLogger.auditRetentionDays * 24 * 3600)
    local purgedCount = 0
    
    for eventId, event in pairs(AuditLogger.auditEvents) do
        if event.timestamp < cutoffTime then
            -- Remove from all indexes
            AuditLogger._removeEventFromIndexes(event)
            
            -- Remove from main storage
            AuditLogger.auditEvents[eventId] = nil
            purgedCount = purgedCount + 1
        end
    end
    
    if purgedCount > 0 then
        print(string.format("[AuditLogger] Purged %d old audit events", purgedCount))
    end
end

function AuditLogger._removeEventFromIndexes(event)
    if AuditLogger.eventIndex.byType[event.eventType] then
        AuditLogger.eventIndex.byType[event.eventType][event.eventId] = nil
    end
    
    if AuditLogger.eventIndex.bySeverity[event.severity] then
        AuditLogger.eventIndex.bySeverity[event.severity][event.eventId] = nil
    end
    
    if event.playerId and AuditLogger.eventIndex.byPlayer[event.playerId] then
        AuditLogger.eventIndex.byPlayer[event.playerId][event.eventId] = nil
    end
    
    if event.processId and AuditLogger.eventIndex.byProcess[event.processId] then
        AuditLogger.eventIndex.byProcess[event.processId][event.eventId] = nil
    end
    
    if event.correlationId and AuditLogger.eventIndex.byCorrelation[event.correlationId] then
        AuditLogger.eventIndex.byCorrelation[event.correlationId][event.eventId] = nil
    end
end

function AuditLogger._mapActionToSeverity(action)
    if action == "TERMINATE" then
        return AuditLogger.SEVERITY_LEVELS.CRITICAL
    elseif action == "BLOCK" then
        return AuditLogger.SEVERITY_LEVELS.HIGH
    elseif action == "WARN" then
        return AuditLogger.SEVERITY_LEVELS.MEDIUM
    else
        return AuditLogger.SEVERITY_LEVELS.LOW
    end
end

function AuditLogger._mapEnforcementToSeverity(enforcement)
    if enforcement == "TERMINATE" then
        return AuditLogger.SEVERITY_LEVELS.CRITICAL
    elseif enforcement == "BLOCK" then
        return AuditLogger.SEVERITY_LEVELS.HIGH
    elseif enforcement == "WARN" then
        return AuditLogger.SEVERITY_LEVELS.MEDIUM
    else
        return AuditLogger.SEVERITY_LEVELS.LOW
    end
end

function AuditLogger._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: security.components.audit-logger =====


-- ===== MODULE: security.components.policy-enforcer =====
-- File: ao-processes/security/components/policy-enforcer.lua
-- Original require: local PolicyEnforcer = require("security.components.policy-enforcer")

-- Security Policy Enforcer
-- Enforces security policies across all process boundaries


-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require: local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====


-- ===== MODULE: security.components.audit-logger =====
-- File: ao-processes/security/components/audit-logger.lua
-- Original require: local AuditLogger = require("security.components.audit-logger")


-- ===== END MODULE: security.components.audit-logger =====


local PolicyEnforcer = {
    -- Policy storage
    securityPolicies = {},
    policyViolations = {},
    
    -- Enforcement metrics
    enforcementMetrics = {
        totalEnforcements = 0,
        policiesEvaluated = 0,
        violationsDetected = 0,
        actionsBlocked = 0,
        processesTerminated = 0
    },
    
    -- Configuration
    maxViolationHistory = 10000,
    defaultPolicyMode = "WARN" -- MONITOR, WARN, BLOCK, TERMINATE
}

-- Enforcement modes
PolicyEnforcer.ENFORCEMENT_MODES = {
    MONITOR = "MONITOR",     -- Log violations but allow action
    WARN = "WARN",           -- Log and warn but allow action
    BLOCK = "BLOCK",         -- Block action and log violation
    TERMINATE = "TERMINATE"  -- Terminate process/session and log
}

-- Policy scope types
PolicyEnforcer.SCOPE_TYPES = {
    GLOBAL = "*",
    PROCESS_TYPE = "process-type:",
    SPECIFIC_PROCESS = "process-id:"
}

-- Initialize policy enforcer
function PolicyEnforcer.initialize()
    PolicyEnforcer.securityPolicies = {}
    PolicyEnforcer.policyViolations = {}
    PolicyEnforcer.enforcementMetrics = {
        totalEnforcements = 0,
        policiesEvaluated = 0,
        violationsDetected = 0,
        actionsBlocked = 0,
        processesTerminated = 0
    }
    
    -- Load default security policies
    PolicyEnforcer._loadDefaultSecurityPolicies()
    
    print("[PolicyEnforcer] Policy enforcement system initialized with " .. 
          PolicyEnforcer._getTableSize(PolicyEnforcer.securityPolicies) .. " policies")
end

-- Load default security policies
function PolicyEnforcer._loadDefaultSecurityPolicies()
    -- Input validation policy
    PolicyEnforcer.addSecurityPolicy({
        policyId = "input-validation",
        policyName = "Input Validation Policy",
        enforcement = PolicyEnforcer.ENFORCEMENT_MODES.BLOCK,
        processScope = {PolicyEnforcer.SCOPE_TYPES.GLOBAL},
        rules = {
            {
                ruleId = "require-correlation-id",
                description = "All inter-process messages must include correlation ID",
                evaluationLogic = function(context)
                    if context.messageType == "INTER_PROCESS" then
                        if not context.correlation or not context.correlation.id then
                            return false, "Missing correlation ID in inter-process message"
                        end
                    end
                    return true, nil
                end
            },
            {
                ruleId = "validate-wallet-address",
                description = "Wallet addresses must be valid Arweave format",
                evaluationLogic = function(context)
                    if context.playerId then
                        if type(context.playerId) ~= "string" or #context.playerId ~= 43 then
                            return false, "Invalid wallet address format"
                        end
                        if not string.match(context.playerId, "^[A-Za-z0-9_%-]+$") then
                            return false, "Invalid wallet address characters"
                        end
                    end
                    return true, nil
                end
            }
        }
    })
    
    -- Process authentication policy
    PolicyEnforcer.addSecurityPolicy({
        policyId = "process-auth",
        policyName = "Inter-Process Authentication Policy",
        enforcement = PolicyEnforcer.ENFORCEMENT_MODES.BLOCK,
        processScope = {PolicyEnforcer.SCOPE_TYPES.GLOBAL},
        rules = {
            {
                ruleId = "require-process-token",
                description = "Inter-process communications must include valid authentication token",
                evaluationLogic = function(context)
                    if context.messageType == "INTER_PROCESS" and context.processAuth then
                        if not context.processAuth.authToken or not context.processAuth.sourceProcessId then
                            return false, "Missing process authentication credentials"
                        end
                        
                        -- Validate token with ProcessAuthenticator
                        local isValid, authContext, error = ProcessAuthenticator.validateAuthToken(
                            context.processAuth.authToken.tokenId,
                            context.processAuth.authToken.signature
                        )
                        
                        if not isValid then
                            return false, "Invalid process authentication token: " .. tostring(error)
                        end
                        
                        -- Verify process ID matches token
                        if authContext.processId ~= context.processAuth.sourceProcessId then
                            return false, "Process ID mismatch in authentication"
                        end
                    end
                    return true, nil
                end
            },
            {
                ruleId = "validate-process-capabilities",
                description = "Process must have required capabilities for operation",
                evaluationLogic = function(context)
                    if context.operation and context.processAuth then
                        local processInfo = ProcessAuthenticator.getProcessInfo(context.processAuth.sourceProcessId)
                        if processInfo then
                            -- Check if process has required capability
                            local hasCapability = false
                            for _, capability in ipairs(processInfo.capabilities or {}) do
                                if capability == "*" or capability == context.operation then
                                    hasCapability = true
                                    break
                                end
                            end
                            
                            if not hasCapability then
                                return false, "Process lacks required capability: " .. context.operation
                            end
                        end
                    end
                    return true, nil
                end
            }
        }
    })
    
    -- Data integrity policy
    PolicyEnforcer.addSecurityPolicy({
        policyId = "data-integrity",
        policyName = "Data Integrity Validation Policy",
        enforcement = PolicyEnforcer.ENFORCEMENT_MODES.WARN,
        processScope = {
            PolicyEnforcer.SCOPE_TYPES.PROCESS_TYPE .. "battle",
            PolicyEnforcer.SCOPE_TYPES.PROCESS_TYPE .. "pokemon"
        },
        rules = {
            {
                ruleId = "pokemon-stat-consistency",
                description = "Pokemon statistics must be mathematically consistent",
                evaluationLogic = function(context)
                    if context.pokemon then
                        local pokemon = context.pokemon
                        
                        -- HP consistency check
                        if pokemon.hp and pokemon.maxHp and pokemon.hp > pokemon.maxHp then
                            return false, "Pokemon HP exceeds maximum HP"
                        end
                        
                        -- Level-stat consistency (basic check)
                        if pokemon.level and pokemon.level > 100 then
                            return false, "Pokemon level exceeds maximum (100)"
                        end
                        
                        -- Negative stat check
                        local stats = {"hp", "attack", "defense", "spAttack", "spDefense", "speed"}
                        for _, stat in ipairs(stats) do
                            if pokemon[stat] and pokemon[stat] < 0 then
                                return false, "Pokemon has negative " .. stat
                            end
                        end
                    end
                    return true, nil
                end
            },
            {
                ruleId = "battle-state-consistency",
                description = "Battle state must be logically consistent",
                evaluationLogic = function(context)
                    if context.battleState then
                        local battle = context.battleState
                        
                        -- Turn consistency
                        if battle.turn and battle.turn < 0 then
                            return false, "Negative battle turn number"
                        end
                        
                        -- Active Pokemon consistency
                        if battle.activePlayerPokemon and battle.activeEnemyPokemon then
                            if battle.activePlayerPokemon.hp and battle.activePlayerPokemon.hp <= 0 and
                               battle.battlePhase ~= "FAINTED" then
                                return false, "Active Pokemon has 0 HP but battle continues"
                            end
                        end
                    end
                    return true, nil
                end
            }
        }
    })
    
    -- Rate limiting policy
    PolicyEnforcer.addSecurityPolicy({
        policyId = "rate-limiting",
        policyName = "Action Rate Limiting Policy",
        enforcement = PolicyEnforcer.ENFORCEMENT_MODES.BLOCK,
        processScope = {PolicyEnforcer.SCOPE_TYPES.GLOBAL},
        rules = {
            {
                ruleId = "message-rate-limit",
                description = "Players cannot exceed maximum message rate",
                evaluationLogic = function(context)
                    if context.playerId and context.timestamp then
                        -- Simple rate limiting logic (would be more sophisticated in production)
                        local rateKey = "rate_" .. context.playerId
                        local lastMessageTime = PolicyEnforcer._getRateLimitData(rateKey)
                        
                        if lastMessageTime and (context.timestamp - lastMessageTime) < 100 then -- 100ms minimum
                            return false, "Message rate limit exceeded"
                        end
                        
                        PolicyEnforcer._setRateLimitData(rateKey, context.timestamp)
                    end
                    return true, nil
                end
            }
        }
    })
end

-- Rate limiting storage (simple in-memory implementation)
PolicyEnforcer._rateLimitData = {}

function PolicyEnforcer._getRateLimitData(key)
    return PolicyEnforcer._rateLimitData[key]
end

function PolicyEnforcer._setRateLimitData(key, value)
    PolicyEnforcer._rateLimitData[key] = value
end

-- Add security policy
function PolicyEnforcer.addSecurityPolicy(policy)
    if not policy.policyId or type(policy.policyId) ~= "string" then
        return false, "Policy ID required and must be a string"
    end
    
    if not policy.policyName or type(policy.policyName) ~= "string" then
        return false, "Policy name required and must be a string"
    end
    
    if not policy.rules or type(policy.rules) ~= "table" or #policy.rules == 0 then
        return false, "Policy must have at least one rule"
    end
    
    if not policy.enforcement or not PolicyEnforcer.ENFORCEMENT_MODES[policy.enforcement] then
        return false, "Valid enforcement mode required"
    end
    
    -- Validate rules
    for _, rule in ipairs(policy.rules) do
        if not rule.ruleId or not rule.evaluationLogic or type(rule.evaluationLogic) ~= "function" then
            return false, "Each rule must have ruleId and evaluationLogic function"
        end
    end
    
    PolicyEnforcer.securityPolicies[policy.policyId] = {
        policyId = policy.policyId,
        policyName = policy.policyName,
        enforcement = policy.enforcement,
        processScope = policy.processScope or {PolicyEnforcer.SCOPE_TYPES.GLOBAL},
        rules = policy.rules,
        enabled = policy.enabled ~= false,
        metadata = policy.metadata or {},
        createdAt = 0,
        lastModified = 0
    }
    
    return true, nil
end

-- Enforce policies for a given context
function PolicyEnforcer.enforcePolicies(context)
    local startTime = msg.Timestamp
    local violations = {}
    local actionsToBlock = {}
    local highestEnforcement = PolicyEnforcer.ENFORCEMENT_MODES.MONITOR
    
    PolicyEnforcer.enforcementMetrics.totalEnforcements = PolicyEnforcer.enforcementMetrics.totalEnforcements + 1
    
    -- Evaluate all applicable policies
    for policyId, policy in pairs(PolicyEnforcer.securityPolicies) do
        if policy.enabled and PolicyEnforcer._isPolicyApplicable(policy, context) then
            PolicyEnforcer.enforcementMetrics.policiesEvaluated = PolicyEnforcer.enforcementMetrics.policiesEvaluated + 1
            
            -- Evaluate each rule in the policy
            for _, rule in ipairs(policy.rules) do
                local success, ruleResult, violationMessage = pcall(rule.evaluationLogic, context)
                
                if success then
                    if not ruleResult then
                        -- Policy violation detected
                        local violation = {
                            policyId = policyId,
                            policyName = policy.policyName,
                            ruleId = rule.ruleId,
                            ruleDescription = rule.description,
                            enforcement = policy.enforcement,
                            violationMessage = violationMessage or "Policy rule violation",
                            timestamp = msg.Timestamp,
                            context = {
                                playerId = context.playerId,
                                processId = context.processId,
                                operation = context.operation,
                                messageType = context.messageType
                            }
                        }
                        
                        table.insert(violations, violation)
                        PolicyEnforcer.enforcementMetrics.violationsDetected = PolicyEnforcer.enforcementMetrics.violationsDetected + 1
                        
                        -- Track enforcement escalation
                        if PolicyEnforcer._getEnforcementLevel(policy.enforcement) > 
                           PolicyEnforcer._getEnforcementLevel(highestEnforcement) then
                            highestEnforcement = policy.enforcement
                        end
                        
                        -- Log policy violation
                        AuditLogger.logPolicyViolation(violation, context.correlationId)
                        
                        print(string.format("[PolicyEnforcer] Policy violation: %s - %s", 
                              policyId, violationMessage))
                    end
                else
                    print(string.format("[PolicyEnforcer] Error evaluating rule %s: %s", 
                          rule.ruleId, tostring(ruleResult)))
                end
            end
        end
    end
    
    -- Determine enforcement action
    local enforcementResult = {
        allowed = true,
        enforcement = highestEnforcement,
        violations = violations,
        actionMessage = nil
    }
    
    if #violations > 0 then
        -- Apply enforcement based on highest severity
        if highestEnforcement == PolicyEnforcer.ENFORCEMENT_MODES.BLOCK then
            enforcementResult.allowed = false
            enforcementResult.actionMessage = "Action blocked due to policy violations"
            PolicyEnforcer.enforcementMetrics.actionsBlocked = PolicyEnforcer.enforcementMetrics.actionsBlocked + 1
            
        elseif highestEnforcement == PolicyEnforcer.ENFORCEMENT_MODES.TERMINATE then
            enforcementResult.allowed = false
            enforcementResult.actionMessage = "Process terminated due to critical policy violations"
            PolicyEnforcer.enforcementMetrics.processesTerminated = PolicyEnforcer.enforcementMetrics.processesTerminated + 1
            
        elseif highestEnforcement == PolicyEnforcer.ENFORCEMENT_MODES.WARN then
            enforcementResult.actionMessage = "Action allowed with warnings due to policy violations"
            
        else -- MONITOR
            enforcementResult.actionMessage = "Action monitored, no enforcement applied"
        end
        
        -- Record policy violations for tracking
        PolicyEnforcer._recordPolicyViolations(violations, context)
    end
    
    local endTime = msg.Timestamp
    local enforcementTime = endTime - startTime
    
    return enforcementResult, enforcementTime
end

-- Check if policy applies to the given context
function PolicyEnforcer._isPolicyApplicable(policy, context)
    if not policy.processScope then
        return true
    end
    
    for _, scope in ipairs(policy.processScope) do
        if scope == PolicyEnforcer.SCOPE_TYPES.GLOBAL then
            return true
        elseif string.match(scope, "^process%-type:") then
            local processType = string.sub(scope, 14) -- Remove "process-type:" prefix
            if context.processType == processType then
                return true
            end
        elseif string.match(scope, "^process%-id:") then
            local processId = string.sub(scope, 12) -- Remove "process-id:" prefix
            if context.processId == processId then
                return true
            end
        elseif context.processId and string.match(context.processId, scope) then
            return true
        end
    end
    
    return false
end

-- Record policy violations for tracking
function PolicyEnforcer._recordPolicyViolations(violations, context)
    for _, violation in ipairs(violations) do
        local violationId = "id_" .. msg.Timestamp .. "_" .. (#PolicyEnforcer.policyViolations + 1)
        
        PolicyEnforcer.policyViolations[violationId] = {
            violationId = violationId,
            policyId = violation.policyId,
            ruleId = violation.ruleId,
            playerId = context.playerId,
            processId = context.processId,
            enforcement = violation.enforcement,
            violationMessage = violation.violationMessage,
            timestamp = violation.timestamp,
            context = violation.context,
            resolved = false
        }
    end
    
    -- Cleanup old violations if at limit
    PolicyEnforcer._cleanupOldViolations()
end

-- Cleanup old violation records
function PolicyEnforcer._cleanupOldViolations()
    local violationCount = PolicyEnforcer._getTableSize(PolicyEnforcer.policyViolations)
    
    if violationCount > PolicyEnforcer.maxViolationHistory then
        -- Convert to array and sort by timestamp
        local violationArray = {}
        for violationId, violation in pairs(PolicyEnforcer.policyViolations) do
            violation.violationId = violationId
            table.insert(violationArray, violation)
        end
        
        table.sort(violationArray, function(a, b) return a.timestamp < b.timestamp end)
        
        -- Remove oldest 20%
        local removeCount = math.floor(violationCount * 0.2)
        for i = 1, removeCount do
            PolicyEnforcer.policyViolations[violationArray[i].violationId] = nil
        end
    end
end

-- Get enforcement level as number for comparison
function PolicyEnforcer._getEnforcementLevel(enforcement)
    local levels = {
        [PolicyEnforcer.ENFORCEMENT_MODES.MONITOR] = 1,
        [PolicyEnforcer.ENFORCEMENT_MODES.WARN] = 2,
        [PolicyEnforcer.ENFORCEMENT_MODES.BLOCK] = 3,
        [PolicyEnforcer.ENFORCEMENT_MODES.TERMINATE] = 4
    }
    return levels[enforcement] or 1
end

-- Get policy enforcement statistics
function PolicyEnforcer.getStatistics()
    local policyStats = {}
    for policyId, policy in pairs(PolicyEnforcer.securityPolicies) do
        policyStats[policyId] = {
            policyName = policy.policyName,
            enforcement = policy.enforcement,
            enabled = policy.enabled,
            ruleCount = #policy.rules,
            processScope = policy.processScope
        }
    end
    
    return {
        totalEnforcements = PolicyEnforcer.enforcementMetrics.totalEnforcements,
        policiesEvaluated = PolicyEnforcer.enforcementMetrics.policiesEvaluated,
        violationsDetected = PolicyEnforcer.enforcementMetrics.violationsDetected,
        actionsBlocked = PolicyEnforcer.enforcementMetrics.actionsBlocked,
        processesTerminated = PolicyEnforcer.enforcementMetrics.processesTerminated,
        activePolicies = PolicyEnforcer._getTableSize(PolicyEnforcer.securityPolicies),
        trackedViolations = PolicyEnforcer._getTableSize(PolicyEnforcer.policyViolations),
        policies = policyStats
    }
end

-- Get policy violations for a player or process
function PolicyEnforcer.getPolicyViolations(playerId, processId, days)
    local violations = {}
    days = days or 7
    local cutoffTime = 0 - (days * 24 * 3600)
    
    for violationId, violation in pairs(PolicyEnforcer.policyViolations) do
        if violation.timestamp >= cutoffTime then
            local includeViolation = true
            
            if playerId and violation.playerId ~= playerId then
                includeViolation = false
            end
            
            if processId and violation.processId ~= processId then
                includeViolation = false
            end
            
            if includeViolation then
                table.insert(violations, violation)
            end
        end
    end
    
    -- Sort by timestamp (most recent first)
    table.sort(violations, function(a, b) return a.timestamp > b.timestamp end)
    
    return violations
end

-- Enable/disable security policy
function PolicyEnforcer.setPolicyEnabled(policyId, enabled)
    local policy = PolicyEnforcer.securityPolicies[policyId]
    if policy then
        policy.enabled = enabled
        policy.lastModified = 0
        return true
    end
    return false
end

-- Update policy enforcement mode
function PolicyEnforcer.updatePolicyEnforcement(policyId, enforcement)
    if not PolicyEnforcer.ENFORCEMENT_MODES[enforcement] then
        return false, "Invalid enforcement mode"
    end
    
    local policy = PolicyEnforcer.securityPolicies[policyId]
    if policy then
        policy.enforcement = enforcement
        policy.lastModified = 0
        return true
    end
    return false, "Policy not found"
end

-- Get health status
function PolicyEnforcer.getHealth()
    local stats = PolicyEnforcer.getStatistics()
    
    -- Check if enforcement system is functioning
    if stats.activePolicies == 0 then
        return "DEGRADED"
    end
    
    -- Check if violations are being tracked
    if stats.totalEnforcements > 100 and stats.violationsDetected == 0 then
        return "DEGRADED" -- Might indicate rules are too permissive
    end
    
    return "HEALTHY"
end

-- Helper function
function PolicyEnforcer._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: security.components.policy-enforcer =====


-- ===== MODULE: security.components.integrity-monitor =====
-- File: ao-processes/security/components/integrity-monitor.lua
-- Original require: local IntegrityMonitor = require("security.components.integrity-monitor")

-- Data Integrity Monitor
-- Monitors cross-process data consistency and corruption detection


-- ===== MODULE: game-logic.rng.crypto-rng =====
-- File: ao-processes/game-logic/rng/crypto-rng.lua
-- Original require: local CryptoRNG = require("game-logic.rng.crypto-rng")


-- ===== END MODULE: game-logic.rng.crypto-rng =====


-- ===== MODULE: security.components.audit-logger =====
-- File: ao-processes/security/components/audit-logger.lua
-- Original require: local AuditLogger = require("security.components.audit-logger")


-- ===== END MODULE: security.components.audit-logger =====


local IntegrityMonitor = {
    -- Integrity tracking
    dataChecksums = {},
    integrityChecks = {},
    corruptionIncidents = {},
    
    -- Monitoring metrics
    monitoringMetrics = {
        totalChecks = 0,
        dataCorruptions = 0,
        consistencyViolations = 0,
        checksumMismatches = 0,
        averageCheckTime = 0
    },
    
    -- Configuration
    checksumAlgorithm = "simple-hash",
    maxCorruptionHistory = 1000,
    integrityCheckInterval = 300, -- 5 minutes
    crossProcessSyncTimeout = 30000 -- 30 seconds
}

-- Integrity check types
IntegrityMonitor.CHECK_TYPES = {
    CHECKSUM_VALIDATION = "CHECKSUM_VALIDATION",
    CROSS_PROCESS_CONSISTENCY = "CROSS_PROCESS_CONSISTENCY",
    STATE_CORRUPTION = "STATE_CORRUPTION",
    DATA_SYNCHRONIZATION = "DATA_SYNCHRONIZATION"
}

-- Corruption severity levels
IntegrityMonitor.CORRUPTION_SEVERITY = {
    LOW = "LOW",           -- Minor inconsistencies, recoverable
    MEDIUM = "MEDIUM",     -- Data inconsistencies requiring attention
    HIGH = "HIGH",         -- Critical data corruption
    CRITICAL = "CRITICAL"  -- System-wide data corruption
}

-- Initialize integrity monitor
function IntegrityMonitor.initialize()
    IntegrityMonitor.dataChecksums = {}
    IntegrityMonitor.integrityChecks = {}
    IntegrityMonitor.corruptionIncidents = {}
    
    IntegrityMonitor.monitoringMetrics = {
        totalChecks = 0,
        dataCorruptions = 0,
        consistencyViolations = 0,
        checksumMismatches = 0,
        averageCheckTime = 0,
        totalCheckTime = 0
    }
    
    print("[IntegrityMonitor] Data integrity monitoring system initialized")
    
    -- Log initialization
    AuditLogger.logSecurityEvent({
        eventType = AuditLogger.EVENT_TYPES.SYSTEM_EVENT,
        severity = AuditLogger.SEVERITY_LEVELS.LOW,
        processId = ao.id or "security-process",
        eventData = {
            message = "Integrity monitoring system initialized",
            checksumAlgorithm = IntegrityMonitor.checksumAlgorithm,
            checkInterval = IntegrityMonitor.integrityCheckInterval
        }
    })
end

-- Generate data checksum for integrity validation
function IntegrityMonitor.generateDataChecksum(data, dataType, contextId)
    if not data then
        return nil, "No data provided for checksum"
    end
    
    local serializedData = IntegrityMonitor._serializeData(data)
    local checksum = IntegrityMonitor._calculateChecksum(serializedData)
    local timestamp = 0
    
    local checksumRecord = {
        checksum = checksum,
        dataType = dataType or "unknown",
        contextId = contextId or "unknown",
        timestamp = timestamp,
        dataSize = #serializedData,
        algorithm = IntegrityMonitor.checksumAlgorithm
    }
    
    -- Store checksum for later validation
    local checksumId = IntegrityMonitor._generateChecksumId(dataType, contextId, timestamp)
    IntegrityMonitor.dataChecksums[checksumId] = checksumRecord
    
    return checksum, checksumId
end

-- Validate data against stored checksum
function IntegrityMonitor.validateDataChecksum(data, expectedChecksum, checksumId)
    local startTime = msg.Timestamp
    
    if not data then
        return false, "No data provided for validation", 0
    end
    
    if not expectedChecksum then
        return false, "No expected checksum provided", 0
    end
    
    local serializedData = IntegrityMonitor._serializeData(data)
    local actualChecksum = IntegrityMonitor._calculateChecksum(serializedData)
    
    local isValid = actualChecksum == expectedChecksum
    local endTime = msg.Timestamp
    local checkTime = endTime - startTime
    
    -- Update metrics
    IntegrityMonitor.monitoringMetrics.totalChecks = IntegrityMonitor.monitoringMetrics.totalChecks + 1
    IntegrityMonitor.monitoringMetrics.totalCheckTime = IntegrityMonitor.monitoringMetrics.totalCheckTime + checkTime
    IntegrityMonitor.monitoringMetrics.averageCheckTime = 
        IntegrityMonitor.monitoringMetrics.totalCheckTime / IntegrityMonitor.monitoringMetrics.totalChecks
    
    if not isValid then
        IntegrityMonitor.monitoringMetrics.checksumMismatches = IntegrityMonitor.monitoringMetrics.checksumMismatches + 1
        
        -- Record corruption incident
        IntegrityMonitor._recordCorruptionIncident({
            checkType = IntegrityMonitor.CHECK_TYPES.CHECKSUM_VALIDATION,
            severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH,
            description = "Data checksum validation failed",
            expectedChecksum = expectedChecksum,
            actualChecksum = actualChecksum,
            checksumId = checksumId,
            dataSize = #serializedData
        })
    end
    
    return isValid, isValid and "Checksum validation passed" or "Checksum validation failed", checkTime
end

-- Perform cross-process data consistency check
function IntegrityMonitor.performCrossProcessConsistencyCheck(processStates, dataKey)
    local startTime = msg.Timestamp
    local consistencyResults = {
        consistent = true,
        conflicts = {},
        processCount = 0,
        dataKey = dataKey
    }
    
    if not processStates or IntegrityMonitor._getTableSize(processStates) < 2 then
        return consistencyResults, "Insufficient process states for consistency check"
    end
    
    local referenceChecksum = nil
    local referenceProcessId = nil
    
    -- Compare checksums across all processes
    for processId, processState in pairs(processStates) do
        consistencyResults.processCount = consistencyResults.processCount + 1
        
        if processState.data then
            local currentChecksum = IntegrityMonitor._calculateChecksum(
                IntegrityMonitor._serializeData(processState.data)
            )
            
            if not referenceChecksum then
                referenceChecksum = currentChecksum
                referenceProcessId = processId
            elseif referenceChecksum ~= currentChecksum then
                -- Inconsistency detected
                consistencyResults.consistent = false
                table.insert(consistencyResults.conflicts, {
                    processId = processId,
                    expectedChecksum = referenceChecksum,
                    actualChecksum = currentChecksum,
                    referenceProcess = referenceProcessId
                })
            end
        end
    end
    
    local endTime = msg.Timestamp
    local checkTime = endTime - startTime
    
    -- Update metrics
    IntegrityMonitor.monitoringMetrics.totalChecks = IntegrityMonitor.monitoringMetrics.totalChecks + 1
    IntegrityMonitor.monitoringMetrics.totalCheckTime = IntegrityMonitor.monitoringMetrics.totalCheckTime + checkTime
    IntegrityMonitor.monitoringMetrics.averageCheckTime = 
        IntegrityMonitor.monitoringMetrics.totalCheckTime / IntegrityMonitor.monitoringMetrics.totalChecks
    
    if not consistencyResults.consistent then
        IntegrityMonitor.monitoringMetrics.consistencyViolations = 
            IntegrityMonitor.monitoringMetrics.consistencyViolations + 1
        
        -- Record consistency violation
        IntegrityMonitor._recordCorruptionIncident({
            checkType = IntegrityMonitor.CHECK_TYPES.CROSS_PROCESS_CONSISTENCY,
            severity = IntegrityMonitor.CORRUPTION_SEVERITY.MEDIUM,
            description = "Cross-process data consistency violation detected",
            dataKey = dataKey,
            conflicts = consistencyResults.conflicts,
            processCount = consistencyResults.processCount
        })
        
        -- Log audit event
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.DATA_INTEGRITY_VIOLATION,
            severity = AuditLogger.SEVERITY_LEVELS.MEDIUM,
            processId = ao.id or "security-process",
            eventData = {
                checkType = IntegrityMonitor.CHECK_TYPES.CROSS_PROCESS_CONSISTENCY,
                dataKey = dataKey,
                processCount = consistencyResults.processCount,
                conflictCount = #consistencyResults.conflicts,
                conflicts = consistencyResults.conflicts
            }
        })
    end
    
    return consistencyResults, checkTime
end

-- Monitor for state corruption patterns
function IntegrityMonitor.detectStateCorruption(gameState, stateType, contextId)
    local startTime = msg.Timestamp
    local corruptionDetails = {
        corrupted = false,
        corruptionTypes = {},
        severity = IntegrityMonitor.CORRUPTION_SEVERITY.LOW
    }
    
    if not gameState then
        return corruptionDetails, "No game state provided"
    end
    
    -- Pokemon state corruption checks
    if stateType == "pokemon" and gameState.pokemon then
        for pokemonIndex, pokemon in ipairs(gameState.pokemon) do
            local pokemonCorruption = IntegrityMonitor._checkPokemonStateCorruption(pokemon, pokemonIndex)
            if pokemonCorruption.corrupted then
                corruptionDetails.corrupted = true
                table.insert(corruptionDetails.corruptionTypes, pokemonCorruption)
                
                -- Update severity based on corruption type
                if pokemonCorruption.severity == IntegrityMonitor.CORRUPTION_SEVERITY.CRITICAL then
                    corruptionDetails.severity = IntegrityMonitor.CORRUPTION_SEVERITY.CRITICAL
                elseif pokemonCorruption.severity == IntegrityMonitor.CORRUPTION_SEVERITY.HIGH and
                       corruptionDetails.severity ~= IntegrityMonitor.CORRUPTION_SEVERITY.CRITICAL then
                    corruptionDetails.severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH
                end
            end
        end
    end
    
    -- Battle state corruption checks
    if stateType == "battle" and gameState.battleState then
        local battleCorruption = IntegrityMonitor._checkBattleStateCorruption(gameState.battleState)
        if battleCorruption.corrupted then
            corruptionDetails.corrupted = true
            table.insert(corruptionDetails.corruptionTypes, battleCorruption)
            
            if battleCorruption.severity == IntegrityMonitor.CORRUPTION_SEVERITY.CRITICAL then
                corruptionDetails.severity = IntegrityMonitor.CORRUPTION_SEVERITY.CRITICAL
            end
        end
    end
    
    -- Inventory state corruption checks
    if stateType == "inventory" and gameState.inventory then
        local inventoryCorruption = IntegrityMonitor._checkInventoryStateCorruption(gameState.inventory)
        if inventoryCorruption.corrupted then
            corruptionDetails.corrupted = true
            table.insert(corruptionDetails.corruptionTypes, inventoryCorruption)
        end
    end
    
    local endTime = msg.Timestamp
    local checkTime = endTime - startTime
    
    -- Update metrics and record incidents
    IntegrityMonitor.monitoringMetrics.totalChecks = IntegrityMonitor.monitoringMetrics.totalChecks + 1
    IntegrityMonitor.monitoringMetrics.totalCheckTime = IntegrityMonitor.monitoringMetrics.totalCheckTime + checkTime
    IntegrityMonitor.monitoringMetrics.averageCheckTime = 
        IntegrityMonitor.monitoringMetrics.totalCheckTime / IntegrityMonitor.monitoringMetrics.totalChecks
    
    if corruptionDetails.corrupted then
        IntegrityMonitor.monitoringMetrics.dataCorruptions = IntegrityMonitor.monitoringMetrics.dataCorruptions + 1
        
        IntegrityMonitor._recordCorruptionIncident({
            checkType = IntegrityMonitor.CHECK_TYPES.STATE_CORRUPTION,
            severity = corruptionDetails.severity,
            description = "Game state corruption detected",
            stateType = stateType,
            contextId = contextId,
            corruptionTypes = corruptionDetails.corruptionTypes
        })
    end
    
    return corruptionDetails, checkTime
end

-- Check Pokemon state for corruption
function IntegrityMonitor._checkPokemonStateCorruption(pokemon, pokemonIndex)
    local corruption = {
        corrupted = false,
        pokemonIndex = pokemonIndex,
        issues = {},
        severity = IntegrityMonitor.CORRUPTION_SEVERITY.LOW
    }
    
    -- HP validation
    if pokemon.hp and pokemon.maxHp then
        if pokemon.hp < 0 then
            corruption.corrupted = true
            corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH
            table.insert(corruption.issues, "Negative HP: " .. pokemon.hp)
        elseif pokemon.hp > pokemon.maxHp then
            corruption.corrupted = true
            corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.MEDIUM
            table.insert(corruption.issues, "HP exceeds maxHP: " .. pokemon.hp .. " > " .. pokemon.maxHp)
        end
    end
    
    -- Level validation
    if pokemon.level then
        if pokemon.level < 1 or pokemon.level > 100 then
            corruption.corrupted = true
            corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH
            table.insert(corruption.issues, "Invalid level: " .. pokemon.level)
        end
    end
    
    -- Stat validation
    local stats = {"attack", "defense", "spAttack", "spDefense", "speed"}
    for _, stat in ipairs(stats) do
        if pokemon[stat] and pokemon[stat] < 0 then
            corruption.corrupted = true
            corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH
            table.insert(corruption.issues, "Negative " .. stat .. ": " .. pokemon[stat])
        end
    end
    
    -- Move validation
    if pokemon.moves then
        for moveIndex, move in ipairs(pokemon.moves) do
            if move.pp and move.maxPP and move.pp > move.maxPP then
                corruption.corrupted = true
                corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.MEDIUM
                table.insert(corruption.issues, "Move " .. moveIndex .. " PP exceeds maxPP")
            end
        end
    end
    
    return corruption
end

-- Check battle state for corruption
function IntegrityMonitor._checkBattleStateCorruption(battleState)
    local corruption = {
        corrupted = false,
        issues = {},
        severity = IntegrityMonitor.CORRUPTION_SEVERITY.LOW
    }
    
    -- Turn validation
    if battleState.turn and battleState.turn < 0 then
        corruption.corrupted = true
        corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.MEDIUM
        table.insert(corruption.issues, "Negative turn number: " .. battleState.turn)
    end
    
    -- Active Pokemon validation
    if battleState.activePlayerPokemon and battleState.activePlayerPokemon.hp and 
       battleState.activePlayerPokemon.hp <= 0 and battleState.battlePhase ~= "FAINTED" then
        corruption.corrupted = true
        corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH
        table.insert(corruption.issues, "Active Pokemon has 0 HP but battle continues")
    end
    
    -- Battle phase consistency
    if battleState.battlePhase == "BATTLE_ENDED" and battleState.winner == nil then
        corruption.corrupted = true
        corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH
        table.insert(corruption.issues, "Battle ended but no winner declared")
    end
    
    return corruption
end

-- Check inventory state for corruption
function IntegrityMonitor._checkInventoryStateCorruption(inventory)
    local corruption = {
        corrupted = false,
        issues = {},
        severity = IntegrityMonitor.CORRUPTION_SEVERITY.LOW
    }
    
    -- Item quantity validation
    if inventory.items then
        for itemId, quantity in pairs(inventory.items) do
            if quantity < 0 then
                corruption.corrupted = true
                corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.MEDIUM
                table.insert(corruption.issues, "Negative item quantity for " .. itemId .. ": " .. quantity)
            elseif quantity > 999 then -- Assuming max stack of 999
                corruption.corrupted = true
                corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.MEDIUM
                table.insert(corruption.issues, "Item quantity exceeds maximum for " .. itemId .. ": " .. quantity)
            end
        end
    end
    
    -- Money validation
    if inventory.money and inventory.money < 0 then
        corruption.corrupted = true
        corruption.severity = IntegrityMonitor.CORRUPTION_SEVERITY.HIGH
        table.insert(corruption.issues, "Negative money: " .. inventory.money)
    end
    
    return corruption
end

-- Record corruption incident
function IntegrityMonitor._recordCorruptionIncident(incidentData)
    local incidentId = IntegrityMonitor._generateIncidentId()
    local timestamp = 0
    
    local incident = {
        incidentId = incidentId,
        checkType = incidentData.checkType,
        severity = incidentData.severity,
        description = incidentData.description,
        timestamp = timestamp,
        resolved = false,
        details = incidentData
    }
    
    IntegrityMonitor.corruptionIncidents[incidentId] = incident
    
    -- Log audit event
    AuditLogger.logSecurityEvent({
        eventType = AuditLogger.EVENT_TYPES.DATA_INTEGRITY_VIOLATION,
        severity = AuditLogger._mapCorruptionSeverityToAuditSeverity(incidentData.severity),
        processId = ao.id or "security-process",
        eventData = {
            incidentId = incidentId,
            checkType = incidentData.checkType,
            description = incidentData.description,
            details = incidentData
        }
    })
    
    -- Cleanup old incidents if at limit
    IntegrityMonitor._cleanupOldIncidents()
    
    return incidentId
end

-- Generate unique IDs
function IntegrityMonitor._generateChecksumId(dataType, contextId, timestamp)
    local randomSuffix = CryptoRNG.random(1000, 9999)
    return "checksum_" .. (dataType or "unknown") .. "_" .. (contextId or "unknown") .. "_" .. 
           timestamp .. "_" .. randomSuffix
end

function IntegrityMonitor._generateIncidentId()
    local timestamp = msg.Timestamp + CryptoRNG.random(0, 999)
    local randomSuffix = CryptoRNG.random(100000, 999999)
    return "incident_" .. timestamp .. "_" .. randomSuffix
end

-- Data serialization and checksum calculation
function IntegrityMonitor._serializeData(data)
    -- Simple JSON serialization for checksum calculation
    local success, serialized = pcall(json.encode, data)
    if success then
        return serialized
    else
        -- Fallback to string representation
        return tostring(data)
    end
end

function IntegrityMonitor._calculateChecksum(serializedData)
    -- Simple hash function for checksum calculation
    local checksum = 0
    for i = 1, #serializedData do
        local char = string.byte(serializedData, i)
        checksum = ((checksum * 31) + char) % 2147483647 -- Large prime for better distribution
    end
    return string.format("%08x", checksum) -- Return as hex string
end

-- Cleanup old incidents
function IntegrityMonitor._cleanupOldIncidents()
    local incidentCount = IntegrityMonitor._getTableSize(IntegrityMonitor.corruptionIncidents)
    
    if incidentCount > IntegrityMonitor.maxCorruptionHistory then
        local incidentArray = {}
        for incidentId, incident in pairs(IntegrityMonitor.corruptionIncidents) do
            incident.incidentId = incidentId
            table.insert(incidentArray, incident)
        end
        
        table.sort(incidentArray, function(a, b) return a.timestamp < b.timestamp end)
        
        -- Remove oldest 20%
        local removeCount = math.floor(incidentCount * 0.2)
        for i = 1, removeCount do
            IntegrityMonitor.corruptionIncidents[incidentArray[i].incidentId] = nil
        end
    end
end

-- Get integrity monitoring statistics
function IntegrityMonitor.getStatistics()
    return {
        totalChecks = IntegrityMonitor.monitoringMetrics.totalChecks,
        dataCorruptions = IntegrityMonitor.monitoringMetrics.dataCorruptions,
        consistencyViolations = IntegrityMonitor.monitoringMetrics.consistencyViolations,
        checksumMismatches = IntegrityMonitor.monitoringMetrics.checksumMismatches,
        averageCheckTime = IntegrityMonitor.monitoringMetrics.averageCheckTime,
        corruptionRate = IntegrityMonitor.monitoringMetrics.totalChecks > 0 and 
                        (IntegrityMonitor.monitoringMetrics.dataCorruptions / IntegrityMonitor.monitoringMetrics.totalChecks) or 0,
        storedChecksums = IntegrityMonitor._getTableSize(IntegrityMonitor.dataChecksums),
        activeIncidents = IntegrityMonitor._getTableSize(IntegrityMonitor.corruptionIncidents),
        checksumAlgorithm = IntegrityMonitor.checksumAlgorithm
    }
end

-- Get corruption incidents
function IntegrityMonitor.getCorruptionIncidents(severity, days, resolved)
    local incidents = {}
    days = days or 7
    local cutoffTime = 0 - (days * 24 * 3600)
    
    for incidentId, incident in pairs(IntegrityMonitor.corruptionIncidents) do
        if incident.timestamp >= cutoffTime then
            local includeIncident = true
            
            if severity and incident.severity ~= severity then
                includeIncident = false
            end
            
            if resolved ~= nil and incident.resolved ~= resolved then
                includeIncident = false
            end
            
            if includeIncident then
                table.insert(incidents, incident)
            end
        end
    end
    
    -- Sort by timestamp (most recent first)
    table.sort(incidents, function(a, b) return a.timestamp > b.timestamp end)
    
    return incidents
end

-- Resolve corruption incident
function IntegrityMonitor.resolveIncident(incidentId, resolutionNotes)
    local incident = IntegrityMonitor.corruptionIncidents[incidentId]
    if incident then
        incident.resolved = true
        incident.resolvedAt = 0
        incident.resolutionNotes = resolutionNotes or "Incident resolved"
        
        -- Log resolution
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.INCIDENT_RESOLVED,
            severity = AuditLogger.SEVERITY_LEVELS.LOW,
            processId = ao.id or "security-process",
            eventData = {
                incidentId = incidentId,
                resolutionNotes = resolutionNotes,
                originalSeverity = incident.severity
            }
        })
        
        return true
    end
    return false
end

-- Get health status
function IntegrityMonitor.getHealth()
    local stats = IntegrityMonitor.getStatistics()
    
    -- Check corruption rate
    if stats.corruptionRate > 0.1 then -- More than 10% corruption rate
        return "DEGRADED"
    end
    
    -- Check average check time
    if stats.averageCheckTime > 100 then -- More than 100ms average
        return "DEGRADED"
    end
    
    -- Check for unresolved critical incidents
    local criticalIncidents = IntegrityMonitor.getCorruptionIncidents(
        IntegrityMonitor.CORRUPTION_SEVERITY.CRITICAL, 1, false
    )
    
    if #criticalIncidents > 0 then
        return "DEGRADED"
    end
    
    return "HEALTHY"
end

-- Helper function
function IntegrityMonitor._getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end


-- ===== END MODULE: security.components.integrity-monitor =====


-- Process information for discovery
local PROCESS_INFO = {
    type = "SECURITY",
    version = "1.0.0",
    capabilities = {
        "security-validation",
        "anti-cheat-detection",
        "audit-logging",
        "policy-enforcement",
        "integrity-monitoring",
        "incident-response",
        "process-authentication",
        "*" -- Full capabilities for security process
    },
    description = "Centralized security validation and anti-cheat detection process",
    endpoints = {
        "SECURITY_VALIDATION",
        "SECURITY_EVENT_REPORT",
        "POLICY_ENFORCEMENT", 
        "AUDIT_LOG_REQUEST",
        "INTEGRITY_CHECK",
        "INCIDENT_RESPONSE"
    }
}

-- Global security process state
local securityState = {
    initialized = false,
    monitoredProcesses = {},
    activeValidations = {},
    securityPolicies = {},
    auditHistory = {},
    healthStatus = "HEALTHY",
    securityMetrics = {
        validationsProcessed = 0,
        threatsDetected = 0,
        incidentsResolved = 0,
        averageValidationTime = 0
    }
}

-- Expose globals for health checks
AntiCheatValidator = AntiCheatDetector
SecurityHandlers = {
    ValidationEngine = ValidationEngine,
    AntiCheatDetector = AntiCheatDetector,
    AuditLogger = AuditLogger,
    PolicyEnforcer = PolicyEnforcer,
    IntegrityMonitor = IntegrityMonitor
}

-- Initialize security process
local function initialize()
    print("[Security] Initializing security process...")
    
    -- Initialize process coordination foundation
    MessageCorrelator.initialize()
    ProcessAuthenticator.initialize()
    MessageRouter.initialize()
    PerformanceMonitor.initialize()
    
    -- Initialize security-specific components
    ValidationEngine.initialize()
    AntiCheatDetector.initialize()
    AuditLogger.initialize()
    PolicyEnforcer.initialize()
    IntegrityMonitor.initialize()
    
    -- Register this process with authenticator
    local walletAddress = ao.id or "security-process-wallet"
    local authResult = ProcessAuthenticator.registerProcess(
        ao.id or "security-process",
        PROCESS_INFO.type,
        walletAddress,
        PROCESS_INFO.capabilities
    )
    
    if authResult then
        print("[Security] Process registered successfully with ELEVATED auth level")
    else
        print("[Security] Warning: Process registration failed")
    end
    
    -- Load default security policies
    _loadDefaultSecurityPolicies()
    
    securityState.initialized = true
    securityState.startTime = 0
    
    print("[Security] Security process initialized")
    print("[Security] Process ID: " .. (ao.id or "unknown"))
    print("[Security] Capabilities: " .. table.concat(PROCESS_INFO.capabilities, ", "))
    print("[Security] Monitoring enabled for all registered processes")
end

-- Load default security policies
local function _loadDefaultSecurityPolicies()
    -- Input validation policy
    securityState.securityPolicies["input-validation"] = {
        policyId = "input-validation",
        policyName = "Input Validation Policy",
        enforcement = "BLOCK",
        processScope = {"*"},
        rules = {
            "validate-message-format",
            "validate-wallet-address", 
            "validate-data-types",
            "validate-required-fields"
        }
    }
    
    -- Anti-cheat policy
    securityState.securityPolicies["anti-cheat"] = {
        policyId = "anti-cheat",
        policyName = "Anti-Cheat Detection Policy",
        enforcement = "TERMINATE",
        processScope = {"battle", "pokemon", "shop"},
        rules = {
            "impossible-state-detection",
            "behavioral-analysis",
            "statistical-anomaly-detection"
        }
    }
    
    -- Process authentication policy
    securityState.securityPolicies["process-auth"] = {
        policyId = "process-auth",
        policyName = "Inter-Process Authentication Policy", 
        enforcement = "BLOCK",
        processScope = {"*"},
        rules = {
            "validate-process-token",
            "validate-process-capabilities",
            "validate-operation-authorization"
        }
    }
    
    -- Data integrity policy
    securityState.securityPolicies["data-integrity"] = {
        policyId = "data-integrity",
        policyName = "Data Integrity Monitoring Policy",
        enforcement = "WARN",
        processScope = {"*"},
        rules = {
            "cross-process-consistency",
            "integrity-checksum-validation",
            "state-corruption-detection"
        }
    }
    
    print("[Security] Loaded " .. _getTableSize(securityState.securityPolicies) .. " default security policies")
end

-- Process information handler for discovery
Handlers.add(
    "security-process-info",
    Handlers.utils.hasMatchingTag("Action", "Info"),
    function(msg)
        local processInfo = {
            process = PROCESS_INFO,
            state = {
                initialized = securityState.initialized,
                healthStatus = securityState.healthStatus,
                uptime = securityState.startTime and (0 - securityState.startTime) or 0,
                monitoredProcesses = _getTableSize(securityState.monitoredProcesses),
                activeValidations = _getTableSize(securityState.activeValidations),
                securityPolicies = _getTableSize(securityState.securityPolicies)
            },
            metrics = securityState.securityMetrics,
            statistics = {
                messageCorrelator = MessageCorrelator.getStatistics(),
                processAuthenticator = ProcessAuthenticator.getStatistics(),
                performanceMonitor = PerformanceMonitor.getMetrics()
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { Action = "Info-Response" },
            Data = json.encode(processInfo)
        })
    end
)

-- Health check handler
Handlers.add(
    "security-health-check",
    Handlers.utils.hasMatchingTag("Action", "HEALTH_CHECK"),
    function(msg)
        local healthInfo = {
            status = securityState.healthStatus,
            timestamp = msg.Timestamp,
            uptime = securityState.startTime and (0 - securityState.startTime) or 0,
            processId = ao.id or "unknown",
            version = PROCESS_INFO.version,
            components = {
                validationEngine = ValidationEngine.getHealth(),
                antiCheatDetector = AntiCheatDetector.getHealth(),
                auditLogger = AuditLogger.getHealth(),
                policyEnforcer = PolicyEnforcer.getHealth(),
                integrityMonitor = IntegrityMonitor.getHealth()
            },
            metrics = securityState.securityMetrics
        }
        
        ao.send({
            Target = msg.From,
            Tags = {
                Action = "HEALTH_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "health-check"
            },
            Data = json.encode(healthInfo)
        })
    end
)

-- Process registration monitoring handler
Handlers.add(
    "monitor-process-registration",
    Handlers.utils.hasMatchingTag("Action", "PROCESS_REGISTERED"),
    function(msg)
        local registrationData = json.decode(msg.Data)
        if registrationData and registrationData.processId then
            securityState.monitoredProcesses[registrationData.processId] = {
                processId = registrationData.processId,
                processType = registrationData.processType,
                registeredAt = 0,
                lastHealthCheck = 0,
                securityStatus = "MONITORED"
            }
            
            print("[Security] Now monitoring process: " .. registrationData.processId)
            
            -- Create audit log entry for new process monitoring
            AuditLogger.logSecurityEvent({
                eventType = "PROCESS_MONITORING_STARTED",
                severity = "LOW",
                processId = registrationData.processId,
                eventData = registrationData
            })
        end
    end
)

-- Security metrics update handler (internal timer)
Handlers.add(
    "update-security-metrics",
    Handlers.utils.hasMatchingTag("Action", "UPDATE_SECURITY_METRICS"),
    function(msg)
        -- Update performance metrics
        securityState.securityMetrics.averageValidationTime = ValidationEngine.getAverageValidationTime()
        
        -- Update health status based on component health
        local componentsHealthy = 
            ValidationEngine.getHealth() == "HEALTHY" and
            AntiCheatDetector.getHealth() == "HEALTHY" and
            AuditLogger.getHealth() == "HEALTHY" and
            PolicyEnforcer.getHealth() == "HEALTHY" and
            IntegrityMonitor.getHealth() == "HEALTHY"
        
        securityState.healthStatus = componentsHealthy and "HEALTHY" or "DEGRADED"
        
        print("[Security] Metrics updated - Status: " .. securityState.healthStatus)
    end
)

-- Error handler for unhandled security messages
Handlers.add(
    "security-error-handler",
    function(msg)
        -- Catch-all error handler for unhandled messages
        return not (msg.Tags.Action and (
            msg.Tags.Action == "SECURITY_VALIDATION" or
            msg.Tags.Action == "SECURITY_EVENT_REPORT" or
            msg.Tags.Action == "POLICY_ENFORCEMENT" or
            msg.Tags.Action == "AUDIT_LOG_REQUEST" or
            msg.Tags.Action == "INTEGRITY_CHECK" or
            msg.Tags.Action == "INCIDENT_RESPONSE" or
            msg.Tags.Action == "Info" or
            msg.Tags.Action == "HEALTH_CHECK" or
            msg.Tags.Action == "PROCESS_REGISTERED" or
            msg.Tags.Action == "UPDATE_SECURITY_METRICS"
        ))
    end,
    function(msg)
        print("[Security] Unhandled message: Action=" .. (msg.Tags.Action or "nil"))
        
        -- Log security event for unhandled message
        AuditLogger.logSecurityEvent({
            eventType = "UNHANDLED_MESSAGE",
            severity = "LOW",
            processId = msg.From or "unknown",
            eventData = {
                action = msg.Tags.Action,
                from = msg.From,
                correlationId = msg.Tags.CorrelationId
            }
        })
        
        if msg.From and msg.Tags.Action then
            ao.send({
                Target = msg.From,
                Tags = {
                    Action = "ERROR_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Unsupported security action",
                    action = msg.Tags.Action
                })
            })
        end
    end
)

-- Private helper functions

local function _getTableSize(tbl)
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

-- Load security-specific handlers

-- ===== MODULE: security.handlers.security-validation-handler =====
-- File: ao-processes/security/handlers/security-validation-handler.lua
-- Original require: require("security.handlers.security-validation-handler")

-- Security Validation Handler
-- Processes real-time security validation requests from all processes


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: security.components.validation-engine =====
-- File: ao-processes/security/components/validation-engine.lua
-- Original require: local ValidationEngine = require("security.components.validation-engine")


-- ===== END MODULE: security.components.validation-engine =====


-- ===== MODULE: security.components.policy-enforcer =====
-- File: ao-processes/security/components/policy-enforcer.lua
-- Original require: local PolicyEnforcer = require("security.components.policy-enforcer")


-- ===== END MODULE: security.components.policy-enforcer =====


-- ===== MODULE: security.components.audit-logger =====
-- File: ao-processes/security/components/audit-logger.lua
-- Original require: local AuditLogger = require("security.components.audit-logger")


-- ===== END MODULE: security.components.audit-logger =====


-- Security Validation Request Handler
Handlers.add(
    "security-validation",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_VALIDATION"),
    function(msg)
        local startTime = msg.Timestamp
        
        -- Parse validation request
        local validationRequest = json.decode(msg.Data)
        if not validationRequest then
            local errorResponse = {
                correlation = {
                    id = msg.Tags.CorrelationId or "unknown",
                    responseType = "VALIDATION_ERROR"
                },
                result = {
                    success = false,
                    error = "Invalid validation request format",
                    valid = false,
                    securityAction = "BLOCK"
                }
            }
            
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_VALIDATION_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode(errorResponse)
            })
            return
        end
        
        local correlationId = (validationRequest.correlation and validationRequest.correlation.id) or 
                             msg.Tags.CorrelationId or
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        -- Update correlation status
        MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.PROCESSING)
        
        print(string.format("[SecurityValidationHandler] Processing validation request from %s - Type: %s", 
              msg.From, validationRequest.validationData and validationRequest.validationData.validationType or "unknown"))
        
        -- Validate request format
        if not validationRequest.validationData or 
           not validationRequest.validationData.validationType or
           not ValidationEngine.VALIDATION_TYPES[validationRequest.validationData.validationType] then
            
            local errorResponse = {
                correlation = {
                    id = correlationId,
                    responseType = "VALIDATION_ERROR"
                },
                result = {
                    success = false,
                    error = "Invalid validation type or missing validation data",
                    valid = false,
                    securityAction = "BLOCK"
                }
            }
            
            MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.FAILED, 
                                                      "Invalid validation request")
            
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_VALIDATION_RESPONSE",
                    CorrelationId = correlationId
                },
                Data = json.encode(errorResponse)
            })
            return
        end
        
        local validationData = validationRequest.validationData
        local processAuth = validationRequest.processAuth
        
        -- Authenticate requesting process if auth data provided
        local authContext = nil
        if processAuth and processAuth.authToken then

-- ===== MODULE: game-logic.process-coordination.process-authenticator =====
-- File: ao-processes/game-logic/process-coordination/process-authenticator.lua
-- Original require:             local ProcessAuthenticator = require("game-logic.process-coordination.process-authenticator")


-- ===== END MODULE: game-logic.process-coordination.process-authenticator =====

            local isValidAuth, authResult, authError = ProcessAuthenticator.validateAuthToken(
                processAuth.authToken.tokenId, 
                processAuth.authToken.signature
            )
            
            if isValidAuth then
                authContext = authResult
            else
                print("[SecurityValidationHandler] Process authentication failed: " .. tostring(authError))
            end
        end
        
        -- Perform validation using ValidationEngine
        local isValid, violations, securityAction, validationSource = ValidationEngine.validate(
            validationData.validationType,
            validationData.data,
            validationData.processId or msg.From
        )
        
        -- Enforce security policies
        local policyContext = {
            validationType = validationData.validationType,
            playerId = validationData.playerId,
            processId = validationData.processId or msg.From,
            operation = validationData.operation,
            messageType = "SECURITY_VALIDATION",
            correlationId = correlationId,
            authContext = authContext,
            data = validationData.data
        }
        
        local policyResult, policyTime = PolicyEnforcer.enforcePolicies(policyContext)
        
        -- Combine validation and policy results
        local finalSecurityAction = securityAction
        if not policyResult.allowed then
            finalSecurityAction = policyResult.enforcement == "TERMINATE" and "TERMINATE" or "BLOCK"
            isValid = false
            
            -- Add policy violations to validation violations
            if policyResult.violations then
                for _, policyViolation in ipairs(policyResult.violations) do
                    table.insert(violations, {
                        ruleId = "policy-" .. policyViolation.policyId,
                        severity = "HIGH",
                        errorMessage = policyViolation.violationMessage,
                        timestamp = msg.Timestamp,
                        type = "POLICY_VIOLATION"
                    })
                end
            end
        end
        
        local endTime = msg.Timestamp
        local totalValidationTime = endTime - startTime
        
        -- Create validation result
        local validationResult = {
            valid = isValid,
            validationType = validationData.validationType,
            violations = violations,
            securityAction = finalSecurityAction,
            playerId = validationData.playerId,
            processId = validationData.processId or msg.From,
            validationLatency = totalValidationTime,
            policyLatency = policyTime,
            rulesEvaluated = #violations,
            cacheHit = validationSource == "CACHED",
            auditEventId = nil -- Will be set by audit logging
        }
        
        -- Log validation result to audit system
        local auditEventId = AuditLogger.logValidationResult(validationResult, correlationId)
        validationResult.auditEventId = auditEventId
        
        -- Prepare response
        local validationResponse = {
            correlation = {
                id = correlationId,
                responseType = "VALIDATION_RESULT"
            },
            result = {
                success = true,
                valid = validationResult.valid,
                validationType = validationResult.validationType,
                violations = validationResult.violations,
                securityAction = validationResult.securityAction,
                auditEventId = validationResult.auditEventId
            },
            metadata = {
                validationLatency = validationResult.validationLatency,
                policyLatency = validationResult.policyLatency,
                rulesEvaluated = validationResult.rulesEvaluated,
                cacheHit = validationResult.cacheHit,
                processedAt = 0
            }
        }
        
        -- Update correlation status
        MessageCorrelator.updateCorrelationStatus(
            correlationId, 
            MessageCorrelator.MESSAGE_STATUS.COMPLETED
        )
        
        -- Send validation response
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_VALIDATION_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(validationResponse)
        })
        
        print(string.format(
            "[SecurityValidationHandler] Validation completed: %s (%s) - Action: %s - Time: %dms",
            isValid and "VALID" or "INVALID",
            validationData.validationType,
            finalSecurityAction,
            totalValidationTime
        ))
    end
)

-- Batch Validation Handler (for multiple validations in one request)
Handlers.add(
    "security-batch-validation",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_BATCH_VALIDATION"),
    function(msg)
        local startTime = msg.Timestamp
        
        -- Parse batch validation request
        local batchRequest = json.decode(msg.Data)
        if not batchRequest or not batchRequest.validations or type(batchRequest.validations) ~= "table" then
            local errorResponse = {
                correlation = {
                    id = msg.Tags.CorrelationId or "unknown",
                    responseType = "BATCH_VALIDATION_ERROR"
                },
                result = {
                    success = false,
                    error = "Invalid batch validation request format",
                    validationResults = {}
                }
            }
            
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_BATCH_VALIDATION_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode(errorResponse)
            })
            return
        end
        
        local correlationId = (batchRequest.correlation and batchRequest.correlation.id) or 
                             msg.Tags.CorrelationId or
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.PROCESSING)
        
        print(string.format("[SecurityValidationHandler] Processing batch validation: %d validations from %s", 
              #batchRequest.validations, msg.From))
        
        local validationResults = {}
        local allValid = true
        local totalViolations = 0
        
        -- Process each validation in the batch
        for i, validationData in ipairs(batchRequest.validations) do
            if ValidationEngine.VALIDATION_TYPES[validationData.validationType] then
                local isValid, violations, securityAction = ValidationEngine.validate(
                    validationData.validationType,
                    validationData.data,
                    validationData.processId or msg.From
                )
                
                local validationResult = {
                    index = i,
                    valid = isValid,
                    validationType = validationData.validationType,
                    violations = violations,
                    securityAction = securityAction,
                    playerId = validationData.playerId,
                    processId = validationData.processId or msg.From
                }
                
                table.insert(validationResults, validationResult)
                
                if not isValid then
                    allValid = false
                    totalViolations = totalViolations + #violations
                end
                
                -- Log individual validation result
                AuditLogger.logValidationResult(validationResult, correlationId .. "_" .. i)
                
            else
                -- Invalid validation type
                table.insert(validationResults, {
                    index = i,
                    valid = false,
                    validationType = validationData.validationType,
                    violations = {{
                        ruleId = "invalid-validation-type",
                        severity = "HIGH",
                        errorMessage = "Invalid validation type: " .. tostring(validationData.validationType),
                        timestamp = 0
                    }},
                    securityAction = "BLOCK",
                    playerId = validationData.playerId,
                    processId = validationData.processId or msg.From
                })
                allValid = false
                totalViolations = totalViolations + 1
            end
        end
        
        local endTime = msg.Timestamp
        local totalProcessingTime = endTime - startTime
        
        -- Prepare batch response
        local batchResponse = {
            correlation = {
                id = correlationId,
                responseType = "BATCH_VALIDATION_RESULT"
            },
            result = {
                success = true,
                allValid = allValid,
                validationResults = validationResults,
                summary = {
                    totalValidations = #batchRequest.validations,
                    validValidations = #batchRequest.validations - (#validationResults - (#batchRequest.validations - totalViolations)),
                    totalViolations = totalViolations
                }
            },
            metadata = {
                processingTime = totalProcessingTime,
                averageValidationTime = totalProcessingTime / #batchRequest.validations,
                processedAt = 0
            }
        }
        
        MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.COMPLETED)
        
        -- Send batch response
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_BATCH_VALIDATION_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(batchResponse)
        })
        
        print(string.format(
            "[SecurityValidationHandler] Batch validation completed: %d/%d valid - Time: %dms",
            #batchRequest.validations - totalViolations,
            #batchRequest.validations,
            totalProcessingTime
        ))
    end
)

-- Validation Rule Management Handler
Handlers.add(
    "security-validation-rule-management",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_VALIDATION_RULE_MANAGEMENT"),
    function(msg)
        local request = json.decode(msg.Data)
        if not request or not request.operation then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_VALIDATION_RULE_MANAGEMENT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid rule management request"
                })
            })
            return
        end
        
        local result = { success = false, error = "Unknown operation" }
        
        if request.operation == "ADD_RULE" and request.rule then
            local success, error = ValidationEngine.addValidationRule(request.rule)
            result.success = success
            result.error = error
            
        elseif request.operation == "REMOVE_RULE" and request.ruleId then
            result.success = ValidationEngine.removeValidationRule(request.ruleId)
            result.error = not result.success and "Rule not found" or nil
            
        elseif request.operation == "ENABLE_RULE" and request.ruleId then
            result.success = ValidationEngine.setRuleEnabled(request.ruleId, true)
            result.error = not result.success and "Rule not found" or nil
            
        elseif request.operation == "DISABLE_RULE" and request.ruleId then
            result.success = ValidationEngine.setRuleEnabled(request.ruleId, false)
            result.error = not result.success and "Rule not found" or nil
            
        elseif request.operation == "LIST_RULES" then
            result.success = true
            result.rules = ValidationEngine.getValidationRules(request.ruleType, request.processId)
            
        elseif request.operation == "GET_STATISTICS" then
            result.success = true
            result.statistics = ValidationEngine.getStatistics()
        end
        
        -- Log rule management activity
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.SYSTEM_EVENT,
            severity = AuditLogger.SEVERITY_LEVELS.LOW,
            processId = msg.From,
            eventData = {
                operation = request.operation,
                ruleId = request.ruleId,
                success = result.success,
                error = result.error
            }
        })
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_VALIDATION_RULE_MANAGEMENT_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "unknown"
            },
            Data = json.encode(result)
        })
    end
)


-- ===== END MODULE: security.handlers.security-validation-handler =====


-- ===== MODULE: security.handlers.security-audit-handler =====
-- File: ao-processes/security/handlers/security-audit-handler.lua
-- Original require: require("security.handlers.security-audit-handler") 

-- Security Audit Handler
-- Processes audit log requests and security event reporting


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: security.components.audit-logger =====
-- File: ao-processes/security/components/audit-logger.lua
-- Original require: local AuditLogger = require("security.components.audit-logger")


-- ===== END MODULE: security.components.audit-logger =====


-- ===== MODULE: security.components.anti-cheat-detector =====
-- File: ao-processes/security/components/anti-cheat-detector.lua
-- Original require: local AntiCheatDetector = require("security.components.anti-cheat-detector")


-- ===== END MODULE: security.components.anti-cheat-detector =====


-- Audit Log Query Handler
Handlers.add(
    "audit-log-request",
    Handlers.utils.hasMatchingTag("Action", "AUDIT_LOG_REQUEST"),
    function(msg)
        local startTime = msg.Timestamp
        
        -- Parse audit query request
        local auditQuery = json.decode(msg.Data)
        if not auditQuery then
            local errorResponse = {
                correlation = {
                    id = msg.Tags.CorrelationId or "unknown",
                    responseType = "AUDIT_QUERY_ERROR"
                },
                result = {
                    success = false,
                    error = "Invalid audit query request format",
                    events = {}
                }
            }
            
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "AUDIT_LOG_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode(errorResponse)
            })
            return
        end
        
        local correlationId = (auditQuery.correlation and auditQuery.correlation.id) or 
                             msg.Tags.CorrelationId or
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.PROCESSING)
        
        print(string.format("[SecurityAuditHandler] Processing audit query from %s", msg.From))
        
        -- Extract query filters
        local filters = auditQuery.filters or {}
        local limit = auditQuery.limit or 100
        local offset = auditQuery.offset or 0
        
        -- Query audit events
        local events, totalMatched = AuditLogger.queryAuditEvents(filters, limit, offset)
        
        local endTime = msg.Timestamp
        local queryTime = endTime - startTime
        
        -- Prepare audit response
        local auditResponse = {
            correlation = {
                id = correlationId,
                responseType = "AUDIT_QUERY_RESULT"
            },
            result = {
                success = true,
                events = events,
                totalMatched = totalMatched,
                returned = #events,
                limit = limit,
                offset = offset
            },
            metadata = {
                queryTime = queryTime,
                processedAt = 0,
                requestedBy = msg.From
            }
        }
        
        MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.COMPLETED)
        
        -- Send audit response
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "AUDIT_LOG_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(auditResponse)
        })
        
        -- Log audit access
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.SYSTEM_EVENT,
            severity = AuditLogger.SEVERITY_LEVELS.LOW,
            processId = msg.From,
            eventData = {
                operation = "AUDIT_LOG_ACCESS",
                eventsReturned = #events,
                totalMatched = totalMatched,
                filters = filters,
                queryTime = queryTime
            }
        }, correlationId)
        
        print(string.format(
            "[SecurityAuditHandler] Audit query completed: %d/%d events returned - Time: %dms",
            #events, totalMatched, queryTime
        ))
    end
)

-- Security Event Correlation Handler
Handlers.add(
    "security-event-correlation",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_EVENT_CORRELATION"),
    function(msg)
        local correlationQuery = json.decode(msg.Data)
        if not correlationQuery or not correlationQuery.correlationId then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_EVENT_CORRELATION_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Missing correlation ID for event correlation query"
                })
            })
            return
        end
        
        local requestCorrelationId = msg.Tags.CorrelationId or 
                                    MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        -- Get correlated events
        local correlatedEvents = AuditLogger.getEventsByCorrelation(correlationQuery.correlationId)
        
        -- Get correlation chain from MessageCorrelator
        local correlationChain = MessageCorrelator.getCorrelationChain(correlationQuery.correlationId)
        
        local correlationResponse = {
            correlation = {
                id = requestCorrelationId,
                responseType = "EVENT_CORRELATION_RESULT"
            },
            result = {
                success = true,
                targetCorrelationId = correlationQuery.correlationId,
                correlatedEvents = correlatedEvents,
                correlationChain = correlationChain,
                eventCount = #correlatedEvents
            },
            metadata = {
                processedAt = 0,
                requestedBy = msg.From
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_EVENT_CORRELATION_RESPONSE",
                CorrelationId = requestCorrelationId
            },
            Data = json.encode(correlationResponse)
        })
        
        print(string.format(
            "[SecurityAuditHandler] Event correlation query completed: %d events found for correlation %s",
            #correlatedEvents, correlationQuery.correlationId
        ))
    end
)

-- Player Security History Handler
Handlers.add(
    "player-security-history",
    Handlers.utils.hasMatchingTag("Action", "PLAYER_SECURITY_HISTORY"),
    function(msg)
        local historyQuery = json.decode(msg.Data)
        if not historyQuery or not historyQuery.playerId then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "PLAYER_SECURITY_HISTORY_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Missing player ID for security history query"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local playerId = historyQuery.playerId
        local days = historyQuery.days or 30 -- Default to last 30 days
        local eventTypes = historyQuery.eventTypes -- Optional filter
        
        -- Get player security events
        local securityEvents = AuditLogger.getPlayerSecurityEvents(playerId, eventTypes, days)
        
        -- Get player behavior analysis from AntiCheatDetector
        local behaviorAnalysis, behaviorError = AntiCheatDetector.getPlayerBehaviorAnalysis(playerId)
        
        -- Get policy violations for this player

-- ===== MODULE: security.components.policy-enforcer =====
-- File: ao-processes/security/components/policy-enforcer.lua
-- Original require:         local PolicyEnforcer = require("security.components.policy-enforcer")


-- ===== END MODULE: security.components.policy-enforcer =====

        local policyViolations = PolicyEnforcer.getPolicyViolations(playerId, nil, days)
        
        local historyResponse = {
            correlation = {
                id = correlationId,
                responseType = "PLAYER_SECURITY_HISTORY_RESULT"
            },
            result = {
                success = true,
                playerId = playerId,
                securityEvents = securityEvents,
                behaviorAnalysis = behaviorAnalysis,
                policyViolations = policyViolations,
                summary = {
                    totalSecurityEvents = #securityEvents,
                    totalPolicyViolations = #policyViolations,
                    daysCovered = days,
                    riskLevel = behaviorAnalysis and behaviorAnalysis.riskLevel or "UNKNOWN"
                }
            },
            metadata = {
                processedAt = 0,
                requestedBy = msg.From
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "PLAYER_SECURITY_HISTORY_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(historyResponse)
        })
        
        -- Log security history access
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.SYSTEM_EVENT,
            severity = AuditLogger.SEVERITY_LEVELS.LOW,
            processId = msg.From,
            playerId = playerId,
            eventData = {
                operation = "PLAYER_SECURITY_HISTORY_ACCESS",
                daysCovered = days,
                eventsReturned = #securityEvents,
                violationsReturned = #policyViolations,
                riskLevel = behaviorAnalysis and behaviorAnalysis.riskLevel or "UNKNOWN"
            }
        }, correlationId)
        
        print(string.format(
            "[SecurityAuditHandler] Player security history completed for %s: %d events, %d violations",
            playerId, #securityEvents, #policyViolations
        ))
    end
)

-- Security Statistics Handler
Handlers.add(
    "security-statistics",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_STATISTICS"),
    function(msg)
        local statsQuery = json.decode(msg.Data)
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        -- Collect statistics from all security components
        local auditStats = AuditLogger.getStatistics()

-- ===== MODULE: security.components.validation-engine =====
-- File: ao-processes/security/components/validation-engine.lua
-- Original require:         local ValidationEngine = require("security.components.validation-engine")


-- ===== END MODULE: security.components.validation-engine =====

        local validationStats = ValidationEngine.getStatistics()
        local cheatDetectionStats = AntiCheatDetector.getStatistics()

-- ===== MODULE: security.components.policy-enforcer =====
-- File: ao-processes/security/components/policy-enforcer.lua
-- Original require:         local PolicyEnforcer = require("security.components.policy-enforcer")


-- ===== END MODULE: security.components.policy-enforcer =====

        local policyStats = PolicyEnforcer.getStatistics()

-- ===== MODULE: security.components.integrity-monitor =====
-- File: ao-processes/security/components/integrity-monitor.lua
-- Original require:         local IntegrityMonitor = require("security.components.integrity-monitor")


-- ===== END MODULE: security.components.integrity-monitor =====

        local integrityStats = IntegrityMonitor.getStatistics()
        
        -- Calculate aggregate statistics
        local aggregateStats = {
            totalSecurityChecks = validationStats.totalValidations + cheatDetectionStats.totalChecks + integrityStats.totalChecks,
            totalSecurityEvents = auditStats.totalEvents,
            totalThreatDetections = cheatDetectionStats.cheatsDetected + integrityStats.dataCorruptions,
            systemHealth = {
                validation = ValidationEngine.getHealth(),
                cheatDetection = AntiCheatDetector.getHealth(),
                audit = AuditLogger.getHealth(),
                policy = PolicyEnforcer.getHealth(),
                integrity = IntegrityMonitor.getHealth()
            }
        }
        
        local statisticsResponse = {
            correlation = {
                id = correlationId,
                responseType = "SECURITY_STATISTICS_RESULT"
            },
            result = {
                success = true,
                statistics = {
                    audit = auditStats,
                    validation = validationStats,
                    cheatDetection = cheatDetectionStats,
                    policy = policyStats,
                    integrity = integrityStats,
                    aggregate = aggregateStats
                }
            },
            metadata = {
                processedAt = 0,
                requestedBy = msg.From
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_STATISTICS_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(statisticsResponse)
        })
        
        print("[SecurityAuditHandler] Security statistics query completed")
    end
)

-- Audit Export Handler (for compliance and external analysis)
Handlers.add(
    "audit-export",
    Handlers.utils.hasMatchingTag("Action", "AUDIT_EXPORT"),
    function(msg)
        local exportQuery = json.decode(msg.Data)
        if not exportQuery then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "AUDIT_EXPORT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid audit export request format"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local startDate = exportQuery.startDate
        local endDate = exportQuery.endDate
        local eventTypes = exportQuery.eventTypes
        
        -- Export audit events
        local exportedEvents = AuditLogger.exportAuditEvents(startDate, endDate, eventTypes)
        
        local exportResponse = {
            correlation = {
                id = correlationId,
                responseType = "AUDIT_EXPORT_RESULT"
            },
            result = {
                success = true,
                exportedEvents = exportedEvents,
                eventCount = #exportedEvents,
                exportCriteria = {
                    startDate = startDate,
                    endDate = endDate,
                    eventTypes = eventTypes
                }
            },
            metadata = {
                exportedAt = 0,
                requestedBy = msg.From
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "AUDIT_EXPORT_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(exportResponse)
        })
        
        -- Log export activity
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.SYSTEM_EVENT,
            severity = AuditLogger.SEVERITY_LEVELS.MEDIUM,
            processId = msg.From,
            eventData = {
                operation = "AUDIT_EXPORT",
                eventCount = #exportedEvents,
                startDate = startDate,
                endDate = endDate,
                eventTypes = eventTypes
            }
        }, correlationId)
        
        print(string.format(
            "[SecurityAuditHandler] Audit export completed: %d events exported",
            #exportedEvents
        ))
    end
)

-- Security Event Report Handler (for incoming security events from other processes)
Handlers.add(
    "security-event-report",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_EVENT_REPORT"),
    function(msg)
        local eventReport = json.decode(msg.Data)
        if not eventReport or not eventReport.securityEvent then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_EVENT_REPORT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid security event report format"
                })
            })
            return
        end
        
        local correlationId = (eventReport.correlation and eventReport.correlation.id) or 
                             msg.Tags.CorrelationId or
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local securityEvent = eventReport.securityEvent
        
        -- Validate and enrich the security event
        securityEvent.processId = securityEvent.processId or msg.From
        securityEvent.reportedBy = msg.From
        securityEvent.reportedAt = 0
        
        -- Log the reported security event
        local auditEventId = AuditLogger.logSecurityEvent({
            eventType = securityEvent.eventType or AuditLogger.EVENT_TYPES.SECURITY_ALERT,
            severity = securityEvent.severity or AuditLogger.SEVERITY_LEVELS.MEDIUM,
            playerId = securityEvent.playerId,
            processId = securityEvent.processId,
            eventData = securityEvent.eventData,
            actionTaken = securityEvent.actionTaken
        }, correlationId)
        
        local reportResponse = {
            correlation = {
                id = correlationId,
                responseType = "SECURITY_EVENT_REPORT_ACKNOWLEDGMENT"
            },
            result = {
                success = true,
                auditEventId = auditEventId,
                message = "Security event logged successfully"
            },
            metadata = {
                processedAt = 0,
                reportedBy = msg.From
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_EVENT_REPORT_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(reportResponse)
        })
        
        print(string.format(
            "[SecurityAuditHandler] Security event report logged: %s from %s - Event ID: %s",
            securityEvent.eventType or "UNKNOWN",
            msg.From,
            auditEventId
        ))
    end
)


-- ===== END MODULE: security.handlers.security-audit-handler =====


-- ===== MODULE: security.handlers.security-enforcement-handler =====
-- File: ao-processes/security/handlers/security-enforcement-handler.lua
-- Original require: require("security.handlers.security-enforcement-handler")

-- Security Enforcement Handler
-- Processes policy enforcement requests and security action execution


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: security.components.policy-enforcer =====
-- File: ao-processes/security/components/policy-enforcer.lua
-- Original require: local PolicyEnforcer = require("security.components.policy-enforcer")


-- ===== END MODULE: security.components.policy-enforcer =====


-- ===== MODULE: security.components.audit-logger =====
-- File: ao-processes/security/components/audit-logger.lua
-- Original require: local AuditLogger = require("security.components.audit-logger")


-- ===== END MODULE: security.components.audit-logger =====


-- ===== MODULE: security.components.anti-cheat-detector =====
-- File: ao-processes/security/components/anti-cheat-detector.lua
-- Original require: local AntiCheatDetector = require("security.components.anti-cheat-detector")


-- ===== END MODULE: security.components.anti-cheat-detector =====


-- Policy Enforcement Handler
Handlers.add(
    "policy-enforcement",
    Handlers.utils.hasMatchingTag("Action", "POLICY_ENFORCEMENT"),
    function(msg)
        local startTime = msg.Timestamp
        
        -- Parse enforcement request
        local enforcementRequest = json.decode(msg.Data)
        if not enforcementRequest or not enforcementRequest.context then
            local errorResponse = {
                correlation = {
                    id = msg.Tags.CorrelationId or "unknown",
                    responseType = "ENFORCEMENT_ERROR"
                },
                result = {
                    success = false,
                    error = "Invalid policy enforcement request format",
                    allowed = false,
                    enforcement = "BLOCK"
                }
            }
            
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "POLICY_ENFORCEMENT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode(errorResponse)
            })
            return
        end
        
        local correlationId = (enforcementRequest.correlation and enforcementRequest.correlation.id) or 
                             msg.Tags.CorrelationId or
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.PROCESSING)
        
        local context = enforcementRequest.context
        context.correlationId = correlationId
        context.processId = context.processId or msg.From
        
        print(string.format("[SecurityEnforcementHandler] Processing policy enforcement from %s - Operation: %s", 
              msg.From, context.operation or "unknown"))
        
        -- Perform policy enforcement
        local enforcementResult, enforcementTime = PolicyEnforcer.enforcePolicies(context)
        
        local endTime = msg.Timestamp
        local totalProcessingTime = endTime - startTime
        
        -- Log enforcement action
        if #enforcementResult.violations > 0 then
            AuditLogger.logSecurityEvent({
                eventType = AuditLogger.EVENT_TYPES.POLICY_VIOLATION,
                severity = enforcementResult.enforcement == "TERMINATE" and AuditLogger.SEVERITY_LEVELS.CRITICAL or
                          enforcementResult.enforcement == "BLOCK" and AuditLogger.SEVERITY_LEVELS.HIGH or
                          AuditLogger.SEVERITY_LEVELS.MEDIUM,
                playerId = context.playerId,
                processId = context.processId,
                eventData = {
                    violations = enforcementResult.violations,
                    enforcement = enforcementResult.enforcement,
                    operation = context.operation,
                    allowed = enforcementResult.allowed
                },
                actionTaken = enforcementResult.enforcement
            }, correlationId)
        end
        
        -- Prepare enforcement response
        local enforcementResponse = {
            correlation = {
                id = correlationId,
                responseType = "ENFORCEMENT_RESULT"
            },
            result = {
                success = true,
                allowed = enforcementResult.allowed,
                enforcement = enforcementResult.enforcement,
                violations = enforcementResult.violations,
                actionMessage = enforcementResult.actionMessage
            },
            metadata = {
                enforcementTime = enforcementTime,
                totalProcessingTime = totalProcessingTime,
                violationCount = #enforcementResult.violations,
                processedAt = 0
            }
        }
        
        MessageCorrelator.updateCorrelationStatus(correlationId, MessageCorrelator.MESSAGE_STATUS.COMPLETED)
        
        -- Send enforcement response
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "POLICY_ENFORCEMENT_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(enforcementResponse)
        })
        
        print(string.format(
            "[SecurityEnforcementHandler] Enforcement completed: %s (%d violations) - Time: %dms",
            enforcementResult.allowed and "ALLOWED" or "BLOCKED",
            #enforcementResult.violations,
            totalProcessingTime
        ))
    end
)

-- Security Action Execution Handler
Handlers.add(
    "security-action-execution",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_ACTION_EXECUTION"),
    function(msg)
        local actionRequest = json.decode(msg.Data)
        if not actionRequest or not actionRequest.action or not actionRequest.target then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_ACTION_EXECUTION_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid security action execution request"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local action = actionRequest.action
        local target = actionRequest.target
        local reason = actionRequest.reason or "Security enforcement action"
        local severity = actionRequest.severity or "MEDIUM"
        
        local executionResult = {
            success = false,
            action = action,
            target = target,
            executed = false,
            message = "Unknown action"
        }
        
        print(string.format("[SecurityEnforcementHandler] Executing security action: %s on %s", action, target.type))
        
        -- Execute the security action based on type
        if action == "WARN_PLAYER" then
            executionResult = _executePlayerWarning(target, reason, correlationId)
            
        elseif action == "SUSPEND_PLAYER" then
            executionResult = _executePlayerSuspension(target, reason, correlationId)
            
        elseif action == "TERMINATE_SESSION" then
            executionResult = _executeSessionTermination(target, reason, correlationId)
            
        elseif action == "BLOCK_PROCESS" then
            executionResult = _executeProcessBlock(target, reason, correlationId)
            
        elseif action == "QUARANTINE_DATA" then
            executionResult = _executeDataQuarantine(target, reason, correlationId)
            
        elseif action == "ALERT_ADMINISTRATORS" then
            executionResult = _executeAdministratorAlert(target, reason, severity, correlationId)
            
        else
            executionResult.message = "Unsupported security action: " .. action
        end
        
        -- Log the security action execution
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.SECURITY_ALERT,
            severity = severity == "CRITICAL" and AuditLogger.SEVERITY_LEVELS.CRITICAL or
                      severity == "HIGH" and AuditLogger.SEVERITY_LEVELS.HIGH or
                      AuditLogger.SEVERITY_LEVELS.MEDIUM,
            playerId = target.playerId,
            processId = target.processId or msg.From,
            eventData = {
                action = action,
                target = target,
                reason = reason,
                success = executionResult.success,
                executed = executionResult.executed,
                message = executionResult.message
            },
            actionTaken = action
        }, correlationId)
        
        -- Send execution response
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_ACTION_EXECUTION_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode({
                success = executionResult.success,
                executed = executionResult.executed,
                action = executionResult.action,
                target = executionResult.target,
                message = executionResult.message,
                correlationId = correlationId,
                processedAt = 0
            })
        })
        
        print(string.format(
            "[SecurityEnforcementHandler] Security action %s: %s",
            executionResult.executed and "executed" or "failed",
            executionResult.message
        ))
    end
)

-- Anti-Cheat Action Handler
Handlers.add(
    "anti-cheat-action",
    Handlers.utils.hasMatchingTag("Action", "ANTI_CHEAT_ACTION"),
    function(msg)
        local cheatActionRequest = json.decode(msg.Data)
        if not cheatActionRequest or not cheatActionRequest.playerId or not cheatActionRequest.cheatData then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "ANTI_CHEAT_ACTION_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid anti-cheat action request"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local playerId = cheatActionRequest.playerId
        local cheatData = cheatActionRequest.cheatData
        
        -- Perform cheat analysis
        local cheatDetected, detectedCheats, suspicionScore, analysisTime = 
            AntiCheatDetector.analyzeForCheating(cheatData, playerId)
        
        local actionTaken = "NONE"
        local actionMessage = "No cheat detected"
        
        if cheatDetected then
            -- Determine action based on suspicion score and cheat types
            if suspicionScore >= AntiCheatDetector.SUSPICION_LEVELS.CRITICAL then
                actionTaken = "TERMINATE_SESSION"
                actionMessage = "Critical cheat detected - session terminated"
                
                -- Execute immediate session termination
                _executeSessionTermination({
                    type = "player_session",
                    playerId = playerId
                }, "Critical anti-cheat violation", correlationId)
                
            elseif suspicionScore >= AntiCheatDetector.SUSPICION_LEVELS.HIGH then
                actionTaken = "SUSPEND_PLAYER"
                actionMessage = "High-confidence cheat detected - player suspended"
                
                -- Execute player suspension
                _executePlayerSuspension({
                    type = "player",
                    playerId = playerId
                }, "High-confidence anti-cheat violation", correlationId)
                
            elseif suspicionScore >= AntiCheatDetector.SUSPICION_LEVELS.MEDIUM then
                actionTaken = "WARN_PLAYER"
                actionMessage = "Suspicious activity detected - player warned"
                
                -- Execute player warning
                _executePlayerWarning({
                    type = "player",
                    playerId = playerId
                }, "Suspicious activity detected", correlationId)
            end
            
            -- Log cheat detection
            AuditLogger.logCheatDetection({
                playerId = playerId,
                processId = msg.From,
                suspicionScore = suspicionScore,
                detectedCheats = detectedCheats,
                analysisTime = analysisTime,
                actionTaken = actionTaken,
                cheatTypes = _extractCheatTypes(detectedCheats)
            }, correlationId)
        end
        
        local cheatActionResponse = {
            correlation = {
                id = correlationId,
                responseType = "ANTI_CHEAT_ACTION_RESULT"
            },
            result = {
                success = true,
                cheatDetected = cheatDetected,
                suspicionScore = suspicionScore,
                detectedCheats = detectedCheats,
                actionTaken = actionTaken,
                actionMessage = actionMessage
            },
            metadata = {
                analysisTime = analysisTime,
                processedAt = 0,
                playerId = playerId
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "ANTI_CHEAT_ACTION_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(cheatActionResponse)
        })
        
        print(string.format(
            "[SecurityEnforcementHandler] Anti-cheat analysis completed for %s: %s (Score: %.1f)",
            playerId, 
            cheatDetected and "CHEAT_DETECTED" or "CLEAN",
            suspicionScore
        ))
    end
)

-- Policy Management Handler
Handlers.add(
    "policy-management",
    Handlers.utils.hasMatchingTag("Action", "POLICY_MANAGEMENT"),
    function(msg)
        local policyRequest = json.decode(msg.Data)
        if not policyRequest or not policyRequest.operation then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "POLICY_MANAGEMENT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid policy management request"
                })
            })
            return
        end
        
        local result = { success = false, error = "Unknown operation" }
        
        if policyRequest.operation == "ADD_POLICY" and policyRequest.policy then
            local success, error = PolicyEnforcer.addSecurityPolicy(policyRequest.policy)
            result.success = success
            result.error = error
            
        elseif policyRequest.operation == "ENABLE_POLICY" and policyRequest.policyId then
            result.success = PolicyEnforcer.setPolicyEnabled(policyRequest.policyId, true)
            result.error = not result.success and "Policy not found" or nil
            
        elseif policyRequest.operation == "DISABLE_POLICY" and policyRequest.policyId then
            result.success = PolicyEnforcer.setPolicyEnabled(policyRequest.policyId, false)
            result.error = not result.success and "Policy not found" or nil
            
        elseif policyRequest.operation == "UPDATE_ENFORCEMENT" and policyRequest.policyId and policyRequest.enforcement then
            result.success, result.error = PolicyEnforcer.updatePolicyEnforcement(policyRequest.policyId, policyRequest.enforcement)
            
        elseif policyRequest.operation == "GET_VIOLATIONS" then
            result.success = true
            result.violations = PolicyEnforcer.getPolicyViolations(
                policyRequest.playerId,
                policyRequest.processId,
                policyRequest.days
            )
            
        elseif policyRequest.operation == "GET_STATISTICS" then
            result.success = true
            result.statistics = PolicyEnforcer.getStatistics()
        end
        
        -- Log policy management activity
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.SYSTEM_EVENT,
            severity = AuditLogger.SEVERITY_LEVELS.LOW,
            processId = msg.From,
            eventData = {
                operation = policyRequest.operation,
                policyId = policyRequest.policyId,
                success = result.success,
                error = result.error
            }
        })
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "POLICY_MANAGEMENT_RESPONSE",
                CorrelationId = msg.Tags.CorrelationId or "unknown"
            },
            Data = json.encode(result)
        })
    end
)

-- Private helper functions for security action execution

function _executePlayerWarning(target, reason, correlationId)
    -- In a real implementation, this would send a warning message to the player
    -- For now, we'll just log the warning action
    
    return {
        success = true,
        action = "WARN_PLAYER",
        target = target,
        executed = true,
        message = "Player warning logged: " .. reason
    }
end

function _executePlayerSuspension(target, reason, correlationId)
    -- In a real implementation, this would suspend the player's account
    -- For now, we'll just log the suspension action
    
    -- Alert administrators about the suspension
    _executeAdministratorAlert(target, "Player suspended: " .. reason, "HIGH", correlationId)
    
    return {
        success = true,
        action = "SUSPEND_PLAYER",
        target = target,
        executed = true,
        message = "Player suspension logged: " .. reason
    }
end

function _executeSessionTermination(target, reason, correlationId)
    -- In a real implementation, this would forcibly terminate the player's session
    -- For now, we'll just log the termination action
    
    -- Alert administrators about the termination
    _executeAdministratorAlert(target, "Session terminated: " .. reason, "CRITICAL", correlationId)
    
    return {
        success = true,
        action = "TERMINATE_SESSION",
        target = target,
        executed = true,
        message = "Session termination logged: " .. reason
    }
end

function _executeProcessBlock(target, reason, correlationId)
    -- In a real implementation, this would block communication with the specified process
    -- For now, we'll just log the block action
    
    return {
        success = true,
        action = "BLOCK_PROCESS",
        target = target,
        executed = true,
        message = "Process block logged: " .. reason
    }
end

function _executeDataQuarantine(target, reason, correlationId)
    -- In a real implementation, this would quarantine suspicious data
    -- For now, we'll just log the quarantine action
    
    return {
        success = true,
        action = "QUARANTINE_DATA",
        target = target,
        executed = true,
        message = "Data quarantine logged: " .. reason
    }
end

function _executeAdministratorAlert(target, reason, severity, correlationId)
    -- In a real implementation, this would send alerts to system administrators
    -- For now, we'll just log the alert
    
    print(string.format("[ADMIN_ALERT] %s: %s - Target: %s", 
          severity, reason, json.encode(target)))
    
    return {
        success = true,
        action = "ALERT_ADMINISTRATORS",
        target = target,
        executed = true,
        message = "Administrator alert sent: " .. reason
    }
end

function _extractCheatTypes(detectedCheats)
    local cheatTypes = {}
    for _, cheat in ipairs(detectedCheats) do
        if not cheatTypes[cheat.cheatType] then
            cheatTypes[cheat.cheatType] = 0
        end
        cheatTypes[cheat.cheatType] = cheatTypes[cheat.cheatType] + 1
    end
    return cheatTypes
end


-- ===== END MODULE: security.handlers.security-enforcement-handler =====


-- ===== MODULE: security.handlers.security-response-handler =====
-- File: ao-processes/security/handlers/security-response-handler.lua
-- Original require: require("security.handlers.security-response-handler")

-- Security Response Handler
-- Processes incident management and automated security responses


-- ===== MODULE: game-logic.process-coordination.message-correlator =====
-- File: ao-processes/game-logic/process-coordination/message-correlator.lua
-- Original require: local MessageCorrelator = require("game-logic.process-coordination.message-correlator")


-- ===== END MODULE: game-logic.process-coordination.message-correlator =====


-- ===== MODULE: security.components.audit-logger =====
-- File: ao-processes/security/components/audit-logger.lua
-- Original require: local AuditLogger = require("security.components.audit-logger")


-- ===== END MODULE: security.components.audit-logger =====


-- ===== MODULE: security.components.integrity-monitor =====
-- File: ao-processes/security/components/integrity-monitor.lua
-- Original require: local IntegrityMonitor = require("security.components.integrity-monitor")


-- ===== END MODULE: security.components.integrity-monitor =====


-- ===== MODULE: security.components.anti-cheat-detector =====
-- File: ao-processes/security/components/anti-cheat-detector.lua
-- Original require: local AntiCheatDetector = require("security.components.anti-cheat-detector")


-- ===== END MODULE: security.components.anti-cheat-detector =====


-- Incident Response Handler
Handlers.add(
    "incident-response",
    Handlers.utils.hasMatchingTag("Action", "INCIDENT_RESPONSE"),
    function(msg)
        local incidentRequest = json.decode(msg.Data)
        if not incidentRequest or not incidentRequest.incident then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "INCIDENT_RESPONSE_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid incident response request"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local incident = incidentRequest.incident
        local requestedActions = incidentRequest.requestedActions or {}
        
        print(string.format("[SecurityResponseHandler] Processing incident response: %s - Severity: %s", 
              incident.type or "unknown", incident.severity or "unknown"))
        
        -- Process the security incident based on type and severity
        local responseResult = _processSecurityIncident(incident, requestedActions, correlationId)
        
        -- Log the incident response
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.INCIDENT_CREATED,
            severity = incident.severity or AuditLogger.SEVERITY_LEVELS.MEDIUM,
            playerId = incident.playerId,
            processId = incident.processId or msg.From,
            eventData = {
                incidentType = incident.type,
                incidentData = incident.data,
                requestedActions = requestedActions,
                responseActions = responseResult.actionsExecuted,
                responseTime = responseResult.responseTime
            },
            actionTaken = "INCIDENT_RESPONSE_INITIATED"
        }, correlationId)
        
        local incidentResponse = {
            correlation = {
                id = correlationId,
                responseType = "INCIDENT_RESPONSE_RESULT"
            },
            result = {
                success = responseResult.success,
                incidentId = responseResult.incidentId,
                actionsExecuted = responseResult.actionsExecuted,
                responseTime = responseResult.responseTime,
                message = responseResult.message
            },
            metadata = {
                processedAt = 0,
                processedBy = ao.id or "security-process"
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "INCIDENT_RESPONSE_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(incidentResponse)
        })
        
        print(string.format("[SecurityResponseHandler] Incident response completed: %s actions executed", 
              #responseResult.actionsExecuted))
    end
)

-- Integrity Check Handler
Handlers.add(
    "integrity-check",
    Handlers.utils.hasMatchingTag("Action", "INTEGRITY_CHECK"),
    function(msg)
        local integrityRequest = json.decode(msg.Data)
        if not integrityRequest then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "INTEGRITY_CHECK_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid integrity check request"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local checkType = integrityRequest.checkType or "STATE_CORRUPTION"
        local data = integrityRequest.data
        local contextId = integrityRequest.contextId
        
        print(string.format("[SecurityResponseHandler] Performing integrity check: %s", checkType))
        
        local integrityResult = {}
        
        if checkType == "CHECKSUM_VALIDATION" and integrityRequest.expectedChecksum then
            local isValid, message, checkTime = IntegrityMonitor.validateDataChecksum(
                data, 
                integrityRequest.expectedChecksum,
                integrityRequest.checksumId
            )
            
            integrityResult = {
                checkType = checkType,
                valid = isValid,
                message = message,
                checkTime = checkTime,
                expectedChecksum = integrityRequest.expectedChecksum
            }
            
        elseif checkType == "CROSS_PROCESS_CONSISTENCY" and integrityRequest.processStates then
            local consistencyResult, checkTime = IntegrityMonitor.performCrossProcessConsistencyCheck(
                integrityRequest.processStates,
                integrityRequest.dataKey
            )
            
            integrityResult = {
                checkType = checkType,
                valid = consistencyResult.consistent,
                message = consistencyResult.consistent and "Data consistent across processes" or 
                         "Data inconsistency detected",
                checkTime = checkTime,
                consistencyDetails = consistencyResult
            }
            
        elseif checkType == "STATE_CORRUPTION" then
            local corruptionDetails, checkTime = IntegrityMonitor.detectStateCorruption(
                data,
                integrityRequest.stateType or "unknown",
                contextId
            )
            
            integrityResult = {
                checkType = checkType,
                valid = not corruptionDetails.corrupted,
                message = corruptionDetails.corrupted and "State corruption detected" or 
                         "State integrity verified",
                checkTime = checkTime,
                corruptionDetails = corruptionDetails
            }
            
        else
            integrityResult = {
                checkType = checkType,
                valid = false,
                message = "Unsupported integrity check type: " .. checkType,
                checkTime = 0
            }
        end
        
        -- Log integrity check result
        if not integrityResult.valid then
            AuditLogger.logSecurityEvent({
                eventType = AuditLogger.EVENT_TYPES.DATA_INTEGRITY_VIOLATION,
                severity = AuditLogger.SEVERITY_LEVELS.HIGH,
                processId = msg.From,
                eventData = {
                    checkType = checkType,
                    contextId = contextId,
                    integrityResult = integrityResult
                }
            }, correlationId)
        end
        
        local integrityResponse = {
            correlation = {
                id = correlationId,
                responseType = "INTEGRITY_CHECK_RESULT"
            },
            result = {
                success = true,
                integrityResult = integrityResult
            },
            metadata = {
                processedAt = 0,
                checkTime = integrityResult.checkTime
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "INTEGRITY_CHECK_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(integrityResponse)
        })
        
        print(string.format(
            "[SecurityResponseHandler] Integrity check completed: %s - Time: %dms",
            integrityResult.valid and "VALID" or "INVALID",
            integrityResult.checkTime or 0
        ))
    end
)

-- Security Alert Handler
Handlers.add(
    "security-alert",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_ALERT"),
    function(msg)
        local alertRequest = json.decode(msg.Data)
        if not alertRequest or not alertRequest.alert then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "SECURITY_ALERT_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid security alert request"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local alert = alertRequest.alert
        local alertSeverity = alert.severity or "MEDIUM"
        local alertType = alert.type or "GENERIC_ALERT"
        
        print(string.format("[SecurityResponseHandler] Processing security alert: %s - Severity: %s", 
              alertType, alertSeverity))
        
        -- Process the security alert and determine response
        local alertResponse = _processSecurityAlert(alert, correlationId)
        
        -- Log the security alert
        AuditLogger.logSecurityEvent({
            eventType = AuditLogger.EVENT_TYPES.SECURITY_ALERT,
            severity = alertSeverity == "CRITICAL" and AuditLogger.SEVERITY_LEVELS.CRITICAL or
                      alertSeverity == "HIGH" and AuditLogger.SEVERITY_LEVELS.HIGH or
                      alertSeverity == "MEDIUM" and AuditLogger.SEVERITY_LEVELS.MEDIUM or
                      AuditLogger.SEVERITY_LEVELS.LOW,
            playerId = alert.playerId,
            processId = alert.processId or msg.From,
            eventData = {
                alertType = alertType,
                alertData = alert.data,
                response = alertResponse
            },
            actionTaken = alertResponse.actionTaken or "ALERT_LOGGED"
        }, correlationId)
        
        local securityAlertResponse = {
            correlation = {
                id = correlationId,
                responseType = "SECURITY_ALERT_PROCESSED"
            },
            result = {
                success = true,
                alertProcessed = true,
                response = alertResponse,
                alertId = alertResponse.alertId
            },
            metadata = {
                processedAt = 0,
                alertType = alertType,
                severity = alertSeverity
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_ALERT_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(securityAlertResponse)
        })
        
        print(string.format("[SecurityResponseHandler] Security alert processed: %s - Action: %s", 
              alertType, alertResponse.actionTaken or "LOGGED"))
    end
)

-- Incident Resolution Handler
Handlers.add(
    "incident-resolution",
    Handlers.utils.hasMatchingTag("Action", "INCIDENT_RESOLUTION"),
    function(msg)
        local resolutionRequest = json.decode(msg.Data)
        if not resolutionRequest or not resolutionRequest.incidentId then
            ao.send({
                Target = msg.From,
                Tags = { 
                    Action = "INCIDENT_RESOLUTION_RESPONSE",
                    CorrelationId = msg.Tags.CorrelationId or "unknown"
                },
                Data = json.encode({
                    success = false,
                    error = "Invalid incident resolution request"
                })
            })
            return
        end
        
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        local incidentId = resolutionRequest.incidentId
        local resolutionNotes = resolutionRequest.resolutionNotes or "Incident resolved"
        
        -- Resolve the incident (using IntegrityMonitor as it tracks corruption incidents)
        local resolved = IntegrityMonitor.resolveIncident(incidentId, resolutionNotes)
        
        local resolutionResponse = {
            correlation = {
                id = correlationId,
                responseType = "INCIDENT_RESOLUTION_RESULT"
            },
            result = {
                success = resolved,
                incidentId = incidentId,
                resolved = resolved,
                message = resolved and "Incident resolved successfully" or "Incident not found",
                resolutionNotes = resolutionNotes
            },
            metadata = {
                processedAt = 0,
                resolvedBy = msg.From
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "INCIDENT_RESOLUTION_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(resolutionResponse)
        })
        
        print(string.format("[SecurityResponseHandler] Incident resolution: %s - %s", 
              incidentId, resolved and "SUCCESS" or "FAILED"))
    end
)

-- Security Health Check Handler
Handlers.add(
    "security-health-check",
    Handlers.utils.hasMatchingTag("Action", "SECURITY_HEALTH_CHECK"),
    function(msg)
        local correlationId = msg.Tags.CorrelationId or 
                             MessageCorrelator.generateCorrelationId(MessageCorrelator.CORRELATION_TYPES.INTER_PROCESS)
        
        -- Get health status from all security components

-- ===== MODULE: security.components.validation-engine =====
-- File: ao-processes/security/components/validation-engine.lua
-- Original require:         local ValidationEngine = require("security.components.validation-engine")


-- ===== END MODULE: security.components.validation-engine =====


-- ===== MODULE: security.components.policy-enforcer =====
-- File: ao-processes/security/components/policy-enforcer.lua
-- Original require:         local PolicyEnforcer = require("security.components.policy-enforcer")


-- ===== END MODULE: security.components.policy-enforcer =====

        
        local healthStatus = {
            validationEngine = ValidationEngine.getHealth(),
            antiCheatDetector = AntiCheatDetector.getHealth(),
            auditLogger = AuditLogger.getHealth(),
            policyEnforcer = PolicyEnforcer.getHealth(),
            integrityMonitor = IntegrityMonitor.getHealth()
        }
        
        -- Determine overall health
        local overallHealth = "HEALTHY"
        for component, health in pairs(healthStatus) do
            if health == "DEGRADED" then
                overallHealth = "DEGRADED"
                break
            end
        end
        
        -- Get system statistics
        local systemStats = {
            validation = ValidationEngine.getStatistics(),
            antiCheat = AntiCheatDetector.getStatistics(),
            audit = AuditLogger.getStatistics(),
            policy = PolicyEnforcer.getStatistics(),
            integrity = IntegrityMonitor.getStatistics()
        }
        
        local healthResponse = {
            correlation = {
                id = correlationId,
                responseType = "SECURITY_HEALTH_STATUS"
            },
            result = {
                success = true,
                overallHealth = overallHealth,
                componentHealth = healthStatus,
                systemStatistics = systemStats
            },
            metadata = {
                processedAt = 0,
                uptime = 0 - (securityState and securityState.startTime or 0)
            }
        }
        
        ao.send({
            Target = msg.From,
            Tags = { 
                Action = "SECURITY_HEALTH_CHECK_RESPONSE",
                CorrelationId = correlationId
            },
            Data = json.encode(healthResponse)
        })
        
        print(string.format("[SecurityResponseHandler] Health check completed: %s", overallHealth))
    end
)

-- Private helper functions

function _processSecurityIncident(incident, requestedActions, correlationId)
    local startTime = msg.Timestamp
    local actionsExecuted = {}
    local incidentId = "id_" .. msg.Timestamp .. "_" .. #requestedActions
    
    -- Process each requested action
    for _, action in ipairs(requestedActions) do
        local actionResult = {
            action = action.type,
            executed = false,
            message = "Action not implemented",
            timestamp = 0
        }
        
        -- Execute the action based on type
        if action.type == "ISOLATE_PLAYER" and incident.playerId then
            actionResult.executed = true
            actionResult.message = "Player isolation logged for " .. incident.playerId
            
        elseif action.type == "RESET_GAME_STATE" and incident.playerId then
            actionResult.executed = true
            actionResult.message = "Game state reset logged for " .. incident.playerId
            
        elseif action.type == "ESCALATE_TO_ADMIN" then
            actionResult.executed = true
            actionResult.message = "Incident escalated to administrators"
            
        elseif action.type == "GENERATE_EVIDENCE_PACKAGE" then
            actionResult.executed = true
            actionResult.message = "Evidence package generation logged"
            
        elseif action.type == "NOTIFY_STAKEHOLDERS" then
            actionResult.executed = true
            actionResult.message = "Stakeholder notification logged"
        end
        
        table.insert(actionsExecuted, actionResult)
    end
    
    local endTime = msg.Timestamp
    
    return {
        success = true,
        incidentId = incidentId,
        actionsExecuted = actionsExecuted,
        responseTime = endTime - startTime,
        message = string.format("Incident processed with %d actions", #actionsExecuted)
    }
end

function _processSecurityAlert(alert, correlationId)
    local alertId = "id_" .. msg.Timestamp .. "_" .. (alert.type or "generic")
    local actionTaken = "ALERT_LOGGED"
    
    -- Determine automatic response based on alert type and severity
    if alert.severity == "CRITICAL" then
        actionTaken = "IMMEDIATE_INVESTIGATION_REQUIRED"
        
        -- In a real implementation, this might trigger immediate notifications
        print("[CRITICAL_ALERT] " .. (alert.type or "Unknown") .. ": " .. (alert.message or "No message"))
        
    elseif alert.severity == "HIGH" then
        actionTaken = "PRIORITY_INVESTIGATION_SCHEDULED"
        
    elseif alert.type == "PERFORMANCE_DEGRADATION" then
        actionTaken = "PERFORMANCE_MONITORING_ENABLED"
        
    elseif alert.type == "UNUSUAL_PATTERN_DETECTED" then
        actionTaken = "PATTERN_ANALYSIS_INITIATED"
    end
    
    return {
        alertId = alertId,
        processed = true,
        actionTaken = actionTaken,
        processedAt = 0,
        message = "Alert processed and logged"
    }
end


-- ===== END MODULE: security.handlers.security-response-handler =====


-- Initialize process on load
initialize()

