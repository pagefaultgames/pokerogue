import type { RewardId } from "#enums/reward-id";
import type { RarityTier } from "#enums/reward-tier";
import type { PlayerPokemon } from "#field/pokemon";
import type { Exact } from "#types/type-helpers";
import type { PokemonMoveSelectFilter, PokemonSelectFilter } from "#ui/party-ui-handler";
import i18next from "i18next";

/**
 * @module
 * The term "Reward" refers to items the player can access in the post-battle screen (although
 * they may be used in other places of the code as well).

 * Examples include (but are not limited to):
 * - Potions and other healing items
 * - Held items and trainer items
 * - Money items such as nugget and ancient relic

 * Rewards have a basic structure with a name, description, and icon. These are used to display
 * the reward in the reward select screen. All rewards have an .apply() method, which applies the
 * effect, for example:
 * - Apply healing to a pokemon
 * - Assign a held item to a pokemon, or a trainer item to the player
 * - Add money

 * Some rewards, once clicked, simply have their effect---these are Rewards that add money, pok√©ball,
 * vouchers, or global effect such as Sacred Ash.
 * Most rewards require extra parameters. They are divided into subclasses depending on the parameters
 * that they need, in particular:
 * - PokemonReward requires to pass a Pokemon (to apply healing, assign item...)
 * - PokemonMoveReward requires to pass a Pokemon and a move (for Elixir, or PP Up)
 * Plus some edge cases for Memory Mushroom and DNA Splicers.

 * The parameters to be passed are generated by the .applyReward() function in {@linkcode SelectRewardPhase}.
 * This function takes care of opening the party screen and letting the player select a party pokemon,
 * a move, etc. depending on what is required. Once the parameters are generated, instead of calling
 * .apply() directly, we call the .applyReward() method in BattleScene, which also plays the sound.
 * [This method could perhaps be removed].

 * Rewards are assigned RewardId, and there are also RewardCategoryId. For example, TM is a RewardCategoryId,
 * while CommonTM, RareTM etc are RewardIds. There is _not_ a RewardId for _each_ move. Similarly,
 * some specific categories of held items are assigned their own RewardId, but they all fall under a single
 * RewardCategoryId.

 * rewardInitObj plays a similar role to allHeldItems, except instead of containing all possible reward
 * instances, it instead contains functions that generate those rewards. Here, the keys used are strings
 * rather than RewardId, the difference exists because here we want to distinguish unique held items
 * for example. The entries of rewardInitObj are used in the RewardPool.

 * There are some more derived classes, in particular:
 * RewardGenerator, which creates Reward instances from a certain group (e.g. TMs, nature mints, or berries);
 * and RewardOption, which is displayed during the select reward phase at the end of each encounter.
*/

/**
 * Type helper to exactly match objects and nothing else.
 * @todo merge with `Exact` later on
 */
export type MatchExact<T> = T extends object ? Exact<T> : T;

export abstract class Reward {
  // TODO: If all we care about for categorization is the reward's ID's _category_, why not do it there?
  public id: RewardId;
  public localeKey: string;
  public iconImage: string;
  public group: string; // TODO: Make a union type of all groups
  public soundName: string;
  public tier: RarityTier;

  constructor(localeKey: string | null, iconImage: string | null, group?: string, soundName?: string) {
    this.localeKey = localeKey!; // TODO: is this bang correct?
    this.iconImage = iconImage!; // TODO: is this bang correct?
    this.group = group!; // TODO: is this bang correct?
    this.soundName = soundName ?? "se/restore";
  }

  get name(): string {
    return i18next.t(`${this.localeKey}.name`);
  }

  // TODO: These should be getters
  get description(): string {
    return i18next.t(`${this.localeKey}.description`);
  }

  get iconName(): string {
    return this.iconImage;
  }

  // TODO: Should this be abstract?
  /**
   * Check whether this reward should be applied.
   */
  // TODO: This is erroring on stuff with `undefined`
  shouldApply(_params: MatchExact<Parameters<this["apply"]>[0]>): boolean {
    return true;
  }

  /** Apply this Reward's effects. */
  // TODO: Remove `boolean` return from all superclasses' type signatures
  abstract apply(_params?: unknown): void;
}

/**
 * A {@linkcode RewardGenerator} represents a dynamic generator for a given type of reward.
 * These can be customized by lieu of {@linkcode generateReward} to alter the generation result.
 */
export abstract class RewardGenerator {
  /**
   * Dynamically generate a new reward.
   * @param pregenArgs - An optional argument taken by super classes to customize the reward generated.
   * @returns The generated reward, or `null` if none are able to be produced
   */
  // TODO: Remove null from signature in favor of adding a condition or similar (reduces bangs needed)
  abstract generateReward(pregenArgs?: unknown): Reward | null;
}

/** Rewards that are applied to individual Pokemon. */
export abstract class PokemonReward extends Reward {
  // TODO: Make this an overriddable getter rather than defining functions in the constructor
  public selectFilter: PokemonSelectFilter | undefined;

  constructor(
    localeKey: string,
    iconImage: string,
    selectFilter?: PokemonSelectFilter,
    group?: string,
    soundName?: string,
  ) {
    super(localeKey, iconImage, group, soundName);
    this.selectFilter = selectFilter;
  }

  abstract override apply(_params: PokemonRewardParams): void;
}

export abstract class PokemonMoveReward extends PokemonReward {
  public moveSelectFilter: PokemonMoveSelectFilter | undefined;

  constructor(
    localeKey: string,
    iconImage: string,
    id: RewardId,
    selectFilter?: PokemonSelectFilter,
    moveSelectFilter?: PokemonMoveSelectFilter,
    group?: string,
  ) {
    super(localeKey, iconImage, selectFilter, group);
    this.moveSelectFilter = moveSelectFilter;
    this.id = id;
  }

  apply(_params: PokemonMoveRewardParams): boolean {
    return false;
  }
}

export interface PokemonRewardParams {
  pokemon: PlayerPokemon;
}

export interface PokemonMoveRewardParams {
  pokemon: PlayerPokemon;
  moveIndex: number;
}

export interface PokemonMoveRecallRewardParams {
  pokemon: PlayerPokemon;
  moveIndex: number;
  cost?: number;
}

export interface PokemonFusionRewardParams {
  pokemon: PlayerPokemon;
  pokemon2: PlayerPokemon;
}

export class RewardOption {
  public type: Reward;
  public upgradeCount: number;
  public tier: RarityTier;
  public cost: number;

  constructor(type: Reward, upgradeCount: number, tier: RarityTier, cost = 0) {
    this.type = type;
    this.upgradeCount = upgradeCount;
    this.tier = tier;
    this.cost = Math.min(Math.round(cost), Number.MAX_SAFE_INTEGER);
  }
}

export class EmptyReward extends Reward {
  constructor() {
    super("", "");
  }

  override apply(): void {}
}
