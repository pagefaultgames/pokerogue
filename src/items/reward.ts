import { TYPE_BOOST_ITEM_BOOST_PERCENT } from "#app/constants";
import { globalScene } from "#app/global-scene";
import { getPokemonNameWithAffix } from "#app/messages";
import { EvolutionItem, FusionSpeciesFormEvolution, pokemonEvolutions } from "#balance/pokemon-evolutions";
import { FRIENDSHIP_GAIN_FROM_RARE_CANDY } from "#balance/starters";
import { tmPoolTiers, tmSpecies } from "#balance/tms";
import { allHeldItems, allMoves, allTrainerItems } from "#data/data-lists";
import { getLevelTotalExp } from "#data/exp";
import { SpeciesFormChangeItemTrigger } from "#data/form-change-triggers";
import { getNatureName, getNatureStatMultiplier } from "#data/nature";
import { getPokeballCatchMultiplier, getPokeballName, MAX_PER_TYPE_POKEBALLS } from "#data/pokeball";
import { pokemonFormChanges, SpeciesFormChangeCondition } from "#data/pokemon-forms";
import { BattlerTagType } from "#enums/battler-tag-type";
import type { BerryType } from "#enums/berry-type";
import { FormChangeItem } from "#enums/form-change-item";
import { HeldItemId } from "#enums/held-item-id";
import { LearnMoveType } from "#enums/learn-move-type";
import type { MoveId } from "#enums/move-id";
import { Nature } from "#enums/nature";
import type { PokeballType } from "#enums/pokeball";
import { PokemonType } from "#enums/pokemon-type";
import { RewardId } from "#enums/reward-id";
import type { RarityTier } from "#enums/reward-tier";
import { SpeciesFormKey } from "#enums/species-form-key";
import { SpeciesId } from "#enums/species-id";
import type { PermanentStat, TempBattleStat } from "#enums/stat";
import { Stat, TEMP_BATTLE_STATS } from "#enums/stat";
import { TrainerItemId } from "#enums/trainer-item-id";
import type { PlayerPokemon, Pokemon } from "#field/pokemon";
import { attackTypeToHeldItem } from "#items/attack-type-booster";
import { permanentStatToHeldItem, statBoostItems } from "#items/base-stat-booster";
import { berryTypeToHeldItem } from "#items/berry";
import { getNewAttackTypeBoosterHeldItem, getNewBerryHeldItem, getNewVitaminHeldItem } from "#items/held-item-pool";
import { formChangeItemName } from "#items/item-utility";
import type { SpeciesStatBoosterItemId, SpeciesStatBoostHeldItem } from "#items/stat-booster";
import { TrainerItemEffect, tempStatToTrainerItem } from "#items/trainer-item";
import type { PokemonMove } from "#moves/pokemon-move";
import { getVoucherTypeIcon, getVoucherTypeName, type VoucherType } from "#system/voucher";
import type { Exact } from "#types/type-helpers";
import type { PokemonMoveSelectFilter, PokemonSelectFilter } from "#ui/party-ui-handler";
import { PartyUiHandler } from "#ui/party-ui-handler";
import { formatMoney, NumberHolder, padInt, randSeedInt, randSeedItem } from "#utils/common";
import { getEnumKeys, getEnumValues } from "#utils/enums";
import i18next from "i18next";

/**
 * @module
 * The term "Reward" refers to items the player can access in the post-battle screen (although
 * they may be used in other places of the code as well).

 * Examples include (but are not limited to):
 * - Potions and other healing items
 * - Held items and trainer items
 * - Money items such as nugget and ancient relic

 * Rewards have a basic structure with a name, description, and icon. These are used to display
 * the reward in the reward select screen. All rewards have an .apply() method, which applies the
 * effect, for example:
 * - Apply healing to a pokemon
 * - Assign a held item to a pokemon, or a trainer item to the player
 * - Add money

 * Some rewards, once clicked, simply have their effect---these are Rewards that add money, pok√©ball,
 * vouchers, or global effect such as Sacred Ash.
 * Most rewards require extra parameters. They are divided into subclasses depending on the parameters
 * that they need, in particular:
 * - PokemonReward requires to pass a Pokemon (to apply healing, assign item...)
 * - PokemonMoveReward requires to pass a Pokemon and a move (for Elixir, or PP Up)
 * Plus some edge cases for Memory Mushroom and DNA Splicers.

 * The parameters to be passed are generated by the .applyReward() function in {@linkcode SelectRewardPhase}.
 * This function takes care of opening the party screen and letting the player select a party pokemon,
 * a move, etc. depending on what is required. Once the parameters are generated, instead of calling
 * .apply() directly, we call the .applyReward() method in BattleScene, which also plays the sound.
 * [This method could perhaps be removed].

 * Rewards are assigned RewardId, and there are also RewardCategoryId. For example, TM is a RewardCategoryId,
 * while CommonTM, RareTM etc are RewardIds. There is _not_ a RewardId for _each_ move. Similarly,
 * some specific categories of held items are assigned their own RewardId, but they all fall under a single
 * RewardCategoryId.

 * rewardInitObj plays a similar role to allHeldItems, except instead of containing all possible reward
 * instances, it instead contains functions that generate those rewards. Here, the keys used are strings
 * rather than RewardId, the difference exists because here we want to distinguish unique held items
 * for example. The entries of rewardInitObj are used in the RewardPool.

 * There are some more derived classes, in particular:
 * RewardGenerator, which creates Reward instances from a certain group (e.g. TMs, nature mints, or berries);
 * and RewardOption, which is displayed during the select reward phase at the end of each encounter.
*/

/**
 * Type helper to exactly match objects and nothing else.
 * @todo merge with `Exact` later on
 */
type MatchExact<T> = T extends object ? Exact<T> : T;

export abstract class Reward {
  // TODO: If all we care about for categorization is the reward's ID's _category_, why not do it there?
  // TODO: Make abstract and readonly
  public id: RewardId;
  public localeKey: string;
  public iconImage: string;
  public group: string; // TODO: Make a union type of all groups
  public soundName: string;
  public tier: RarityTier;

  constructor(localeKey: string | null, iconImage: string | null, group?: string, soundName?: string) {
    this.localeKey = localeKey!; // TODO: is this bang correct?
    this.iconImage = iconImage!; // TODO: is this bang correct?
    this.group = group!; // TODO: is this bang correct?
    this.soundName = soundName ?? "se/restore";
  }

  get name(): string {
    return i18next.t(`${this.localeKey}.name`);
  }

  getDescription(): string {
    return i18next.t(`${this.localeKey}.description`);
  }

  getIcon(): string {
    return this.iconImage;
  }

  // TODO: Should this be abstract?
  /**
   * Check whether this reward should be applied.
   */
  // TODO: This is erroring on stuff with `undefined`
  shouldApply(_params: MatchExact<Parameters<this["apply"]>[0]>): boolean {
    return true;
  }

  /** Apply this Reward's effects. */
  // TODO: Remove `boolean` return from all superclasses' type signatures
  abstract apply(_params?: unknown): void;
}

/**
 * A {@linkcode RewardGenerator} represents a dynamic generator for a given type of reward.
 * These can be customized by lieu of {@linkcode generateReward} to alter the generation result.
 */
export abstract class RewardGenerator {
  /**
   * Dynamically generate a new reward.
   * @param pregenArgs - An optional argument taken by super classes to customize the reward generated.
   * @returns The generated reward, or `null` if none are able to be produced
   */
  // TODO: Remove null from signature in favor of adding a condition or similar (reduces bangs needed)
  abstract generateReward(pregenArgs?: unknown): Reward | null;
}

export class AddPokeballReward extends Reward {
  private pokeballType: PokeballType;
  private count: number;

  constructor(iconImage: string, pokeballType: PokeballType, count: number, id: RewardId) {
    super("", iconImage, "pb", "se/pb_bounce_1");
    this.pokeballType = pokeballType;
    this.count = count;
    this.id = id;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.AddPokeballModifierType.name", {
      modifierCount: this.count,
      pokeballName: getPokeballName(this.pokeballType),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.AddPokeballModifierType.description", {
      modifierCount: this.count,
      pokeballName: getPokeballName(this.pokeballType),
      catchRate:
        getPokeballCatchMultiplier(this.pokeballType) > -1
          ? `${getPokeballCatchMultiplier(this.pokeballType)}x`
          : "100%",
      pokeballAmount: `${globalScene.pokeballCounts[this.pokeballType]}`,
    });
  }

  /**
   * Applies {@linkcode AddPokeballReward}
   * @returns always `true`
   */
  apply(): boolean {
    const pokeballCounts = globalScene.pokeballCounts;
    pokeballCounts[this.pokeballType] = Math.min(
      pokeballCounts[this.pokeballType] + this.count,
      MAX_PER_TYPE_POKEBALLS,
    );

    return true;
  }
}

export class AddVoucherReward extends Reward {
  private voucherType: VoucherType;
  private count: number;

  constructor(voucherType: VoucherType, count: number, id: RewardId) {
    super("", getVoucherTypeIcon(voucherType), "voucher");
    this.count = count;
    this.voucherType = voucherType;
    this.id = id;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.AddVoucherConsumableType.name", {
      modifierCount: this.count,
      voucherTypeName: getVoucherTypeName(this.voucherType),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.AddVoucherConsumableType.description", {
      modifierCount: this.count,
      voucherTypeName: getVoucherTypeName(this.voucherType),
    });
  }

  /**
   * Applies {@linkcode AddVoucherReward}
   * @param battleScene {@linkcode BattleScene}
   * @returns always `true`
   */
  apply(): boolean {
    const voucherCounts = globalScene.gameData.voucherCounts;
    voucherCounts[this.voucherType] += this.count;

    return true;
  }
}

export class AddMoneyReward extends Reward {
  private moneyMultiplier: number;
  private moneyMultiplierDescriptorKey: string;

  constructor(
    localeKey: string,
    iconImage: string,
    moneyMultiplier: number,
    moneyMultiplierDescriptorKey: string,
    id: RewardId,
  ) {
    super(localeKey, iconImage, "money", "se/buy");

    this.moneyMultiplier = moneyMultiplier;
    this.moneyMultiplierDescriptorKey = moneyMultiplierDescriptorKey;
    this.id = id;
  }

  getDescription(): string {
    const moneyAmount = new NumberHolder(globalScene.getWaveMoneyAmount(this.moneyMultiplier));
    globalScene.applyPlayerItems(TrainerItemEffect.MONEY_MULTIPLIER, { numberHolder: moneyAmount });
    const formattedMoney = formatMoney(globalScene.moneyFormat, moneyAmount.value);

    return i18next.t("modifierType:ModifierType.MoneyRewardModifierType.description", {
      moneyMultiplier: i18next.t(this.moneyMultiplierDescriptorKey as any),
      moneyAmount: formattedMoney,
    });
  }

  /**
   * Applies {@linkcode AddMoneyReward}
   * @returns always `true`
   */
  apply(): boolean {
    const moneyAmount = new NumberHolder(globalScene.getWaveMoneyAmount(this.moneyMultiplier));

    globalScene.applyPlayerItems(TrainerItemEffect.MONEY_MULTIPLIER, { numberHolder: moneyAmount });

    globalScene.addMoney(moneyAmount.value);

    for (const p of globalScene.getPlayerParty()) {
      if (p.hasSpecies(SpeciesId.GIMMIGHOUL)) {
        const factor = Math.min(Math.floor(this.moneyMultiplier), 3);
        p.heldItemManager.add(HeldItemId.GIMMIGHOUL_EVO_TRACKER, factor);
      }
    }

    return true;
  }
}

/** Rewards that are applied to individual Pokemon. */
export abstract class PokemonReward extends Reward {
  public selectFilter: PokemonSelectFilter | undefined;

  constructor(
    localeKey: string,
    iconImage: string,
    selectFilter?: PokemonSelectFilter,
    group?: string,
    soundName?: string,
  ) {
    super(localeKey, iconImage, group, soundName);
    this.selectFilter = selectFilter;
  }

  abstract override apply(_params: PokemonRewardParams): void;
}

export interface PokemonRewardParams {
  pokemon: PlayerPokemon;
}

export interface PokemonMoveRewardParams {
  pokemon: PlayerPokemon;
  moveIndex: number;
}

export interface PokemonMoveRecallRewardParams {
  pokemon: PlayerPokemon;
  moveIndex: number;
  cost?: number;
}

export interface PokemonFusionRewardParams {
  pokemon: PlayerPokemon;
  pokemon2: PlayerPokemon;
}

export class HeldItemReward extends PokemonReward {
  public itemId: HeldItemId;
  constructor(itemId: HeldItemId, group?: string, soundName?: string) {
    super(
      "",
      "",
      (pokemon: PlayerPokemon) => {
        const hasItem = pokemon.heldItemManager.hasItem(this.itemId);
        const maxStackCount = allHeldItems[this.itemId].getMaxStackCount();
        if (!maxStackCount) {
          return i18next.t("modifierType:ModifierType.PokemonHeldItemModifierType.extra.inoperable", {
            pokemonName: getPokemonNameWithAffix(pokemon),
          });
        }
        if (hasItem && pokemon.heldItemManager.getStack(this.itemId) === maxStackCount) {
          return i18next.t("modifierType:ModifierType.PokemonHeldItemModifierType.extra.tooMany", {
            pokemonName: getPokemonNameWithAffix(pokemon),
          });
        }
        return null;
      },
      group,
      soundName,
    );
    this.itemId = itemId;
    this.id = RewardId.HELD_ITEM;
  }

  get name(): string {
    return allHeldItems[this.itemId].name;
  }

  getDescription(): string {
    return allHeldItems[this.itemId].description;
  }

  getIcon(): string {
    return allHeldItems[this.itemId].iconName;
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    return pokemon.heldItemManager.add(this.itemId);
  }
}

export class TrainerItemReward extends Reward {
  public itemId: TrainerItemId;
  constructor(itemId: TrainerItemId, group?: string, soundName?: string) {
    super("", "", group, soundName);
    this.itemId = itemId;
    this.id = RewardId.TRAINER_ITEM;
  }

  get name(): string {
    return allTrainerItems[this.itemId].name;
  }

  getDescription(): string {
    return allTrainerItems[this.itemId].description;
  }

  getIcon(): string {
    return allTrainerItems[this.itemId].iconName;
  }

  apply(): boolean {
    return globalScene.trainerItems.add(this.itemId);
  }
}

export class LapsingTrainerItemReward extends TrainerItemReward {
  constructor(itemId: TrainerItemId, id?: RewardId) {
    super(itemId);
    this.id = id ?? RewardId.TRAINER_ITEM;
  }

  apply(): boolean {
    return globalScene.trainerItems.add(this.itemId, allTrainerItems[this.itemId].getMaxStackCount());
  }
}

export class ChangeTeraTypeReward extends PokemonReward {
  private teraType: PokemonType;

  constructor(teraType: PokemonType) {
    super(
      "",
      `${PokemonType[teraType].toLowerCase()}_tera_shard`,
      (pokemon: PlayerPokemon) => {
        if (
          [pokemon.species.speciesId, pokemon.fusionSpecies?.speciesId].filter(
            s => s === SpeciesId.TERAPAGOS || s === SpeciesId.OGERPON || s === SpeciesId.SHEDINJA,
          ).length > 0
        ) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "tera_shard",
    );

    this.teraType = teraType;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.ChangeTeraTypeModifierType.name", {
      teraType: i18next.t(`pokemonInfo:Type.${PokemonType[this.teraType]}`),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.ChangeTeraTypeModifierType.description", {
      teraType: i18next.t(`pokemonInfo:Type.${PokemonType[this.teraType]}`),
    });
  }

  // TODO: What is this for?
  getPregenArgs(): any[] {
    return [this.teraType];
  }

  /**
   * Checks if {@linkcode TerrastalizeConsumable} should be applied
   * @param playerPokemon The {@linkcode PlayerPokemon} that consumes the item
   * @returns `true` if the {@linkcode TerrastalizeConsumable} should be applied
   */
  shouldApply({ pokemon }: PokemonRewardParams): boolean {
    return (
      pokemon.teraType !== this.teraType &&
      ![SpeciesId.SHEDINJA, SpeciesId.OGERPON, SpeciesId.TERAPAGOS].some(s => pokemon.hasSpecies(s))
    );
  }

  /**
   * Applies {@linkcode TerrastalizeConsumable}
   * @param pokemon The {@linkcode PlayerPokemon} that consumes the item
   * @returns `true` if hp was restored
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    pokemon.teraType = this.teraType;
    return true;
  }
}

// todo: denest
// TODO: Consider removing `revive` from the signature of PokemonHealPhase in the wake of this
// (was only used for revives)
function restorePokemonHp(
  pokemon: Pokemon,
  percentToRestore: number,
  pointsToRestore = 0,
  healStatus = false,
  fainted = false,
): boolean {
  if (!pokemon.hp === fainted) {
    if (fainted || healStatus) {
      pokemon.resetStatus(true, true, false, false);
    }
    // Apply HealingCharm
    let multiplier = 1;
    if (!fainted) {
      const hpRestoreMultiplier = new NumberHolder(1);
      this.applyPlayerItems(TrainerItemEffect.HEALING_BOOSTER, { numberHolder: hpRestoreMultiplier });
      multiplier = hpRestoreMultiplier.value;
    }
    const restorePoints = Math.floor(pointsToRestore * multiplier);
    const restorePercent = Math.floor(percentToRestore * 0.01 * multiplier * pokemon.getMaxHp());
    pokemon.heal(Math.max(restorePercent, restorePoints, 1));
    return true;
  }
  return false;
}

export class PokemonHpRestoreReward extends PokemonReward {
  protected restorePoints: number;
  protected restorePercent: number;
  protected healStatus: boolean;

  constructor(
    localeKey: string,
    iconImage: string,
    id: RewardId,
    restorePoints: number,
    restorePercent: number,
    healStatus = false,
    selectFilter?: PokemonSelectFilter,
    group?: string,
  ) {
    super(
      localeKey,
      iconImage,
      selectFilter ||
        ((pokemon: PlayerPokemon) => {
          if (
            !pokemon.hp ||
            (pokemon.isFullHp() && (!this.healStatus || (!pokemon.status && !pokemon.getTag(BattlerTagType.CONFUSED))))
          ) {
            return PartyUiHandler.NoEffectMessage;
          }
          return null;
        }),
      group || "potion",
    );

    this.restorePoints = restorePoints;
    this.restorePercent = restorePercent;
    this.healStatus = healStatus;
    this.id = id;
  }

  getDescription(): string {
    return this.restorePoints
      ? i18next.t("modifierType:ModifierType.PokemonHpRestoreModifierType.description", {
          restorePoints: this.restorePoints,
          restorePercent: this.restorePercent,
        })
      : this.healStatus
        ? i18next.t("modifierType:ModifierType.PokemonHpRestoreModifierType.extra.fullyWithStatus")
        : i18next.t("modifierType:ModifierType.PokemonHpRestoreModifierType.extra.fully");
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    return restorePokemonHp(pokemon, this.restorePercent, this.restorePoints, this.healStatus, false);
  }
}

export class PokemonReviveReward extends PokemonHpRestoreReward {
  constructor(localeKey: string, iconImage: string, id: RewardId, restorePercent: number) {
    super(
      localeKey,
      iconImage,
      id,
      0,
      restorePercent,
      false,
      (pokemon: PlayerPokemon) => {
        if (!pokemon.isFainted()) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "revive",
    );

    this.selectFilter = (pokemon: PlayerPokemon) => {
      if (pokemon.hp) {
        return PartyUiHandler.NoEffectMessage;
      }
      return null;
    };
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonReviveModifierType.description", {
      restorePercent: this.restorePercent,
    });
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    return restorePokemonHp(pokemon, this.restorePercent, 0, false, true);
  }
}

export class AllPokemonFullReviveReward extends Reward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, "modifierType:ModifierType.AllPokemonFullReviveModifierType");
    this.id = RewardId.SACRED_ASH;
  }

  apply(): boolean {
    for (const pokemon of globalScene.getPlayerParty()) {
      restorePokemonHp(pokemon, 100, 0, false, true);
    }

    return true;
  }
}

export class PokemonStatusHealReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, (pokemon: PlayerPokemon) => {
      if (!pokemon.hp || (!pokemon.status && !pokemon.getTag(BattlerTagType.CONFUSED))) {
        return PartyUiHandler.NoEffectMessage;
      }
      return null;
    });
    this.id = RewardId.FULL_HEAL;
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonStatusHealModifierType.description");
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    pokemon.resetStatus(true, true, false, false);
    return true;
  }
}

export abstract class PokemonMoveReward extends PokemonReward {
  public moveSelectFilter: PokemonMoveSelectFilter | undefined;

  constructor(
    localeKey: string,
    iconImage: string,
    id: RewardId,
    selectFilter?: PokemonSelectFilter,
    moveSelectFilter?: PokemonMoveSelectFilter,
    group?: string,
  ) {
    super(localeKey, iconImage, selectFilter, group);
    this.moveSelectFilter = moveSelectFilter;
    this.id = id;
  }

  apply(_params: PokemonMoveRewardParams): boolean {
    return false;
  }
}

export class PokemonPpRestoreReward extends PokemonMoveReward {
  protected restorePoints: number;

  constructor(localeKey: string, iconImage: string, id: RewardId, restorePoints: number) {
    super(
      localeKey,
      iconImage,
      id,
      (_pokemon: PlayerPokemon) => {
        return null;
      },
      (pokemonMove: PokemonMove) => {
        if (!pokemonMove.ppUsed) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "ether",
    );

    this.restorePoints = restorePoints;
  }

  getDescription(): string {
    return this.restorePoints > -1
      ? i18next.t("modifierType:ModifierType.PokemonPpRestoreModifierType.description", {
          restorePoints: this.restorePoints,
        })
      : i18next.t("modifierType:ModifierType.PokemonPpRestoreModifierType.extra.fully");
  }

  /**
   * Applies {@linkcode PokemonPpRestoreConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should get move pp restored
   * @returns always `true`
   */
  apply({ pokemon, moveIndex }: PokemonMoveRewardParams): boolean {
    const move = pokemon.getMoveset()[moveIndex];

    if (move) {
      move.ppUsed = this.restorePoints > -1 ? Math.max(move.ppUsed - this.restorePoints, 0) : 0;
    }

    return true;
  }
}

export class PokemonAllMovePpRestoreReward extends PokemonReward {
  protected restorePoints: number;

  constructor(localeKey: string, iconImage: string, id: RewardId, restorePoints: number) {
    super(
      localeKey,
      iconImage,
      (pokemon: PlayerPokemon) => {
        if (!pokemon.getMoveset().filter(m => m.ppUsed).length) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "elixir",
    );

    this.restorePoints = restorePoints;
    this.id = id;
  }

  getDescription(): string {
    return this.restorePoints > -1
      ? i18next.t("modifierType:ModifierType.PokemonAllMovePpRestoreModifierType.description", {
          restorePoints: this.restorePoints,
        })
      : i18next.t("modifierType:ModifierType.PokemonAllMovePpRestoreModifierType.extra.fully");
  }

  /**
   * Applies {@linkcode PokemonAllMovePpRestoreConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should get all move pp restored
   * @returns always `true`
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    for (const move of pokemon.getMoveset()) {
      if (move) {
        move.ppUsed = this.restorePoints > -1 ? Math.max(move.ppUsed - this.restorePoints, 0) : 0;
      }
    }

    return true;
  }
}

export class PokemonPpUpReward extends PokemonMoveReward {
  protected upPoints: number;

  constructor(localeKey: string, iconImage: string, id: RewardId, upPoints: number) {
    super(
      localeKey,
      iconImage,
      id,
      (_pokemon: PlayerPokemon) => {
        return null;
      },
      (pokemonMove: PokemonMove) => {
        if (pokemonMove.getMove().pp < 5 || pokemonMove.ppUp >= 3 || pokemonMove.maxPpOverride) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "ppUp",
    );

    this.upPoints = upPoints;
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonPpUpModifierType.description", { upPoints: this.upPoints });
  }

  /**
   * Applies {@linkcode PokemonPpUpConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that gets a pp up on move-slot {@linkcode moveIndex}
   * @returns
   */
  apply({ pokemon, moveIndex }: PokemonMoveRewardParams): boolean {
    const move = pokemon.getMoveset()[moveIndex];

    if (move && !move.maxPpOverride) {
      move.ppUp = Math.min(move.ppUp + this.upPoints, 3);
    }

    return true;
  }
}

export class PokemonNatureChangeReward extends PokemonReward {
  protected nature: Nature;

  constructor(nature: Nature) {
    super(
      "",
      `mint_${
        getEnumKeys(Stat)
          .find(s => getNatureStatMultiplier(nature, Stat[s]) > 1)
          ?.toLowerCase() || "neutral"
      }`,
      (pokemon: PlayerPokemon) => {
        if (pokemon.getNature() === this.nature) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "mint",
    );

    this.nature = nature;
    this.id = RewardId.MINT;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.PokemonNatureChangeModifierType.name", {
      natureName: getNatureName(this.nature),
    });
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.PokemonNatureChangeModifierType.description", {
      natureName: getNatureName(this.nature, true, true, true),
    });
  }

  /**
   * Applies {@linkcode PokemonNatureChangeConsumable}
   * @param playerPokemon {@linkcode PlayerPokemon} to apply the {@linkcode Nature} change to
   * @returns
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    pokemon.setCustomNature(this.nature);
    globalScene.gameData.unlockSpeciesNature(pokemon.species, this.nature);

    return true;
  }
}

export class RememberMoveReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string, group?: string) {
    super(
      localeKey,
      iconImage,
      (pokemon: PlayerPokemon) => {
        if (!pokemon.getLearnableLevelMoves().length) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      group,
    );
    this.id = RewardId.MEMORY_MUSHROOM;
  }

  /**
   * Applies {@linkcode RememberMoveConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should remember the move
   * @returns always `true`
   */
  apply({ pokemon, moveIndex, cost }: PokemonMoveRecallRewardParams): boolean {
    globalScene.phaseManager.unshiftNew(
      "LearnMovePhase",
      globalScene.getPlayerParty().indexOf(pokemon as PlayerPokemon),
      pokemon.getLearnableLevelMoves()[moveIndex],
      LearnMoveType.MEMORY,
      cost,
    );

    return true;
  }
}

export class BerryRewardGenerator extends RewardGenerator {
  override generateReward(pregenArgs?: BerryType): HeldItemReward {
    if (pregenArgs !== undefined) {
      const item = berryTypeToHeldItem[pregenArgs];
      return new HeldItemReward(item);
    }
    const item = getNewBerryHeldItem();
    return new HeldItemReward(item);
  }
}

export class MintRewardGenerator extends RewardGenerator {
  override generateReward(pregenArgs?: Nature) {
    if (pregenArgs !== undefined) {
      return new PokemonNatureChangeReward(pregenArgs);
    }
    return new PokemonNatureChangeReward(randSeedItem(getEnumValues(Nature)));
  }
}

export class TeraTypeRewardGenerator extends RewardGenerator {
  override generateReward(pregenArgs?: PokemonType) {
    if (pregenArgs !== undefined) {
      return new ChangeTeraTypeReward(pregenArgs[0]);
    }
    if (!globalScene.trainerItems.hasItem(TrainerItemId.TERA_ORB)) {
      return null;
    }

    const shardType = this.getTeraType();
    return new ChangeTeraTypeReward(shardType);
  }

  private getTeraType(): PokemonType {
    // If all party members have a given Tera Type, omit it from the pool
    const excludedType = globalScene.getPlayerParty().reduce((prevType, p) => {
      if (
        // Ignore Pokemon with fixed Tera Types
        p.hasSpecies(SpeciesId.TERAPAGOS) ||
        p.hasSpecies(SpeciesId.OGERPON) ||
        p.hasSpecies(SpeciesId.SHEDINJA)
      ) {
        return prevType;
      }
      return prevType === p.teraType ? prevType : PokemonType.UNKNOWN;
    }, PokemonType.UNKNOWN);

    const validTypes = getEnumValues(PokemonType).filter(t => t !== excludedType);
    // 1/64 chance for tera stellar
    return randSeedInt(64) ? randSeedItem(validTypes) : PokemonType.STELLAR;
  }
}

export class AttackTypeBoosterReward extends HeldItemReward {
  public moveType: PokemonType;
  public boostPercent: number;

  constructor(moveType: PokemonType, boostPercent: number) {
    const itemId = attackTypeToHeldItem[moveType];
    super(itemId);
    this.moveType = moveType;
    this.boostPercent = boostPercent;
  }

  getPregenArgs(): any[] {
    return [this.moveType];
  }
}

function incrementLevelWithCandy(pokemon: Pokemon): boolean {
  const levelCount = new NumberHolder(1);
  globalScene.applyPlayerItems(TrainerItemEffect.LEVEL_INCREMENT_BOOSTER, { numberHolder: levelCount });

  pokemon.level += levelCount.value;
  if (pokemon.level <= globalScene.getMaxExpLevel(true)) {
    pokemon.exp = getLevelTotalExp(pokemon.level, pokemon.species.growthRate);
    pokemon.levelExp = 0;
  }

  if (pokemon.isPlayer()) {
    pokemon.addFriendship(FRIENDSHIP_GAIN_FROM_RARE_CANDY);

    globalScene.phaseManager.unshiftNew(
      "LevelUpPhase",
      globalScene.getPlayerParty().indexOf(pokemon),
      pokemon.level - levelCount.value,
      pokemon.level,
    );
  }
  return true;
}

export class PokemonLevelIncrementReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, (_pokemon: PlayerPokemon) => null);
    this.id = RewardId.RARE_CANDY;
  }

  getDescription(): string {
    let levels = 1;
    const candyJarStack = globalScene.trainerItems.getStack(TrainerItemId.CANDY_JAR);
    levels += candyJarStack;
    return i18next.t("modifierType:ModifierType.PokemonLevelIncrementModifierType.description", { levels });
  }

  /**
   * Applies {@linkcode PokemonLevelIncrementConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should get levels incremented
   * @param levelCount The amount of levels to increment
   * @returns always `true`
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    return incrementLevelWithCandy(pokemon);
  }
}

export class AllPokemonLevelIncrementReward extends Reward {
  id = RewardId.RARER_CANDY;

  getDescription(): string {
    let levels = 1;
    const candyJarStack = globalScene.trainerItems.getStack(TrainerItemId.CANDY_JAR);
    levels += candyJarStack;
    return i18next.t("modifierType:ModifierType.AllPokemonLevelIncrementModifierType.description", { levels });
  }

  apply(): boolean {
    for (const pokemon of globalScene.getPlayerParty()) {
      incrementLevelWithCandy(pokemon);
    }

    return true;
  }
}

export class BaseStatBoosterReward extends HeldItemReward {
  private stat: PermanentStat;
  private key: string;

  constructor(stat: PermanentStat) {
    const key = statBoostItems[stat];
    const itemId = permanentStatToHeldItem[stat];
    super(itemId);

    this.stat = stat;
    this.key = key;
  }
}

export class TmReward extends PokemonReward {
  public moveId: MoveId;

  constructor(moveId: MoveId) {
    super(
      "",
      `tm_${PokemonType[allMoves[moveId].type].toLowerCase()}`,
      (pokemon: PlayerPokemon) => {
        if (
          pokemon.compatibleTms.indexOf(moveId) === -1 ||
          pokemon.getMoveset().filter(m => m.moveId === moveId).length
        ) {
          return PartyUiHandler.NoEffectMessage;
        }
        return null;
      },
      "tm",
    );

    this.moveId = moveId;
  }

  get name(): string {
    return i18next.t("modifierType:ModifierType.TmModifierType.name", {
      moveId: padInt(Object.keys(tmSpecies).indexOf(this.moveId.toString()) + 1, 3),
      moveName: allMoves[this.moveId].name,
    });
  }

  getDescription(): string {
    return i18next.t(
      globalScene.enableMoveInfo
        ? "modifierType:ModifierType.TmModifierTypeWithInfo.description"
        : "modifierType:ModifierType.TmModifierType.description",
      { moveName: allMoves[this.moveId].name },
    );
  }

  /**
   * Applies {@linkcode TmConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should learn the TM
   * @returns always `true`
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    globalScene.phaseManager.unshiftNew(
      "LearnMovePhase",
      globalScene.getPlayerParty().indexOf(pokemon),
      this.moveId,
      LearnMoveType.TM,
    );

    return true;
  }
}

export class EvolutionItemReward extends PokemonReward {
  public evolutionItem: EvolutionItem;

  constructor(evolutionItem: EvolutionItem) {
    super("", EvolutionItem[evolutionItem].toLowerCase(), (pokemon: PlayerPokemon) => {
      if (
        pokemonEvolutions.hasOwnProperty(pokemon.species.speciesId) &&
        pokemonEvolutions[pokemon.species.speciesId].filter(e => e.validate(pokemon, false, this.evolutionItem))
          .length &&
        pokemon.getFormKey() !== SpeciesFormKey.GIGANTAMAX
      ) {
        return null;
      }
      if (
        pokemon.isFusion() &&
        pokemon.fusionSpecies &&
        pokemonEvolutions.hasOwnProperty(pokemon.fusionSpecies.speciesId) &&
        pokemonEvolutions[pokemon.fusionSpecies.speciesId].filter(e => e.validate(pokemon, true, this.evolutionItem))
          .length &&
        pokemon.getFusionFormKey() !== SpeciesFormKey.GIGANTAMAX
      ) {
        return null;
      }

      return PartyUiHandler.NoEffectMessage;
    });

    this.evolutionItem = evolutionItem;
  }

  get name(): string {
    return i18next.t(`modifierType:EvolutionItem.${EvolutionItem[this.evolutionItem]}`);
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.EvolutionItemModifierType.description");
  }

  getPregenArgs(): any[] {
    return [this.evolutionItem];
  }

  /**
   * Applies {@linkcode EvolutionItemConsumable}
   * @param playerPokemon The {@linkcode PlayerPokemon} that should evolve via item
   * @returns `true` if the evolution was successful
   */
  apply({ pokemon }: PokemonRewardParams): boolean {
    let matchingEvolution = pokemonEvolutions.hasOwnProperty(pokemon.species.speciesId)
      ? pokemonEvolutions[pokemon.species.speciesId].find(
          e => e.evoItem === this.evolutionItem && e.validate(pokemon, false, e.item!),
        )
      : null;

    if (!matchingEvolution && pokemon.isFusion()) {
      matchingEvolution = pokemonEvolutions[pokemon.fusionSpecies!.speciesId].find(
        e => e.evoItem === this.evolutionItem && e.validate(pokemon, true, e.item!),
      );
      if (matchingEvolution) {
        matchingEvolution = new FusionSpeciesFormEvolution(pokemon.species.speciesId, matchingEvolution);
      }
    }

    if (matchingEvolution) {
      globalScene.phaseManager.unshiftNew("EvolutionPhase", pokemon, matchingEvolution, pokemon.level - 1);
      return true;
    }

    return false;
  }
}

/**
 * Class that represents form changing items
 */
export class FormChangeItemReward extends PokemonReward {
  public formChangeItem: FormChangeItem;

  constructor(formChangeItem: FormChangeItem) {
    super("", FormChangeItem[formChangeItem].toLowerCase(), (pokemon: PlayerPokemon) => {
      // Make sure the Pokemon has alternate forms
      if (
        pokemonFormChanges.hasOwnProperty(pokemon.species.speciesId) &&
        // Get all form changes for this species with an item trigger, including any compound triggers
        pokemonFormChanges[pokemon.species.speciesId]
          .filter(
            fc => fc.trigger.hasTriggerType(SpeciesFormChangeItemTrigger) && fc.preFormKey === pokemon.getFormKey(),
          )
          // Returns true if any form changes match this item
          .flatMap(fc => fc.findTrigger(SpeciesFormChangeItemTrigger) as SpeciesFormChangeItemTrigger)
          .flatMap(fc => fc.item)
          .includes(this.formChangeItem)
      ) {
        return null;
      }

      return PartyUiHandler.NoEffectMessage;
    });

    this.formChangeItem = formChangeItem;
    this.id = RewardId.FORM_CHANGE_ITEM;
  }

  get name(): string {
    return formChangeItemName(this.formChangeItem);
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.FormChangeItemModifierType.description");
  }

  apply({ pokemon }: PokemonRewardParams): boolean {
    if (pokemon.heldItemManager.hasFormChangeItem(this.formChangeItem)) {
      return false;
    }

    pokemon.heldItemManager.addFormChangeItem(this.formChangeItem);
    pokemon.heldItemManager.toggleActive(this.formChangeItem);

    globalScene.triggerPokemonFormChange(pokemon, SpeciesFormChangeItemTrigger);

    globalScene.updateItems(true);

    return true;
  }
}

export class FusePokemonReward extends PokemonReward {
  constructor(localeKey: string, iconImage: string) {
    super(localeKey, iconImage, (pokemon: PlayerPokemon) => {
      if (pokemon.isFusion()) {
        return PartyUiHandler.NoEffectMessage;
      }
      return null;
    });
    this.id = RewardId.DNA_SPLICERS;
  }

  getDescription(): string {
    return i18next.t("modifierType:ModifierType.FusePokemonModifierType.description");
  }

  /**
   * Applies {@linkcode FusePokemonConsumable}
   * @param playerPokemon {@linkcode PlayerPokemon} that should be fused
   * @param playerPokemon2 {@linkcode PlayerPokemon} that should be fused with {@linkcode playerPokemon}
   * @returns always Promise<true>
   */
  apply({ pokemon, pokemon2 }: PokemonFusionRewardParams): boolean {
    pokemon.fuse(pokemon2);
    return true;
  }
}

export class AttackTypeBoosterRewardGenerator extends RewardGenerator {
  override generateReward(pregenArgs?: PokemonType) {
    if (pregenArgs !== undefined) {
      return new AttackTypeBoosterReward(pregenArgs, TYPE_BOOST_ITEM_BOOST_PERCENT);
    }

    const item = getNewAttackTypeBoosterHeldItem(globalScene.getPlayerParty());

    return item ? new HeldItemReward(item) : null;
  }
}

export class BaseStatBoosterRewardGenerator extends RewardGenerator {
  override generateReward(pregenArgs?: PermanentStat) {
    if (pregenArgs !== undefined) {
      return new BaseStatBoosterReward(pregenArgs);
    }
    return new HeldItemReward(getNewVitaminHeldItem());
  }
}

export class TempStatStageBoosterRewardGenerator extends RewardGenerator {
  public static readonly items: Record<TempBattleStat, string> = {
    [Stat.ATK]: "x_attack",
    [Stat.DEF]: "x_defense",
    [Stat.SPATK]: "x_sp_atk",
    [Stat.SPDEF]: "x_sp_def",
    [Stat.SPD]: "x_speed",
    [Stat.ACC]: "x_accuracy",
  };

  override generateReward(pregenArgs?: TempBattleStat) {
    return new LapsingTrainerItemReward(tempStatToTrainerItem[pregenArgs ?? randSeedItem(TEMP_BATTLE_STATS)]);
  }
}

/**
 * Consumable type generator for {@linkcode SpeciesStatBoosterReward}, which
 * encapsulates the logic for weighting the most useful held item from
 * the current list of {@linkcode items}.
 * @extends RewardGenerator
 */
export class SpeciesStatBoosterRewardGenerator extends RewardGenerator {
  /** Object comprised of the currently available species-based stat boosting held items */

  private rare: boolean;
  constructor(rare: boolean) {
    super();
    this.rare = rare;
  }
  override generateReward(pregenArgs?: SpeciesStatBoosterItemId) {
    if (pregenArgs !== undefined) {
      return new HeldItemReward(pregenArgs);
    }

    // Get a pool of items based on the rarity.
    const tierItems = this.rare
      ? [HeldItemId.LIGHT_BALL, HeldItemId.THICK_CLUB, HeldItemId.METAL_POWDER, HeldItemId.QUICK_POWDER]
      : [HeldItemId.DEEP_SEA_SCALE, HeldItemId.DEEP_SEA_TOOTH];

    const weights = new Array(tierItems.length).fill(0);

    for (const p of globalScene.getPlayerParty()) {
      const speciesId = p.getSpeciesForm(true).speciesId;
      const fusionSpeciesId = p.isFusion() ? p.getFusionSpeciesForm(true).speciesId : null;
      // TODO: Use commented boolean when Fling is implemented
      const hasFling = false; /* p.getMoveset(true).some(m => m.moveId === MoveId.FLING) */

      for (const i in tierItems) {
        const checkedSpecies = (allHeldItems[tierItems[i]] as SpeciesStatBoostHeldItem).species;

        // If party member already has the item being weighted currently, skip to the next item
        const hasItem = p.heldItemManager.hasItem(tierItems[i]);

        if (!hasItem) {
          if (checkedSpecies.includes(speciesId) || (!!fusionSpeciesId && checkedSpecies.includes(fusionSpeciesId))) {
            // Add weight if party member has a matching species or, if applicable, a matching fusion species
            weights[i]++;
          } else if (checkedSpecies.includes(SpeciesId.PIKACHU) && hasFling) {
            // Add weight to Light Ball if party member has Fling
            weights[i]++;
          }
        }
      }
    }

    // TODO: Replace this with a helper function
    let totalWeight = 0;
    for (const weight of weights) {
      totalWeight += weight;
    }

    if (totalWeight !== 0) {
      const randInt = randSeedInt(totalWeight, 1);
      let weight = 0;

      for (const i in weights) {
        if (weights[i] !== 0) {
          const curWeight = weight + weights[i];
          if (randInt <= weight + weights[i]) {
            return new HeldItemReward(tierItems[i]);
          }
          weight = curWeight;
        }
      }
    }

    return null;
  }
}

export class TmRewardGenerator extends RewardGenerator {
  private tier: RarityTier;
  constructor(tier: RarityTier) {
    super();
    this.tier = tier;
  }

  override generateReward(pregenArgs?: MoveId) {
    if (pregenArgs !== undefined) {
      return new TmReward(pregenArgs);
    }

    const party = globalScene.getPlayerParty();
    const partyMemberCompatibleTms = party.map(p => {
      const previousLevelMoves = p.getLearnableLevelMoves();
      return (p as PlayerPokemon).compatibleTms.filter(
        tm => !p.moveset.find(m => m.moveId === tm) && !previousLevelMoves.find(lm => lm === tm),
      );
    });
    const tierUniqueCompatibleTms = partyMemberCompatibleTms
      .flat()
      .filter(tm => tmPoolTiers[tm] === this.tier)
      .filter(tm => !allMoves[tm].name.endsWith(" (N)"))
      .filter((tm, i, array) => array.indexOf(tm) === i);
    if (!tierUniqueCompatibleTms.length) {
      return null;
    }

    const randTmIndex = randSeedItem(tierUniqueCompatibleTms);
    return new TmReward(randTmIndex);
  }
}

export class EvolutionItemRewardGenerator extends RewardGenerator {
  private rare: boolean;
  constructor(rare: boolean) {
    super();
    this.rare = rare;
  }

  override generateReward(pregenArgs?: EvolutionItem) {
    if (pregenArgs !== undefined) {
      return new EvolutionItemReward(pregenArgs);
    }

    const party = globalScene.getPlayerParty();

    const evolutionItemPool = [
      party
        .filter(
          p =>
            pokemonEvolutions.hasOwnProperty(p.species.speciesId) &&
            (!p.pauseEvolutions ||
              p.species.speciesId === SpeciesId.SLOWPOKE ||
              p.species.speciesId === SpeciesId.EEVEE ||
              p.species.speciesId === SpeciesId.KIRLIA ||
              p.species.speciesId === SpeciesId.SNORUNT),
        )
        .flatMap(p => {
          const evolutions = pokemonEvolutions[p.species.speciesId];
          return evolutions.filter(e => e.isValidItemEvolution(p));
        }),
      party
        .filter(
          p =>
            p.isFusion() &&
            p.fusionSpecies &&
            pokemonEvolutions.hasOwnProperty(p.fusionSpecies.speciesId) &&
            (!p.pauseEvolutions ||
              p.fusionSpecies.speciesId === SpeciesId.SLOWPOKE ||
              p.fusionSpecies.speciesId === SpeciesId.EEVEE ||
              p.fusionSpecies.speciesId === SpeciesId.KIRLIA ||
              p.fusionSpecies.speciesId === SpeciesId.SNORUNT),
        )
        .flatMap(p => {
          const evolutions = pokemonEvolutions[p.fusionSpecies!.speciesId];
          return evolutions.filter(e => e.isValidItemEvolution(p, true));
        }),
    ]
      .flat()
      .flatMap(e => e.evoItem)
      .filter(i => !!i && i > 50 === this.rare);

    if (!evolutionItemPool.length) {
      return null;
    }

    return new EvolutionItemReward(randSeedItem(evolutionItemPool));
  }
}

export class FormChangeItemRewardGenerator extends RewardGenerator {
  private isRareFormChangeItem: boolean;

  constructor(isRareFormChangeItem: boolean) {
    super();
    this.isRareFormChangeItem = isRareFormChangeItem;
  }

  override generateReward(pregenArgs?: FormChangeItem) {
    if (pregenArgs !== undefined) {
      return new FormChangeItemReward(pregenArgs);
    }
    const party = globalScene.getPlayerParty();

    // TODO: REFACTOR THIS FUCKERY PLEASE
    const formChangeItemPool = [
      ...new Set(
        party
          .filter(p => pokemonFormChanges.hasOwnProperty(p.species.speciesId))
          .flatMap(p => {
            const formChanges = pokemonFormChanges[p.species.speciesId];
            let formChangeItemTriggers = formChanges
              .filter(
                fc =>
                  ((fc.formKey.indexOf(SpeciesFormKey.MEGA) === -1 &&
                    fc.formKey.indexOf(SpeciesFormKey.PRIMAL) === -1) ||
                    globalScene.trainerItems.hasItem(TrainerItemId.MEGA_BRACELET)) &&
                  ((fc.formKey.indexOf(SpeciesFormKey.GIGANTAMAX) === -1 &&
                    fc.formKey.indexOf(SpeciesFormKey.ETERNAMAX) === -1) ||
                    globalScene.trainerItems.hasItem(TrainerItemId.DYNAMAX_BAND)) &&
                  (!fc.conditions.length ||
                    fc.conditions.filter(cond => cond instanceof SpeciesFormChangeCondition && cond.predicate(p))
                      .length) &&
                  fc.preFormKey === p.getFormKey(),
              )
              .map(fc => fc.findTrigger(SpeciesFormChangeItemTrigger) as SpeciesFormChangeItemTrigger)
              .filter(t => t?.active && !p.heldItemManager.hasFormChangeItem(t.item));

            if (p.species.speciesId === SpeciesId.NECROZMA) {
              // technically we could use a simplified version and check for formChanges.length > 3, but in case any code changes later, this might break...
              let foundULTRA_Z = false,
                foundN_LUNA = false,
                foundN_SOLAR = false;
              formChangeItemTriggers.forEach((fc, _i) => {
                console.log("Checking ", fc.item);
                switch (fc.item) {
                  case FormChangeItem.ULTRANECROZIUM_Z:
                    foundULTRA_Z = true;
                    break;
                  case FormChangeItem.N_LUNARIZER:
                    foundN_LUNA = true;
                    break;
                  case FormChangeItem.N_SOLARIZER:
                    foundN_SOLAR = true;
                    break;
                }
              });
              if (foundULTRA_Z && foundN_LUNA && foundN_SOLAR) {
                // all three items are present -> user hasn't acquired any of the N_*ARIZERs -> block ULTRANECROZIUM_Z acquisition.
                formChangeItemTriggers = formChangeItemTriggers.filter(
                  fc => fc.item !== FormChangeItem.ULTRANECROZIUM_Z,
                );
              } else {
                console.log("DID NOT FIND ");
              }
            }
            return formChangeItemTriggers;
          }),
      ),
    ]
      .flat()
      .flatMap(fc => fc.item)
      .filter(i => (i && i < 100) === this.isRareFormChangeItem);
    // convert it into a set to remove duplicate values, which can appear when the same species with a potential form change is in the party.

    if (!formChangeItemPool.length) {
      return null;
    }

    return new FormChangeItemReward(randSeedItem(formChangeItemPool));
  }
}

export class RewardOption {
  public type: Reward;
  public upgradeCount: number;
  public tier: RarityTier;
  public cost: number;

  constructor(type: Reward, upgradeCount: number, tier: RarityTier, cost = 0) {
    this.type = type;
    this.upgradeCount = upgradeCount;
    this.tier = tier;
    this.cost = Math.min(Math.round(cost), Number.MAX_SAFE_INTEGER);
  }
}

// TODO: If necessary, add the rest of the modifier types here.
// For now, doing the minimal work until the modifier rework lands.
const RewardConstructorMap = Object.freeze({
  RewardGenerator,
});

/**
 * Map of of modifier type strings to their constructor type
 */
export type RewardConstructorMap = typeof RewardConstructorMap;

/**
 * Map of modifier type strings to their instance type
 */
export type RewardInstanceMap = {
  [K in keyof RewardConstructorMap]: InstanceType<RewardConstructorMap[K]>;
};

export type RewardString = keyof RewardConstructorMap;
