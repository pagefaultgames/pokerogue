# Story 8.4: Shop & Economic System

**Epic:** 8 - Item & Modifier Systems  
**Status:** Draft
**Created:** 2025-09-03  
**Assigned:** Developer Agent  

## Story Statement
As an **economic system developer**,
I want **to implement item purchasing, selling, and economic balance**,
so that **players can acquire items through shops with proper pricing and availability**.

## Acceptance Criteria
1. Shop inventory maintains item availability with proper restocking mechanics
2. Item pricing follows current game economy with buy/sell price ratios
3. Money validation prevents purchases exceeding available funds
4. Item selling generates correct money amounts based on purchase price ratios
5. Shop inventory expansion unlocks based on game progression milestones
6. Rare item availability controlled through progression gates and special conditions
7. Bulk purchasing handles quantity selection and inventory limits properly
8. Transaction logging maintains purchase/sale history for economic tracking

## Dev Notes

### Previous Story Insights
Key learnings from previous story (8.2 - Held Item System):
- **Item Database Foundation**: Complete item database established with 165+ items across all categories - shop system can leverage this extensive database for inventory management
- **Item Effects Infrastructure**: ItemEffectsProcessor system provides comprehensive effect processing with deterministic calculations using AO crypto module - shop system must integrate for item validation
- **Inventory Integration**: InventoryManager handles item acquisition, removal, and persistence - shop system must integrate for purchase/sale validation and transaction processing
- **Pokemon State Integration**: System successfully integrated with existing Pokemon State Manager - shop system needs minimal Pokemon integration except for item usage validation
- **Battle System Integration**: Battle Resolution Handler integration established - shop system operates independently but must validate item usability
- **Testing Infrastructure**: Comprehensive unit and integration test framework established with 100% coverage - shop system must follow identical testing patterns
- **Behavioral Parity**: All calculations must match TypeScript reference implementation exactly using deterministic processing with AO crypto module for RNG
- **Coding Standards Compliance**: Enforced AO crypto module usage (never math.random()) and proper error handling patterns - shop system must maintain identical compliance

### Data Models
**Player Model Inventory Integration** [Source: architecture/data-models.md#player-model]:
- `inventory`: table - Items, money, and resources with transaction logging
- Item tracking within player progression system for collection management
- Inventory persistence across battles and save/load cycles for purchased items
- Money tracking for purchase/sale transactions and economic balance

**Pokemon Model Shop Integration** [Source: architecture/data-models.md#pokemon-model]:
- No direct integration required, but shop must validate item usability for Pokemon
- Item purchases must consider Pokemon compatibility for consumables and held items

**Battle Model Shop Restrictions** [Source: architecture/data-models.md#battle-model]:
- Shop access may be restricted during active battles
- Item purchases must validate against battle-specific usage rules

### API Specifications
No specific API specifications found in architecture docs for shop system. Shop system will follow standard AO message handler patterns:
- Purchase handler for item buying with money validation
- Sell handler for item disposal with price calculation
- Inventory query handler for shop display
- Transaction history handler for economic tracking

### Component Specifications
**Game State Coordinator Integration** [Source: architecture/components.md#game-state-coordinator]:
- `updateProgression(playerId, progressData)` - Wave advancement and unlock tracking for shop inventory expansion
- `saveGameState(playerId, gameData)` - Complete game state serialization including shop transaction history
- `validateStateIntegrity(playerId)` - Save data corruption prevention for economic data

**Query Response Handler Integration** [Source: architecture/components.md#query-response-handler]:
- `queryPlayerState(playerId, stateType)` - Player progression and inventory data for shop access validation
- Shop system must provide query interfaces for inventory display and transaction history

### File Locations
Based on project structure analysis [Source: architecture/source-tree.md]:
- **Shop Manager**: `ao-processes/game-logic/items/shop-manager.lua` - Core shop functionality
- **Economic System**: `ao-processes/game-logic/items/economic-system.lua` - Pricing and balance calculations
- **Shop Handler**: `ao-processes/handlers/shop-handler.lua` - AO message processing for shop actions
- **Shop Data**: `ao-processes/data/items/shop-database.lua` - Shop inventory and pricing definitions
- **Unit Tests**: `ao-processes/tests/unit/items/shop-manager.test.lua`, `ao-processes/tests/unit/items/economic-system.test.lua`
- **Integration Tests**: `ao-processes/tests/integration/shop-integration.test.lua`

### Testing Requirements
**Unit Tests** [Source: architecture/test-strategy-and-standards.md#unit-tests]:
- Location: `ao-processes/tests/unit/items/`
- Framework: Custom Lua test framework with TypeScript comparison utilities
- Coverage Requirement: 100% for price calculations, 95% for shop logic
- Generate tests for all public functions automatically
- Cover edge cases including insufficient funds, inventory limits, and invalid items
- Mock all external dependencies including inventory management and progression system

**Integration Tests** [Source: architecture/test-strategy-and-standards.md#integration-tests]:
- Location: `ao-processes/tests/integration/shop-integration.test.lua`
- Test complete shop workflows including purchase, sell, and inventory management
- Validate integration with Player state manager for money tracking and progression gates
- Test shop persistence across save/load cycles and session boundaries
- Test shop restrictions and availability based on game progression

### Technical Constraints
**Behavioral Parity Requirements** [Source: architecture/coding-standards.md]:
- Never use Lua's math.random() - ALWAYS use AO crypto module for any randomness in shop operations
- All price calculations must match TypeScript implementation exactly
- Never hardcode item pricing data - always reference shop database tables
- All AO message responses must include success boolean for proper error handling
- Shop transactions must be deterministic and reproducible

**Technology Stack** [Source: architecture/tech-stack.md]:
- Lua 5.3 runtime with AO Handlers for message processing
- In-process Lua tables for shop inventory tracking
- JSON message protocol for player/agent communication
- Custom Lua schemas for shop data validation and transaction processing
- AO process memory with JSON serialization for transaction history persistence

### Project Structure Notes
**Alignment with Existing Structure**: Shop system aligns well with existing item system architecture:
- Leverages existing `ao-processes/game-logic/items/` directory for shop logic
- Integrates with existing `ao-processes/data/items/item-database.lua` for item references
- Uses existing `ao-processes/game-logic/items/inventory-manager.lua` for transaction processing
- Follows established handler pattern in `ao-processes/handlers/` directory

**New Files Required**: No structural conflicts identified. Shop system requires new files in established directories:
- Shop-specific handlers and managers in existing items directories
- Shop database in existing data/items directory
- Tests following existing testing structure

## Tasks / Subtasks

### Task 1: Shop Database and Pricing System (AC: 2, 6)
**Reference:** [Source: architecture/source-tree.md#data-items]
- [ ] Create `shop-database.lua` with comprehensive item pricing and availability definitions
- [ ] Implement price calculation system matching TypeScript buy/sell ratios (typically 50% sell value)
- [ ] Add progression-gated item availability with unlock conditions
- [ ] Create rare item availability system with special acquisition conditions
- [ ] Implement shop inventory categories (healing, Pok√© Balls, berries, etc.)
- [ ] Add item rarity classification and pricing tiers
- [ ] Create shop restocking mechanics with time-based or event-based triggers

### Task 2: Core Shop Manager (AC: 1, 3, 4, 7)
**Reference:** [Source: architecture/components.md#game-state-coordinator]
- [ ] Create `shop-manager.lua` for core shop operations and state management
- [ ] Implement item purchase functionality with money validation and inventory limits
- [ ] Add item selling system with proper price calculation and inventory management
- [ ] Create bulk purchasing system with quantity selection and validation
- [ ] Implement shop inventory management and restocking mechanics
- [ ] Add transaction validation preventing purchases exceeding available funds
- [ ] Create inventory space validation for purchase operations
- [ ] Implement shop access restrictions based on game state

### Task 3: Economic System and Balance (AC: 2, 4, 8)
**Reference:** [Source: architecture/coding-standards.md]
- [ ] Create `economic-system.lua` for price calculations and economic balance
- [ ] Implement deterministic price calculations matching TypeScript exactly
- [ ] Add transaction history tracking with purchase/sale logging
- [ ] Create economic balance validation preventing exploit scenarios
- [ ] Implement dynamic pricing system based on item rarity and availability
- [ ] Add money validation and transaction rollback for failed purchases
- [ ] Create economic reporting system for balance tracking

### Task 4: Shop Message Handlers (AC: 1, 3, 4, 7)
**Reference:** [Source: architecture/tech-stack.md#message-protocol]
- [ ] Create `shop-handler.lua` for AO message processing of shop actions
- [ ] Implement purchase message handler with comprehensive validation
- [ ] Add sell message handler with item validation and price calculation
- [ ] Create inventory query handler for shop display and availability
- [ ] Implement transaction history query handler for economic tracking
- [ ] Add bulk purchase message handler with quantity and limit validation
- [ ] Create shop availability query handler for progression-based access
- [ ] Implement proper error handling and success/failure responses

### Task 5: Integration with Existing Systems (AC: 5, 6)
**Reference:** [Source: architecture/components.md#query-response-handler]
- [ ] Integrate shop system with Player progression for unlock conditions
- [ ] Connect shop availability to Game State Coordinator for progression tracking
- [ ] Implement shop access validation through Query Response Handler
- [ ] Add shop transaction persistence through Game State Coordinator save system
- [ ] Create shop inventory synchronization with player inventory limits
- [ ] Integrate shop system with existing item validation and usage systems
- [ ] Add shop transaction validation preventing duplicate or invalid purchases

### Task 6: Unit Testing (AC: All)
**Reference:** [Source: architecture/test-strategy-and-standards.md#unit-tests]
- [ ] Create comprehensive unit tests for `shop-manager.lua` with 100% coverage
- [ ] Implement unit tests for `economic-system.lua` price calculations
- [ ] Add unit tests for `shop-handler.lua` message processing
- [ ] Create tests for shop database validation and item availability
- [ ] Implement edge case testing for insufficient funds and inventory limits
- [ ] Add mock testing for all external dependencies (inventory, progression)
- [ ] Create parity tests comparing Lua calculations to TypeScript reference

### Task 7: Integration Testing (AC: All)
**Reference:** [Source: architecture/test-strategy-and-standards.md#integration-tests]
- [ ] Create `shop-integration.test.lua` for complete shop workflow testing
- [ ] Test complete purchase/sell cycles with inventory and money management
- [ ] Validate shop system integration with player progression and unlocks
- [ ] Test shop persistence across save/load cycles and session boundaries
- [ ] Create multi-transaction testing for bulk purchases and complex scenarios
- [ ] Implement shop restriction testing based on game progression and state
- [ ] Add transaction history validation and economic balance verification